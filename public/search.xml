<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[GSMA RCS标准的演变]]></title>
    <url>%2F2018%2F05%2F16%2FGSMA-RCS%E6%A0%87%E5%87%86%E7%9A%84%E6%BC%94%E5%8F%98%2F</url>
    <content type="text"><![CDATA[市场需求推动了丰富通信服务技术标准的发展.开放移动联盟（OMA）基于IMS和SIP技术指定了SIMPLE IM和融合IP消息系统（CPM）的技术细节.这种技术的概念反映了2000年代中期左右流行的基于PC的消息传送服务.自2000年代后期左右智能手机时代以来、以运营商为中心的生态系统开始崩溃、许多OTT（Over-The-Top、通信服务）通信服务开始在市场上以其免费短信和语音通话服务起飞、从而威胁到传统 运营商的收入.运营商通过提出GSMA指定的丰富通信套件（RCS）技术来应对这些威胁.RCS的标准仍在不断发展、其中纳入了上市时间服务功能的各种要求、并考虑了商业模式。 I. 导言当GSM协会（GSMA）于2011年4月首次指定富通讯套件演变（RCSe）标准、品牌名称为“Joyn”时、许多全球电信公司预计Joyn可能成为与现有和突出OTT服务、如Whatsapp、Viber、Line等。从运营商的角度来看、这些OTT服务通过搭载电信公司的既有基础设施而大幅增长、他们甚至通过免费提供免费电话服务的收入来源mVoIP和消息服务功能。在韩国、三大电信公司（即SKT、KT和LG U +）于2012年底开始提供Joyn服务、而在欧洲、特别是西班牙和德国、沃达丰和Orange等全球性公司也开始提供相同的服务。从那时起已经差不多三年了。与最初的猜测不同的是、这些国家的Joyn服务并没有得到很大的普及、而OTT服务在市场上稳步增长。这使得大多数尚未开始服务的电信公司仍然犹豫推出自己的服务。即使那些已经提供服务的人也对他们的服务进一步投资犹豫不决。尽管Joyn的普及程度不高、Rich Communication Suite（RCS）技术以及GSMA的相关规范一直在不断发展以跟上市场趋势。本文将略述全球标准方面不断演变的通信技术路线图、这将有助于您更好地了解电信行业如何努力符合市场趋势。 II. IP消息系统服务的出现以及向融合IP消息系统的演进 开放移动联盟（OMA）将SIMPLE IM技术指定为早在2000年代中期的第一个基于IP的消息传递技术.SIMPLE IM提供典型的基于SIP的消息功能、例如一对一和群组会话消息（即聊天）。这SIMPLE IM成为通信技术的以下技术标准的基础。自2005年以来、OMA MWG工作组（现称COM WG）开始开发融合IP消息（CPM）技术（图1中的[1]）、该技术采用了SIMPLE IM的许多服务特性和技术.CPM通过将传统消息服务（例如、SMS、MMS、电子邮件等）集成到IP聊天功能、语音流、视频流等新服务中来提供融合通信服务功能.CPM还提供了一些功能、特别针对拥有多台设备的用户、为他们提供融合的通信环境和跨设备的一致用户体验。严格地说、即使在OMA提出OMA CPM之前、融合通信环境和一致的用户体验已经通过基于PC的信使服务（例如ICQ、AOL、MSN信使等）被用户广泛接受。此类第三方服务已经在IP网络之上提供了聊天、状态信息共享、SMS / MMS集成、文件传输、对话历史备份等多项服务。因此、OMA的此类标准活动可以被解释为许多全球运营商为移动环境带来类似用户体验的努力、希望通过提供那些已被证明是成功的服务功能来增加另一个收入来源网络。Snipaste_2018-05-16_19-16-10.png III. OTT vs运营商 自iPhone在21世纪后期进入市场以来、所有设备制造商开始推出自己的智能手机。这些新型智能手机的到来改变了电信行业生态系统中的许多事情。感谢Apple的AppStore和Google Android Market（现在称为Google Play）、第三方应用程序开发人员可以自己成为服务提供商。以运营商为中心的垂直价值链崩溃、大量第三方服务开始免费开放。许多技术领导者开始声称运营商最终会成为一个愚蠢的管道。由于消费者渴望坚持免费的OTT服务、运营商失去了市场上的谈判权力。有一些企图限制OTT服务的流量。然而、它被网络中立的名称所禁止、被市场和法律所禁止。一些OTT服务、如Viber、Line、Whatsapp成为消息传播市场的英雄、因为它们蓬勃发展。许多成功抢占智能手机时代早期市场的第三方服务开始超越传统运营商。随着OTT突出服务的出现、运营商开始失去传统的关键领域、例如短信和语音通话。成功锁定早期市场的OTT服务提供商由于锁定效应而不断增长。运营商消息业务的收入随着流量而下降。市场上的这些激进变化促使全球运营商聚集到GSMA、寻找抵御OTT服务威胁的方法。他们决定启动GSM协会的RCS项目、以提供丰富的基于IP的通信服务。规定了RCS服务要求、并且OMA SIMPLE IM和CPM采用了许多满足要求的技术细节.RCS规范已经开发并发布到RCS r4.0（图1中的[2]、[4]）。 IV. JOYNSnipaste_2018-05-16_19-16-26.png RCS r4.0包含OMA SIMPLE IM和CPM的大部分高级功能。然而、没有运营商提出RCS服务、因为他们对服务的益处和可行性持怀疑态度。由于涉及技术困难和各种服务功能、实施RCS r4.0可能看起来过于复杂。虽然运营商正在制定技术标准、并且由于任何原因而不愿意建立RCS服务、但OTT用户的数量在市场上飙升、导致运营商的收入进一步下降。考虑到这种情况、运营商可能会觉得他们需要一个上市时间的服务、这种服务很简单、可以在短时间内建立起来。作为这种讨论的结果、他们想出了一个简单的RCS服务叫做“Joyn”。该服务基于RCSe、最后更新为RCSe r1.2.2（图1中的[3]）.RCSe r1.2.2的主要功能如下：主设备（即PS访问设备）的基于HTTP的配置设置：向RCS设备提供服务相关配置.服务能力发现：查找具有RCS功能的联系人的程序.IP消息系统（即一对一聊天、群聊）存储和转发一对一聊天：如果收件人RCS用户不可用、暂时存储邮件、然后在用户可用时转发邮件.一对一的文件传输基于GSMA的图像共享[IR.79]：与同伴进行语音通话的实时图像共享.基于GSMA的视频共享[IR.74]：与同伴进行语音通话的实时视频共享.社交呈现信息共享（即匿名获取、可选）：查看联系人的社交呈现信息、如肖像图标、自由文本、最爱链接、可用性等。 V. 在RCS中采用CPM体系结构在RCS工作之初、GSMA RCS采用了OMA SIMPLE IM架构。当RCS更新到r4.0时、它通过采用OMA CPM更新了架构、该架构在SIMPLE IM架构之上引入了更多组件、即基于网络的消息存储和互操作功能。基于网络的消息存储用于存储RCS用户的对话历史记录、并在用户的多个设备上同步对话历史记录。互通功能用于将诸如SMS和MMS之类的传统消息服务集成到网络侧.OMA CPM中的电子邮件互通功能未包含在RCS中。Snipaste_2018-05-16_19-17-04.png VI. RCS r4和RCSe合并到RCS r5.x中 GSMA RCS r5基于RCS r4和RCSe r1.2.2（图1中的[5]）。两者的所有技术和服务功能已合并到RCS r5中。截至目前、RCS r5已经发展到RCS r5.4.RCS r5.x打算整合基于IP网络的所有通信功能。诸如SMS和MMS之类的传统消息服务已集成到IP Chat功能中.IP语音/视频呼叫功能与VoLTE服务集成在一起、并支持各种补充业务。所有这些通信服务都通过集成的UX / UI呈现给用户.RCS r5.1的主要特性可概括如下：在RCS r5.1中扩展了配置调配、以适应非PS接入设备和RCS用户的辅助设备。还添加了许多配置参数.独立消息传递提供了与SMS / MMS相同的用户体验、因为两者都是无会话通信。根据要发送的消息的大小、在独立消息中定义了两种模式：Page寻呼模式消息传送（&lt;= 1,300字节）Large大消息模式消息传送（&gt; 1,300字节）IP内的多媒体聊天会话已被允许在RCS r5.1中.RCS用户可以在IP聊天会话中发送多媒体内容。如果多媒体内容大于聊天会话允许的内容、则使用文件传输机制发送。文件传输会话将与现有聊天会话分开、以便并行处理。即使当内容作为文件传送发送并且在单独的会话中时、RCS用户仍然可以在现有聊天会话的相同对话上下文中查看传送的多媒体内容.群聊中的存储和转发提高了群聊过程中消息传递的可靠性。由于连接丢失、电池电量耗尽等原因导致与群组会话非自愿断开的参与者可以在设备重新连接后重新加入群组会话。重新加入的参与者可以接收所有在断开连接时错过的RCS消息（基本存储和转发）。即使是迟到参加集体会议的人也可以收到完整的对话历史记录（完整存储和转发）.Group会话重启（Long Lived Group）捕捉OTT服务中提供的当前用户体验、用户可以通过在存储在本地设备中的会话线程发送任何消息来开始聊天会话。在RCS r5.1中、如果闲置计时器过期、则会发布群聊会话。在群组会话关闭后、只要不删除它、对话历史将保留在参与者的本地设备中。因此、任何用户都可以通过在对话历史记录线程中发送新的聊天消息或文件来重新启动相同的群组会话。为了重新启动组会话、组会话标识应保存在RCS系统中。如果由于相应的组会话标识符已从RCS系统中删除而无法重新启动组会话、RCS客户端可能会自动尝试启动新的组会话.基于HTTP和MSRP的文件传输用于HTTP或MSRP进行文件传输。在使用HTTP的情况下、要发送的文件由发起者上传到网络中的特定内容存储器、并且获得存储的对象的位置URL作为回报。位置URL通过聊天会话或作为独立消息发送给收件人。收件人可以从收到的位置URL中检索文件.文件传输缩略图预览用于在文件传输请求中将缩略图连同其他文件信息（如文件名、文件类型、文件大小等）发送给收件人。接收方RCS用户可以根据此信息确定是否接受文件传输请求.文件传输暂停和恢复用于在文件传输过程中暂停文件传输、并在需要时恢复。由于其他原因、文件传输也可能会意外暂停、例如连接丢失。如果稍后由最终用户恢复文件传输、则可以从暂停的位置传输文件。要在多设备环境中恢复暂停传输、RCS用户需要使用相同的设备。否则、文件传输将从头开始、因为该设备中没有文件片段.文件传输存储和转发用于在收件人不可用时临时存储文件、然后在收件人变为可用时再将其传输.组会话中的文件传输用于在组会话的上下文中传输文件.通过调整RCS用户的位置信息、RCS r5.1丰富了社交存在信息。社交存在信息应该由已经建立了社交存在关系的RCS用户共享.VIP联系人是实时向RCS用户通知其社交呈现信息变化的联系人类型。如果与RCS用户处于社交在线关系的联系人不是VIP联系人、则RCS用户需要对该联系人执行一次性订阅以查看他/她的社交呈现信息.基于网络的个人黑名单可以由RCS用户创建/删除/修改。来自黑名单中的联系人的任何RCS消息或通信尝试都将被阻止.地理位置共享推/拉用于在RCS用户之间共享地理位置信息.RCS用户可以将他/她的位置信息推送到RCS联系人（推送）或请求联系人的位置信息（拉）.内容共享用于在RCS用户之间实时共享图像或视频剪辑。在RCSe中、内容共享功能依赖于现有的语音呼叫会话、这意味着内容共享功能仅在存在语音呼叫会话时才可用。而RCS r5.1中的内容共享功能独立于语音呼叫会话.RCS用户可以使用内容共享服务作为独立的服务功能.基于网络的消息存储用于存储RCS用户的对话历史记录。存储在基于网络的消息存储器中的对话历史可以与RCS用户的一个或多个设备同步。基于网络的消息存储功能为用户提供跨多个设备的一致用户体验.传统消息互通是RCS r5.1的一项支持功能、包括SMS和MMS。鉴于此功能、无论消息类型如何、所有对话历史都集成在同一个对话线程中。IP语音/视频呼叫和VoLTE与IP聊天功能一起集成在RCS r5.1中。 VII. SIMPLE IM 2.0 由于开始时RCS采用了OMA SIMPLE IM 1.0、因此RCS已经发展并具有其他功能.OMA SIMPLE IM 2.0有意填补RCS和SIMPLE IM之间的空白（图1中的[6]）.在一对一IM会话内发送即时消息通知提供会话外通知存储和转发在一对一IM内发送的消息和通知 VIII.CPM 2.0 CPM 1.0体系结构被RCS r4.0所采用、而RCS r4.0已经发展成适用于RCSe特性的RCS r5.x。与SIMPLE IM 2.0类似、OMA CPM 2.0有意填补RCS和CPM 1.0之间的差距（图1中的[7]）.CPM 2.0还包含了对以前版本的一些澄清.在群组会话中存储和转发支持封闭群组、长期存活群组支持聊天消息的实时录像通过SIMPLE IM 2.0与网络接口（NNI）互通在进行CPM会话时进行文件传输存储并在文件传输中转发文件传输暂停和恢复支持最大文件大小策略支持文件传输中的缩略图预览 IX. RCS blackbird按照时间顺序来说、只是在RCS r5.1发布之后才推出了RCS blackbird（图1中的[8]）。然而、从服务特性的角度来看、RCS blackbird是RCSe和RCS r5.x之间的中间版本.RCS黑鹂包括除存在相关功能外的大部分RCSe功能。它还具有RCS r5.x中的许多功能、以提供类似的用户体验。例如、RCS blackbird通过设备内的RCS和SMS / MMS客户端之间的内部互通、在UX / UI级别上集成了传统消息功能。目前、RCS blackbird已经升级到4.0版本。 X、总结 RCS服务功能从RCSe发展到RCS blackbird和RCS r5.x. RCSe包含基本的IP聊天功能、RCS blackbird侧重于从UX / UI角度看消息传递和集成通信.RCS r5.x集成了IP聊天、传统消息传递、IP语音/视频通话、VoLTE服务等所有功能、为用户提供统一的用户体验。从功能上看、名为“Joyn”的RCS技术似乎超越了现有的OTT功能。用户在打电话或发短信时可享受与以前的通信服务相同的用户体验、同时基于RCS带给IP网络的优势、丰富用户体验。虽然GSMA正在提供上市时间服务要求、但OMA正在提供技术细节以通过升级SIMPLE IM和CPM来支持这些要求.3GPP正在从核心网的角度与GSMA和OMA合作、考虑技术细节的实施。通过这种方式、许多标准开发组织（SDO）正在彼此协调工作、以提出具有竞争力的通信服务特性和技术。 参考[1] GSMA, “RCS-e Advanced Communications: Services and Client Specifications”, v1.2.2 July[2] GSMA, “Rich Communication Suite 5.1 Advanced Communications: Services and Client Specifications”, v4.0 November[3] OMA, “OMA-RD-IM-V2_0-20120731-C”, v2.0 July[4] OMA, “OMA-RD-CPM-V2_0-20130611-C”, v2.0 June 2013]]></content>
      <tags>
        <tag>GSMA</tag>
        <tag>RCS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5G白皮书 5G服务路线图 2022]]></title>
    <url>%2F2018%2F05%2F16%2F5G%E7%99%BD%E7%9A%AE%E4%B9%A6-5G%E6%9C%8D%E5%8A%A1%E8%B7%AF%E7%BA%BF%E5%9B%BE-2022%2F</url>
    <content type="text"><![CDATA[源文档链接 5G 使用场景3.1.1.虚拟现实/增强现实3.1.2.大量内容流3.2.1.以用户为中心的计算3.2.2.拥挤的地区服务3.3.1.物联网（人，建筑物，城市）3.4.1.智能交通3.4.2.机器人3.4.3.无人机3.5.1.灾难监测3.5.2.私人保安/公共安全3.5.3.紧急服务 第0章 执行摘要Snipaste_2018-05-16_14-07-53.png 第1章 概述随着信息通信技术（ICT）和相应的应用程序自20世纪80年代以来已经发展并不断发展，信息通信技术已成为社会和经济发展的关键要素，因为它们成功地创造了人类获得新的利益和/或便利之前无法享受.例如，当4G网络推出时，人们开始在移动设备上体验宽带服务，这相当于连接到有线互联网的计算机的性能.但是，对于4G技术来说，提供需要实时响应和大数据量的服务仍然存在障碍，这些将成为未来服务的关键要求.例如，当前的4G / LTE网络不能够向移动用户提供即时云服务，这使得人们可以在旅途中具有类似桌面的体验，因为这样的基于云的服务预计将被公众更普遍地访问2020的社会.另外，通过商用LTE网络下载4千兆字节（GB）大小的电影需要7分17秒以上的时间.而且，LTE网络可以同时为有限数量的移动用户提供高质量的视频体验.因此，基于新技术和新服务，未来生活预计将通过几种方式得到加强. 5G的新功能将包括无限的信息交换，大量多样的连接以及具有自主能量的设备.这些功能特性将基于不同形式因素（包括服装，办公室和家庭用具以及运输因素）中的最短等待时间来支持.通过这些创新，预计将出现各种服务的集体协同作用，这将改变未来几代人的生活方式，并使信息和通信技术行业开放新的融合服务.因此，5G网络目前被视为创新ICT产业的关键基础设施，每个国家在5G竞争中激烈竞争，并正在进行国家投资，例如大型政府资助的研发项目.为了准备5G网络基础设施，首先要定义5G时代的详细业务场景和相应的时间表，并据此推导出业务需求.为此，本文重点研究移动网络从4G到5G的创新，研究最新的问题，预测未来社会，推导潜在的服务领域并提出可行的选择.具体而言，首先，通过预测潜在服务和分析趋势来说明未来的5G服务，并提出可行的行动（必要技术，合作措施，政府政策等）.然后，我们描述了各个服务领域可能在目标年份（2018-2022年）出现的各种服务场景，并最终提出了基于家庭服务行业竞争力分析和移动网络技术现状实现服务所需的服务需求. 第2章 5G移动业务市场分析2.1.大趋势的移动服务 在本节中，我们将通过调查以下五大趋势的移动服务来描述5G服务将如何改变我们日后的日常生活. - 移动数据流量的爆炸式增长 - 连接设备的快速增长 - 云上的一切 - 融合服务的超现实媒体 - 作为大数据分析所实现的服务的知识 2.1.1.移动数据流量爆炸 最近，移动多媒体和社交网络服务越来越流行，导致移动数据流量呈指数级增长.与传统移动服务一样，新兴的物联网服务也在加速移动数据流量的增长速度.根据VNI全球移动数据流量预测（2016年CISCO），2020年的移动数据流量（每月30.6艾字节，1EB = 1,000,000TB）将比2015年（每月3.7艾字节）高出8.3倍. 2.1.2.连接设备快速增加过去十年中的一个重要趋势是智能移动设备的增长.特别是在过去几年中，可穿戴设备，无人机和机器人等新兴未来设备迅速发展.从全球范围来看，我们预计连接到互联网（网络）的手机和其他物联网设备的数量可能会从2015年的79亿美元增加到2020年的116亿美元.这一趋势是启用新用户的主要贡献者之一经验和各种使用案例，并介绍相应的网络要求. 2.1.3.云上的一切 移动云计算已经发展成为通过任何移动设备随时随地访问移动服务的关键技术. GSMA预测，移动云流量占移动流量总量的比例将从2013年的35％上升到2020年的70％，因此预计到2020年大部分5G移动服务将被移植到移动云计算系统中. 2.1.4.用于融合服务的超现实媒体移动网络和设备的最新进展使得基于超现实媒体的增强现实，虚拟现实和多点视图等新的移动体验成为可能.预计移动和媒体技术将发展为基于3D /全息图创造更逼真和交互式的体验.此外，超逼真的媒体将作为融合媒体服务提供，与机器人，无人机，智能医疗保健和安全等其他行业紧密结合. 2.1.5.通过大数据分析实现的知识即服务 大数据分析被认为通过数据分析，处理，信息可视性，趋势分析和未来预测等有效提取有用的信息，创造了新的商业机会.云计算有助于最大限度地发挥大数据分析的性能，特别是在知识领域和人工智能服务（例如，机器学习，深度学习，推理和对IBM Watson的认可）.此外，必须发展能够共享公共信息并保护个人信息的技术和体制系统. 2.2.移动服务的市场预测2.2.1.传统移动设备/网络设备/电信服务A.全球电信市场 预计全球电信市场将从2015年的14,448亿美元增长至2020年的17,776亿美元，复合年增长率为3.9％.截至2015年，电信服务市场为9653亿美元，占整个市场的最高比例（66.6％）.终端和网络设备市场分别为4,427亿美元（30.6％）和406亿美元（2.8％）. B.全球手机市场从全球来看，2015年智能手机市场占移动终端销售总额的91.2％（4038亿美元）.它将持续增长，预计到2020年将占整个移动设备市场的97.5％. C.全球移动网络设备市场预计全球电信网络设备市场将从2015年的406亿美元增长至2020年的603亿美元，复合年增长率为8.2％.截至2015年，LTE设备市场规模达到181亿美元，占整个市场的55.1％，到2020年将持续增长，直至5G网络在商用部署.另外，由于覆盖扩展的高需求，小蜂窝市场一直在持续增长 D.全球语音和数据服务市场2015年，全球电信服务市场为9653亿美元.预计到2020年，语音服务市场将以-4.9％的复合年增长率下滑，而数据服务市场将以8.3％的复合年增长率增长.特别是数据业务市场自2015年以来已经超过语音业务市场，预计到2020年将占整个电信业务市场的65.7％. E.全球移动应用市场预计智能手机，平板电脑等移动应用市场将在2015-2020年期间以29.1％的复合年增长率高速增长（从454亿美元增长至1626亿美元）.具体来说，到2020年，应用下载和应用内支付市场预计将达到近50％的增长率. F.全球M2M市场 截至2015年，M2M（机器对机器）市场达到1357亿美元，到2020年将增长到3465亿美元，因为连接的M2M设备数量增加了几十倍. G.韩国电信市场预计未来五年（2016 - 2010年）韩国电信市场将趋于成熟和稳定，达到约37〜38万亿韩元.此外，智能手机市场几乎饱和，智能手机的平均售价持续下降，导致智能手机市场略有下滑.然而，可穿戴设备等新兴设备市场将以17.4％的复合年增长率持续增长.此外，由于韩国三家移动运营商的持续投资，移动网络设备的市场规模预计将达到年均33.2亿韩元. H.韩国语音/数据电信服务 韩国电信服务市场预计将在2020年以23,997亿韩元的速度增长，从2015年的22％增长到1.3％，年复合增长率为1.3％.与海外发达市场类似，电信服务市场增长预计将放缓或稳定.竞争加剧和市场饱和，但移动广告，门户，M2M等移动应用和融合业务的销售将继续增长.与全球语音服务市场相同，韩国的语音市场将以-5.7％的复合年增长率下滑，而数据服务市场在2020年将占整个服务市场的74.1％，复合年增长率为4.7％. 2.2.2. 5G移动设备/网络设备/电信服务预计5G网络将在2020年实现商业化，然后逐步取代传统网络和服务.全球5G服务的市场规模将高速增长，复合年增长率为92.7％（从2020年的364亿美元增加到2026年的18,615亿美元）.与全球5G市场类似，韩国5G市场将从2020年的963亿韩元增长到2026年的4158.3亿韩元. 2.2.3. 5G移动服务A.沉浸式5G服务 随着智能设备数量的不断增长，全球数字内容市场预计将从2018年的4748亿美元增长至2025年的11,741亿美元，复合年增长率为13.8％.为积极应对未来的数字内容市场，全球公司正在加强虚拟现实技术，全息技术，五感互动等领域的技术开发，并准备应用技术嵌入数字制作和发行平台内容.具体而言，由于UHD视频设备（即，显示器，发射器和相机）的出现，3D / UHD视频内容变得越来越流行.此外，传感器为基础的现实/沉浸式内容服务提供五感信息将在不久的将来成为可能.到2020年，诸如HMD（头戴式设备）等新硬件设备将占AR市场的30％以上.在增强现实内容方面，电子商务的市场规模首位，其次是数据，语音，电影/电视内容，企业AR，广告和游戏到主题公园. Hologram是另一种新兴媒体，能够提供最终的实际体验，因此受到了所有其他现实媒体的关注，期待在音乐会/表演，教育，游戏，广告，医疗，等等.从2020年起，数字全息图将更加可行，其市场将通过逐渐取代传统的模拟和伪全息图市场而进一步增长. B.智能5G服务 IDC预测，作为下一代IT环境的第三代平台（移动，社交，云，大数据）将占全球ICT投资的三分之一.首先，大数据市场将持续增长，因为全球IT公司正在大力推进大数据市场.特别是在5G中，包括机器和人类产生的数据在内的各种信息预计将被有效和系统地收集和处理，最终用于创造新的业务价值.因此，全球大数据市场预计将从2018年的400亿美元增长到2025年的890亿美元. 此外，由于5G网络支持的实时能力和移动性的提高，云计算市场将受到更多关注.特别是公众用户无限制地访问公共云服务将成为主流，因此在市场上越来越受欢迎.因此，全球公共云计算市场将从2018年的2746亿美元增长到2025年的4,727亿美元.此外，人造智能服务市场已经出现，这有助于解决与不同b在知识，推理和启发式搜索的使用领域. BCC Research和Technavio将智能机器定义为人工智能设备，并预测相关市场，包括专家系统，自主机器人，智能虚拟助理，智能嵌入式系统，神经计算等. 根据针对TIA（电信行业协会）58个全球电信运营商的2015年5G运营商调查，智能超密集小型小区服务被评为最重要的5G特性，而不是通过毫米波和设备到设备通信的Massive MIMO服务.预计2018-2025年全球超密集小型蜂窝电话服务市场年均增长26亿美元. C.无所不在的5G服务 目前，基于物联网（IoT）的超连接创新正在世界各地展开，旨在将一切与互联网连接起来.综合思科，爱立信和Gartner等大公司的预测，到目前为止，连接网络的东西的比例估计不到未来连接网络的1％.随着传感器价格的降低以及与互联网连接的东西数量的增加，预计将发生通过社会各个领域的颠覆性创新产生的价值和效用.尤其是，基于物联网的这一创新将显着提高传统行业的生产率和效率，通过大数据和高效数据处理创造新业务，解决各种社会问题，从而提高生活质量. 为此，移动网络的作用越来越重要，可以支持任何设备上的任何时间任何地点的超连接.特别是，2020年新部署的5G网络将被视为超连接社会的关键基础设施和平台.在全球蜂窝式物联网服务市场，预计“汽车”销售比例最高，其次是“资产管理”，“运输”和“零售与支付”. D.自主5G服务汽车市场正在迅速发展成为基于智能汽车的新型融合服务市场，支持定制化的运输服务，与驾驶员，汽车，道路和ICT基础设施紧密相连.特别是对安全便捷驾驶的要求促进了车辆与信息技术的融合，推动了汽车行业从面向制造商的汽车市场向面向驾驶员的运输服务市场发展的巨大范式转变. NHTSA（国家公路交通安全管理局）已将自驾车等级（情景）分为五个阶段，如下表所示.目前，市场上大部分可用的自动驾驶车辆都位于1级和2级之间. 全球公司对自动驾驶汽车的未来市场有不同看法，但完全自驾车（leve4：全自动驾驶自动驾驶）早在2025年左右就会商业化.在此之前，预计低水平（情景）将部分采用速度控制系统，先进的紧急制动系统和车道保持系统等驾驶自动化系统.具体来说，自动驾驶汽车系统的全球市场预计到2020年将达到1890亿美元，并在2035年增长到11.52亿美元（支持自动驾驶汽车，土地，基础设施和运输部的商业化计划）.此外，电动零部件和软件的成本将在2030年达到自动驾驶汽车总成本的50％（Navigation Research（2013））. 机器人的技术进步分为三代：第一代（自动机器人，用于简单重复工作），第二代（低价清洁机器人和玩具机器人，高端军事机器人和研发机器人）和第三代（人形机器人机器人，自然而然地与人交谈）.目前，拥有第二代机器人技术的国家正在专注于第三代自主机器人的研究和开发. 2018年全球自主机器人市场预计为336亿美元，2025年达到416亿美元. 目前以军事用例为重点的无人驾驶航空器市场预计将多元化为个人和公共使用案例，市场将持续增长; 2018年的市场规模将达到48亿美元，2025年的市场规模将达到54亿美元.具体来说，这些无人驾驶的飞行器通过1）电影，照片和视频，2）精准农业，3）检查，监控，测绘和测量，4）交付，5）公共安全，急救员，6）等，预计将在更多样化的领域采用，如下图所示. E.公共5G服务由于全球变暖等原因，天气异常，洪水，地震等自然灾害加剧.而且，对城市的集中和世界人口的高速增长导致事故每年增加.因此，致力于公共安全的新通信系统对于防止潜在的灾难和救援人员的涌现至关重要.移动宽带公共安全通信服务是公共5G服务中最典型的领域，它提供了应急服务组织（例如警察，消防和紧急医疗服务）使用的无线通信网络，以防止或应对危害或危害人员​​或财产的事件.公众5G服务必将提高对安全威胁的快速反应能力，因此其市场需求将不断增加.预计2018年全球公共安全网络市场的销售额将达到288亿美元，2025年的销售额将达到432亿美元，复合年增长率为5.9％.具体而言，预计“人身安全和位置”在市场规模上位居第一，其次是“视频监控”和“员工合作”. 第3章 5G移动服务场景 在第三章中，我们将研究各种5G移动服务场景和每项服务的需求.在研究5G移动服务方案之前，我们必须从最终用户的角度探讨为什么需要5G移动服务的必要性. 我们可以通过分析移动业务的大趋势，5G移动业务市场的趋势以及未来的市场预测，来思考用户在5G中可能遇到的各种业务场景.如图6所示，从最终用户的角度来看，这些服务场景可以分为5个标准. 第III.1节将虚拟现实/增强现实服务和海量内容流服务作为身临其境的5G服务的例子.第III.2节涉及以用户为中心的计算服务和拥挤区域服务作为智能5G服务的例子.第III.3节涉及基于物联网的服务（智能人/智能建筑/智能城市）作为无所不在的5G服务的示例，第III.4节涉及智能交通服务，基于无人机的3D连接服务和基于机器人的服务服务作为自主5G服务的例子.另外，第III.5节介绍灾害监测服务，私人安全/公共安全服务和紧急服务作为公共5G服务的例子. 3.1.沉浸式5G服务3.1.1.虚拟现实/增强现实A.服务理念 虚拟现实（VR）的定义：虚拟现实指的是人与计算机之间的接口，它使用户能够体验仿真环境或与仿真环境或情境进行交互，就好像它是实际的物理存在一样. - 由于视频设备的发展，视频设备和用户之间的距离正在缩小.随着视频设备的不断发展，对VR使用HMD（头戴式显示器）是很自然的. - 由于人体识别信息与设备视觉信息识别不一致，导致头晕，晕车和长时间使用困难.为了解决这样的问题，需要100Hz以上的刷新率和20ms以下的运动 - 光子等待时间. ※运动到光子等待时间指的是充分反映用户对显示屏幕的运动所需的时间.一般而言，如果虚拟现实服务的运动到光子延迟为20ms或更短，用户确信他/她处于现实之外的空间.随着延迟增加，虚拟现实服务体验下降. - 此外，还应改善由于图像质量不足，视角，输入界面和信息显示方法不足造成的问题. 增强现实（AR）的定义：它指的是人与计算机之间的接口，它将虚拟对象或信息合成到实际环境中，以便可以将对象或信息视为在现实世界中真实存在.换句话说，它是一种使虚拟物体或信息与用户观看的真实世界重叠表示的技术. B.详细的服务使用案例 为不能参加奥运场馆和音乐厅/歌剧院等实际场地的用户提供实时VR / AR服务.可以为用户提供实时的VR / AR服务，与以前的视频服务相比，这种服务的沉浸感最大化与以前不同. ePPV（增强型按次付费）服务是指应用于娱乐内容的实时VR / AR和Telepresence的扩展概念，以便消费者在购买或查看内容时可以体验真实环境理想位置. 通过基于VR / AR技术复制与实际场地相同的环境，可以观看与实际演出场地几乎相同的演出.可以将这项技术应用于各种娱乐内容，包括表演，体育比赛，需要使用昂贵设备的纪录片.此外，在安全教育中的应用，探索难以实际体验的旅游目的地的野性，文化体验和虚拟体验可以大大提高用户体验. 通过5G现场观看演出的远程地点，通过VR / AR技术观看的人们之间可以进行实时通信和互动. 网真服务是指让用户感觉好像他/她与用户位于同一地点的技术.它不仅限于视觉，还包括可以共享的五种感官，包括触觉.为了分享这种感觉，可以使用VR和全息图，或者可以利用机器人等实际的物理系统. 通过基于5G的AR / VR技术实时分析用户环境，可以以虚拟和可视数字内容的形式获取必要的信息. C.当前技术的局限性和5G的必要性/适当性 为了向用户提供实时的VR / AR服务，应解决图像质量和视角问题.全高清（FHD）和四路高清（QHD）以外的4K或8K分辨率可以解决清晰度问题.而且，VR视角的当前状态为110度左右，应达到200度的视角，以保证用户的满意度. 4G的最大传输速度对于移动服务来说不足以克服图像质量和视角问题.因此需要高速5G移动网络. 为了在移动环境中提供高清视频和3D图形，当使用个人设备或HMD（处理能力有限）进行处理时，存储/存储容量/加热/电池消耗问题也存在.这使得难以实时提供真实的内容.为了克服这些问题，需要在服务器端处理包括3D图形的复杂计算，然后将内容流式传输到用户终端的云处理.这导致了对5G技术的低延迟和高带宽网络的需求. 为了提供实时AR / VR服务以及高清视频，需要更快的传输速度，因为需要低延迟处理的技术，如语音识别，头部运动跟踪，注视跟踪，眼部手势感测，手势感测被利用，并且它们的传感器数据和高质量音频传输需要更多的数据传输速度.对于实时VR / AR服务，需要根据扫描速率对光子延迟7〜20ms或更小的运动.这个数字包含了通过网络时收发信息的延迟. 关于HMD，存在HMD设备的视觉信息和人类感知之间的不一致.因此，需要对低延迟处理和低延迟电信技术进行高级研究. 为了实施VR / AR，需要逼真的3D图形处理技术.由于这种3D图形数据量非常大，因此支持极高数据速率的5G移动通信技术势在必行. 3.1.2.大量内容流A.服务理念 随着数字和电信技术的发展，基于音频/视频的多媒体内容的供需在包括广播，电影，互联网和个人媒体在内的各个领域迅速扩大. 随着消费者对现实媒体的需求增加，显示技术的快速发展导致高清实际内容的需求急剧增长.同样在5G中，超高容量的视频内容流服务如4K高清（3840 2160）是全高清分辨率的4倍和8K超高清（7680 4320）的16倍.被推广.下图显示了图片分辨率的数据量比较. 随着视频分辨率的提高，多视图交互式3D服务，个人多媒体广播服务，海量内容共享服务以及3D全息图服务将通过5G技术进一步扩展. 全息术是利用光的干涉来记录与实际材料相同的3维信息的技术，全息图是指通过全息技术记录材料图像的照片胶片或视频.随着全息图技术的发展，将来可以实现实时超现实的移动全息电信服务. ※全息原理：通过光学干涉仪向物体提供良好的相干性的激光光线时，在物体表面发生散射反射的物体光束和与物体散射的物体光束相互交叉的物体光束相互交叉，两盏灯.在记录在照片记录材料上产生的光的干涉图案之后，如果再次将激光射线注入到照片记录材料上，则干涉图案作为衍射光栅.因此，即使没有实际的物体，物体的所有三维信息也可以毫无损失地恢复.如上所述，将记录在光学记录材料上的干涉图样与来自物体的散射光的大小和相位信息一起称为全息图. B.详细的服务使用案例 通过4K超高清和8K超高清内容流媒体服务，其尺寸比1080p全高清和可表达视频的尺寸大4倍和16倍，与以前的全高清相比，用户可以使用逼真的多媒体服务. 多维现实媒体是指通过五种感官可以看到，听到和感受到的信息，可以克服空间和时间的限制.由于技术上的限制，以前的媒体专注于简单的声音和视频传送.然而，可以表达和处理多维现实媒体，为5G世界的用户提供身临其境的感受，从而形成多维的真实媒体广播服务. 在5G中，提供了多视图交互式3D服务，可以提供视频的深度和立体效果.多视点视频以多种相机拍摄相同的三维场景.它旨在从多个角度实现一个场景，并提供以用户想要的视角拍摄的视频.但是，由于视频数量与摄像机数量相同，因此数据太大.因此需要有效处理这些技术. 不能参加重要奥运会的人可以通过实时超真实移动全息图表享受游戏乐趣.与电视相比，用户将能够享受更逼真的体验. 此外，全息图SMS信息可以通过基于5G的全息图技术实时传输.通过全息技术在移动设备中显示发送消息的用户的视觉.同样，视频通话可以提供自然的用户体验，以便通过移动设备实现与远程对端的真实对话. C.当前技术的局限性和5G的必要性/恰当性 利用当前的技术，可以提供高清视频通话/流媒体服务和高质量的语音通话服务.但是，这种服务与实际的面对面交谈在用户体验方面存在巨大差距.通过5G的海量内容流服务，预计可以解决这种用户体验差距. 为了向潜在用户提供定制的现实服务，需要全息图生成和传输技术. 4G技术具有1Gbps的数据速率，但是这种传输速率难以提供实时全息电信服务.因此，需要先进的5G技术研究来实现实时超现实的移动全息通信服务. 从根本上说，全息显示使用光的衍射.而且，只有当衍射光栅的尺寸接近光的波长时才可以实现相当大的衍射角. 实现全息图需要数TB的带宽，并且很难用5G带宽进行处理.因此应该制定控制转换到其最低速率的限制性全息图服务.还需要对压缩效率提高和解码算法等关键技术进行研究. 3.2.智能5G服务3.2.1.以用户为中心的计算A.服务理念 通过识别，解释和推断通过各种传感器采集的大数据情况信息，在确定用户的情况后，重新配置它们以适应情况，从而提供内容/服务. 收集与个人健康状况，精神状态，社交相关的生活记录后，可以根据大数据提供个人保健，心理治疗，痛苦，银护，社交生活指导，商业指导等智能治疗服务生活等. 由于设备和数据流量大量增加，未来网络拥塞会更加严重，因此，在连接到云计算服务器以使用移动服务的过程中，可能会严重导致网络延迟问题.在这种情况下，使用移动边缘计算技术可以减少延迟时间并最大限度地利用有线/无线资源的效率.移动边缘计算技术可应用于智能汽车，智能医疗，工业汽车，增强现实/虚拟现实和游戏等移动服务. B.详细的服务使用案例 基于通过传感器收集的大数据，它提供移动生活指导服务，提供咨询专家，心理学家，哲学家和社会学家的专业知识.它通过结合和处理移动用户的专家知识和经验，提供用户定制的知识服务.为了保证定制信息的及时性，移动边缘计算技术可以与大数据处理技术一起应用. 基于从与医疗保健和各种用户终端相关的传感器收集的大数据，可以提供个人健康管理服务和可能遍布全国的流行病管理. 根据从各种传感器收集到的大数据，可以提供预防及时处理灾害的服务，并提供早期的反作用服务，以应对气候变化和工业事故. C.当前技术的局限性和5G的必要性/恰当性 由于数据传输量急剧增加以及设备数量而导致的延迟和数据传输速率问题都需要解决.为此，5G技术和服务的研发是一个先决条件. 提高传感器和执行器的能源效率是必要的，需要扩展稳定的低功率通信技术.此外，还需要用于高效数据处理和从传感器收集的大数据的快速传输的技术.移动边缘计算技术对于减少用户在即将到来的移动世界中感知的延迟时间至关重要. 3.2.2.拥挤的地区服务A.服务理念 如果许多用户和终端在某个区域密集人群，那就被定义为一个拥挤的区域.在单位面积拥有大量用户的拥挤区域和终端中，存在大量的流量. 城市中的体育场馆，大型购物中心和拥挤区域可分为拥挤区域.在这种情况下，存在许多用户，并且他们具有各种类型的终端.用户有时会在不同的时间和不同的观点获得类似的内容. （他们观看UHD或3D视频，并且视频的开始时间和角度（或观点）可以根据用户而不同，因此这样的视频服务本质上不同于广播服务）.许多用户上传UHD视频，捕获到社交网络上. B.详细的服务使用案例 在体育场馆中，有许多观众，他们可以同时访问互联网，查看有关运动员，先前比分，比赛对手和以往比赛的亮点的信息.他们可能会在不同时间播放在体育场内各处拍摄的视频.在这种情况下，通过利用移动边缘计算和其他技术将视频的数据放置在基站的网络边缘，可以根据用户的需求发送视频，从而减少5G核心网络的负担，而不是将拍摄的视频在各个地方到中央服务器.用户可以上传用户捕获的多媒体数据. 在COEX等大型购物中心内，可提供收集产品介绍，优惠券和折扣活动等购物信息的服务.在这种情况下，信息可以根据用户的位置而不同，即基于位置的服务. 在江南或街头活动或音乐会等拥挤地区的场景中，人群聚集在那里，他们发送和接收各种多媒体内容. C.当前技术的局限性和5G的必要性/恰当性 这些拥挤的地区服务可以由当前的4G网络提供，条件是安装了许多基站并且骨干的容量（带宽）足够.因此，采用小蜂窝概念和移动边缘计算的新网络结构的5G可以在建立网络的成本方面高效地提供这样的服务. 在UHD和3D多媒体内容成为主要数据而不是当前低容量内容以及同时生成大量内容的情况下，5G网络需要支持更高的传输速率. 如果通过中央服务器以高容量传输多媒体数据，将会遇到骨干网络中处理能力和容量的限制.因此，5G网络需要诸如通过在本地服务器中定位服务数据来提供服务的本地缓存等技术. 3.3.无所不在的5G服务3.3.1.物联网（人，建筑物，城市）A.服务理念 当5G被广泛使用时，与4G相比，具有不同特性的多种终端将出现.除智能手机之外，一个人包含许多可穿戴设备，而且生活空间中的各种设备经常相互通信，并发生许多信息交换. 这种信息交流不仅限于个人区域通信，而且包括时间和空间在内的各种维度的大量信息由各种终端收集，并保存在一个巨大容量的存储设备中，并将通过大数据技术用于各种目的. 物联网的范围可以从个人区域延伸到社会范围如下. - 智能个人网络：它是由各种可穿戴设备组成的网络，包括智能手表，眼镜，各种医疗感应设备以及检查包括动作在内的各种数量的设备.个人网络的主要服务是信息娱乐，医疗保健，移动门房等. （参考：HIS，2013年10月） - 智能建筑：由电视，个人电脑（包括平板电脑），游戏机和各种家用电器组成的家庭网络可以被看作是物联网的一个例子.根据环境的不同，办公室或整个建筑可以是一系列物联网.将部署包含各种传感器，光和温度控制器，高效能源控制器和建筑物预防犯罪系统的收敛网络. - 智能城市：可以在一个城市（或社会）上配置一个网络，以通过使用广域网来提高效率.作为一个典型的例子，可以考虑使用几种类型的交通传感器的高效的交通灯控制系统.当自动驾驶汽车出现时，这种智能交通控制系统将能够通过车辆和基础设施之间的通信更加积极地控制交通.此外，还可以包括智能电网，智能电网是一个综合能源管理系统，用于控制各类建筑物的各种更新能源和能源消耗，以提高城市的能源效率.此外，通过使用大数据技术处理有关交通流量的信息，可以利用物联网建立高效的城市基础设施.根据信息的类型，它可以用于商业目的. B.详细的服务使用案例 作为物联网服务的例子，可以将智能个人网络服务说明如下： 服务通过传感器检查诸如血糖，血压和心率的个人健康状况，并且建议锻炼，食物和服药.对于专利，可以考虑自动注射药物并将病人的状况提供给负责医生. 根据日常事务信息，可以通知监控设备和位置识别设备位于个人移动路径中的推荐运输和到达时间.根据个人的生活模式提供各种个人信息也是可能的. 通过分析服务提供商网络基础设施内部存在的智能引擎，帮助用户做出符合用户偏好的最佳选择并适合用户的情况. C.当前技术的局限性和5G的必要性/恰当性 如果使用4G网络，由于将来有大量设备连接到网络，设备或数据流的标识（如国际移动用户识别码（IMSI）和IPv4）可能会被耗尽. 通过正交划分这些资源，4G网络使用给定的频率，时间和空间资源.然而，在物联网场景中，例如智能城市服务，与4G场景相比，与传感器，汽车，移动终端同时连接的链路数量增加了1000倍以上. 5G传输和网络技术需要通过有限的资源发送和接收数据来保持与多个终端的连接. 在提高整个城市和包括智能交通网络在内的智能城市网络的能源效率和电力供应的智能电网网络中，需要低等待时间（以ms为单位）的网络.如果这样的等待时间要求不能满足，交通安全方面的严重问题可能会导致整个城市的停电. 由于单位面积内终端数量的增加，应考虑整体业务的潜在增量.以智能个人网络为例，大部分流量都是由4G时代的智能手机产生的.然而，在5G时代，随着智能手机扮演传感器或人携带的可穿戴设备集线器的角色，交通量将急剧增加.另外，如果交互式手机游戏通过可穿戴设备运行，则应考虑提高数据传输速率. 截至目前，移动服务的价格是按终端收费的，即连接费.如果包括传感器在内的终端数量呈指数增长，则需要为传感器确定连接价格的新标准. 3.4.自主5G服务3.4.1.智能交通A.服务理念 智能交通是指方便安全的交通系统，最大限度地提高汽车，公交，地铁，航空等交通运营效率.在本节中，考虑通过结合5G和运输系统创造新的附加价值的自动驾驶车辆，车辆排队，交通安全和交通控制. 自主驾驶系统是指汽车通过传感器和人工智能算法识别，决定和命令的系统，无论驾驶员是否在车内.无人驾驶车辆平台是指在特定环境下按照既定命令和任务进行无人驾驶控制和驾驶的车辆平台. 下表显示了自动驾驶车辆的自动化水平. B.详细的服务使用案例 自主驾驶车辆：人工智能驾驶技术通过识别自身位置和周围环境识别危险，并通过规划路径控制车辆到达给定的目的地和动作来执行任务.自主驾驶汽车具有自行识别，决定，计划和控制的智能.此外，驾驶的主体是无人驾驶或自驾车，并不意味着一个人是否在这样的车内.如果将自动驾驶概括起来，那么车辆在驾驶汽车时将具有驾驶员休息的新的空间意义. 车辆排队：车辆可以通过与5G基站和车辆通信形成车辆排，更容易地在公路上行驶.车辆排由前车和后车组成，后车的司机可以休息，因为他们不需要控制方向盘. 5G基站实时了解车辆的位置信息，并通过5G低延迟通信交换加速/减速信息，并支持维持汽车之间的最小距离. 交通安全：在由于障碍物，恶劣天气和日落而无法确保视线的情况下，该服务通过快速感应和低延迟通信及时检测事故情况，并快速向具有移动边缘的5G基站提前计算功能来预防车祸. 交通控制：通过实时分析交通信息和信息，这项服务可高效安全地控制交通，防止在没有交通信号灯的十字路口发生交通拥堵. C.当前技术的局限性和5G的必要性/恰当性 无人驾驶车辆应处理至少1Gbps信息以找出环境并做出决定，但目前的技术无法支持在1 Km2范围内的数千辆汽车中同时传输和接收信息 5G移动服务技术对于指导驾驶路径，实时根据实时最佳路径运行的自动驾驶汽车的环境变化跟踪，以及驾驶汽车中的视频会议和高清内容流传输等. 在5G中，车对车（V2V）通信和车对基础设施（V2I）通信在无线通信中需要急剧的短暂等待时间，而目前的无线电技术无法提供交通安全服务. - 据了解，通过神经向人体传递电信号的速度最高可达120米/秒.这意味着人手感觉的信息在10ms内传递给大脑. - 由于自动驾驶汽车控制系统的信息更新周期为10ms，因此信息应在此时间内交付和处理. - 在无线通信中，需要几ms内的端到端延迟才能保证自然的即时交付，这种交付等同于通过人体神经传递电信号.然而，目前的无线电通信技术和半导体技术在提供这种低延迟无线电通信服务方面存在许多困难. - 换句话说，有很多问题需要解决，比如智能手机识别屏幕触摸，调制解调器，基站和网络延迟，安全性，身份验证，数据压缩延迟等.设计和开发考虑延迟的系统必要. 3.4.2.机器人A.服务理念 随着机器人及其技术的广泛部署，机器人正在生成各种应用领域.因此，接收由机器人发送的视频和数据并且将由人或控制系统确定的致动器控制信息再次传输给机器人的信息流将成为5G服务的典型示例. 机器人的感测数据通过网络传送到控制单元，控制单元给出的控制信息操作机器人的执行器.这一系列的操作被称为网络物理系统（CPS）. 5G机器人服务分为遥控操作和智能产业化服务. B.详细的服务使用案例 遥操作服务：指放置在偏远地方的机器人由人控制的服务.远程手术和遥感可以是一个典型的例子.- 如果考虑患者住在医疗设施差的农村医院的情况，并且大城市的综合医院的医生对该患者进行手术，则存在传输捕获手术的3D视频的系统实时现场和各种医疗数据，以及位于偏远地区的医院手术台中的手术机器人.综合医院的远程手术系统接收这些数据并将其显示给医生，并且医生根据该数据控制机器人并传递手术机器人的控制信息，由此手术机器人相应地执行动作. - 以放射性污染区域为例，将机器人发送到人不能直接在那里工作的地方，并且机器人根据机器人捕获的视频和各种感测数据进行远程控制以监视该区域. 智能工业化：智能工业化是指为了重复执行相同的工作而取代劳动力，例如使用机器人组装工艺.它也可以用于农业.机器人不能由人控制，而应由控制程序控制.在负责不同作业的多个机器人进行联合作业的情况下，重要的是让机器人在精确时间进行精确操作，同时监视其他机器人的所有动作. C.当前技术的局限性和5G的必要性/恰当性 为了让人感觉不到遥控器的延迟，需要少于20毫秒的延迟时间.例如，当一个人（控制器）改变机器人手臂的位置时，他/她应该觉得自己好像站在那里并且自己移动手臂.但是，目前的4G网络不符合这样的要求.因此，需要具有这种超低延迟的5G网络技术. 来自机器人的视频和感应数据应与实际看到的相同.应支持来自机器人的高清视频网络的传输速度.使用五感传感器以及高清3D或全息图的识别技术以及云计算技术可用于机器人服务.因此，宽带移动数据服务是必需的，因为这种情况下的数据量不容忽视.当多个机器人执行联合工作并将其数据交付给一个控制器时，宽带服务的需求变得更加重要.只有5G网络可以支持这种机器人服务. 机器人的故障与人的生命以及工作过程直接相关.因此应确保更高水平的网络可靠性.另外，为了将故障率保持在六西格玛以下，通过网络进行高可靠性的传感和控制数据传输是关键要求之一. 3.4.3.无人机A.服务理念 无人机可用于许多应用，因为它的优点是可以监视和飞行广阔的区域，没有任何空间限制.其工业领域可以持续增长.然而，由于法律规定和技术问题，无人机无法扩展到更广泛的行业，除了个人爱好或广播视频捕获之外. 如果可以通过5G克服无人机的技术限制，可以用于军事领域，灾难监控，基础设施管理，智能车辆，救灾，采购运输等. 用于无人机目的的5G网络服务被分类为用于传输捕获的视频的数据链路和由无人机收集的数据以及用于控制无人机的控制链路.另外，在这里可以考虑一个合作型无人机网络，其中许多无人机在一个小组中飞行并相互合作. B.详细的服务使用案例 为了军事目的，无人驾驶飞机可以在调查敌人的同时发挥捕获的视频的作用，并可以自己攻击敌人.无人驾驶飞机还可以与载人飞行器或地面部队合作，以提高战斗效率. 考虑使用无人机建立移动监视网络.这是移动CCTV的一个角色，当监控区域广泛时，可以配置网状网络或中继网络与多个无人机交换控制信息和视频数据. 无人机可用于监测灾难，检查大坝和桥梁等基础设施的状况.为此，可以在该地区安装的无人机和传感器之间建立一个网络.它可以用来监视状态并在灾难情况下人们无法访问的地区救援人员. 无人机在智能交通网络中发挥重要作用.无人驾驶飞机通过5G网络监控并提供市区或高速公路的交通状况. C.目前的技术限制和5G的必要性/适当性 目前没有关于无人机通信链路的具体标准，900MHz作为替代方案，2.4GHz或5GHz WiFi用于视频数据传输.因此，存在诸如通信范围限制，可靠性保证，网络延迟等问题.首先，需要通过在新的即将到来的5G中为无人机分配专用信道来扩展通信范围.通过配置5G自组织网络和采用中继技术，可以扩展范围. 为了遥控无人机，无人驾驶飞机收集的视频信息应顺利交付给控制器.尽管控制无人机的数据流量和通知控制状态的数据并不那么大，但要保证网络的低延迟和高可靠性. 为了提高无人机的运行时间，应使用高能效的5G传输和网络技术. 无人驾驶飞机最靠近收集无人机网状网络中的信息的终端，可能具有非常高的通信量，因为它们不仅要传送其自己收集的数据，还要传送由网状网络内其他无人机收集的信息，以信息收集终端.因此，由于当前解决方案的传输数据速率有限，无人机服务可能需要5G网络. 3.5.公共5G服务3.5.1.灾难监测A.服务理念 在山脉，海洋，放射性污染区域和火山区域，通过与公共安全网络互动并提供快速响应，使用多个传感器监测该区域，并最大限度地减少灾害情况下的损害. 无线传感器部署在监控区域.这些传感器通过电池或从周围环境收集能量的能量收集方法运行. B.详细的服务使用案例 对于山区，传感器使用温度，振动，风速和风向等传感信息监测森林火灾和景观变化. 放射性检测传感器安装在原子能发电厂的内部和外部以及放射性污染区域，并监测放射性指数的变化.通过这种方式，可以实时监测放射性污染，并将这些信息用于访问控制或灾难通知服务. 传感器安装在水坝，大型桥梁和高速公路等基础设施中，用于设施维护和监测崩溃风险. C.当前技术的局限性和5G的必要性/适当性 截至目前，使用传感器的监控网络使用其他网络，例如WiFi或ZigBee，然而，它们不能成为能够提供足够的覆盖范围服务质量，能源效率，网络可靠性和成本效益. 在5G网络中，传感器网络的要求，即覆盖范围（包括单链路覆盖和在网状网络中使用多跳中继的覆盖范围）和能源效率应同时考虑. 通过5G灾害监测网络提供的信息应以高可靠性传输.特别是，如果每个链路的特性在网状网络中动态变化，则应确保信息传递的可靠性. 传感器终端的连接成本以及建立灾害监测网络的成本也应考虑成本效益. 3.5.2.私人保安/公共安全A.服务理念 通过在灾难情况下使用移动基站和无线核心网络，应尽可能快地恢复网络.通过恢复网络，可以在受灾地区开展救灾活动.在救援人员无法通过无人机和无人机器人进入的情况下，克服空间限制是可能的. 在网络基础设施因灾难而崩溃的情况下，可以通过仅与移动设备形成无线网络来提供最低限度的电信服务. 通过连接城市安装的闭路电视，可以监控城市安全.通过与警察局和消防局的网络互动，可迅速对出现的情况作出反应. B.详细的服务使用案例 如果发生地震或山体滑坡，救援机器人可进入救援人员无法接近的地方，并将救援人员通知救援人员或指挥中心并远程救援并恢复现场. 当网络基础设施由于灾难而崩溃时，可以通过在启用公共安全（PS）的终端之间使用中继传输来提供通知救援人员位置的服务 综合性的犯罪预防网络服务通过私人或公共闭路电视和各种预防犯罪特征的传感器的互通提供. 公共安全网络可以用作军事战略网络，因为两者都有许多相似的特征. C.当前技术的局限性和5G的必要性/适当性 应该优先安排公共安全服务数据来优先处理公共安全服务. 能够通过具有广播其消息并在终端之间进行直接中继的PS终端提供服务 在公共安全网络或军事战略网络中，网络的安全性和可靠性应得到保证. 对于启用PS的终端，应确保高能效，以增加移动终端的操作时间. 考虑到服务特性，即长距离传输和能源效率，而不是带宽，需要为公共安全网络分配专用频率. 3.5.3.紧急服务A.服务理念 在紧急情况下，通过在救护车上提供患者病情数据并提供远程医疗服务，可以提高对出现的反应. B.详细的服务使用案例 如果山区发生需要紧急行动的事故，则通过急救机器人提供远程医疗. 如果在海上航行的船舶发生事故，可以提供紧急医疗和手术 C.当前技术的局限性和5G的必要性/恰当性 由于从紧急情况获得的医疗数据以及远程急诊医疗和外科手术的信息的交付应当保证可靠性和低延迟. 关于紧急事故和患者医疗数据领域的高质量视频需要高速传输，网络覆盖范围在没有网络基础设施的地区也非常重要. 第4章5G服务路线图和网络要求4.1. 5G网络要求4.2. 5G服务要求 每个服务的网络要求分类在下表中. 完]]></content>
      <tags>
        <tag>5G</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openBTS part11 附录C]]></title>
    <url>%2F2018%2F05%2F16%2FopenBTS-part11-%E9%99%84%E5%BD%95C%2F</url>
    <content type="text"><![CDATA[附录C捕获流量两种来源可用于捕获OpenBTS安装中的活动。可以记录网络的IP侧进行调试或分析，原始的GSM和GPRS无线电帧也是如此。统一到一个单一的流中，它为基带开发人员，应用程序作者和网络工程师提供了一个非常强大的研究工具。 IP流量第一个来源是在OpenBTS的各个组件之间发送的原始IP数据包。除了VoIP信令和媒体流之外，还有许多其他端口交换数据。表A-3列出了这些端口及其设置和类型的列表。为了从这些端口捕获数据，需要一个名为tcpdump的小型实用程序。它可以侦听系统上的任何网络接口，并显示和/或将流量记录到文件中。现在安装它：1$ sudo apt-get install tcpdump tcpdump的确切用法超出了本书的范围，因此仅举几个例子。要了解更多信息，请使用man（manual）命令：1$ man tcpdump 要从本地环回接口（-i lo）在控制台上显示（-s0 -A）所有SIP信令（portrange 5060-5069），请执行以下内容：1$ sudo tcpdump -i lo -n -s0 -A portrange 5060-5069 您可以将其记录在pcap（数据包捕获）格式的文件中，而不显示跟踪的流量。下面概述的Wireshark GUI工具使用pcap格式。要将所有RTP介质（portrange 16484-16584）记录到文件（-w rtp.pcap），执行以下命令：1$ sudo tcpdump -i lo -n -s0 -w rtp.pcap portrange 16484-16584 当运行一个多节点系统中，流量不会出现在环回接口上。它将通过硬件网络接口进行物理传输和接收。要指定此接口，请使用上面的“-i”标志，但用接口名称替换“lo”。例如，要在控制台上从eth0接口显示（-s0 -A）所有对等协议（端口16001），请执行以下命令：1$ sudo tcpdump -i eth0 -n -s0 -A port 16001 GSM流量IP流量为容易捕捉，但无线电接口如何？这样做有一个方便的功能，叫做GSMTAP。它将通过空中发送和接收的GSM和GPRS无线电突发重新封装为IP数据包。这些数据包然后成为正常IP跟踪的一部分，由tcpdump捕获，如上所述。有三个参数用于配置GSMTAP： Control.GSMTAP.GSM启用或禁用GSM跟踪Control.GSMTAP.GPRS启用或禁用GPRS跟踪Control.GSMTAP.TargetIP GSMTAP数据的IP目的地 假设所有组件都从同一台计算机上运行，控制.GSMTAP.TargetIP的默认值127.0.0.1会很好。这意味着GSMTAP帧将被发送到本地环回接口，以便通过tcpdump进行捕获。如果您的组件在不同的计算机上运行，​​则需要将Con trol.GSMTAP.TargetIP设置为您的中央服务计算机的IP地址。要开始发送GSM无线电通信作为IP，必须启用Control.GSMTAP.GSM密钥：1OpenBTS&gt; config Control.GSMTAP.GSM 1 Control.GSMTAP.GSM from “0” to “1” 现在，使用tcpdump捕获所有IP环回接口上的IP流量并将其存储为pcap文件：1$ sudo tcpdump -i lo -n -s0 -w gsmtap.pcap 当您完成跟踪时，可以通过按Ctrl-C来停止tcpdump。生成的文件gsmtap.pcap可以在Wireshark中打开。您可以在您的测试系统上安装Wireshark（如果它已经有可用的桌面），或者使用SFTP将pcap文件复制到您的日常桌面计算机上。 捕获在Wireshark中打开的TrafficOnce，GSMTAP数据可以显示为任何其他网络流量。它甚至有自己的显示过滤器：gsmtap。在下面的屏幕截图中，使用了一个相当常见的过滤器组合：（gsmtap或sip）和！icmp。通过这种滤波器组合，GSM和SIP信令按时间顺序可见，使得痕迹易于理解。图C-1来自成功向基站注册的手机的GSMTAP迹线。 Packets 1991和1992（OpenBTS和SIPAuthServe之间的SIP交换）启动了此GSM认证信息请求。突出显示的分组2042是从基站发送给手持设备的认证请求。下面的数据包2055是手机对基站的响应。图C-1。 Wireshark中的GSMTAP数据 正如您所看到的，与tcpdump和Wireshark相结合的GSMTAP是一个非常强大的工具。]]></content>
      <tags>
        <tag>OpenBTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openBTS part10 附录B]]></title>
    <url>%2F2018%2F05%2F16%2FopenBTS-part10-%E9%99%84%E5%BD%95B%2F</url>
    <content type="text"><![CDATA[附录B操作系统安装在新计算机或虚拟机上，请执行以下步骤以生成兼容的最低操作系统安装。如果您已安装兼容的操作系统，请随时跳到第8页上的“Git兼容性”。使用虚拟机时，必须至少将两个内核分配给该实例。 下载和准备启动媒体Ubuntu 12.04 LTS安装镜像（.iso文件）可从此页面下载。在“服务器安装CD”部分中，下载从“PC（Intel×86）服务器安装CD”链接的文件。“这是32位服务器安装程序。 Ubuntu桌面与Ubuntu服务器一样也同样工作，但服务器版本的安装足迹更小。图像下载完成后，可以将其刻录到物理磁盘上，以便安装在独立的服务器硬件上。如果您使用的是虚拟机，只需在系统提示启动介质时选择该.iso映像文件即可。 如果您正在使用VMware软件，请取消选中“使用简易安装”选项。一旦物理服务器将这个新磁盘放入其CD托盘中，将其启动。同样，现在可以启动新的虚拟机。 开始安装您将看到的第一件事是语言选择菜单。这是将用于安装过程的语言。本书将使用英文，但可以随意使用您的母语。用箭头键移动选择器以突出显示所需的语言，然后按Enter键。现在主菜单如图B-1所示。图B-1。主菜单从该菜单中选择“安装Ubuntu服务器”。 配置安装显示的下一个屏幕是另一个语言选择菜单。这是将在安装的系统中使用的语言，而不是安装过程。再次，本书将使用英文，但如果需要，您可以选择更舒适的选项。使用箭头键移动选择器以突出显示所需的语言，然后按Enter键。随后的屏幕标题为“选择您的位置”，用于配置时区和区域设置，例如日期和时间的格式。美国将在本书中使用。使用箭头键移动选择器以突出显示您的国家，然后按Enter键。现在你的键盘布局必须被选中。您可以使用键盘布局自动检测或选择国家和布局。检测是一系列相对简单的要求按键和问题，将决定使用的键盘类型。本书中的步骤假定您使用了自动检测方法。出现“检测键盘布局？”的问题后，使用箭头键选择“是”并按下Enter开始自动检测过程，如图B-2所示。完成后，按Enter键确认检测到的布局，选择“继续”。图B-2。键盘选择最后，必须为系统输入一个主机名。您可以选择适合您的网络命名方案的主机名。本书使用默认名称“Ubuntu”。通过按Tab选择它以突出显示“继续”，然后按Enter键确认。 添加OpenBTS用户系统上必须存在用户“openbts”。最简单的方法是在安装过程中进行配置。在“设置用户和密码”屏幕上的“新用户全名”字段中，输入“openbts”，按Tab键突出显示“继续”，然后按Enter键确认。配置安装| 87将出现下一个字段，“您帐户的用户名”。在此字段中输入“openbts”，按Tab键突出显示“继续”，然后按Enter键确认。现在将显示新用户的密码字段。输入密码，按Tab突出显示“继续”，然后按Enter键确认。随后将出现密码确认字段。输入相同的密码，按Tab键突出显示“继续”，然后按Enter键确认。如果密码不够复杂，可能会出现一个屏幕，询问您是否要使用此弱密码。您可以选择制作更复杂的密码，也可以接受它。一旦提问“使用弱密码？”，请使用箭头键选择“是”或“否”，然后按Enter键确认。最后，会出现一个屏幕，询问您是否想为该用户的主目录加密。 OpenBTS套件尚未经过加密用户目录的测试，因此此处的安全选项为“否”。使用箭头键选择“否”并按Enter键确认。 网络配置和自动检测安装程序大多会自动执行下一节，因为它使用DHCP自动配置网络连接。如果DHCP服务不可用，则需要手动输入服务器的IP地址以及网络的网络掩码，网关和DNS信息。这不在本书的范围之内。请在线查阅Ubuntu服务器文档。网络硬件和配置自动完成后，将出现带有自动检测时区的提示，如图B-3所示。图B-3。时区自动检测如果时区对应您的位置，请使用箭头键选择“是”，然后按Enter键确认。如果不匹配，请选择“否”，然后按Enter键调出手动选择菜单。 配置磁盘安装程序现在已经快要开始将文件写入磁盘，但必须先对其进行分区。最简单的方法是让Ubuntu使用整个磁盘。如果您已经在磁盘上安装了另一个操作系统，或者想自定义所使用的分区方案，则需要再次查阅Ubuntu文档，因为这不在本书的讨论范围之内。在“分区磁盘”屏幕上的“分区方法”问题中，使用箭头键突出显示“引导 - 使用整个磁盘”并按Enter键确认。将出现一个新的屏幕，列出可用的磁盘。使用箭头键突出显示所需的目标磁盘，然后按Enter键确认。最后，将出现一个确认屏幕，如图B-4所示。图B-4。提交对磁盘提示的更改请确保它是正确的目标磁盘。完成此步骤后，磁盘内容可能会不可逆转地丢失。对于“将更改写入磁盘？”问题，请使用箭头键选择“是”，然后按Enter键确认。 基本软件和更新程序包管理器现在需要配置。出现的第一个屏幕允许您在网络上指定HTTP代理。如果有，请在“HTTP配置磁盘”中输入89proxy信息“字段;否则留空。按Tab键突出显示“继续”，然后按Enter键确认。标题为“配置tasksel”的下一个屏幕允许在系统上激活自动更新。为避免未经您许可的情况下安全更新破坏您的系统的可能性，应将其停用。按回车确认“无自动更新”的默认值。最后，将出现一个屏幕，允许您将一些基础软件添加到默认安装。唯一有趣的项目是“OpenSSH”，它安装了Secure Shell服务，允许远程控制台访问服务器。使用空格键激活“OpenSSH”，然后按Tab键突出显示“Continue”并按Enter确认，如图B-5所示。图B-5。将SSH添加到默认安装 完成安装仍需要一小部分名为GRUB的软件，以便可以在系统引导时加载操作系统。与分区说明一样，如果您将Ubuntu安装在另一个现有操作系统旁边，则需要查阅Ubuntu文档。出现“将GRUB引导装载程序安装到主引导记录？”的问题后，使用箭头键突出显示“是”，然后按Enter键确认。最终屏幕将显示确认安装已完成。如果这是一台物理服务器，请在此时删除安装CD。按Enter确认，系统现在将重新启动。 第一次登录系统重新启动后，请使用用户名“openbts”和密码登录。 SSH如果您不想直接使用Linux服务器硬件或虚拟机，请改为使用SSH访问。这是在安装步骤中安装的“OpenSSH”服务。它允许您通过网络连接登录到计算机。如果您使用的是OS X或Linux桌面，则SSH客户端是内置的。打开终端应用程序并执行以下命令：$ ssh openbts @ your-linux-server-ip如果您使用Windows，则需要一个第三方客户端。最流行的是PuTTY。使用以下登录详细信息进行连接：•用户名：openbts•密码：您选择的密码•主机：your-linux-server-ip•端口：22您已登录并准备好继续配置开发环境。]]></content>
      <tags>
        <tag>OpenBTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openBTS part9 附录A]]></title>
    <url>%2F2018%2F05%2F16%2FopenBTS-part9-%E9%99%84%E5%BD%95A%2F</url>
    <content type="text"><![CDATA[附录A快速参考以下是遍布本书的许多事实的快速参考。我发现自己经常看这些东西，并想把它们放在一个统一的部分。 GSM层次结构本书不能尝试在短短几章中教给你GSM。然而，掌握一个非常有用的东西是从宏观到微观的GSM术语的层次结构。塔是我们都熟悉的天线，有时伪装成仙人掌或树。每座塔可以分为多个部门。这些部门覆盖了可能的360º的一部分（例如塔上的四个90º扇区）。一个单一的塔楼覆盖360º。每个扇区将被分配一个或多个ARFCN，有时也称为载波，因为它们是实际交换数据的实际频率对。每个ARFCN有八个时隙。每个时隙都有一个分配给它的组合。每个组合都由多个逻辑通道组成。这些逻辑信道被划分为信令和媒体两大类。 SDCCH（独立专用控制信道）携带手机注册流量或SMS流量等信令。 TCH（业务信道）承载诸如GPRS数据或语音业务的媒体。逻辑信道由多个帧组成，帧由突发组成。要查看此系统的实际运行情况，请打开GSM时隙和通道可视化器。 分贝和分贝毫瓦分贝可用于表示两个值之间的比率，或者与基本单位配对时表示绝对值。当以dB表示时，仅表示比率。例如，10dB的SNR意味着信号比噪声强10倍。当写入81dBm时，以毫瓦表示绝对值。例如，GSM手机可以传输最大33 dBm或2 W.需要牢记的一个便利因素是，每次发生3 dB的变化时，该比率会增加一倍或两倍。 Table A-1. dB: Decibels and ratios dB Ratio 30 1000 20 100 10 10 6 ~4 3 ~2 1 1.259 0 1 -1 0.794 -3 ~0.5 -6 ~0.25 -10 0.1 -20 0.01 -30 0.001 Table A-2. dBm: Decibel milliwatts dBm Absolute value 30 1000 mW or 1 W 20 100 mW 10 10 mW 6 4 mW 3 2 mW 1 1.3 mW 0 1.0 mW or 1000 µW -1 794 µW -3 501 µW -6 251 µW -10 100 µW -20 10 µW -30 1 µW or 1000 nW Network PortsTable A-3. Network ports Port Type Setting Description 5062 UDP SIP.Local.Port OpenBTS SIP signaling 5063 UDP SIP.Local.Port SMQueue SIP signaling 5064 UDP SIP.Local.Port SIPAuthServe VoIP SIP signaling 5700 UDP TRX.Port Raw radio samples between OpenBTS and transceiver application 16001 UDP Peering.Port OpenBTS multinode info and event string exchange 16484 UDP RTP.Start and RTP.Range OpenBTS VoIP RTP media 45060 ZeroMQ RESP NodeManager.Commands.Port OpenBTS NodeManager command port 45063 ZeroMQ RESP NodeManager.Commands.Port SMQueue NodeManager command port 45064 ZeroMQ RESP NodeManager.Commands.Port SIPAuthServe NodeManager command port 45160 ZeroMQ PUB NodeManager.Events.Port OpenBTS NodeManager events port 49300 TCP CLI.Port OpenBTS command-line interface string exchange File PathsTable A-4. Important files File path Description /etc/OpenBTS/OpenBTS.db OpenBTS configuration database /etc/OpenBTS/SIPAuthServe.db SIPAuthServe configuration database /etc/OpenBTS/SMQueue.db SMQueue configuration database /var/log/OpenBTS.log Logging destination for events from all components /etc/asterisk/sip.conf Extra SIP account configuration for Asterisk /etc/asterisk/extensions.conf Extra dialplan configuration for Asterisk /var/lib/asterisk/sqlite3dir/sqlite3.db Subscriber registry database used by SIPAuthServe, SMQueue, and Asterisk]]></content>
      <tags>
        <tag>OpenBTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openBTS part8]]></title>
    <url>%2F2018%2F05%2F16%2FopenBTS-part8%2F</url>
    <content type="text"><![CDATA[第八章向前和向上希望你已经完成了本书，成功实现了你感兴趣的领域。以下是进一步研究和实验的几个起点。 连接到外部世界 要将手机与外部世界中的“真实”手机连接起来，您需要Internet电话服务提供商（ITSP）。 ITSP接受来自您的网络的SIP信令和RTP媒体，并将它们桥接到PSTN。 语音 为语音服务寻找ITSP非常简单。已经有这些公司的在线直播，并且有多种计划可以从预付费的会议分钟到按月计费。入境电话号码或直接拨号（DID），也在全球大多数国家提供。其中许多公司还提供使用Asterisk时如何连接它们的说明，并可为您的安装提供技术支持。 短信 短信更难。没有太多的ITSP将SMS MESSAGE提供给SMS服务。提供此服务的提供商通常不会将其与语音DID配对，因此单个手机在进行语音呼叫时的发件人ID与发送SMS消息时的呼叫者ID不同。这种情况正在改善，但现在需要替代品。其他提供商提供短消息点对点（SMPP）网关或HTTP REST API网关。同样，所有DID的可用性都是不可预知的，并且需要一些额外的粘合剂才能从SIP MESSAGE连接到这些解决方案中的任何一个。 nexmo提供了一个使用这种API的成功集成示例。 频谱管制本书无法解决的头号问题是受到严格管制的无线电频率的合法可用性。虽然传统上只有最大的参与者才能获得频谱，但这种情况正在开始发生变化。监管机构的压力越来越大，将访问划分为更小的可用块，并将其分发给愿意在本地区做一些有用的事情的实体。在欧洲，最具前瞻性的频谱政策似乎正在发展。英国，荷兰和瑞典已经分配了几个ARFCN的频谱供公众使用，包括标准的GSM频段。任何人都可以在没有许可证的情况下以有限的功率水平使用这些频率美国联邦通讯委员会似乎在不断发展，并计划在2015年进行一场大型频谱拍卖，为特定区域的无执照使用释放高达28 MHz的保护频谱。动态频谱联盟等组织和GSM空白研究等举措分别在政治和技术上解决频谱接入问题。 开关集成 目前正在开展工作以标准化OpenBTS所需的SIP信号 - 主要是使用GSM和UMTS认证算法而不是MD5。迄今为止，整合一直是一次性的，但努力正在加速。使Asterisk和FreeSWITCH直接支持来自OpenBTS的注册和语音呼叫的补丁已经编写完成，并且正处于这些项目采用的各个阶段。 Kazoo平台已经拥有最全面的支持，包括注册，语音和短信全部工作。 3G数据OpenBTS-UMTS 1.0于2014年10月发布。它是我们所知道的第一个开放源UMTS协议栈，并将3G数据速度添加到这些新“混合网络”的功能列表中。更多信息请参见此处。 开源硬件 如果你是一个硬件设计师，并且对SDR是如何构建好奇的，那么你很幸运。移动网络不仅使用开源软件构建，而且使用开源硬件构建。几个SDR的原理图完全打开并在GitHub上提供。•Fairwaves UmTRX•HackRF•Range Networks RAD1 / SDR1 社区 OpenBTS社区可以提供许多主题的专业知识。注册邮件列表。有不同背景的参与者：制造商，黑客，研究人员和集成商欢迎！ 革命如果要使用互联网世界的标准来设计现代移动网络，会是什么样子？我们开始看到这个问题的答案：大规模简化，非常灵活，可以接受各种新想法，而且价格便宜很多。有史以来第一次，凡人可以下载一些软件，拿起radio，并建立一个功能性的移动网络。欢迎来到革命！]]></content>
      <tags>
        <tag>OpenBTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openBTS part7]]></title>
    <url>%2F2018%2F05%2F16%2FopenBTS-part7%2F</url>
    <content type="text"><![CDATA[第7章NodeManager APINodeManager是用于系统配置和监视的跨OpenBTS，SMQueue和SIPAuthServe的通用控制接口。所有组件都支持一些通用功能（如配置操作），并使用可用于组件特定任务或数据源的专用API。 NodeManager API分为两大类：请求/响应和流。这两种类型都使用JSON格式的消息并通过ZeroMQ进行通信，ZeroMQ是一个在进程间创建简单且可靠的套接字连接的库。实施NodeManager API以简化多个OpenBTS实例的远程管理，以及SMQueue和SIPAuthServe等中央服务。 API是互联网的正常组成部分，因此这可能看起来不太令人兴奋。但是，当阅读第74页上的“PhysicalStatus API”时，请牢记图I-1。不需要十几种协议和实体 - 核心无线电测量数据现在可直接作为JSON消息流使用！其他API将在未来的发行版中添加到NodeManager界面中。 nmcli.py在名为nmcli.py的NodeManager存储库中包含一个小型Python实用程序。它需要安装一些依赖项，但build.sh脚本（在第9页的“构建代码”中）应该已经完成​​了。为了确保拥有它们，下面是手动命令：123$ sudo add-apt-repository -y ppa:chris-lea/zeromq$ sudo apt-get update$ sudo apt-get install libzmq3-dev libzmq3 python-zmq nmcli.py的功能总是在新的NodeManager API实现时扩展。要查看当前使用情况，请运行nmcli.py，不要使用任何参数：1$ ./nmcli.py nmcli.py的实用程序不是作为NodeManager API的专业接口，而是用于快速格式化消息并在实现时测试新API端点的开发工具。它将在本章中用于演示不同的API端点。首先列出nmcli.py的用法，然后是交换格式化的JSON消息。 版本API所有组件都实现版本，请求/响应API。这是一个简单的API，但公开了一个非常重要的关于在远程节点上运行的组件的信息：它的当前版本。现在使用nmcli.py向SMQueue询问它的版本：1$ ./nmcli.py smqueue version 它发送给SMQueue的JSON请求非常简单：123&#123; &quot;command&quot; : &quot;version&quot;&#125; …并且回应同样是明确的：1234&#123; &quot;code&quot; : 200, &quot;data&quot; : &quot;release 5.0.0-prealpha+667f928701 CommonLibs:3ad343b97b built 2014-09-17T21:26:56 &quot;&#125; 配置API所有组件都实现config，一个请求/响应API。该API用于修改每个组件中的配置值。每个组件的配置模式在接受请求之前对其进行评估，这使得API更适合于简单地更新适当的SQLite3数据库中的值。 读取所有键现在使用nmcli.py向SMQueue询问所有配置参数：1$ ./nmcli.py smqueue config read 它使用“config”命令和“read”操作生成请求：1234&#123; &quot;command&quot; : &quot;config&quot;, &quot;action&quot; : &quot;read&quot;&#125; SMQueue以其支持的每个配置键的巨大列表响应（剪切为空间）：123456&#123; &quot;code&quot; : 200, &quot;data&quot; : [ ... ]&#125; 读取一个键API还支持读取特定键。现在使用nmcli.py向SC.Register.Code参数询问SMQueue：1$ ./nmcli.py smqueue config read SC.Register.Code 它使用“config”命令和“read”的操作以及SC.Register.Code的新关键字段生成请求：12345&#123; &quot;command&quot; : &quot;config&quot;, &quot;action&quot; : &quot;read&quot;, &quot;key&quot; : &quot;SC.Register.Code&quot;&#125; SMQueue响应使用此特定配置键的模式和值信息：+123456789101112131415&#123; &quot;code&quot; : 200, &quot;data&quot; : &#123; &quot;defaultValue&quot; : &quot;101&quot;, &quot;description&quot; : &quot;Short code to the application which registers the sender to the system.&quot;, &quot;key&quot; : &quot;SC.Register.Code&quot;, &quot;scope&quot; : 0, &quot;static&quot; : false, &quot;type&quot; : &quot;string&quot;, &quot;units&quot; : &quot;&quot;, &quot;validValues&quot; : &quot;^[0-9]&#123;3,6&#125;$&quot;, &quot;value&quot; : &quot;101&quot;, &quot;visibility&quot; : &quot;customer - can be freely changed by the customer without any detriment to their system&quot; &#125;&#125; 请求不存在的键将导致类似于组件的404响应： 123&#123; &quot;code&quot; : 404&#125; 更新如果配置API不允许设置新值，那么配置API不会太有用。消息的操作字段将更改为“更新”，并且必须指定一个包含所需更改的新值字段。使用nmcli.py来更新我们查询的最后一个键—SC.Register.Code-为555而不是101：1$ ./nmcli.py smqueue config update SC.Register.Code 555 注意新的值字段和更新的动作字段：123456&#123; &quot;command&quot; : &quot;config&quot;, &quot;action&quot; : &quot;update&quot;, &quot;key&quot; : &quot;SC.Register.Code&quot;, &quot;value&quot; : &quot;555&quot;&#125; 响应包括两条信息：1234&#123; &quot;code&quot; : 204, &quot;dirty&quot; : 0&#125; 204代码表示动作是成功但没有需要报告的数据。肮脏的领域让你知道，没有任何需要应用的静态键，也就是说，你的配置是活的。如果脏不为零，则最终需要重新启动组件才能完全应用更改。以下是其他响应方式：•304：无需更改，旧值和新值匹配•404：未知键（与读命令类似）•406：新值无效•409：新值与另一配置键冲突•500 ：数据库错误，存储新值失败 PhysicalStatus APIOpenBTS是实现PhysicalStatus（流API）的唯一组件。它没有被默认激活;使用NodeManager.API.PhysicalStatus键来启用它。为了保持向后兼容性，PhysicalStatus API在发布时支持不同的模式。目前，只有模式0.1已经实施。将键设置为值0.1将使用模式0.1激活PhysicalStatus API和流事件数据。由于您已经有了nmcli.py，所以现在就使用它来激活API：1$ ./nmcli.py openbts config update NodeManager.API.PhysicalStatus 0.1 在激活此流后，您需要附加一个客户端来查看正在生成的数据。 OpenBTS / apps存储库目录中提供了一个名为JSONEventsClient.cpp的示例客户端。它在构建OpenBTS时默认编译，但在使用该包时未安装到系统上。该客户端连接到由NodeManager.Events.Port定义的ZeroMQ端口，并等待API发布事件。立即进入OpenBTS源代码的克隆版并执行客户端：12$ cd dev/openbts/apps$ ./JSONEventsClient 在OpenBTS安装中存在活动之前，没有什么有趣的事情会发生。重启手机，发送短信或拨打电话，PhysicalStatus读数将开始显示在控制台上。这些读数的例子如下：12345678910111213141516171819202122232425262728293031&#123; &quot;name&quot; : &quot;PhysicalStatus&quot;, &quot;timestamp&quot; : &quot;18446744072283447705&quot;, &quot;version&quot; : &quot;0.1&quot;, &quot;data&quot; : &#123; &quot;burst&quot; : &#123; &quot;RSSI&quot; : -49.4808, &quot;RSSP&quot; : -27.4808, &quot;actualMSPower&quot; : 11, &quot;actualMSTimingAdvance&quot; : 0, &quot;timingError&quot; : 1.59709 &#125;, &quot;channel&quot; : &#123; &quot;ARFCN&quot; : 153, &quot;IMSI&quot; : &quot;001010000000001&quot;, &quot;carrierNumber&quot; : 0, &quot;timeslotNumber&quot; : 0, &quot;typeAndOffset&quot; : &quot;SDCCH/4-1&quot;, &quot;uplinkFrameErrorRate&quot; : 0 &#125;, &quot;reports&quot; : &#123; &quot;neighboringCells&quot; : [], &quot;servingCell&quot; : &#123; &quot;RXLEVEL_FULL_dBm&quot; : -67, &quot;RXLEVEL_SUB_dBm&quot; : -67, &quot;RXQUALITY_FULL_BER&quot; : 0, &quot;RXQUALITY_SUB_BER&quot; : 0 &#125; &#125; &#125;&#125; 这些读数显示手机和基站之间的业务流量时的物理无线电突发信息。这些读数也称为测量报告，作为GSM标准的一部分发生在背景中。它们为基站提供用于适当调整手机发射功率的信息，触发切换消息并计算定时提前。那么访问这些数据的价值是什么？许多应用程序可以使用这些有关网络无线电条件的原始元信息来做出明智的功耗决策，更加智能地分担负载，等等。它目前正在用于搜索和救援行动。冰岛的直升机配备了运行OpenBTS的便携式基站，并且正在飞往偏远地区，在那里已知失去远足者。 OpenRegistration配置为使该区域中的所有手机都自动允许加入网络。当网络发送测试SMS消息时，来自基站和手机的无线电接收电平和发射功率被不断记录。除了这些无线电信息外，还记录了直升机当前的纬度，经度和高度。然后可以对这些信息进行算法分析，以确定在高达35公里的距离内65米范围内任何手机在该区域的位置。关于这个项目的更多信息可以在这里找到。]]></content>
      <tags>
        <tag>OpenBTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openBTS part6]]></title>
    <url>%2F2018%2F05%2F16%2FopenBTS-part6%2F</url>
    <content type="text"><![CDATA[第6章OpenRegistrationOpenRegistration是OpenBTS特有的功能，可为移动网络提供WiFi专用门户实施。任何使用机场或酒店的公共WiFi连接的人都熟悉门禁门户。您的设备可以连接到WiFi网络，但在您回答问题，观看广告，输入PIN等设备之前，将被拒绝访问某些功能。设备用于自行设置。同样，OpenRegistration允许手机以最初限制访问的方式加入移动网络。它可以拨出，但手机没有分配的号码，因此不能由网络中的其他参与者呼叫。但是，它可以用于通过SMS提供自己的号码。这种类型的网络在用户临时性和流动性或网络本身只是临时需要的任何临时安装中非常有用：应急响应，远程工作区域，旅游目的地，大型节日等等。因为管理员不是需要创建账户和分配号码，OpenRegistration网络更容易部署，对用户来说仍然非常有用。 启用要开始使用OpenRegistration网络，必须启用功能本身。首先，看一下键：123456OpenBTS&gt; config OpenRegistrationControl.LUR.OpenRegistration (disabled) [default]Control.LUR.OpenRegistration.Message Welcome to the test network. YourIMSI is [default]Control.LUR.OpenRegistration.Reject (disabled) [default]Control.LUR.OpenRegistration.ShortCode 101 [default] 要启用OpenRegistration，必须将Control.LUR.OpenRegistration键设置为正则表达式。正则表达式（有时写成“正则表达式”）是定义要匹配的模式的一种方式。他们有一些标准，更多的信息可以在Wikipedia上找到。匹配此正则表达式的IMSI将被授予访问网络的权限。表6-1列举了一些模式的例子及其效果。Table 6-1. OpenRegistration regular expressions Regular Expression OpenRegistration Effect .* Match all IMSIs ^460 Match any IMSI starting with “460”, the MCC for China ^46002 Match any IMSI from China Mobile (MCC=460, MNC=02) 460027217080245 Match only IMSI “460027217080245” 0 Match any IMSI containing a “0” 1 Match any IMSI containing a “1” 1234$ Match any IMSI ending in “1234” 对于本书，OpenRegistration将被启用以接受它遇到的任何IMSI：12OpenBTS&gt; config Control.LUR.OpenRegistration .*Control.LUR.OpenRegistration changed from &quot;&quot; to &quot;.*&quot; 还有一个额外的键允许明确拒绝它匹配的IMSI。如果您希望允许除特定组以外的每个IMSI，这很方便。再次从上面的表格中，设置网络明确拒绝来自中国移动的任何IMSI：12OpenBTS&gt; config Control.LUR.OpenRegistration.Reject ^46002Control.LUR.OpenRegistration.Reject changed from &quot;&quot; to &quot;^46002&quot; 确保您有信心在野外部署它们之前了解这些模式如何工作。噩梦般的情况是有人无意中加入了你的开放网络，心脏病发作，并且因为你的网络不支持它而无法呼叫紧急服务。仔细检查您的网络的GSM.RACH.AC仍然被设置为默认值0x0400。这会在您的信标中宣传“不支持紧急呼叫”。 个性化加入你的网络的用户将会看到Control.LUR.Open Registration.Reject键的内容。现在更改为与您的安装更相关：12345OpenBTS&gt; config Control.LUR.OpenRegistration.Message Welcome to IslandNet! Callor text 101 for assistance. Your IMSI is:Control.LUR.OpenRegistration.Message changed from &quot;Welcome to the test network.Your IMSI is &quot; to &quot;Welcome to IslandNet! Call or text 101 for assistance. YourIMSI is: &quot; 这指示新加入的成员通过拨打101寻求帮助。您的网络应该有人分配给101号码或在那里实施自动语音菜单。用户也可以按照指示向该号码发送短信。默认情况下，SMQueue具有101号码的简码处理程序，并将开始与用户进行对话，以获得指定的电话号码。 SMQueue中的SC.Register。参数控制使用哪种短代码以及消息的措辞，以及允许用户可选的数字范围。 SMQueue尚未具有CLI界面，但nmcli.py可用于读取和修改这些参数：12$ ./nmcli.py smqueue config read$ ./nmcli.py smqueue config update Configuration.Key.Name new-value 如果您想使用101以外的数字，则应确保将OpenBTS Control.LUR.OpenRegistration.ShortCode设置为你的新号码。该键设置欢迎短信的源地址。如果它被设置为您的新帮助号码，用户可以简单地回复初始消息。 禁用要再次禁用OpenRegistration，必须重置接受和拒绝模式：1234OpenBTS&gt; unconfig Control.LUR.OpenRegistrationControl.LUR.OpenRegistration disabledOpenBTS&gt; unconfig Control.LUR.OpenRegistration.RejectControl.LUR.OpenRegistration.Reject disabled OpenBTS现在已恢复为使用订户数据库来授予或拒绝访问，而不是IMSI模式。]]></content>
      <tags>
        <tag>OpenBTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openBTS part5]]></title>
    <url>%2F2018%2F05%2F16%2FopenBTS-part5%2F</url>
    <content type="text"><![CDATA[第5章GPRS移动网络已经在世界的许多地区沦为数据网络。像WhatsApp和Skype这样的OTT服务只需要一个数据管道，参与者可以连接到任何运营商。参与者之间的费用也不取决于地理位置，不同于本地和长途费用。 GPRS的速度太慢，无法支持双向流视频，但可以满足低质量的语音通话。它的速度非常适合电子邮件和OTT短信。传感器和基础设施（如热量和流量传感器或电子和停车计时器）的世界也需要数据连接。这些低带宽机器到机器（M2M）设备，现在被称为物联网（IoT）设备，是GPRS的一种非常常见的用途。 GPRS实际上不是GSM的一部分。它是在GSM已经标准化之后开发的，通常被称为2.5G，而普通的GSM是2G。 OpenBTS可以抽象出这些差异，并在可能的情况下提供统一的配置。 启用/禁用默认情况下，OpenBTS中的GPRS服务被禁用。通过切换GPRS.Enable键现在打开它：123OpenBTS&gt; config GPRS.Enable 1GPRS.Enable changed from &quot;0&quot; to &quot;1&quot;GPRS.Enable is static; change takes effect on restart 重新启动OpenBTS以应用此静态键：12$ sudo stop openbts$ sudo start openbts 一旦OpenBTS重新启动，请重新登录其命令行并使用gprs list命令确认OpenBTS已为GPRS设置了几个通道：123OpenBTS&gt; gprs listPDCH ARFCN=166 TN=1 FER=0%PDCH ARFCN=166 TN=2 FER=0% 中央服务GPRS不依赖任何附加组件，但是必须在Linux主机上安装一些配置才能正常工作。在安装过程中，这应该已经从range-configs包中处理好了，但这是如何仔细检查事情是否正常。手机的IP流量通过OpenBTS传输到名为sgsntun的虚拟网络接口中。您现在可以确认OpenBTS已经使用ifconfig创建了它：1234567$ ifconfig sgsntunsgsntun Link encap:UNSPEC HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00UP POINTOPOINT RUNNING NOARP MULTICAST MTU:1500 Metric:1RX packets:0 errors:0 dropped:0 overruns:0 frame:0TX packets:0 errors:0 dropped:0 overruns:0 carrier:0collisions:0 txqueuelen:500RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) 虚拟网络接口还需要应用于iptables Linux防火墙的路由和规则。示例规则位于/etc/OpenBTS/iptables.rules中，如果需要更改网关接口名称，则可以对其进行修改。默认情况下，它们是为eth0编写的。现在手动应用规则：1$ sudo iptables-restore &lt; /etc/OpenBTS/iptables.rules 为了让系统在每次启动eth0界面时应用这些规则，修改/ etc / network / interfaces以添加下面包含“pre-up”的最后一行：123456789# This file describes the network interfaces available on your system# and how to activate them. For more information, see interfaces(5).# The loopback network interfaceauto loiface lo inet loopback# The primary network interfaceauto eth0iface eth0 inet dhcppre-up iptables-restore &lt; /etc/OpenBTS/iptables.rules 在隧道设备存在且应用规则，你的Linux主机应该是有序的。 连接尽管您的手机应该执行LUR并在网络恢复后加入网络，但可能还需要其他步骤来确保GPRS服务已被识别并可用。在GPRS中，这不是一个LUR;它被称为GPRS连接。由于几个原因，手机可能无法执行此附件。如果您正在使用其他运营商的SIM卡，则手机GPRS子系统在加入OpenBTS网络时可能会认为自己正在漫游。除非手机中的“使用数据漫游”已打开，否则GPRS子系统不会尝试进行附加。再次检查您的手机的接入点名称（APN）设置。 OpenBTS不关心在名称，用户名和密码字段中放入了什么信息，但手机可能不会发出附加请求，直到输入内容。当涉及APN条目时，Android有一个非常奇怪的错误。在某些版本中，您可以添加新的APN，但除非您输入的移动国家代码（MCC）和移动网络代码（MNC）与SIM卡上定义的那些匹配，否则它不会保存。这个失败是无声的，没有迹象表明新的APN设置不会被使用。它们也不会显示在设备上的APN列表中。但是，如果您将SIM卡替换为与您输入的MCC和MNC相匹配的SIM卡，则会再次出现您的APN信息。尽管如此，有些手机可能仍需要几分钟时间才能连接。他们可能会在放弃并开始新的评估之前向OpenBTS提供旧的网络访问信息。成功连接后，手机的IP地址通过sgsn list命令可见：1234OpenBTS&gt; sgsn listGMM Context: imsi=001010000000009 ptmsi=0x47001 tlli=0xc0047001state=GmmRegisteredNormal age=32 idle=0 MS#1,TLLI=c0047001,7d4373aeIPs=192.168.99.1 故障排除如果您能够连接但尚未收到IP地址，则防火墙设置可能会妨碍您的工作。通常这不是问题，但根据Linux安装和IP网络配置，这是可能的。现在禁用防火墙并重新启动OpenBTS以应用更改：123OpenBTS&gt; config GGSN.Firewall.Enable 0GGSN.Firewall.Enable changed from &quot;1&quot; to &quot;0&quot;GGSN.Firewall.Enable is static; change takes effect on restart OpenBTS还会尝试检测您的DNS服务器设置并将它们传递到手机。如果您发现手机无法解析域名，请尝试手动设置DNS服务器并重新启动OpenBTS以应用更改：123OpenBTS&gt; config GGSN.DNS 8.8.8.8GGSN.DNS changed from &quot;&quot; to &quot;8.8.8.8&quot;GGSN.DNS is static; change takes effect on restart 网关GPRS支持节点（GGSN）和服务GPRS支持节点（SGSN）通常是GSM中的独立实体网络，但直接嵌入在OpenBTS中。为了更深入地了解这些组件发生了什么，您可以设置一个单独的日志文件，并观察手机与网络上的GPRS服务交互时的内容。将GGSN.Logfile.Name键设置为您希望发送日志的文件路径，然后重新启动OpenBTS以应用更改：123OpenBTS&gt; devconfig GGSN.Logfile.Name /tmp/GGSN.logGGSN.Logfile.Name changed from &quot;&quot; to &quot;/tmp/GGSN.log&quot;GGSN.Logfile.Name is static; change takes effect on restart 现在，当GPRS网络上的活动通过GGSN时，新条目将添加到此日志文件中。使用tail命令和-f标志来监视内容：1234567891011$ tail -f /tmp/GGSN.log19:44:04.5: GGSN.MS.IP.Base=192.168.99.119:44:04.5: GGSN.MS.IP.MaxCount=25419:44:04.5: GGSN.MS.IP.Route=192.168.99.0/2419:44:04.5: GGSN.IP.MaxPacketSize=152019:44:04.5: GGSN.IP.ReuseTimeout=18019:44:04.5: GGSN.Firewall.Enable=019:44:04.5: GGSN.IP.TossDuplicatePackets=019:44:04.5:GGSN: DNS servers: 8.8.8.8 0.0.0.019:44:04.5:ip link set sgsntun up19:44:04.7:ip route add to 192.168.99.0/24 dev sgsntun 性能调整OpenBTS尝试在信令的独立专用控制信道（SDCCH）和媒体的TCH之间智能划分资源。但是，它还没有一种机制来平衡不同类型的TCH使用。 语音与GPRS话音和GPRS业务都使用携带TCH逻辑信道的时隙。如果您的网络将部署为主要服务于GPRS而不是语音，则应调整GPRS.Channels.Min.C0键，该键指定应该用于GPRS的可用TCH时隙的最小数量。默认值是两个。要查看当前可用信道数量，请使用load命令：123456789OpenBTS&gt; load== GSM ==SDCCH load/available: 0/4TCH/F load/available: 0/5PCH load: active, total: 0, 0AGCH load: active, pending: 0, 0== GPRS ==current PDCHs: 2utilization: 0% 在这里，我们看到有7个可用的TCH信道：GSM语音（GSM：TCH / F）有5个，GPRS数据（GPRS：PDCH）有2个可用。要使GPRS网络最大化，请将GPRS.Channels.Min.C0设置为7，即可用的TCH通道总数，然后重新启动OpenBTS以应用更改：123OpenBTS&gt; config GPRS.Channels.Min.C0 7GPRS.Channels.Min.C0 changed from &quot;2&quot; to &quot;7&quot;GPRS.Channels.Min.C0 is static; change takes effect on restart 重新运行负载将显示所有TCH通道都已分配给GPRS：123456789OpenBTS&gt; load== GSM ==SDCCH load/available: 0/4TCH/F load/available: 0/0PCH load: active: 0 total: 0AGCH load: active: 0 () pending: 0== GPRS ==current PDCHs: 7utilization: 0% 如果您想手动控制它们，OpenBTS允许您更改所有时间片分配。您可以调整组合1（TCH）与组合7（SDCCH）时隙分配的数量。您还可以调整这些时间段的顺序，以及GPRS时隙应该出现在多ARFCN系统中的位置。通过搜索“Channels”来查看所有键：1234567OpenBTS&gt; config ChannelsGPRS.Channels.Min.C0 2 [default]GPRS.Channels.Min.CN 0 [default]GSM.Channels.C1sFirst 0 [default]GSM.Channels.NumC1s auto [default]GSM.Channels.NumC7s auto [default]GSM.Channels.SDCCHReserve 0 [default] 个人手机吞吐量手机可以同时使用多个时隙来访问GPRS。上行链路和下行链路支持的并行时隙数称为多时隙类。默认情况下，OpenBTS被设置为支持3 + 2多时隙等级：三个下行链路的连续时隙和两个上行链路。这并不意味着一部手机将同时支配所有五个时隙，但您现在可以明白为什么将尽可能多的时隙添加到以GPRS为中心的网络中非常重要。一个更高的多时隙类将向单个手机提供更高速的数据，但随着多个手机试图使用它，网络将变得更加迅速拥塞。您可以使用以下两个键来调整支持的多时隙类：123OpenBTS&gt; config MultislotGPRS.Multislot.Max.Downlink 3 [default]GPRS.Multislot.Max.Uplink 2 [default] 覆盖面积与吞吐量GPRS为传送的数据定义了四种不同的编码方案（CS）。它们被适当命名为CS1，CS2，CS3和CS4。编码方案1的吞吐量最低，但可靠性最高。它分配更多的比特用于消除无线传输过程中引入的错误。另一方面，编码方案4具有最高的吞吐量，但在传输过程中容易出错。这些传输错误限制了每种编码方案的可用覆盖范围。 OpenBTS支持CS1和CS4。您可以选择低吞吐量，但是可以选择可靠的覆盖区域，或者更高的吞吐量，而且鲁棒性较差的纠错会导致覆盖区域更小。默认情况下，OpenBTS已启用，但可以在上行链路和下行链路上单独调整它们：123OpenBTS&gt; devconfig CodecsGPRS.Codecs.Downlink 1,4 [default]GPRS.Codecs.Uplink 1,4 [default] 期望GPRS不是很快，但数据是数据。在无法使用WiFi的地方，相对较大的区域可以使用调制解调器速度的互联网接入，无论是M2M /物联网设备还是联系亲朋好友的人。表5-1列出了每部手机的预期吞吐量。Table 5-1. Multislot class and coding scheme throughputs Slots down+up 1+1 2+1 2+2 3+2 CS1 9.05/9.05 kbps 18.1/9.05 kbps 18.1/18.1 kbps 27.15/18.1 kbps CS4 21.4/21.4 kbps 42.8/21.4 kbps 42.8/42.8 kbps 64.2/42.8 kbps 这些都是最佳吞吐量，并且非常依赖于网络拥塞，无论是本地无线电还是互联网上行链路。无可否认，OpenBTS GPRS支持并不完美。 GSM语音和短信几乎都是OpenBTS内部完成的工作，但是GPRS仍然可以进行改进和优化。这些改进大部分与分配接入无线电媒体以及数据包重新安排的算法有关。优化这些将大大提高OpenBTS中的GPRS体验。]]></content>
      <tags>
        <tag>OpenBTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openBTS part4]]></title>
    <url>%2F2018%2F05%2F16%2FopenBTS-part4%2F</url>
    <content type="text"><![CDATA[第4章从单个到多个节点具有单塔的移动网络比具有零塔的移动网络更有用。然而，无论单塔如何调整，都无法有效覆盖特定区域。由于OpenBTS使用相同的软件堆栈来实现大范围和小范围的覆盖区域，甚至可以在Raspberry Pi上运行，因此试图释放您对经典“细胞塔”图像的想法。塔可以很容易地放入鞋盒或与您的WiFi接入点融合。本章介绍如何将网络扩展到多个物理站点，但仍然保持单个逻辑网络。这个逻辑网络将支持任何商业网络的移动性和切换。 移动性，切换和漫游这些术语之间存在一些混淆。虽然它们确实意味着非常具体的事情，但即使是该领域的专家也会将它们放在讨论中，并希望对方从背景中理解正确的含义。为了澄清这个歧义，我们将简要概述每个术语。 移动性移动性是手机在运营商网络中的不同物理基站上接收服务的能力。当手机在三维空间中移动时，它从相邻基站接收到的信号质量将会波动。当手机检测到来自邻近基站的显着更好的信号时，它发送LUR以注册或“驻扎”到新的基站。为了区分，在同一基站的定期LUR刷新现有注册，但新基站的LUR重新刷新，将注册切换到新塔。除非两个基站具有不同的位置区域码（LAC），否则不会执行LUR。在传统的GSM网络中，给定地理区域内的所有基站都具有相同的LAC。然而，OpenBTS目前要求所有基站都有独特的LAC，因此在基站之间移动时将执行LUR。这触发更新的SIP REGISTER消息，并因此触发包含新基站的IP的更新的订户注册表项。移动性是网络的一个功能，但手机决定重新播放。而且，只有当手机没有处于诸如语音呼叫或交换SMS之类的活动交易时也是如此。移动性也可以被称为“空闲模式重新征卡”。 切换切换是在两个基站之间的过渡期间存活的语音呼叫的能力。移动性是切换的先决条件，但与移动性不同，网络决定并执行切换。手机别无选择，只能服从网络发送它的切换命令。基站控制器（BSC）控制传统GSM网络中的切换。 OpenBTS通过使用新的对等协议消除了对BSC的需求。通过此协议交换关于相邻频率，身份和活动事务的信息，从而简化部署体系结构。几个因素决定执行切换的决定。首先，来自当前服务该手机的基站的下行链路信号必须足够弱。而且，来自最强的相邻基站的信号也必须超过服务基站电平一个设定的阈值。最后，最强的相邻基站最近不会因拥塞而拒绝任何切换。如果满足这些条件，则服务基站将发起切换到最强的相邻基站。 漫游漫游是跨运营商的移动性。它需要这些运营商和通用接口技术之间的管理协议，通常是7号信令系统（SS7）网络上的GSM-Mobile应用部分（MAP）信令。在你自己的网络中漫游是不可能的。 拓扑到目前为止，您一直在构建一个“网箱在线”拓扑结构，每个单个组件都位于单个服务器上，即单个逻辑实体。在多节点网络中，现在有两个逻辑实体：中央服务和“塔”。到目前为止，您熟悉的组件必须进行重新安排以支持这一点。中央服务将需要安装SIPAuthServe，SMQueue和Asterisk。为了简单起见，SIPAuthServe，SMQueue和Asterisk在本章剩余部分将被称为中央服务。塔将只运行OpenBTS。将有一个单一的中央服务安装和多塔安装，如图4-1所示。Snipaste_2018-05-16_10-01-09.png Towers通过IP回传到中心服务，允许多个覆盖区域共享相同的用户数据库和配置。在以下说明中，中央服务将位于192.168.158.100，而塔将从192.168.158.201开始。 中央服务设置而不是从现有的盒内网络配置中提取中央服务，只需将OpenBTS实例和无线电硬件移动到新家即可。这避免了必须移植SMQueue，SIPAuthServe和Asterisk的订户数据和配置。 删除OpenBTS为了确保OpenBTS不会在启动时启动，并且因为缺少收音机而不断失败，请立即将其卸载：1$ sudo apt-get remove openbts 配置日志记录独立的每座塔楼以及中央服务部门都将生成记录信息。您需要将中央服务设置为接受来自所有塔的记录信息，以便通过网络捕获所有活动。这一步不是建立功能多节点网络所必需的，但在调试时非常有用。使用单独的日志追踪多个塔中的错误并不是很有趣。用你最喜欢的编辑器编辑/etc/rsyslog.conf并在“提供UDP系统日志接收”之后直接取消注释这两行：123# provides UDP syslog reception$ModLoad imudp$UDPServerRun 514 这两行意味着rsyslog将接受端口514上的UDP日志通信。要应用这些设置，需要重新启动该服务：1$ sudo service rsyslog restart Asterisk，SMQueue和SIPAuthServe这些组件中无需重新配置。他们不关心OpenBTS实例是本地通信还是通过IP网络进行通信。 塔设置跳回到第7页的“操作系统和开发环境设置”，并按照新的虚拟机或新服务器来启动并运行新塔的操作系统和组件。确保选择塔的唯一主机名，以便在集中日志中区分它。此外，只需安装OpenBTS，在这些说明的末尾节省一些时间。这些说明假定您的塔式计算机和中央服务计算机位于同一个网络子网上。一旦登录到新的塔式安装，确保您可以通过中央服务（按Ctrl-C停止ping命令）：12345678910$ ping 192.168.158.100PING 192.168.158.100 (192.168.158.100) 56(84) bytes of data.64 bytes from 192.168.158.100: icmp_req=1 ttl=128 time=4.28 ms64 bytes from 192.168.158.100: icmp_req=2 ttl=128 time=4.34 ms64 bytes from 192.168.158.100: icmp_req=3 ttl=128 time=4.48 ms64 bytes from 192.168.158.100: icmp_req=4 ttl=128 time=4.48 ms^C--- 192.168.158.100 ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 3006msrtt min/avg/max/mdev = 4.285/4.399/4.484/0.086 ms 配置SIP代理OpenBTS使用SIP连接到所有其他组件。由于这些组件位于另一台主机上，因此需要对SIP.Proxy键进行相应的调整。此外，现在OpenBTS正在与除localhost之外的IP地址上的服务通话，它需要知道将自己的请求发送到哪个地址。 SIP.Local.IP键允许您设置其他服务在联系OpenBTS或回复其请求时应使用的IP地址。现在使用塔的IP地址进行设置：123OpenBTS&gt; config SIP.Local.IP 192.168.158.201SIP.Local.IP changed from &quot;127.0.0.1&quot; to &quot;192.168.158.201&quot;SIP.Local.IP is static; change takes effect on restart 重新启动OpenBTS以应用此静态键：12$ sudo stop openbts$ sudo start openbts 现在，每个SIP.Proxy键都可以更新为指向中央服务，因此注册，语音和短信流量将发送到那里，而不是本地主机：123456OpenBTS&gt; config SIP.Proxy.Registration 192.168.158.100:5064SIP.Proxy.Registration changed from &quot;127.0.0.1:5064&quot; to &quot;192.168.158.100:5064&quot;OpenBTS&gt; config SIP.Proxy.SMS 192.168.158.100:5063SIP.Proxy.SMS changed from &quot;127.0.0.1:5063&quot; to &quot;192.168.158.100:5063&quot;OpenBTS&gt; config SIP.Proxy.Speech 192.168.158.100:5060SIP.Proxy.Speech changed from &quot;127.0.0.1:5060&quot; to &quot;192.168.158.100:5060&quot; 确保包含端口信息。每个组件都运行在不同的端口上，并将请求路由到不正确的端口会破坏功能。 强制手机通过这种新拓扑进行注册以测试事情。语音和短信也应该起作用。在继续之前验证这一点。 配置日志记录记录每个塔产生的信息可以发送到中央服务。中央服务上的日志记录守护程序已更改为接受此通信;现在是时候告诉塔节点发送它。使用您最喜欢的编辑器编辑/etc/rsyslog.d/OpenBTS.conf，以便它在现有local7条目正下方包含一个新行：12local7.* /var/log/OpenBTS.loglocal7.* @the-central-services-ip 此行意味着除了将信息记录到磁盘上的OpenBTS.log文件之外，还会将相同的消息发送到中央服务以便在那里记录。要应用这些设置，需要重新启动服务：1$ sudo service rsyslog restart 拓扑重做到目前为止，您的网络在功能上是相同的。仍然有一个覆盖区域由一个逻辑塔和中央服务创建 - 它们只是分成两个独立的物理机器。下一步需要向网络添加更多的邻近塔，并将其配置为单个RAN。 添加相邻的塔塔架设置部分现在可以重复用于您想要添加的任意多个物理塔架。一旦它们被配置为至少起到独立塔的作用，它们必须被配置为在网络内作为适当的邻近塔。此外，所有现有的塔必须被告知这个新的塔。到目前为止，假设您的网络中只有一个塔 - 您刚刚从网络集中式布局移植的塔。现在看看它的身份参数：12345678OpenBTS&gt; config IdentityGSM.Identity.BSIC.BCC 2 [default]GSM.Identity.BSIC.NCC 0 [default]GSM.Identity.CI 10 [default]GSM.Identity.LAC 1000 [default]GSM.Identity.MCC 001 [default]GSM.Identity.MNC 01 [default]GSM.Identity.ShortName GroundControl 其中一些参数必须是唯一的，而其他参数必须在所有邻居中相同。表4-1是一个方便的总结。配置模式也将这些信息嵌入到作用域中。范围字段会告诉您键必须是唯一的还是相邻的塔之间或网络中的所有塔之间。Table 4-1. Configuration scope Identical Unique GSM.Identity.MCC GSM.Identity.LAC GSM.Identity.MNC GSM.Identity.CI GSM.Identity.BSIC.NCC GSM.Identity.BSIC.BCC GSM.CellSelection.NCCsPermitted GSM.Radio.C0 GSM.Identity.ShortName 一些背景信息将被呈现，因此每个参数都可以被理解，以及设置你的下一个塔的分步指南。 必须完全一致GSM.Identity.MCC和GSM.Identity.MNC键是任何网络的最高级别标识，指示该网络在哪个国家以及哪个运营商正在运行它。监管机构分配这两个ID。测试网络总是分别使用001和01。如果这不是一个测试网络，那么您可能已经为许可证付了钱，并且非常了解适当的价值。GSM.Identity.BSIC.NCC键是您的网络颜色代码（NCC），这是手机用来快速确定他们是否可以访问网络的信息。特定区域内的所有运营商必须具有唯一的颜色代码。与最后一个键相关的是GSM.CellSelection.NCCsPermitted。在与合作伙伴网络合作时使用此键来表达以下内容：“不仅我的NCC正常，而且允许其他NCC。”NCC许可键是一个按位标志，而不是一个整数值。无论如何，所有的塔都应该具有相同的NCCsPermitted设置。GSM.Identity.ShortName键在所有塔中应该是相同的，但它不是必需的。部署多节点网络时，一种方便的调试技术是为每个塔设置唯一的短名称。如果您的手机可靠地显示短名称，您现在可以立即知道手机在移动时驻留的塔楼。一步步本节的逐步说明非常基本：确保所有这些键与网络中现有的塔相同。 必须是唯一的第一个键GSM.Radio.C0必须是唯一的，因为它是ARFCN，因此在该塔上使用RF。如果物理上相邻的塔使用相同的频率，则会对重叠信号区域中的任何参与者造成干扰并拒绝服务。C0 ARFCN不仅必须是唯一的，而且它们也不能在数字上相邻。由于信号间隔仅为200 KHz，信号带宽为270 KHz，相邻的ARFCN重叠。部署物理上相邻的塔时，至少使用其他每个ARFCN（例如，塔1使用ARFCN 151，塔2使用ARFCN 153）。GSM.Identity.BSIC.BCC对于物理上相邻的塔也必须是唯一的。它发信号给基站色码（BCC），一个3位字段允许7个唯一值。您获得许可的C0 ARFCN和BCC数量非常有限，如果您打算购买大量的色彩地图，可能会有助于将值分配给塔。彩色地图显示所有塔的地理位置并为每个塔分配一种颜色。每种颜色对应于ARFCN编号和BCC对，如图4-2所示。如果您的计划显示没有两个相邻的塔楼具有相同的“颜色”，则移动性和交接不会因与ARFCN或BCC冲突而受到阻碍。Snipaste_2018-05-16_10-04-42.png GSM.Identity.LAC在您的网络中的所有信号塔中必须是唯一的。当手机穿过塔台边界时，它意识到位置区域代码正在改变，并且应该执行另一个LUR。该LUR被转换为SIP REGISTER，并且SIPAuthServe可以更新该手机可达的塔的IP地址。 LAC独特的要求特定于OpenBTS。传统网络的LAC对应于包含多个塔的更大的地理区域.GSM.Identity.CI是单元ID（CI），并且在网络中的所有塔中必须是唯一的。 一步步为新塔分配颜色并使用相应的C0值和BCC：12345OpenBTS&gt; config GSM.Radio.C0 168GSM.Radio.C0 changed from &quot;151&quot; to &quot;168&quot;GSM.Radio.C0 is static; change takes effect on restartOpenBTS&gt; config GSM.Identity.BSIC.BCC 3GSM.Identity.BSIC.BCC changed from &quot;2&quot; to &quot;3&quot; 由于有很多LAC和CI值，只需使用每个塔的下一个：1234OpenBTS&gt; config GSM.Identity.LAC 1001GSM.Identity.LAC changed from &quot;1000&quot; to &quot;1001&quot;OpenBTS&gt; config GSM.Identity.CI 11GSM.Identity.CI changed from &quot;10&quot; to &quot;11&quot; 重新启动OpenBTS以应用更改：12$ sudo stop openbts$ sudo start openbts 邻居列表和命令你的塔现在被配置为不会在物理上通过其传输频率或逻辑上在他们的ID编号方案中彼此踩踏。他们仍然必须在配置中被告知彼此。这是使用GSM.Neighbors键完成的。每个塔必须将其GSM.Neighbors键设置为与所有物理相邻塔对应的空间分离IP地址列表，但不包括其本身。在您的新塔楼（192.168.158.202）上，输入以下内容以告知您的原塔楼（192.168.158.201）：12OpenBTS&gt; config GSM.Neighbors 192.168.158.201GSM.Neighbors changed from &quot;&quot; to &quot;192.168.158.201&quot; 对原来的塔做同样的事情，以便了解新塔的情况：12OpenBTS&gt; config GSM.Neighbors 192.168.158.202GSM.Neighbors changed from &quot;&quot; to &quot;192.168.158.202&quot; 仍然在你的原始塔，192.168.158.201，检查邻居命令：1234OpenBTS&gt; neighborshost C0 BSIC FreqIndex Noise ARFCNs TCH-Avail Updated Holdoff------------------ --- ---- --------- ----- ------ --------- ------- -------192.168.158.202:16001 168 2 0 68 1 7 16 0 OpenBTS对等协议自动查询有关GSM.Neighbors中定义的相邻基站的信息。 neighbors命令提供对这些信息的访问。在这里您可以看到C0 ARFCN，当前噪声级别，总ARFCN数量和可用业务信道（TCH）。 启用了邻居的命令既然您有一对功能相近的人，chans命令也会在通话期间提供更多信息。该信息与手机报告的最强邻居塔的当前接收等级有关。要查看它，请使用带有-l标志的chans命令：123456OpenBTS&gt; chans -lCN TN chan transaction LAPDm recyc Signal RSSI RSSP SNR FER BER TA type id state dB dB dB pct pct sym0 1 TCH/F T100 LinkEstablished false 26 -50 -24 38.7 0.00 0 0.9TXPWR TA_DL RXLEV_DL BER_DL Time IMSI Neighbor HandoverdBm sym dBm pct M:S ARFCN(dBm) C0:BSIC7 0 -93 2.26 0:25 2140... 168 (-76) 覆盖重叠调整每个塔单独调谐，最棘手的部分是相互调整它们。再看一下图4-1。塔1和塔2之间的重叠区域是至关重要的。该区域必须足够宽，以便穿过它的手机可以可靠地与两个塔接触，只要它执行切换。必须考虑该区域的地形以及潜在的手机速度。重叠不能太过于浪费资源。在可靠的重叠和优化的整体覆盖范围之间找到平衡是关键。再次，整个企业都可以建立在这种专业知识基础之上，深入的研究不在“入门”的范围之内。手机移动只有一个键来配置：GSM.CellSelection.CELLRESELECT-HYSTERESIS。这个关键指示手机在重新播放之前应该有多好的潜在邻近塔的信号。 OpenBTS可以更直接地控制切换。有几个键可用于调整切换行为：12345OpenBTS&gt; config HandoverGSM.Handover.FailureHoldoff 20 [default]GSM.Handover.Margin 15 [default]GSM.Handover.Ny1 50 [default]GSM.Timer.Handover.Holdoff 10 [default] GSM.Handover.Margin键与GSM.CellSelection.CELL-RESELECTHYSTERESIS类似，只是它用于切换操作。在这两种设置下，重要的是要记住，如果它们设置得太高（例如，在切换之前塔必须强得多），则存在手机不能及时跳过的风险。如果它们设置得太低（例如，在切换之前塔必须稍微强一些），当手机快速地来回跳动时，网络可能被位于两个信号大致相等的区域中的手机流量峰值所击中。如果您想尝试OpenBTS切换算法中的权重，那么使用devconfig还可以使用更多参数：12345678910OpenBTS&gt; devconfig HandoverGSM.Handover.FailureHoldoff 20 [default]GSM.Handover.History.Max 32 [default]GSM.Handover.Margin 15 [default]GSM.Handover.Ny1 50 [default]GSM.Handover.RXLEV_DL.History 6 [default]GSM.Handover.RXLEV_DL.Margin 10 [default]GSM.Handover.RXLEV_DL.PenaltyTime 20 [default]GSM.Handover.RXLEV_DL.Target 60 [default]GSM.Timer.Handover.Holdoff 10 [default]]]></content>
      <tags>
        <tag>OpenBTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openBTS part3]]></title>
    <url>%2F2018%2F05%2F16%2FopenBTS-part3%2F</url>
    <content type="text"><![CDATA[第3章 故障排除和性能调整随着您的网络越来越多地适应生产，您将需要一些其他技术来帮助调试出现的问题。虽然有些错误与错误配置直接相关，但其他错误并不明显。根据部署条件和网络使用模式，网络问题实际上可能与性能不佳有关。为您的特定场景优化网络性能可能是关键。因此，故障排除和调整一起呈现。 stats命令观察OpenBTS中事件发生的快速而简单的方法是使用stats命令。有几十个事件类型被跟踪。要获取它们的完整列表，请运行不带参数的stats命令：1OpenBTS&gt; stats 每个事件类型只是一个小型SQLite3数据库中的一个键名，每个键的值对应于该事件发生的次数上次统计数据库已被清除。清除数据库非常方便，可以为您感兴趣的事件提供已知的启动计数。要清除数据库，请执行以下操作：12OpenBTS&gt; stats clearstats table (gReporting) cleared 现在，如果从网络中的一部手机发送短信至另一部手机，并搜索SMS-相关的事件，你会看到如下内容：123456OpenBTS&gt; stats SMSOpenBTS.GSM.MM.CMServiceRequest.MOSMS: 1 events over 4 minutesOpenBTS.GSM.SMS.MOSMS.Start: 1 events over 4 minutesOpenBTS.GSM.SMS.MOSMS.Complete: 1 events over 4 minutesOpenBTS.GSM.SMS.MTSMS.Start: 1 events over 4 minutesOpenBTS.GSM.SMS.MTSMS.Complete: 1 events over 4 minutes OpenBTS.GSM.MM.CMServiceRequest.MOSMS显示手机发信号给基站，它希望执行移动发起的SMS（MOSMS）。 OpenBTS.GSM.SMS.MOSMS.Start和Complete键显示MOSMS已启动并完成。 前三个键与从手机到基站的初始传输有关。 最后两个键显示从基站到目的地手机的移动端接SMS（MTSMS）已经开始并完成。 运行时日志所有OpenBTS组件的日志都存储在/var/log/OpenBTS.log中。 为了在生产时监控它们，请执行：1$ tail -f /var/log/OpenBTS.log 如果您只想监视包含某些文本的日志条目，则可以链接tail和grep命令。 例如，要只监视包含“sipauthserve”文本的新条目，请使用以下命令：1$ tail -f /var/log/OpenBTS.log | grep sipauthserve 您还可以搜索特定文本的现有日志。 在本例中，我们没有监视新条目，而是在整个日志文件中搜索文本“sipauthserve”：1$ grep sipauthserve /var/log/OpenBTS.log 日志条目包含许多不同的信息。 这是OpenBTS生成的一个示例条目：12014-09-04T10:50:09.258961+02:00 ubuntu openbts: NOTICE 27238:27238 2014-09-04T10:50:09.2 GSMConfig.cpp:132:regenerateBeacon: regenerating system information messages, changemark 5 从左到右的字段是：•数据写入时间戳：“2014-09-04T10：50：09.258961 + 02：00”•系统主机名：“ubuntu”•系统应用程序：“openbts”•事件级别：“NOTICE”•事件用户和组：“27238：27238”•数据创建时间戳：“2014-09-04T10：50：09.2”•事件源文件，行和函数名称：“GSMConfig.cpp：132：regenerateBeacon•事件文本：“regenerating system information messages, changemark 5” 日志级别默认情况下，组件仅设置为在通知级别和更高级别上记录事件。这通常是足够的信息来调试典型的服务错误，如掉话或高干扰率。所有OpenBTS组件使用的日志记录系统具有八个报告事件级别：EMERG报告与服务故障或硬件损坏相关的严重故障ALERT报告配置错误或连接不畅导致的服务中断CRIT报告可能会降低服务的异常事件ERR报告在特殊情况下可能导致服务退化的软件内部错误WARNING报告可能表明正常服务退化的异常事件NOTICE报告可能不会影响服务但可能会对网络运营商感兴趣的异常事件INFO报告正常事件DEBUG会降低系统性能;仅供开发人员使用 要从系统中获取不同的信息，请调整日志记录级别。例如，INFO级别还报告正常事件（除NOTICE和以上）。这些正常事件可以为您提供上下文，以推断可能发生的错误。要更改组件范围内的日志记录级别，请执行以下操作：12OpenBTS&gt; config Log.Level INFOLog.Level changed from &quot;NOTICE&quot; to &quot;INFO&quot; 一旦您从日志中定位了一些可疑活动，您就可以使用源文件字段来公开该应用程序的更多信息。 上面的事件是从GSMConfig.cpp发出的。 要在该源文件上启用DEBUG级别日志记录，请执行以下操作：12OpenBTS&gt; rawconfig Log.Level.GSMConfig.cpp DEBUGdefined new config Log.Level.GSMConfig.cpp as &quot;DEBUG&quot; 您需要使用rawconfig来定义此键/值对，因为它不在配置模式中。 要从配置数据库中删除此自定义键/值对，请使用rmconfig：12OpenBTS&gt; rmconfig Log.Level.GSMConfig.cppLog.Level.GSMConfig.cpp removed from the configuration table 从OpenBTS 5.0开始，现在可以为OpenBTS中的各个子系统组定义一个日志级别。 以下每组可单独调整：• Log.Level.Control• Log.Level.SIP• Log.Level.GSM• Log.Level.GPRS• Log.Level.Layer2• Log.Level.SMS同样，因为这是一个自定义键/值对，所以您必须使用rawconfig：12OpenBTS&gt; rawconfig Log.Level.SIP DEBUGdefined new config Log.Level.SIP as &quot;DEBUG&quot; 再次，要从配置数据库中删除自定义键/值对，请使用rmconfig：12OpenBTS&gt; rmconfig Log.Level.SIPLog.Level.SIP removed from the configuration table 在整个组件范围内使用DEBUG级别会产生如此多的信息，以至于它可能会破坏OpenBTS的稳定性。 DEBUG只能用于单个源文件或日志组。 环境调整使OpenBTS在部署环境中良好运行是关键的一步。 周围的建筑物和树叶，气候，塔架高度，天线选择，电缆长度和放大器功率都起到了作用。 整个企业都建立在提供这方面的专业知识的基础上，而硬件主题则过于宽泛，无法在这里以有意义的方式进行讨论。 任何可靠的部署都需要硬件和软件调优。 本节坚持使用OpenBTS软件中的控件。 非用户电话如果您的部署使用第46页的“更强，更清洁的信号”中所述的放大射频链路，并且该区域的其他载波信号较弱或不存在，则必须处理非用户手持设备。所有可以看到您的网络的手机都将尝试加入，因为它们没有本地服务。在农村社区部署中，这是一个非常普遍的问题。这些社区的大多数居民在带着服务前往附近城镇时都有手机。当他们到达时，手机可能不会关机。如果在这种情况下新塔楼升级，它可能不得不处理数千个非订户手持设备。这些手机产生将被拒绝的LUR。有超过20种不同的方式来拒绝这些请求;关键是要为您的部署使用正确的一个。默认情况下，OpenBTS使用非常友好的拒绝原因（0×04），允许手机在几分钟内重试。您需要使用拒绝原因，告诉手机长时间消失，以便LUR流量不会使系统瘫痪，直到授权人无法使用它为止。有两个参数可以定义您想要使用的拒绝原因：12OpenBTS&gt; config RejectCause Control.LUR.404RejectCause 0x04 [default] Control.LUR.UnprovisionedRejectCause 0x04 [default] Control.LUR.404RejectCause键定义哪个原因在未知用户尝试加入时使用，而Control.LUR.UnprovisionedRejectCause定义了当已知用户尝试加入但未通过认证时要使用的内容。可能有理由独立调整它们，但现在它们将被设置为相同。允许的拒绝代码在表3-1中描述。 Table 3-1. Reject causes, as defined in GSM 04.08 section 10.5.3.6 Hex value Description 0x02 IMSI unknown in HLR 0x04 IMSI unknown in VLR 0x05 IMEI not accepted 0x0B PLMN not allowed 0x0C Location area not allowed 0x0D Roaming not allowed in this location area 0x11 Network failure 0x16 Congestion 0x20 Service option not supported 0x21 Requested service option not subscribed 0x22 Service option temporarily out of order 0x26 Call cannot be identified 0x30 Retry upon entry into a new cell 0x5F Semantically incorrect message 0x60 Invalid mandatory information 0x61 Message type nonexistent or not implemented 0x62 Message type not compatible with the protocol state 0x63 Information element nonexistent or not implemented 0x64 Conditional IE error 0x65 Message not compatible with the protocol state 0x6F Unspecified protocol error 根据手机的不同，每种手机都可能有不同的效果。 通过测试，一些最受欢迎的产品出现并在表3-1中突出显示。 这些值会指示非用户手机长时间消失，但与此同时，不会导致手机放弃加入其他网络。 现在更改这些值以减少非用户LUR流量：1234OpenBTS&gt; config Control.LUR.404RejectCause 0x0CControl.LUR.404RejectCause changed from &quot;0x04&quot; to &quot;0x0C&quot;OpenBTS&gt; config Control.LUR.UnprovisionedRejectCause 0x0CControl.LUR.UnprovisionedRejectCause changed from &quot;0x04&quot; to &quot;0x0C&quot; 覆盖区域让手机忽略你的网络的另一种方法是实际上阻止他们看到它。 这是通过缩小可用覆盖区域的物理和政策来完成的。 短信和注册服务的覆盖范围可能比语音服务大4倍（2倍半径），因为丢失的帧可以在不中断服务的情况下进行重传。 物理层收缩OpenBTS有一个功率控制机制，可以调整发射功率的衰减来扩大或缩小覆盖区域。 要检查基站的当前衰减级别，请使用电源命令：12OpenBTS&gt; powercurrent downlink power –10 dB wrt full scale 要调整衰减，只需提供一个参数给power命令。 要将基站增加到覆盖范围最大的最大功率，请指定应该有0 dB的衰减：12OpenBTS&gt; power 0current downlink power 0 dB wrt full scale 相反，增加衰减来降低功耗并缩小覆盖区域：12OpenBTS&gt; power 20current downlink power -20 dB wrt full scale 还有另一种物理层功率控制可用。 手机也使用不同的功率电平向基站传输，因此所有手机的接收功率在到达基站时的强度大致相同。 基站控制手机使用的功率电平，并可用于手机，所以我们可以限制这个范围。 手机无法控制它将使用的功率级别，所以我们可以限制它被告知使用的数值范围。 MS.Power键允许这样做：1234OpenBTS&gt; config MS.PowerGSM.MS.Power.Damping 75 [default]GSM.MS.Power.Max 33 [default]GSM.MS.Power.Min 5 [default] 虽然这种方法不太常用，但为了完整起见，这里也包含它。 policy收缩在大量使用的情况下，物理缩小覆盖区域可能不足以稳定网络。 还有一个参数可以派上用场，GSM.MS.TA.MAX：123OpenBTS&gt; config GSM.MS.TAGSM.MS.TA.Damping 50 [default]GSM.MS.TA.Max 62 [default] TA代表时间提前。定时提前是GSM用于补偿远离基站的手机的一种方法。手机越远，TA值越大。这个值告诉手机提前发射无线电脉冲串，以便在分配的时隙内正确到达基站。光速很快但仍不是瞬时的。返回参数：例如，将GSM.MS.TA.MAX设置为10，会导致OpenBTS默默地忽略TA大于10的任何无线电突发。TA的测量方式称为符号周期，对应的距离约为550米GSM.MS.TA.MAX设置为10时，OpenBTS将根据策略忽略距离5.5公里以外的手机的任何突发事件。因为覆盖区域从来都不是完美的圈子，所以这是政策限制方便的地方。如果你的塔位于一个山谷中，并被三个方向的高程所保护，那么剩下的方向将会收到远离塔的信号。您不想关闭电源，因为山坡上有用户，所以您可以通过策略限制覆盖区域. 信号失真信号失真高度依赖于您的设施周围的地形。 默认情况下，OpenBTS被配置为非常彻底地减少多路径失真。 它通过在试图消除失真时查看更大的时间窗口来实现这一点。 这在计算上非常昂贵。 如果您的安装位于没有任何建筑物或树木的开阔地形中，则可以通过调整GSM.Radio.MaxExpectedDelaySpread来显着降低CPU负载。 较小的覆盖范围也是在这里使用小值的候选对象：12OpenBTS&gt; config DelayGSM.Radio.MaxExpectedDelaySpread 4 [default] 这个关键字决定了将要检查多少个符号周期。调整后如果性能不佳，请调回默认值4。 更强，更清洁的信号为了有效扩展网络的生产用途，您需要一个放大器和谐振腔双工器。由于GSM手机的发射功率通常为2 W，而您的SDR的发射功率为100 mW，因此基站将成为限制您覆盖范围的因素。上行信号可以从手机到达基站，但是从基站返回到手机的下行信号对于手机无法接收太弱。图3-1说明了基站和手机之间的相对功率不对称。 举例来说，在基站的发射链中增加一个2 W的放大器将增加您的覆盖范围，但现在必须对接收链采取额外的预防措施。接收天线现在正从发射天线接收到如此大量的能量，实际上可能会损坏SDR的电路。至少，它将使得解调干净的信号成为不可能的，因为来自放大器的额外的2W本地发射能量算作噪声并且将完全淹没任何远程手持设备。要解决这个问题，你需要一个腔双工器。腔双工器连接到发射和接收天线端口。然后将单个天线连接到双工器，如图3-2所示。 GSM在不同频率上发送和接收，因此双工器能够干净地分离发送和接收信号。这可以防止不必要的发射能量回绕到接收链中。由于此分频是基于频率的，所以必须选择与您将使用的GSM频段（850,900,1800或1900 MHz）相匹配的双工器。]]></content>
      <tags>
        <tag>OpenBTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程精粹Writing Solid Code读书笔记]]></title>
    <url>%2F2018%2F05%2F15%2F%E7%BC%96%E7%A8%8B%E7%B2%BE%E7%B2%B9Writing-Solid-Code%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Writing Solid Code读书笔记引言一、两个关键的问题怎样才能自动地查出这个错误？怎样才能避免这个错误？二、规则 每条准则都有例外第1章 假想的编译程序使用编译程序所有的可选警告设施使用lint来查出编译程序漏掉的错误如果有单元测试，就进行单元测试第2章 自己设计并使用断言 既要维护程序的交付版本，又要维护程序的调试版本assert如果其参数的计算结果为假，就终止调用程序的执行如果把assert作为函数，其调用就会引起不期望的内存或代码的兑换，因此作为宏。要记住，使用assert的程序员是要把它看成一个在任何系统状态下都可以安全使用的无害检测手段。要使用断言对函数参数进行确认1#include&lt;assert.h&gt; assert(表达式)//如果表达式不满足则会终止程序的执行“无定义”意味着“要避开”：要从程序中删去无定义的特性，或者在程序中使用断言来检查出无定义特性的非法使用程序员没有什么好的办法可以确定其代码中的实际错误情况，错误只能慢慢地暴露出来不要浪费别人的时间——详细说明不清楚的断言消除所做的隐式假定，或者利用断言检查其正确性利用断言来检查不可能发生的情况在进行防错性程序设计时，不要隐瞒错误要利用不同的算法对程序的结果进行确认不要等待错误发生，要使用初始检查程序一旦开始使用断言，也许就会发现程序中的错误会显著的增加第3章 为子系统设防 要消除随机特性，使错误可再现 冲掉无用的信息，以免被错误地使用 如果某件事甚少发生的话，设法使其经常发生 保存调试信息，以便进行更强的错误检查 建立详尽的子系统检查并且经常地进行这些检查 仔细设计程序的测试代码，任何选择都应该经过考虑 努力做到透明的一致性的检查 不要把对交付版本的约束应用到相应的调试版本上，要用大小和速度来换取错误检查能力。第4章 对程序进行逐条跟踪 不要等到出了错误再对程序进行逐条的跟踪，养成对程序进行逐条跟踪的好习惯 在对代码进行逐条跟踪时可以对错误的情况进行模拟 对每一条代码路径进行逐条的跟踪 对代码进行逐条跟踪所花的时间要比实现相应代码所花的时间少得多 数据流，程序的命脉：对代码进行逐条跟踪的作用是它可以使我们观察到数据在函数中的流动。 当对代码进行逐条跟踪时，要密切注视数据流源级调试程序可能会隐藏执行的细节，对关键部分的代码要进行汇编指令级的逐条跟踪。第5章 糖果机界面 要使用户不容易忽视错误情况，不要在正常的返回值中隐藏错误代码 要不遗余力地寻找并消除函数界面中的缺陷 不要编写多种功能集与于一身的函数，为了对参数进行更强的确认，要编写功能单一的函数。一开始就要为函数的输入选择严格的定义，并最大限度地利用断言不要模棱两可，要明确地定义函数的参数编写函数使其在给定有效的输入情况下不会失败使程序在调用点明了易懂，要避免布尔参数编写注解突出可能的异常情况第6章 风险事业 任何时候都不要使用“简单的”位域 使用有严格定义的数据类型 尽量用可移植的数据类型 经常反问：“这个变量表达式会上溢或下溢吗？” 尽可能精确地实现设计，近似地实现设计就可能出错 编写无错代码三条原则： 不要接受具有特殊意义的参数，例如NULL指针 按照设计来实现而不能近似地实现 努力使每个函数一次就完成任务即一个“任务”应一次完成 避免无关紧要的if语句 避免使用嵌套的“？：”运算符 在实现中，有时得支持特殊情况，为了避免特殊情况遍及整个函数，应该把处理特数据情况的代码独立出来。 每种特殊情况只能处理一次 避免使用有风险的语言惯用语 关心局部效率是不值得的，如果很注重效率的话，请集中于全局效率和算法的效率上，这样才会看到努力的效果。 如果有可能，就不要把不同类型的操作符混合使用；如果必须把不同类型操作符混合使用，就用括号把它们隔离开来。 不能毫无必要地将不同类型的操作符混合使用，如果必须将不同类型的操作符混合使用，就用括号把它们隔离开来。 避免调用返回错误的函数。第7章 编码中的假象 只引用属于你自己的存储空间 只有系统才能有空闲的存储区，程序员不能拥有 指向输出的指针不是指向工作空间缓冲区的指针 不要利用静态（或全局）量存储区传递数据 不要写寄生函数 不要滥用程序设计语言 紧凑的C代码并不能保证得到高效的机器代码 程序员有两类读者：使用代码的用户和必须对代码进行更新的程序维护人员，所以为一般水平的程序员编写代码，编写直观的代码。第8章 剩下来的就是态度问题 错误几乎不会“消失” 马上修正错误，不要推迟到最后 修改错误要治本，不要治表 除非关系产品的成败，否则不要整理代码 不要实现没有战略意义的特征 不设自由特征 不允许没有必要的灵活性 在找到正确的解法之前，不要一味地“试”，要花时间寻求正确的解 尽量编写和测试小块代码，即使测试代码会影响进度，也要坚持测试代码 测试代码的责任不在测试员身上，而是程序员自己的责任 程序员强调的是代码而测试员强调的是特征 不要责怪测试员发现了你的错误 建立自己的优先级列表并坚持之后记 走向何方 决不允许同样错误出现两次]]></content>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IC卡(智能卡)基础知识简介]]></title>
    <url>%2F2018%2F05%2F15%2FIC%E5%8D%A1-%E6%99%BA%E8%83%BD%E5%8D%A1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[IC卡（智能卡）基础知识简介 1、何为IC卡（智能卡）IC卡是从磁条卡发展而来，它是将一个集成电路芯片封装在一个卡片中。与磁条卡相比，IC卡可靠性好，存储容量大，而且具有一定的“智能”。IC卡大致分为存储器卡与“智能”卡两个最常用的大类，存储器卡是将一个EEPROM存储器芯片封装在卡片中，使卡片具有“记忆”功能。信息可以“写入（存）”卡内或从卡内“读出（取）”，原则上存取过程是不受限制的，整个存储空间也是开放的，对存储空间的管理是在卡片外部进行，这使得存储器卡缺乏良好的安全性。之后存储器卡有了一些改进，主要是增加了密码验证功能对信息的存取过程进行控制，但仍然缺乏较好的存储管理功能。而“智能”卡则不仅将EEPROM存储器封装进卡中，同时还将一个“微控制器（MCU：MicroController Unit）”集成到卡片中，这个MCU中具有对卡片上EEPROM存储器进行管理的一套软件，（这套软件通常被称为“卡片操作系统（COS：Card Operation System）”），从卡片外部发送数据到卡内都要经过MCU进行处理。也就是说，MCU及其搭载的软件（COS）控制着信息的存取过程，同时也管理着存储器的分配与使用。综上所述，我们可以看出IC卡的实质是：信息的存取。而智能卡所谓的“智能”，就是对存取过程的“严格”控制与对存储器的“灵活”管理，目的是使存放在卡内的信息更安全且易于使用。 2、IC卡的相关规范IC卡是一种很规范的产品，不论其外形，还是其内部芯片的电气特性，甚至于其应用方法都受一些较严格的协议控制。最基础最重要的一套规范是ISO/IEC 7816协议。这套协议不仅规定了IC卡的机械电气特性，而且还规定了IC卡（特别是智能卡）的应用方法（包括COS中很多数据结构）。除了7816协议之外，在各个可能应用IC卡的特定领域内还有一些更为具体的协议，比如在中国，金融领域制定PBOC规范，交通管理体系，社会福利体系都有其特定的规范。这些协议规范都是建立在7816协议基础之上，且将7816协议加以具体化形成的。当然，7816协议并不是独立存在（定义）的，它里面有很多概念引自于其它一些相关的协议规范。比如在7816协议中有一些数据的组织采用了“BER-TLV”，而有关“BER-TLV”这个概念的详细表述则是在IEC 8825 ASN.1协议中给出。由此可见7816协议并非完全独出心裁，能够采用规范的概念的场合就不自作主张。这使得各种协议规范形成一个严密的体系。 3、智能卡如何管理其存储器一般的存储器卡不具备管理存储器的能力，这种管理要在卡外部进行。具有存储管理能力的卡只有“智能”卡。因此下面的讨论都是针对“智能”卡的。简单的把存储器划分成一些块进行管理是最常用的一种办法，但此办法在实现的的时候不能过于简单，若要求用户记忆存储器中各个块的编号及属性未免太难于使用了。因此我们通常要在逻辑上更抽象的描述存储块。试想在普通的桌面计算机上我们的大容量存储装置（硬盘之类）也是分块管理的，我们习惯称之为“按扇区方式”组织。但我们在通常使用过程中并不关心（不知道）“扇区”这样的概念，而只是看到一个个“文件”和“子目录”。所谓“文件”，其实就是保存在一系列存储块中的一组数据，而“子目录”就是将一组文件组织在一起的一种形式。“文件”与“子目录”使我们易于使用数据。7816协议规定了智能卡采用“文件”的形式管理卡内存储器，它将卡内的文件分为3类：MF、DF和EF。MF（Master File）相当于桌面系统中的“根目录”，DF（Dedicated File）相当于桌面系统中的“子目录”，而EF（Elementary File）则是一个个保存数据的具体文件了。与桌面系统不同的是智能卡中DF级数（相当于目录层数的概念）通常是固定的，一般为1级（MF – DF），也有的为两级（MF – DF – SubDF）结构，但7816协议本身并不严格规定DF的级数。另外，7816协议对EF文件的类型有基本的定义，所以卡上的文件很多都是有一定格式的（如“定长记录”文件），并不是像桌面系统中的文件那样给出偏移量和长度就能操作的“透明”结构。对于更高层的协议（如EMV、PBOC），对EF文件的类型有更具体的规定，这种规定往往为了适应本领域的应用。比如PBOC协议规定的“钱包文件”，就是为让智能卡适用于金融领域。但要注意这些具体的规定最终要“映射”到7816协议中的某个文件格式中。 4、智能卡如何对信息存取过程进行控制对保存在卡中的文件不是随随便便就可以读出或修改的。每种智能卡都有一整套规则（也可理解为一个安全模型）限制对文件的存取操作。各个协议一般只规定了一个智能卡应该具备哪些算法（DES、3DES、RSA等），在一些特定领域里还会规定必须采用哪个算法才能保证安全。至于这些算法是以怎样的形式运用到安全模型中则没有过于严格的要求。另外，卡与卡终端（能够对卡进行存取操作的设备）之间的通信在某些情况下要求是安全的，就是说信息在卡与卡终端之间传递时不应被第3方破解，也不应该失去其完整性。7816协议规定了“安全报文传递”规则，符合7816协议的智能卡都应支持这个规则。有些卡（或对卡的某些操作）要求在特定的卡终端上进行，有时还要求持卡人授权进行，这些特殊情况要求卡与卡终端之间，卡与持卡人之间能够相互确认。卡与持卡人之间的认证是大家比较熟悉的，每个卡都有PIN码，就是做这个用的。]]></content>
      <tags>
        <tag>IC</tag>
        <tag>SIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexagon QDSP6介绍]]></title>
    <url>%2F2018%2F05%2F15%2FHexagon-QDSP6%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Hexagon（QDSP6）是由Qualcomm开发的基于DSP的32位多线程CPU架构。根据2012年的估算，高通公司在2011年内在其SoC（平均每个SoC 2.3个DSP内核）中出货了12亿个DSP内核，并计划在2012年出现15亿个内核，这使QDSP出货量最大的DSP架构。2011年出货的DSP核心数量为10亿个，拥有90％的IP许可的DSP市场）。Hexagon架构旨在通过各种应用提供低功耗的性能。它具有诸如硬件辅助多线程，特权级别，VLIW（超长指令字），SIMD（单指令多数据），[4]以及面向高效信号处理的指令等功能。 CPU可以按顺序将每条时钟最多4条指令（数据包）分配到4个执行单元。硬件多线程实现为桶时间多线程 - 线程在每个周期以循环方式切换，因此在V5之前，600 MHz物理内核呈现为三个逻辑200 MHz内核。Hexagon V5切换到动态多线程（DMT），并且在L2缺失，中断等待或特殊指令时使用线程切换。Hexagon Linux的端口在虚拟机管理程序层（“Hexagon Virtual Machine”）下运行，并与3.2版本的内核合并。原始的管理程序是封闭的，2013年4月，Qualcomm根据BSD格式的许可证发布了针对QDSP6 V2和V3的最小的开放源代码管理程序实现，“Hexagon MiniVM”Tony Linthicum在3.1版LLVM（低级虚拟机）中增加了对Hexagon的支持。GCC和binutils也有一个非FSF维护的分支。自2006年以来，海克斯康DSP包含在Snapdragon SoC中。在Snapdragon S4（MSM8960和更新版本）中，有三个QDSP内核，两个在调制解调器子系统和一个在多媒体子系统中的Hexagon内核。调制解调器内核仅由Qualcomm编程，只允许用户编程多媒体内核。它们也用于Qualcomm的一些femtocell处理器，包括FSM9832。]]></content>
      <tags>
        <tag>高通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三大运营商eSIM商用情况]]></title>
    <url>%2F2018%2F05%2F15%2F%E4%B8%89%E5%A4%A7%E8%BF%90%E8%90%A5%E5%95%86eSIM%E5%95%86%E7%94%A8%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[文章时间：2016年 伴随着NB-IoT技术与产业的崛起，eSIM在国内火了起来，三大运营商中的中国移动、中国电信均公布eSIM商用路线图，并大力推广eSIM在物联网市场上的应用。 中国移动中国移动开启eSIM卡征程：聚焦物联网市场在日前召开的“2016eSIM技术与创新峰会”上，中移物联网企业合作部高级技术总监肖青透露，中国移动将会在本月底推出支持2G网络，内置eSIM卡的物联网芯片，在明年将会推出支持4G网络的产品。肖青坦言，中国移动内部针对eSIM有过非常激烈的讨论。目前还没有定论，但已经有了几个共识：在手机领域是零和游戏，eSIM并没有带来产业增值；但在物联网领域，需求却是客观存在，也是产业突围方向。 中国电信中国电信完成物联网eSIM卡平台建设：力争明年实现eSIM商用在上周举行的“2016年天翼智能终端交易博览会”期间，中国电信发布了《天翼终端满意度调研报告》与《终端质量报告显示》评测结果。为了能够在物联网的蓝海中占得先机，中国电信制定了详细的工作计划。在物联网技术准备方面，面向以视频监控和车载信息服务等为代表、10Mbps以上的大流量业务，中国电信将提供Cat.1级别的4G网络速度；面向物流管理和移动支付等大约在1Mbps的中低速率流量业务，电信将通过4G eMTC(Cat M)给予支持；面向水表、电表等100Kbps以下的业务，中国电信将通过NB-IoT网络支持。在物联网技术验证及商用方面，中国电信在去年已经完成Cat1和NB-IoT的实验室及现场试验，以及Cat M的实验室试验；2017年中国电信将推动Cat1的商用，针对CatM进行现网实验，并推动NB-IoT标准的商用与试商用工作。鉴于低频谱有利于实现 窄带IoT业务的大量链接和覆盖需求，以及在规模商用方面的考虑，中国电信将800M作为NB-IoT首选部署频段。 在物联网eSIM验证及试商用方面，中国电信已完成物联网eSIM卡平台建设，2017年将进行平台测试与机卡兼容性的测试，并全力在同年实现物联网eSIM商用。 中国联通中国联通仇剑书：eSIM将拉远运营商与用户距离在2016 eSIM技术与创新峰会上，中国联通研究院仇剑书表示，eSIM的出现代表着一种电信服务需求的变化。对于eSIM给市场带来的最大变化，仇剑书认为eSIM将重构整个产业链，传统的角色面临着重新分配的挑战，产业链各个成员需要重新找到自己未来所处角色。对于运营商而言，不仅产业链地位将有所改变，业务模式也将发生转变。从B2B的业务角度上来说，运营商需要更聚焦于创新，在操作层面要建立生态系统，紧密的联系合作伙伴提供客户的支持。在B2C的业务方面，未来单一合约会被用户绑定更多的设备，这可以提高用户的黏性，但也会拉远运营商与用户的距离。“eSIM可以让用户无需面对运营商，只是与服务提供者进行沟通便可使用网络。”对此，仇剑书认为，eSIM的出现将对现有的电信业务模式会带来冲击，如最直接的基础电信业务销售将会降低，而通过其他渠道销售的比例将会增加，因此生态运营将成为运营商未来大力发展的重点。 拒绝SoftSIM ：运营商不甘沦为管道毫无疑问，SoftSIM将颠覆现有的移动运营业的商业模式，削弱运营商对用户的控制。移动运营商的商业模式是以SIM卡为中心的，它将用户固定在其计费系统中，而SoftSIM甚至可以让用户不再与运营商发生联系，便可随便选择运营商，资费套餐。这无疑将让运营商离最终用户越来越远，直接沦为管道，并且让电信市场竞争更加激烈。但这种市场状态是当久了行业老大的运营商十分不愿意见到的，SoftSIM的出现让运营商与用户间通过SIM建立的联系变得不再是牢不可破，甚至是岌岌可危。尤其当来势汹汹的终端与互联网厂商开始抢占运营商市场份额时，运营商更不愿意让SoftSIM进入市场。不过对于用户来说，SoftSIM让其有了更多自主选择权，可以毫无障碍地更换运营商的网络和套餐。尤其是当用户出国时，可以在目的地选择当地运营商的数据资费套餐，而不用去购买当地运营商的SIM卡。 拥抱eSIM：运营商抢占先发优势相较于令运营商生厌的SoftSIM，eSIM则成为了运营商眼中的香饽饽。趋近饱和的大众市场已经不能给运营商带来大量的新用户与利润。但刚刚兴起的物联网市场则可为运营商提供广阔的市场空间。据保守估计，到2020全球物联网链接数量将达到1000亿个。这对于运营商来说，无疑是一片发展蓝海。但相较于大众市场，物联网对成本敏感，安全性、稳定性要求更高，传统的SIM难以满足物联网设备要求。eSIM应运而生，其可直接焊接在物联网设备中保证稳定性，可在终端设备激活使用后选择运营商，并可切换运营商。不过对于eSIM物联网来说，除了eSIM卡外，SM平台(Subion Manager)更是运营关注重点，并成为管理eSIM，更换运营商的关键。SM平台负责从运营商的系统内获取个人化数据，并建立与eSIM卡之间的安全 传输通道，从而完成对eSIM卡的数据更新操作。可以看出谁掌握了SM平台，谁就掌握了eSIM市场未来。据中国移动相关人士介绍，中国移动以1000万用户作为样本计算，每个eSIM可节省4元左右成本，这无疑将加快物联网发展。目前，中国移动物联网用户已经超过2700万，并将在本月底推出支持2G网络，内置eSIM卡的物联网芯片，明年将会推出支持4G网络的产品。不仅仅是中国移动，中国电信已完成物联网eSIM卡平台建设，2017年将进行平台测试与机卡兼容性的测试，并全力在同年实现物联网eSIM商用。 来源：C114中国通信网]]></content>
      <tags>
        <tag>eSIM</tag>
        <tag>行业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openBTS part2]]></title>
    <url>%2F2018%2F05%2F14%2FopenBTS-part2%2F</url>
    <content type="text"><![CDATA[初始测试和配置现在应该安装软件和硬件。本章将指导您完成一些初步的完整性检查，功能测试和基本配置定制。到本章结束时，您将通过您的私人移动网络在手机间成功交换第一条短信息和语音通话！ 初始状态如果服务的其他实例已在运行，则后面的一些手动步骤将会发生冲突并失败。为了确保这个系统上没有别的东西在运行，执行以下命令：1234$ sudo stop openbts $ sudo stop asterisk $ sudo stop sipauthserve $ sudo stop smqueue 现在您可以继续确认链中每个步骤的连通性，然后运行第一个基本试验。 确认无线电连接首先要验证的是收发器应用程序可以与无线电硬件通信。不同的供应商有不同的方法来完成这一点。 Ettus Research Radios所有Ettus硬件均使用Transceiver52M二进制文件，该文件安装在上一章的/OpenBTS中。运行它，如下所示，以查看是否检测到硬件设备：1234567$ cd /OpenBTS $ sudo ./transceiver [sudo] password for openbts：linux; GNU C ++版本4.6.3; Boost_104601; UHD_003.006.002-releaseUsing internal clock reference-- Opening a USRP2/N-Series device...-- Current recv frame size: 1472 bytes-- Current send frame size: 1472 bytes 上述示例显示尝试成功。收发器可以通过按Ctrl-C来停止。如果您看到类似以下输出的内容，则存在以下问题：123456789$ cd /OpenBTS $ sudo ./transceiver [sudo] password for openbts：linux; GNU C++ version 4.6.3; Boost_104601; UHD_003.007.002-releaseUsing internal clock referenceALERT 1745:1745 2014-09-05T22:37:00.4 UHDDevice.cpp:528:open: No UHD devicesfound with address &apos;&apos;ALERT 1745:1745 2014-09-05T22:37:00.4 runTransceiver.cpp:160:main: Transceiverexiting... Ettus提供了一对帮助应用程序来自动检测和检查附加无线电。运行以下命令以列出所有连接的设备。如果未显示，请跳至第18页的“排除USB故障”或第19页的“故障排除以太网”以解决连接问题。这个例子显示了通过以太网连接的N200：12345678$ uhd_find_devices linux; GNU C++ version 4.6.3; Boost_104601; UHD_003.007.002-releaseUHD Device 0Device Address:type: usrp2addr: 192.168.10.2name:serial: XXXXXX 另一个有用的应用程序是uhd_usrp_probe，它将检查设备并返回其技术信息和配置。这个应用程序的示例运行如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677$ uhd_usrp_probelinux; GNU C++ version 4.6.3; Boost_104601; UHD_003.007.002-release-- Opening a USRP2/N-Series device...-- Current recv frame size: 1472 bytes-- Current send frame size: 1472 bytes_____________________________________________________/| Device: USRP2 /N-Series Device| _____________________________________________________| /| | Mboard: N200r4| | hardware: 2576| | mac-addr: XX:XX:XX:XX:XX:XX| | ip-addr: 192.168.10.2| | subnet: 255.255.255.255| | gateway: 255.255.255.255| | gpsdo: none| | serial: XXXXXX| | FW Version: 12.3| | FPGA Version: 10.0| || | Time sources: none, external, _external_, mimo| | Clock sources: internal, external, mimo| | Sensors: mimo_locked, ref_locked| | _____________________________________________________| | /| | | RX DSP: 0| | | Freq range: -50.000 to 50.000 Mhz| | _____________________________________________________| | /| | | RX DSP: 1| | | Freq range: -50.000 to 50.000 Mhz| | _____________________________________________________| | /| | | RX Dboard: A| | | ID: SBX (0x0054)| | | Serial: XXXXXX| | | _____________________________________________________| | | /| | | | RX Frontend: 0| | | | Name: SBXv3 RX| | | | Antennas: TX/RX, RX2, CAL| | | | Sensors: lo_locked| | | | Freq range: 400.000 to 4400.000 Mhz| | | | Gain range PGA0: 0.0 to 31.5 step 0.5 dB| | | | Connection Type: IQ| | | | Uses LO offset: No| | | _____________________________________________________| | | /| | | | RX Codec: A| | | | Name: ads62p44| | | | Gain range digital: 0.0 to 6.0 step 0.5 dB| | | | Gain range fine: 0.0 to 0.5 step 0.1 dB| | _____________________________________________________| | /| | | TX DSP: 0| | | Freq range: -250.000 to 250.000 Mhz| | _____________________________________________________| | /| | | TX Dboard: A| | | ID: SBX (0x0055)| | | Serial: XXXXXX| | | _____________________________________________________| | | /| | | | TX Frontend: 0| | | | Name: SBXv3 TX| | | | Antennas: TX/RX, CAL| | | | Sensors: lo_locked| | | | Freq range: 400.000 to 4400.000 Mhz| | | | Gain range PGA0: 0.0 to 31.5 step 0.5 dB| | | | Connection Type: QI| | | | Uses LO offset: No| | | _____________________________________________________| | | /| | | | TX Codec: A| | | | Name: ad9777| | | | Gain Elements: None Range Networks Radios网络SDR1无线电广播使用TransceiverRAD1二进制文件，该文件安装在上一章的/OpenBTS中。如下运行它，看看是否检测到硬件设备：12$ cd /OpenBTS $ sudo ./transceiver 1 如果程序不立即停止并继续运行，它已成功检测到无线电硬件。收发器可以通过按Ctrl-C停止，如下所示：123$ cd /OpenBTS $ sudo ./transceiver 1 ^C Received shutdown signal 如果程序立即停止，如下面的输出所示，继续进入故障排除USB部分以解决此问题：123$ cd /OpenBTS $ sudo ./transceiver 1 $ USB故障排除使用虚拟机设置时，USB连接最常见的问题是所需的USB设备未与正确的虚拟机相关联。使用虚拟机的设置来查找相应的USB设备并将其分配给运行OpenBTS开发环境的虚拟机。 以太网进行故障诊断无论使用虚拟机还是实际服务器，以太网连接的无线电都必须有一个额外的以太网接口。虽然可以更改无线电的IP地址以匹配您的本地网络，但这是不可取的，因为在收发器应用程序和无线电硬件之间通过以太网交换的样本对延迟和丢失非常敏感。他们应该建立专门的连接。在服务器中安装额外的物理以太网接口或在虚拟机中创建额外的虚拟以太网接口。确保该接口与无线电硬件在同一子网上。所有Ettus硬件的默认IP地址是192.168.10.2。使用以下示例为您的额外以太网接口分配适当的地址：1$ sudo ifconfig eth1 192.168.10.1/24 现在使用简单的ping命令测试连接。按Ctrl-C停止ping测试：12345$ ping 192.168.10.2PING 192.168.10.2 (192.168.10.2) 56(84) bytes of data.64 bytes from 192.168.10.2: icmp_req=1 ttl=64 time=1.037 ms64 bytes from 192.168.10.2: icmp_req=2 ttl=64 time=1.113 ms^C 启动网络既然您已确认收发器软件可以通信使用无线电硬件，您可以在后台开始运行OpenBTS服务。使用以下命令执行此操作：1$ sudo start openbts OpenBTS服务将自动启动收发器软件的实例并连接到无线电硬件。无线电采样然后通过本地用户数据报协议（UDP）套接字在收发器软件和OpenBTS软件之间交换。 配置 系统和CLIOpenBTS的所有配置都是通过操作存储在SQLite3数据库中的密钥来完成的。默认情况下，该数据库存储在/etc/OpenBTS/OpenBTS.db。每个键在OpenBTS中编译的模式中定义，用于验证正在使用的值。这种配置系统所带来的一个优点是，大多数关键值可以在几秒钟内改变并应用于运行系统，而不会中断服务。这些是动态密钥。配置系统中还有一些静态键需要重新启动OpenBTS才能应用更改。 操作配置键最简单的方法是通过OpenBTS命令行界面（CLI）。运行以下shell命令打开它：1$ sudo /OpenBTS/OpenBTSCLI 现在，您将看到一个OpenBTS提示符。这是包括配置更改在内的命令可以被执行以供OpenBTS处理的地方。从现在起，前缀为$的命令将在Linux命令行上执行。 OpenBTS&gt;前缀的命令用于OpenBTS命令行。打开两个终端窗口可能会很方便，因此不需要不断地输入和退出OpenBTS命令行。 改变频段和ARFCN首先要检查的是无线频段和绝对射频频道号（ARFCN）。无线电波段是四个值中的一个：850,900,1800或1900 MHz，对应于全球可用的四个GSM波段。 ARFCN只是选定频段内的一对频率，将用于无线电信号的传输和接收。每个无线电频段有超过100种不同的ARFCN可以使用。 ARFCN也可以被称为载波（例如，使用多个ARFCN的系统是多载波系统）。选择正确的频段和ARFCN对于监管原因以及避免与当地运营商的干扰很重要。您可以使用OpenBTS config命令检查当前频段和ARFCN设置。这些配置键位于GSM.Radio类别中。要查看名称中带有单词GSM.Radio的所有配置密钥，请输入以下命令：123456789OpenBTS&gt; config GSM.RadioGSM.Radio.ARFCNs 1 [default]GSM.Radio.Band 900 [default]GSM.Radio.C0 51 [default]GSM.Radio.MaxExpectedDelaySpread 4 [default]GSM.Radio.PowerManager.MaxAttenDB 10 [default]GSM.Radio.PowerManager.MinAttenDB 0 [default]GSM.Radio.RSSITarget -50 [default]GSM.Radio.SNRTarget 10 [default] GSM.Radio.Band键显示正在使用900 MHz频段，GSM.Radio.C0键表示当前选择该频段的ARFCN＃51。如果您的无线电硬件对特定频率没有限制或优化，则可以继续进行这些设置。消除干扰的简单优化是选择您的国家/地区的其他运营商未使用的频段。一般来说，美洲使用850和1900 MHz系统，而世界其他地区则使用900和1800 MHz。国家列表可以在Wikipedia上找到。另外，如果可能的话，选择较低的频率以改善低功率覆盖。如果您的本地注册管理机构为您指定了特定频段和ARFCN，那么您必须使用它。要更改您的GSM频段，您必须再次使用OpenBTS config命令。这一次，将所需的乐队添加到该命令的末尾。以下示例将频段更改为850 MHz：12345OOpenBTS&gt; config GSM.Radio.Band 850GSM.Radio.Band changed from &quot;900&quot; to &quot;850&quot;WARNING: GSM.Radio.C0 (51) falls outside the valid range of ARFCNs 128-251 forGSM.Radio.Band (850)GSM.Radio.Band is static; change takes effect on restart 该命令确认该Band已更改，但传递了另外两条信息。首先，关于ARFCN对850MHz频段无效的警告。 850 MHz的有效范围是128-251。其次，通知您GSM.Radio.Band参数是静态的，不能在运行时应用; OpenBTS必须重新启动。要修复第一条警告，请再次使用config命令为850 MHz频带设置有效的ARFCN：123OpenBTS&gt; config GSM.Radio.C0 166GSM.Radio.C0 changed from &quot;51&quot; to &quot;166&quot;GSM.Radio.C0 is static; change takes effect on restart 该命令确认ARFCN已更改，并再次警告此参数为静态。您现在可以重新启动OpenBTS以应用更改：1234$ sudo stop openbtsopenbts stop/waiting$ sudo start openbtsopenbts start/running, process 6075 该服务将需要几秒钟时间才能开始备份，并且您可以再次自由使用OpenBTS CLI 。 Range Networks Radio 校准 Range Networks SDR1硬件可以配备滤波器，针对特定的GSM频段优化无线电。 每个单元也被校准到一个特定的频带，并且如果OpenBTS设置不符合这个校准，可能会表现不佳。 要查看收音机的出厂校准，请使用trxfactory命令：12345678OpenBTS&gt; trxfactoryFactory InformationSDR Serial Number = XXXXRF Serial Number = XXXGSM.Radio.Band = 850GSM.Radio.RxGain = 52TRX.TxAttenOffset = 1TRX.RadioFrequencyOffset = 116 要确定是否需要调整，请使用audit命令。 在对安装进行故障排除时，audit命令是您不变的伴侣。 它会报告非默认值，无效值和冲突值，如果您使用的是范围网络硬件，则会列出出厂校准和当前运行配置之间不匹配的部分：123456OpenBTS&gt; audit+---------------------------------------------------------------------+| WARNING : Factory Radio Calibration [key current-value (factory)] || To use the factory value again, execute: rmconfig key |+---------------------------------------------------------------------+TRX.RadioFrequencyOffset &quot;132&quot; (&quot;116&quot;) 在本例中，TRX.RadioFrequencyOffset参数与工厂校准不匹配。 如消息所示，可以使用rmconfig命令再次使用出厂值：123OpenBTS&gt; rmconfig TRX.RadioFrequencyOffsetTRX.RadioFrequencyOffset set back to its default valueTRX.RadioFrequencyOffset is static; change takes effect on restart 这是另一个需要重新启动OpenBTS的静态参数，如上所述。 大多数配置参数不是静态的，因此重新启动OpenBTS将成为例外而不是规则。 对于报告为不匹配的任何其他校准参数重复此过程。 Ettus Research无线电校准Range Networks和Ettus Research无线电之间的一个主要区别在于GSM.Radio.RxGain的适当值。 Range Networks对这个参数使用了一个更高的值，如果它没有调整，Ettus Research设备将无法正常工作。 接收到的信号将过载驱动解调器。 对于初学者，请将GSM.Radio.RxGain设置为10：123OpenBTS&gt; devconfig GSM.Radio.RxGain 10GSM.Radio.RxGain changed from &quot;52&quot; to &quot;10&quot;GSM.Radio.RxGain is static; change takes effect on restart 还有一个专用的命令，可以让你设置这个参数而不用重新启动OpenBTS。 如果您需要进行微调以避免每次重新启动，请使用rxgain。 搜索网络既然Radio已经过校准并且设置已确认，您将使用手机搜索新创建的网络。 每部手机的菜单都不同，但该项通常与“运营商选择”或“网络选择”类似。图2-1中详细介绍了在Android上手动选择不同运营商的流程。Snipaste_2018-05-15_09-10-20.png 从Android菜单系统启动“设置”应用程序。 选择“更多”。 选择“移动网络”。 选择“网络运营商”。这可能会也可能不会启动搜索。 如果没有，请选择“搜索网络”。 搜索完成后，将显示可用运营商网络列表。 图2-2详细说明了在iOS 7上手动选择不同运营商的流程。Snipaste_2018-05-15_09-11-23.png 1.在主屏幕中，打开“设置”应用程序。2.选择“运营商”。3.在“网络选择”屏幕上，禁用自动载波选择。4.手机现在将搜索可用的运营商网络。5.搜索完成后，将显示可用运营商网络列表。 我们在这里看到了可选运营商列表中的测试网络。 根据使用的手机型号，固件和SIM卡，网络ID将显示为“00101”，“001-01”，“测试PLMN 1-1”或GSM“OpenBTS”的短名称。如果您的测试网络 没有被检测到，通过重新选择菜单项，在打开和关闭之间切换飞行模式，或者关闭手机电源，再次强制搜索。 如果仍然无法使用，请再次确认手机支持您在上面配置的GSM频段，并且基带已解锁（即不受合同限制仅使用特定载波）。 本部分让您验证下行链路是否正常工作; 以下部分将指导您验证上行链路。 然后，您将继续输入手机的身份参数并通过第一次连接（第27页）连接至网络。 测试无线电频率环境因素如果您从未有过涉及射频或模拟信号的项目，那么您可能会对可能出现问题的数量感到惊讶。最终，您可能会惊讶于RF通信可以工作！在OpenBTS社区中的射频专家有时被视为黑魔法从业者…但我离题了。在GSM网络中，使用两个独立的射频，因此基站和手机可以在两个方向上同时通信。换句话说，GSM使用频分多址建立全双工通信。选择ARFCN（请参阅第20页的“更改频带和ARFCN”）决定使用哪一对频率。从基站到手机的路径称为下行链路，从手机返回到基站的路径称为上行链路。在上一节中，您已经能够成功搜索并找到新的网络信标。这表明网络的下行链路到达了您的手机，并且信号足够干净以解调和解释所显示的网络短名称和/或身份号码所证明的信息。在建立新网络时需要注意的一点是，无线电干扰或来自上行链路上其他来源的“噪音”。如果上行链路噪声太大，则来自手机的信号不能可靠地解调成可用信息。 OpenBTS将通过使用noise命令显示当前级别：1234OpenBTS&gt; noisenoise RSSI is -68 dB wrt full scaleMS RSSI target is -50 dB wrt full scaleINFO: the current noise level is acceptable. 在本例中，检测到的环境噪声接收信号强度指示（RSSI）为-68 dB（较低的数字更好，意味着噪声较少）以及配置的目标RSSI级别手机是-50分贝。这意味着基站最多可以从手机获得比环境噪声多18dB的能量 - 这是一个非常好的余量，这意味着由于噪声导致的上行链路接收问题不应该成为问题。这两个数字之间的小利润将产生不同的信息。例如，具有10dB或更小的裕量将报告：12WARNING: the current noise level is approaching the MS RSSI target, uplink connectivity will be extremely limited.警告：当前的噪声级别接近MS RSSI目标，上行链路连接将非常有限。 并且零或小于零的边际将报告：12WARNING: the current noise level exceeds the MS RSSI target, uplink connectivity will be impossible.警告：当前噪声级别超过MS RSSI目标，上行链路连接将不可能。 如果报告了这些WARNING消息中的任一个，则需要采取措施来减少上行链路噪声和/或增加手持机发送功率。将来，如果您的手机可以看到基站但无法再连接，应该首先检查噪声。你的配置仍然是100％正确和功能性的，但是无线电环境可能已经改变，阻止了通信。 降低噪声如果您的基站无线电设置不包含频率双工器，上行链路上的头号噪声源实际上可能是下行链路信号。如果没有适当的双工滤波，下行链路信号通常是物理上和频率上最接近上行链路的能量源。有关双工器的更多信息，请参阅第46页的“更强，更清洁的信号”。即使没有双工器，也可以通过多种方法降低上行链路噪声。 天线对齐一种快速双工器可以简单地对齐天线，使它们不容易相互馈入。如果您使用橡胶鸭式天线，请将它们倾斜成90度角。这些天线的辐射方向图将如图2-3所示垂直。Snipaste_2018-05-15_16-39-38.png 如果天线彼此平行，则信号可以有效地从发射机流向接收天线，但是当天线形成90度角时，信号在与接收天线不同的平面上发射。通过在调整前后运行噪音命令来观察更改。这种简单的调整可以将噪音降低多达10 dB。 下行链路传输功率上面的对齐步骤减少了从发射天线到接收天线的能量流。收到的能量可能仍然太高，无法使上行链路可用。降低下行链路传输功率将进一步清除上行链路。在实验室环境中，通过降低下行功率而损失的覆盖区域并不重要。清洁信号优于强信号。不带任何参数运行电源命令以查看当前级别。以衰减分贝报告功率：12OpenBTS&gt; powercurrent downlink power 0 dB wrt full scale 为了降低下行链路发射功率，例如减少20dB，输入以下内容：12OpenBTS&gt; power 20current downlink power -20 dB wrt full scale 下行链路现在以20dB的功率发射。使用noise命令观察改进。 提升手机功率通过调整GSM.Radio.RSSITargetand和GSM.Radio.SNRTarget键，还可以告诉手机PowerHandsets使用更多的电源。在大多数情况下，这些键的默认值应该足够。但是，如果您遇到接收功率的大幅波动（例如，在地下矿井的角落四处走动），可能有必要增加这些值以提供更大的缓冲区以允许功率差异。提高所有手机的功耗将更快地耗尽电池电量，但上行链路信号更加可靠。总是存在权衡。如果您的噪声级别仍然过高，请返回第19页上的“启动网络”以将您的ARFCN更改为噪声较小的一个。 第一连接您现在已验证下行链路和上行链路。为了确保所有的设置都已经被应用，请发出以下命令来重新启动OpenBTS：12$ sudo stop openbts $ sudo start openbts 在实际连接到测试网络之前的唯一一步就是查找并隐藏手机的身份参数，以便将其接收到网络上。 查找IMSI您将要搜索的主要身份参数是国际移动用户身份（IMSI）。这是存储在SIM卡中的14-15位数字，与网络上的手机用户名类似。手机通常不会泄露其SIM卡的IMSI。它有时可能位于菜单中或通过现场测试模式，但是这种确定SIM的IMSI的方法很麻烦。幸运的是，还有其他方法。 OpenBTS也知道它与之交互过的IMSI，因为你掌控着网络端，所以你也可以访问这些信息。为了强制手机和测试网络之间的交互，你需要执行更新请求（LUR）操作网络，类似于注册。这不比从运营商选择列表中选择网络更复杂。在尝试任何LUR之前，您需要启动负责处理这些请求的SIPAuthServe守护进程：12$ sudo start sipauthservesipauthserve start / running，process 7017 现在，再次按照第23页上的“搜索网络”中的步骤，调出载波选择列表并选择您的测试网络。在很短的时间之后，手机应报告注册失败。它也可能会从您的测试网络收到一条短信，指示注册失败。此消息自动包含IM-SI，因此您可以跳到第29页上的“添加订户”。但是，此功能在所有硬件上都不起作用，因此如果您未收到SMS，则继续操作. OpenBTS会按顺序记住这些LUR交互执行一些称为SIM /临时移动订户身份（TMSI）交换的功能。 IMSI / TMSI交换用于TMSI的用户可识别的IMSI，并用于增加网络上的用户隐私。交易所默认是禁用的（修改Control.LUR.SendTMSIs toenable）;但是，信息仍然存在，可以使用tmsis命令进行检查。现在，请使用它查看与手持设备最近的LUR交互：12345OpenBTS&gt; tmsisIMSI TMSI IMEI AUTH CREATED ACCESSED TMSI_ASSIGNED214057715229963 - 012546629231850 0 78s 78s 0001010000000002 - 351771054186520 1 80h 95s 0001010000000003 - 351771053005400 1 80h 108s 0 条目按时间排序，最上面的条目对应于最近的交互操作。您的手机应该是此列表中的首要条目 - 最近与AUTH设置为0的交互，因为LUR由于手机不是知识订阅者而失败。本例中的其他条目是成功执行LUR的附加测试手机，如AUTH列设置为1所示。 查找IMEI在繁忙的环境中，可能很难确定哪个手机硬件与此列表上的哪个条目相对应。要将IMSI与特定硬件匹配，可以使用国际移动设备标识符（IMEI）。这是手机物理无线电硬件的唯一标识符，类似于以太网接口上的MAC地址。手机的IMSI通常印在其电池盖下或非常靠近SIM本身的地方。在许多手机上，IMEI也可以通过在键盘上拨打以下内容来访问：*＃06＃.IMEI值通常仅用于在生产环境中报告和检测被盗硬件。这里可以作为确定哪个SIM卡在哪个手机中的便捷方式。 IMEI的最后一位可能与OpenBTS显示的不匹配。它是一个校验位，在OpenBTS中显示为零。 添加订户您现在应该拥有所有必要的信息以在您的测试网络上创建新的订户帐户。一些字段仍然需要，但可以自由选择：名称和移动台国际用户目录号码（MSISDN）。名称字段仅仅是该用户的友好名称，因此您可以记住与哪个手机或与哪个人相关联。 MSISDN字段并不比订户的电话号码复杂。由于您没有连接到公共电话网络，因此您可以选择任何号码。您需要添加订户的程序是nmcli.py。它是No-deManager API的简单客户端（更多内容参见第7章），并允许您通过JSON格式的命令更改配置参数，添加订阅者，监控活动等。 nmcli.py已经存在于你的开发目录中 - 现在移动它来访问它：1$ cd dev /NodeManager 有两种方法可以使用nmcli.py添加订阅者。第一个创建将使用缓存身份验证的订户：1$ ./nmcli.py sipauthserve subscribers create name imsi msisdn 第二个创建将使用完全身份验证的订户：1$ ./nmcli.py sipauthserve subscribers create name imsi msisdn ki 如果IMSI是“用户名”，手机的“密码”是第5页的“使用备用SIM卡”中讨论的Ki字段。如果您使用来自其他提供商的备用SIM卡，则无法使用Ki，并应使用第一个调用样式。如果你正在使用自己烧过的SIM，Ki会被你知道。使用nmcli.py的第二个调用样式将它包含在新订户中。在这个例子中，在iPhone 4中使用备用SIM卡，并在南达科他州（区号605）为其指定一个假号码：IMSI字段由数字IMSI组成，前缀为字符串“IMSI”。1234567$ ./nmcli.py sipauthserve subscribers create &quot;iPhone 4&quot; IMSI214057715229963 6055551234raw request: &#123;&quot;command&quot;:&quot;subscribers&quot;,&quot;action&quot;:&quot;create&quot;,&quot;fields&quot;:&#123;&quot;name&quot;:&quot;iPhone 4&quot;,&quot;imsi&quot;:&quot;IMSI214057715229963&quot;,&quot;msisdn&quot;:&quot;6055551234&quot;,&quot;ki&quot;:&quot;&quot;&#125;&#125;raw response: &#123;&quot;code&quot; : 200,&quot;data&quot; : &quot;both ok&quot;&#125; 使用您自己的信息执行相同的命令，将第一个用户添加到您的测试网络。 连接现在，当您在连接菜单中选择测试网络时，LUR应该成功。 这可以通过OpenBTS中的tmsis命令来确认。 “AUTH”列现在在对应于您的IMSI的条目中具有“1”：12345OpenBTS&gt; tmsisIMSI TMSI IMEI AUTH CREATED ACCESSED TMSI_ASSIGNED214057715229963 - 012546629231850 1 11m 56s 0001010000000002 - 351771054186520 1 80h 8m 0001010000000003 - 351771053005400 1 80h 9m 0 恭喜，您已成功注册到您自己的私人移动网络！ 在继续之前，请随时注册您想要使用的任何其他手机。 测试短信现在手机可以访问您的网络，您可以执行一些更有趣的测试。 首先是对网络SMS功能的快速测试。 负责接收，路由和安排SMS消息传送的组件是SMQueue。 必须在测试这些功能之前启动它; 执行以下命令来执行此操作：12$ sudo start smqueuesmqueue start/running, process 21101 回声短信（411）在手机上，编号为411的短信。这是SMQueue中的一个“短代码”处理程序，它只会回显接收到的任何内容以及有关使用的网络和用户帐户的其他信息。给411的消息的主体可以是任何你想要的，尽管对每个消息或连续的数字或字母使用独特的内容可能是有用的。这可以帮助您确定发生错误时正在响应的消息。一旦你的信息组成411，点击发送。几秒钟后，应该会出现一个回复（示例如下）：1“1 queued, cell 0.1, IMSI214057715229963, phonenum 6055551234, at Sep 8 02:30:59, Ping pong&quot; 这表示以下内容：•有一条消息排队•基站的负载因子为0.1•从IMSI 214057715229963，MSISDN 6055551234接收到消息•消息在9月8日02:30:59发送•消息正文为“Ping pong”。 “ 直接SMSSMS消息也可以通过使用sendms命令直接从OpenBTS进行测试。在OpenBTS CLI中，让我们看看如何使用help命令调用它：123OpenBTS&gt; help sendsmssendsms IMSI src# message... -- send direct SMS to IMSI on this BTS, addressedfrom source number src#. 通过指定目标IMSI，消息应该看起来源于的源号码和消息主体本身来发送消息。 用您的订户帐户替代信息编写消息并按Enter键：12OpenBTS&gt; sendsms 214057715229963 8675309 direct SMS testmessage submitted for delivery 几秒钟后，您的手机应该显示来自假想号码8675309的新的传入消息，其中包含“直接短信测试”。以这种方式创建的SMS消息根本不会路由SMQueue; 它们通过GSM空中接口直接发送到手机，因此不能重新安排时间。 如果手机离线或无法到达，这些信息就会丢失。 这就是SMQueue需要的原因 - 尝试和重新安排在固有不可预测的无线环境中的交付。 双方短信如果您配置了多个手机用于您的网络，请随时在它们之间来回发送一些消息。 验证接收消息时源号码是否正确，并将这些消息的回复路由回原始发件人。 测试呼叫另一项要测试的服务是语音。与SMS一样，OpenBTS不直接处理语音，并需要额外的服务才能运行，在这种情况下，Asterisk。立即启动Asterisk：12$ sudo start asteriskasterisk start/running, process 1809 使用您在SMS测试中使用的手机，您现在将验证语音服务的几个方面。这是通过使用rangeasterisk-configs软件包定义的一些测试扩展来完成的。分机是内部电话号码，从外面无法接通。 测试音调（2602）您将使用的第一个测试扩展会播放一个不变的音调。这听起来可能不太令人兴奋，但确实证实了有关网络的许多事情： Asterisk正在运行并且可以访问。 呼叫路由按预期工作。 下行音频功能正常。现在用手机拨打2602。当你听到音调时，听音调的变化。音调的这些变化是由于丢失了下行链路语音流路径中的信息，类似于分组丢失。在现场，这是测试音调扩展的主要用途：测试下行链路质量。在生产网络中，下行链路损失3％是正常的，损失5％-7％仍然可以提供可理解的对话。 回声呼叫（2600）下一个测试扩展会创建一个“回声呼叫”。基本上，Asterisk收到的所有音频将立即回送给发件人。除了确认列出的用于测试音调的项目之外，回声呼叫还会显示网络中存在的任何延迟或上行链路质量问题。现在用手机拨打2600。当你对着麦克风讲话时，你很快会听到自己在听筒里的声音。有点延迟是正常的，但更长的延迟会导致更像是使用对讲机的体验。人脑可以处理大约200毫秒的延迟而没有麻烦。除此之外，谈话开始瓦解，双方都停止说话，因为它变得不舒服。 双方通话如果您配置了多个手机用于您的网络，请随时在它们之间拨打一些电话。接收呼叫时验证来源号码是否正确。 测量链路质量此时，您应该了解OpenBTS CLI中可用的便捷工具chans命令。 该工具可用于客观量化链接质量，而不是基于用户感知。 要查看此命令有用的任何内容，必须有一个活动的呼叫。 在这个例子中，呼叫被放置到2602测试音调扩展，并且在10秒钟后执行chans命令（注意“时间”列）。 手机被移动了一米远离正在使用的无线电，另一个带有chans命令的样本被采集：123456OpenBTS&gt; chansCN TN chan transaction Signal SNR FER TA TXPWR RXLEV_DL BER_DL Time IMSI type id dB pct sym dBm dBm pct0 1 TCH/F T101 28 28.7 0.15 1.2 7 -61 0.00 0:10 2140...OpenBTS&gt; chansCN TN chan transaction Signal SNR FER TA TXPWR RXLEV_DL BER_DL Time IMSI type id dB pct sym dBm dBm pct0 1 TCH/F T101 14 31.4 0.50 1.2 19 -73 0.00 0:26 2140... 这里有很多领域，他们都非常有用，但现在我们来关注信噪比（SNR），TXPWR和RXLEV_DL。在两次读数中，都有一个活动频道。 SNR列表示由基站测量的上行链路的SNR：越高越好。随着手机移开，这个数字实际上有所改善！怎么可能？答案在于TXPWR专栏。该列表示手机报告的上行链路发射功率。在二读中，这个数字已经从7跳到19 dBm，这意味着手机使用更多的功率将其信号传输到基站。这可以解释为什么在基站测得的信噪比更好。取决于基站接收其上行链路信号的程度，网络独立地指示手机以不同的功率电平进行发送。这是因为所有的信号都是在基地台以大约相同的强度接收到的，这使得它更容易解调。然而，基站在下行链路上对所有的手机使用相同的发射功率。这可以在RXLEV_DL列中观察到。该列表示手机报告的下行信号电平。在二读时，随着手机远离基站移动，这个数字从-61 dBm下降到-73 dBm。它正在接收较低强度的下行链路信号，因为它现在距离较远。这些字段的完整列表可以通过运行来检索：1OpenBTS&gt; help chans 配置系统（续）在本章中，您已经熟悉了几个OpenBTS命令，其中最重要的一个可能是配置。 在继续之前，我们将提供一些关于配置的最终细节，并且会向您介绍几位亲戚。 配置到目前为止，您使用config来搜索配置键并更改其值。 如果提供了完整的名称，它还可用于提供有关特定配置密钥的其他信息：12345678OpenBTS&gt; config SIP.Proxy.SMSSIP.Proxy.SMS 127.0.0.1:5063 (default)- description: The hostname or IP address and port of the proxy to be used for text messaging. This is smqueue, for example.- type: hostname or IP address and port- default value: 127.0.0.1:5063- visibility level: customer warn - a warning will be presented and confirmation required before changing this sensitive setting- static: 0- scope: value must be the same across all nodes DEVCONFIGdevconfig命令的功能与config命令相同。 但是，它允许您操作更多类型的键。 每个键都有一个可视级别，用于标识键用于用户，开发人员或工厂的人员。 使用devconfig可以访问这些更敏感的键，例如协议定时器：1234567891011OpenBTS&gt; config GSM.TimerGSM.Timer.Handover.Holdoff 10 [default]GSM.Timer.T3109 30000 [default]GSM.Timer.T3212 0 [default]OpenBTS&gt; devconfig GSM.TimerGSM.Timer.Handover.Holdoff 10 [default]GSM.Timer.T3103 12000 [default]GSM.Timer.T3105 50 [default]GSM.Timer.T3109 30000 [default]GSM.Timer.T3113 10000 [default]GSM.Timer.T3212 0 [default] rawconfigrawconfig命令会比devconfig做更多的事情并删除所有输入验证。 如果你有一个你想更改为有效范围之外的实验值的键，则需要使用rawconfig。rawconfig的另一个用途是在数据库中定义全新的自定义键/值对。 编写新功能时这很方便：12OpenBTS&gt; rawconfig My.New.Setting zebradefined new config My.New.Setting as &quot;zebra&quot; unconfig一些控制可选功能的按键可以被禁用。 可以禁用的键将在其类型字段中设置“字符串（可选）”：1234OpenBTS&gt; config Control.LUR.FailedRegistration.MessageControl.LUR.FailedRegistration.Message Your handset is not provisioned for this network. [default]- description: Send this text message, followed by the IMSI, to unprovisioned handsets that are denied registration.- type: string (optional) unconfig命令将尝试禁用某个密钥并在其成功时报告回来.12OpenBTS&gt; unconfig Control.LUR.FailedRegistration.MessageControl.LUR.FailedRegistration.Message disabled rmconfig要将密钥恢复为其默认值，请使用rmconfig：12OpenBTS&gt; rmconfig SIP.Proxy.SMSSIP.Proxy.SMS set back to its default value 该命令也可用于删除使用rawconfig定义的自定义键/值对：12OpenBTS&gt; rmconfig My.New.SettingMy.New.Setting removed from the configuration table 个性化您的网络你的网络已经启动并且正在运行，你知道如何控制它，而不是一个糟糕的开始。 然而，这是你的网络，所以它应该根据你的口味进行定制。 本节将介绍个性化一些事情的过程，以便它绝对是您的网络。 简称浏览时，短名称会显示在某些手机上。 这是搜索网络时有人注意到的第一件事，所以请继续并从OpenBTS的默认设置中进行更改：12OpenBTS&gt; config GSM.Identity.ShortName GroundControlGSM.Identity.ShortName changed from &quot;OpenBTS&quot; to &quot;GroundControl&quot; 只有名称的字母数字字符不允许使用空格和特殊字符。 注册消息如果您还记得，在第27页的“第一次连接”中，有一条“注册失败”的短信发送给手机。 实际上，对于不同的事件，有几条SMS消息。 要查看它们的列表，请使用名称中的Registration.Message搜索配置密钥：1234OpenBTS&gt; config Registration.MessageControl.LUR.FailedRegistration.Message Your handset is not provisioned for this network. [default]Control.LUR.NormalRegistration.Message (disabled) [default]Control.LUR.OpenRegistration.Message Welcome to the test network. Your IMSI is [default] 注册失败的消息很好，但有点无聊。 您可以使用config命令更改它：123OpenBTS&gt; config Control.LUR.FailedRegistration.Message Nuh-uh-uh, you didn&apos;t saythe magic word.Control.LUR.FailedRegistration.Message changed from &quot;Your handset is not provisioned for this network.&quot; to &quot;Nuh-uh-uh, you didn&apos;t say the magic word.&quot; 或者，要完全禁用失败的注册消息，您可以使用unconfig：12OpenBTS&gt; unconfig Control.LUR.FailedRegistration.MessageControl.LUR.FailedRegistration.Message disabled 还有另一个消息，Control.LUR.NormalRegistration.Message，默认情况下是禁用的。 每次成功注册时，该消息都会发送到手机。 虽然在生产环境中很烦人，但它对于实验室来说可能是一个有用的工具，特别是如果他们正在操作多个基站的话。 如果注册更新或切换，该消息用作提示：12OpenBTS&gt; config Control.LUR.NormalRegistration.Message Welcome to BTS 1Control.LUR.NormalRegistration.Message changed from &quot;&quot; to &quot;Welcome to BTS 1&quot; 要测试它，请尝试关闭手机的电源或切换打开和关闭飞行模式。 当手机重新获得您的基站信号并注册时，您应该收到一条消息。 第6章将介绍Control.LUR.OpenRegistration.Message参数。]]></content>
      <tags>
        <tag>OpenBTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openBTS part1]]></title>
    <url>%2F2018%2F05%2F14%2FopenBTS-part1%2F</url>
    <content type="text"><![CDATA[设置在本章中，我们将指导您选择硬件，安装基本操作系统和开发环境设置，以及实际编译和安装组成OpenBTS软件套件的组件。可以采取几个捷径 - 例如，如果您希望使用官方二进制包而不是编译自己的程序包，但整个过程都是针对那些希望从头开始构建的程序。 硬件组件虽然OpenBTS实现了用软件构建移动网络所涉及的大部分复杂性，但无线电波仍然必须以某种方式传输和接收。本节详细介绍了您应该采购哪些硬件组件以在开发环境中实现此功能。第2章介绍了这些组件的配置。 Linux服务器第一个需求是标准的商品Linux服务器。其他体系结构已经开始得到支持，但现在仍然坚持使用运行32位操作系统的x86处理器，以获得最佳结果。这台计算机可以是您测试环境中的独立计算机，也可以是您每天使用的笔记本电脑或台式机上的虚拟机。处理能力和RAM的最低要求由于涉及许多变量，例如并发载波信号的数量，网络负载，网络使用类型，无线电环境等，因此没有明确定义。每个变量都会影响所需的资源。单载波信号要求OpenBTS软件生成下行波形以发送给手机并解调从手机接收的上行波形。 OpenBTS支持在单个物理无线电上创建多个并发载波信号，以线性增加网络容量，但处理需求非常高。对于使用单载波信号（最多7个并行语音通道）的稳定实验室设置，建议使用Intel i5或与2 GB RAM相当的设备。它还必须至少有一个USB2接口，但USB3正迅速成为新软件定义无线电的要求。现在开始使用USB3可能是一个好主意，以避免将来升级。 USB接口增加吞吐量的需求与通过它传送的无线电波形样本的数量和大小有关。在生产环境中，可以使用多个同时载波信号，这大大增加了所需的采样带宽。另外，用于解调信号的算法可以被配置为以更稳健的方式进行操作（例如，纠正由于部署环境造成的信号失真）。因此，产生和解调这些信号所需的处理能力可能比实验室设备中的要大一个数量级。需要记住的另一件事是，随着OpenBTS的更新版本的推出，新的功能可能需要更多的处理能力或内存。例如，全球移动系统（GSM）模式下的OpenBTS可以在英特尔凌动处理器上平稳运行，但新的OpenBTS-UMTS（通用移动电话系统）至少需要一个英特尔i7。这个旁注实际上是在软件中定义无线电接入网络（RAN）的主要优点。随着新标准的发布，可以通过简单的软件更新将它们应用于生产RAN，而不是交换昂贵的硬件基础设施。 软件定义无线电软件无线电（SDR）是从硬件角度使OpenBTS成为可能的关键突破。SDR已用于军事应用大约20年。直到最近，由于技术成本的降低，它们才能提供给更多的观众。现代SDR是一种通过USB电缆或以太网连接到计算机的硬件。它们通常与一副纸牌一样小，或者像三张DVD一样大，并通过USB主机连接或小型外部电源直接供电。 SDR硬件实现了一个完全通用的无线电，它可以通过主机应用程序发送和接收定义频率范围（即60 MHz至4 GHz）的原始波形。该主机应用程序可以是一个FM收音机实现，可以接收原始波形，解调信号并播放音频。这意味着无线电硬件不再是围绕特定应用设计的;完全由主机来定义实现，允许任何人纯粹用软件来创建无线电应用。 OpenBTS支持来自多个供应商的SDR：Ettus Research，Fairwaves，Nuand和Range Networks。这些产品的价格从大约500美元到超过2500美元不等。如果您选择通过以太网连接的产品，请确保您的Linux服务器具有用于无线电的专用以太网端口（最好是千兆位以太网）。大多数SDR是适用于任何无线电项目的完全通用的硬件，而一些SDR专门针对实施移动网络进行了优化。购买前请咨询供应商。天线许多SDR具有足够的发射和接收灵敏度，可以在小型环境下无天线操作。通常，可以实现半径为1米的覆盖区域。这是实验室环境的理想设置，特别是如果多个开发人员使用多个无线电。覆盖区域不会相互重叠和相互干扰。另外，您的网络不会干扰该地区的任何运营商。即使您的覆盖区域非常小，国家监管机构仍然很可能会要求您在使用GSM频率之前获得测试许可证。有关更多信息，请参阅第78页的“频谱管理”。在实验室环境中，多个开发人员将共享一个OpenBTS实例，因此必须扩展覆盖区域。添加一对小型5 dBi天线可以在无阻碍的环境中大幅提升，最高可达25米半径。这些通常是带有SubMiniature A型（SMA）连接器的橡胶鸭式天线，外观与典型的家庭WiFi路由器天线相似。图1-1显示了一个例子。 天线针对特定频率进行调谐，因此请选择与您将使用的GSM频段（850,900,1800或1900 MHz）最接近的频段。频率也在覆盖区域大小中起作用。低频段（850和900 MHz）传播的距离比高频段更大 - 有时几乎是两倍。 测试电话对于测试，至少需要两个与您将使用的频段（850,900,1800或1900 MHz）兼容的GSM手机。大多数现代GSM手机都是“四频段”，这意味着所有频段都得到支持。还有“三频”和“双频”手持设备。确定手机是否与您的网络兼容的最简单方法是在GSM Arena上搜索模型。这里列出了完整的技术规格。您还必须确保您使用的手机已解锁。如果手机处于“锁定”状态，则意味着制造商已将硬件的基带处理器编程为仅与特定载波一起工作。通常可以通过在拨号盘上输入一系列数字来消除此限制，但这超出了本书的范围。最简单的选择是使用可以接受任何运营商的用户身份模块（SIM）卡的解锁手机。 测试SIM卡GSM手机中使用的SIM卡只不过是一个精简的智能卡。智能卡也被称为芯片卡或集成电路卡（ICC），可以在许多认证和识别应用中找到。全尺寸智能卡具有与信用卡相同的尺寸;较新的信用卡实际上使用智能卡技术来提高安全性。 SIM卡使用标准智能卡写入器进行编程，一旦写入，就会从全尺寸卡框中弹出，以便它们适合GSM手机。图1-2显示了全尺寸智能卡载体，弹出的全尺寸SIM卡和微调的SIM卡。 有几种方法可以在您的测试环境中使用SIM卡。根据您的需求和未来的部署计划，您可以决定使用备用SIM，自己创建一些新的SIM，或者委托一家公司对其进行批量编程。 使用备用SIM卡出于测试目的，任何物理上适合手机的SIM卡都可能工作。但是，使用现有的SIM卡，已过期的SIM卡或外国的SIM卡会进行权衡，主要涉及安全功能。存储在SIM中的秘密密钥，名为“Ki”，只有SIM发行者知道。它存储在SIM卡中不可读的部分内存中，制造商将其放置在那里后无法检索。运营商和手机之间的这种共享秘密是允许网络在用户有效的情况下以密码方式确定的。 OpenBTS针对这种情况提供了一种称为“基于缓存的身份验证”的替代身份验证方法。它与手机进行初始身份验证交换并记录结果。它使用这个相同的请求，并期望在未来有相同的答案。该方法并不像每个请求的唯一交换一样安全，但仍然比完全禁用身份验证要好。另一个名为“Kc”的密钥用于支持呼叫加密。在您的测试环境中使用其他电话的SIM卡时，您将失去这两项功能，但如果您无法使用智能卡写卡器和空白卡，则这是您的最佳选择。当使用其他运营商的SIM卡连接到您自己的OpenBTS网络时，一些手机是棘手的。如果手机可以检测到它的“本地”载波信号，手动选择另一个载波的选项可能会从设置菜单中隐藏。在未锁定的iPhone中使用AT＆T SIM卡时通常会遇到这种情况。 自制SIM卡要为您自己的测试环境创建一小批SIM卡，您需要空白的可擦写“神奇”SIM卡和智能卡写卡器。阿里巴巴网站上的多家供应商提供了许多产品。通过USB连接的示例作者如图1-3所示，但市场上有许多不同寻常的作家。 软件安装和写入命令取决于选择哪个写入器和卡。有关编写SIM卡的最新信息可以在OpenBTS wiki页面上找到。 批量SIM卡SIM写入公司开始以合理的价格提供更少量的卡片。您通常会提交一些关于您的订单的参数，例如卡片工艺，所需的验证算法和卡片数量，以获得报价。一旦订购完成，成品将是一盒SIM卡以及一张单独的文件或文件，其中包含每张卡片的ID和加密密钥列表。然后可以使用脚本将该列表批量导入到订户数据库中。现在，您的所有订阅者都可以进行系统配置，无需手动刻录10,000张个人SIM卡，而且每个用户都留下了精美的SIM卡。 全尺寸与微米与纳米相比一旦你有一个技术上兼容的SIM卡（2G与3G与4G等），它可能仍然具有不兼容的外形因素。这很容易通过使用SIM卡切割器来弥补，这是运营商喜欢收取可观的服务费用。它看起来像订书机，但功能更像是曲奇工具，如图1-4所示。 他们可以以低于20美元的价格购买，并将SIM卡从标准转换为微型，并将微型转换为纳米。这些尺寸之间的唯一区别是实际芯片周围的塑料量。 操作系统和开发环境设置现在已经收集了硬件，您可以继续设置开发环境。 OpenBTS传统上是在Ubuntu长期支持（LTS）发行版上开发和测试的。它也在Debian和CentOS发行版上进行了测试。对于本书，将使用经过测试的分发和体系结构：Ubuntu Server 12.04 LTS 32位。从OpenBTS 5.0开始，64位系统也受到支持，但尚未广泛部署。除了Ubuntu 12之外，Ubuntu 13和14系统也已成功使用。基于RPM的系统（CenOS，Fedora和Red Hat Enterprise Linux）的初步打包也可用，但本书不会涉及。请访问OpenBTS.org获取更多信息。如果您尚未安装兼容的操作系统，附录B将提供完整的分步指南。如果您打算使用官方OpenBTS发行包，请随意跳到第10页的“安装”。 Git兼容性Git是一个管理软件源代码更改的版本控制系统。 OpenBTS项目利用了Git中的一些新功能，例如子模块分支跟踪。为确保您的客户端兼容（例如，比1.8.2更新），它需要更新。首先，执行这个命令来添加对Personal Package Archives的支持，这是一种分发二进制发行包的替代方法：1$ sudo apt-get install software-properties-common python-software-properties 然后，执行以下命令为最新的Git构建到您的系统：1$ sudo add-apt-repository ppa：git-core/ppa 现在，您只需刷新软件包列表并再次安装Git来更新系统的客户端：12$ sudo apt-get update $ sudo apt -get install git 要确认新的Git客户端已正确安装，请运行以下命令：12$ git --version git version 1.9.1 现在您已安装Git，您可以继续下载开发脚本。 下载代码OpenBTS项目由多个托管在GitHub上独立开发库中的软件组件组成。理解Git的复杂性不应该成为使用OpenBTS的障碍，因此编写了几个开发脚本，以便下载代码，切换分支和编译组件。要将这些开发脚本下载到新环境中，请运行以下命令：1$ git clone https://github.com/RangeNetworks/dev.git 开发脚本假定您为GitHub设置了安全Shell（SSH）密钥。如果您不这样做，请在继续之前按照这些说明进行设置。现在，要下载所有组件，只需运行clone.sh脚本：1$ cd dev $ ./clone.sh 每个组件的存储库都将从GitHub克隆到您的开发环境中。 clone.sh脚本还会自动初始化所​​需的任何子模块。既然OpenBTS项目源代码位于您的开发环境中，您可以选择特定的分支或版本进行编译。 switchto.sh脚本用于在构建版本目标之间切换。例如，如果要构建v4.0.0发行版，请运行以下命令：1$ ./switchto.sh v4.0.0 可以使用state.sh脚本为每个组件列出当前版本的目标。该脚本还列出了每个组件的任何未完成的本地更改。1$ ./state.sh 本书重点介绍5.0系列分支。要定位5.0中最新，最好的代码，请运行以下命令：1$ ./switchto.sh 5.0 构建代码现在您的开发环境已准备好在5.0系列分支中构建最新的位。要编译二进制包，您将使用build.sh脚本。它会自动安装编译器和自动配置工具以及任何所需的依赖关系。它还控制将构建哪个无线电收发器应用。由于有多种不同的驱动程序可用于各种无线电类型，因此build.sh需要一个参数，以便知道哪个硬件正在定位（有效的无线电类型为SDR1，USRP1，B100，B110，B200，B210，N200和N210）。 OpenBTS还支持Fairwaves的UmTRX硬件。但是，它使用UHD无线电驱动程序的定制版本，并且build.sh脚本尚未自动安装。本书的目标是Ettus Research N200。立即运行build命令：1$ ./build.sh N200 这个过程在第一次运行时可能需要一段时间（30-60分钟），具体取决于正在执行的硬件。展望未来，您只需重新编译更新的组件。例如，以下命令仅重新编译Ettus Research B100收音机的OpenBTS包：1$ ./build.sh B100 openbts当构建脚本完成时，将会有一个名为“BUILDS”的新目录，其中包含一个子目录建立时间戳。此目录的示例如下所示：123456$ ls dev/BUILDS/2014-07-29--20-44-51/*.deb liba53_0.1_i386.deb range-asterisk-config_5.0_all.deb libcoredumper1_1.2.1-1_i386。 deb range-configs_5.0_all.deb libcoredumper-dev_1.2.1-1_i386.deb sipauthserve_5.0_i386.deb openbts_5.0_i386.deb smqueue_5.0_i386.deb range-asterisk_11.7.0.4_i386.deb 恭喜！您现在可以继续安装和启动每个组件，并了解每个组件的用途。 安装现在你已经下载了一套官方发行版软件包或编译好自己的软件包，需要安装并启动它们。为每个组件提供一些背景信息，然后提供安装过程和所需的任何初始化配置。由于一些组件依赖于其他组件，它们将按照满足这些相互依赖性的顺序呈现。在继续之前，请转到新的编译目录：1$ cd dev/BUILDS/2014-07-29--20-44-51/ 安装依赖关系如果您使用build.sh脚本在前一节编译了自己的一组包，这些依赖关系已经安装完毕，这部分可以跳过。如果您使用的是一组官方发行版软件包，则需要安装一些额外的系统库并定义一个额外的资源库源，以便找到并安装所有依赖项。执行以下命令为ZeroMQ定义额外的存储库源，ZeroMQ是所有组件使用的库：123$ sudo apt-get install software-properties-common python-software-properties $ sudo add-apt-repository ppa：chris-lea/zeromq $ sudo apt-get update Coredumper库OpenBTS使用coredumper共享库来产生有意义的调试信息，如果OpenBTS崩溃。 Google最初编写了它，实际上有两个libcoredumper软件包：libcoredumper-dev包含编译利用coredumper库的程序所需的开发文件，libcoredumper包含应用程序在运行时加载的共享库：1$ sudo dpkg -i libcoredumper1_1.2.1-1_i386 .deb 自发布本书以来，包名中的确切版本号可能已发生变化。 A5/3库OpenBTS使用A5/3共享库来支持呼叫加密。它包含必须与OpenBTS分开分发的加密程序例程：1$ sudo dpkg -i liba53_0.1_i386.deb 安装组件通过在全新系统上安装以下所有组件，可以确保您可以使用功能齐全的GSM网络，框。语音，短信和数据所需的一切都将在一个系统中运行。您将要安装的整体架构如图1-5所示。 会话发起协议（SIP）和实时传输协议（RTP）是OpenBTS用于将GSM流量转换为VoIP的两种协议。 系统配置此软件包包含一组默认配置，可让新的Ubuntu系统在安装时即装即用。它包括网络接口，防火墙规则，域名系统（DNS）配置，日志记录等设置。如果您已经习惯于配置Linux发行版，但可能不想安装此软件包，但其内容可用作指导进行所需的更改。在安装过程中，系统会多次提示您确认覆盖某些配置文件。如果您不确定文件的功能，在处理全新系统时，安全答案始终为“Y”：1$ sudo dpkg -i range-configs_5.0_all.deb 如果您回答“Y”，则此软件包将覆盖您的网络接口配置，当询问有关/etc/network/interfaces的更改时。您可以在此提示下回答“N”，并保留您的配置：但是，只有手动将第62页的“中央服务”中详述的文本添加到您的接口定义之后，GPRS才能正常工作。它负责调用iptables-restore自动加载防火墙规则。 AsteriskAsterisk是一个VoIP交换机，负责处理SIP INVITE请求，建立呼叫的各个部分，并将它们连接在一起。有两个包负责设置Asterisk安装，它不需要任何额外的配置：range-asterisk和range-asterisk-configs。 range-asterisk软件包包含Asterisk SIP交换机软件的确认版本，并确保已包含OpenBTS所需的相应模块。没有包含Asterisk的其他补丁;它只是为了代表Asterisk最新的确认版本。 range-asterisk-configs软件包包含一组配置文件，因此Asterisk知道并可以与订户注册数据库进行通信。这个数据库是各种组件存储和更新用户的电话号码，身份，身份验证，来电显示和注册状态的地方。另外，通过使用这个数据库，在将新手机添加到网络时，不再需要手动编辑Asterisk配置文件：1$ sudo dpkg -i range-asterisk*.deb $ sudo apt-get install -f SIPAuthServeSIP授权服务器（SIPAuthServe）是一个应用程序，用于处理OpenBTS在手机尝试加入移动网络时产生的SIP REGISER请求。当手机认证成功时，SIPAuthServe负责使用启动它的OpenBTS实例的IP地址更新订户注册数据库，允许其他订户呼叫手机：12$ sudo dpkg -i sipauthserve_5.0_i386.deb $ sudo apt -get install -f SMQueueSIP MESSAGE Queue（SMQueue）是一个应用程序，用于处理手机发送SMS时OpenBTS生成的SIP MESSAGE请求。它存储消息，安排它们在网络中传送，并在目标手机不可用时重新安排它们：12$ sudo dpkg -i smqueue_5.0_i386.deb $ sudo apt-get install -f OpenBTS最后，我们到达显示。 OpenBTS负责在软件中实现GSM空中接口，并直接与GSM手机通信。该通信在IP网络侧转换为SIP和RTP，并与上述组件交互以形成核心网络。 GSM手机看到一个完全兼容的GSM无线接入网络，核心网络可以看到标准的SIP端点。任何一方都不应该知道允许手持设备无缝连接到IP世界之间有一层：12$ sudo dpkg -i openbts_5.0_i386.deb $ sudo apt-get install -f 启动/停止组件现在每个组件都已安装，你需要开始他们。使用名为Upstart的系统在Ubuntu上控制组件。未来版本的OpenBTS套件将支持其他机制，如systemd，但现在使用Upstart。要启动所有组件，执行以下命令：1234$ sudo start asterisk $ sudo start sipauthserve $ sudo start smqueue $ sudo start openbts 相反，要停止所有组件，请使用：1234$ sudo stop openbts $ sudo stop asterisk $ sudo stop sipauthserve $ sudo stop smqueue 启动和关闭的顺序并不重要，但如果OpenBTS在没有其他组件的情况下运行，GSM网络将可见但不可用。每个组件都在后台运行，并在出现故障时自动重启。要监视组件在后台运行时的控制台输出，可以使用以下日志文​​件：123/var/log/upstart/asterisk.log /var/log/upstart/sipauthserve.log /var/log/upstart/smqueue.log/var/log/upstart/openbts.log 系统组件已安装并正在运行。下一步将开始测试和配置它们。]]></content>
      <tags>
        <tag>OpenBTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openBTS part0]]></title>
    <url>%2F2018%2F05%2F14%2FopenBTS-part0%2F</url>
    <content type="text"><![CDATA[简介电话很酷。是的，智能手机也很酷，但我正在谈论普通老式双向电话机。在地球上任何两点之间传递你的声音的能力是一个了不起的人类成就。也许更令人惊讶的是，这种成就多快被视为理所当然。过去100年来为建立公共交换电话网络进行了巨大的努力。铜网被挂起和埋葬。奠定了城市和城镇之间的长距离线路。人类手动路由和连接呼叫，然后模拟机器和数字计算机自动完成。一路上，移动网络被发明和部署。同样的基础设施故事发生在技术先进：设备升级，手机反复取代。现在，有线和无线电话网络几十年来都在稳固地提供语音服务，因此数据带宽正在进入下一个升级周期：光纤到家，LTE到智能手机。 OpenBTS桥接了这两个世界。通过在无线射频接口和开放IP协议之间转换，它允许任何具有IP连接的人部署移动网络。地球上的许多地方仍然没有家庭电话线或移动网络接收。但是，更多的时候，他们确实通过卫星或长途WiFi连接了互联网。恰当地集成，OpenBTS可以将这种互联网连接转换并分布到一个大的地理区域的移动网络。任何GSM电话都可以连接和使用语音服务或SMS，甚至基本数据。可以将连接带到偏远地区，同时跳过整个基础设施建设和升级周期。 OpenBTS和软件定义无线电的组合改变了我们应该考虑移动网络的方式。这项新技术允许纯软件构建复杂的无线电网络。 OpenBTS是一个C ++应用程序，它实现了GSM栈。随着新功能的实施或增加了协议支持，现有的OpenBTS移动网络的功能可以通过简单的软件更新来增强！另外，因为OpenBTS只是软件，你可以随心所欲地做任何事情。您不再需要硬件供应商的权限来访问其关闭的黑盒子实现。您可以构建一个利基产品或实验功能;移动网络最终开放创新。 谁应该读这本书电信工程师 - 有线或无线，电路交换或分组交换 - 应该能够锁定OpenBTS项目的这一介绍。冒着将材料过于分散的危险，我们已经注意解释OpenBTS的无线电和IP侧。如果你是一名射频（RF）专家，你将学到一些关于互联网电话的知识。并在非常低的水平进行检查。如果您有兴趣在移动设备上调试应用程序，OpenBTS提供了几个原始接口，可以查看无线传输中的具体情况。您的软件还可以使用新的数据API来构建搜索和救援，紧急响应，功率优化，道路交通分析等应用。 为什么我写了本书我的背景主要是在VoIP中。当我开始使用OpenBTS工作时，我很无意识地了解无线电系统的复杂程度。相反，我和其他人一起工作的是无线电专家，但从未接触过VoIP。 OpenBTS项目的文档很丰富，但非常广泛，以支持广泛的有关各方的观众;它需要简化。我们希望有一本新书能够为技术提供一个完整的新手，使他们能够成功建立自己的网络：获得语音通话的工作，交换一些短信等等。这个最初的成功应该建立信心，让这个人自己出发。我试图将健康数量的上下文组合到逐步的部分中。移动网络在GSM和RF方面仍然非常复杂。每个提示都有帮助。我希望你能在设置你的时候避免大问题！我也希望这本书足够有趣，可以在没有硬件的情况下阅读。在深入OpenBTS相关项目之前，本书应该为您提供足够的信息来确定所需资源的范围。 今天移动网络上的文字正如Marc Andreessen所说：“软件正在吃掉世界。”这在移动行业中绝对是正确的。随着处理能力变得更快，更便宜，现在可以在软件中实现极其复杂的信号处理算法。该软件也能够在日益通用的硬件上运行。由于专用硬件和协议而导致供应商锁定的时代已经过时，并且移动基础架构中的一些真正竞争和创新的机会似乎越来越接近。几年前，“建立自己的移动网络”这本书将成为一个非常不同的读者。 “编译”和“定制”这些词甚至可能没有出现。图I-1说明了这种网络的体系结构。 这种网络架构是许多人经过多年研究的令人难以置信的工程。它非常强大且可扩展，但不幸的是，它非常不灵活且非常昂贵。大学越来越关注这个问题，其中最着名的是加州大学伯克利分校新兴地区技术与基础设施（TIER）小组和硅谷卡内基梅隆大学的CyLab流动研究中心，该中心最近发表了一篇论文，这种传统的移动体系结构，包括来自传统有线网络的演变行李。为了解决这个问题，出现了多个开源项目。仅举几例：Osmocom，OpenLTE和YateBTS。每个项目都有不同的目标和体系结构，以自己的方式解决传统网络的难题。然而，这本书是关于该组织的老将，OpenBTS。 OpenBTS项目是一组开源软件组件，可用于构建更现代化的轻量级网络。 OpenBTS允许传统移动网络的“Um”无线电接口直接与互联网电话协议互连。图I-2说明了这种新的“混合”体系结构。 手机上的软件或配置更改是不必要的，因为移动网络的无线接口与传统网络相同。然而，网络核心不再由一系列复杂的协议和服务器组成。它由开放协议组成，并使用IP作为其传输。已经存在许多实施这些开放协议的软件项目。 OpenBTS还开发了一些新组件，以提供仍不可用的功能，以连接GSM和互联网世界。围绕“云”的激动和围绕“应用程序”的激动如此之多，似乎最终这两者之间的沟通开始盛行。 浏览本书到本书结束时，您将建立一个功能齐全的移动网络。它将显示为任何其他网络在您的手机上进行的操作，并在网络参与者之间路由呼叫和SMS，以及在手机和互联网之间提供数据连接。 第1章将逐步指导您选择无线电和处理硬件，设置基本操作系统和开发环境，以及编译和安装软件组件。 第2章介绍初始组件配置和激活以及网络功能测试。 第3章深入探讨生产网络的故障排除和性能调整技术。 第4章详细介绍了如何将您的单节点网络扩展为具有移动性和切换功能的真正的多节点移动网络。 第5章基于您的配置提供通用分组无线业务（GPRS）数据功能。 第6章探讨了一个类似于WiFi专属门户网站的OpenBTS特有功能，可用于应急响应和ad hoc网络。 第7章提供了与OpenBTS NodeManager控件和事件API之上的应用程序交互和构建应用程序的参考资料。 第8章介绍了您的网络的一些后续步骤：与公共交换电话网络（PSTN）互连，专用分支交换（PBX）集成以及当前的频谱监管状态。 附录A提供了GSM术语，RF测量，组件端口，路径和文件的快速参考。 附录B介绍了Ubuntu 12操作系统的安装。 附录C显示了如何捕获不仅IP交换机，而且还捕获原始的GSM无线电帧。 在线资源OpenBTS社区OpenBTS文档GSM时隙和频道可视化器GitHub上的OpenBTS源代码库]]></content>
      <tags>
        <tag>OpenBTS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GSMA SGP.01 第3章学习]]></title>
    <url>%2F2018%2F05%2F12%2FGSMA-SGP-01-%E7%AC%AC3%E7%AB%A0%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[第三章 架构3.1 架构图本节定义了支持远程配置eUICC所需的功能架构. 该体系结构的基本组成部分包括要执行的功能，角色（Role）和分配的参与者（Actors）. 下图显示了eUICC远程供应系统. 第3.3节和附录A中描述了角色的细节，相关的功能和接口. 3.2卡体系结构3.2.1安全域GlobalPlatform提供了安全域（SD）的概念.这些是离卡(off-card)实体的卡内(on-card)代表，提供： 用于加密密钥的安全存储; 使用（GP）安全通道协议访问离卡实体; 加载应用程序的机制; 应用程序的安全服务.通过配置密钥（例如用于SCP02 / 03或SCP80 / 81）以及通过将SD与另一个SD关联来配置SD的属性（例如授权或授权管理，DAP验证，令牌管理，全局删除）与其他权利相关联，将SD与其自身相关联（从而移除高级SD的所有管理权），或者为SD及其所有内容分配内存配额.在早期版本中，ISD（发行者安全域）具有几个独特的特权.但是，在最新的GlobalPlatform Card Specification [GPCS]中，它也是通过权限进行配置的，除了在开始之前，没有一个主要的特定功能.这应该使移动网络运营商能够享受到与UICC当前的ISD一样的优势. 前进的方向是： 在SD结构上构建eUICC，以及 定义其他属性（例如通过权限），以便不同的SD可以表示远程配置profile中各种角色的Actor. 3.2.2卡体系结构本节描述如何设计Profiles，例如，使用Global Platform Card Specification [GPCS]的概念和信息模型的扩展版本.profile包含在eUICC的安全域（SD）中，从而使SD的安全机制可用.更多信息可以在[GPCS]中找到.下图概述了eUICC的示意图. 操作系统（OS）包含基本的平台特征，例如支持GlobalPlatform Card Specification [GPCS]中定义的功能. ECASD（eUICC认证机构安全域）： 在制造时在eUICC内创建; 交货后无法删除或禁用; 基于全球平台CASD的概念（见[GPCS]，[AmdA]和[AmdE]）; 由eUICC制造商在颁发前配置; 包含不可修改的eUICC私钥，相关证书，CI的根公钥和用于密钥/证书续订的EUM密钥集; 与提供底层安全OTA通道的ISD-R相关联; 对ISD-P和ISD-R中的新密钥集的建立，但不限于此; 不支持强制DAP验证功能. ISD-R和ISD-P是具有特殊功能的安全域.ISD-R（ISD-Root）是执行平台管理命令的SM-SR的卡上代表（请参阅第3.3.1.3节中的平台管理功能）.ISD-R应：a）在制造时在eUICC内创建;b）与SM-SR相关联;c）不被删除或禁用;d）使用平台管理证书（[管理]中定义的SCP80或SCP81）向SM-SR提供安全的OTA通道; e）实施支持SM-SR变更的密钥建立协议; f）在profile下载期间提供运输部分的包装和解包服务; g）能够创建具有所需内存配额的新的ISD-Ps（注：内存配额管理有待进一步研究）; h）除ISD-P外无法创建任何SD;i）按照政策规定执行平台管理职能;j）不能在ISD-P内执行任何操作. ISD-P（ISD-Profile）是移动网络运营商的现场代表，或者是MNO授权的SM-DP.ISD-P应：a）在eUICC上成为一个独立的独立实体b）包含文件系统，NAA和政策规则等profile; c）包含与创建，启用和禁用profile相关的状态机; d）包含用于加载和安装阶段的profile管理的密钥; e）实施密钥建立协议，为ISD-P的个性化生成密钥集; f）能够接收和解密，加载并安装由SMDP创建的Profile; g）安装profile后，能够将自己的状态设置为禁用状态; h）提供SCP03能力以确保与SM-DP的通信;i）能够包含CASD.此CASD在profile中是可选的，并且只在profile处于启用状态时才提供服务. MNO-SD是MNO的卡上代表.MNO-SD应：j）与自身相关联;k）包含MNO OTA密钥; l）提供安全的OTA通道（[102225]和[102226]中定义的SCP80或SCP81）;m）有能力托管补充安全域. 一旦profile安装在eUICC的ISD-P上，profile和ISD-P应被认为是联合的，此后它就是被管理的ISD-P的状态.在装载和安装阶段，SM-DP执行ISD-P上的profile管理功能（请参阅第3.3.1.2节）.一旦profile启用，MNO-SD由MNO OTA平台管理. MNO-SD以与当前UICC的ISD等效的方式进行管理. 平台服务管理器是提供平台管理功能和策略规则强制机制（策略规则强制实施器）的操作系统服务.它由ISD-R或ISD-P调用，它根据策略规则执行功能（参见第3.6节）.另外，它可以检索可以根据请求与授权实体共享的ISD-P通用信息（即profileID，profile状态）. 电信框架是一项OS服务，为ISD-Ps中托管的NAA提供标准化的网络认证算法.此外，它还提供了使用所需参数配置算法的功能.包含在ISD-P中的是公知的具有应用的卡结构，用于其他实体的SD，文件系统（MF树，ADF等）（根据ETSI TS 102 221 [102221]和3GPP TS 31 102 [31102 ]）和政策规则. 3.2.3 ISD-P的状态图ISD-P的状态和状态转换如下：在创建ISD-P并建立密钥后，SM-DP代表MNO创建SD ，应用程序，NAA和文件系统.安装profile时，SM-DP将ISD-P的状态设置为禁用状态，从而有效地将其交给SM-SR进行平台管理. 在上图所示的创建状态下，profile被下载并安装在ISD-P中.在创建，禁用或删除状态下，profile对机器不可见以便机器设备 3.3相关角色和功能本节介绍并定义支持远程配置嵌入式UICC所需的相关角色和功能.这些函数描述了角色内部执行哪些操作，或者与架构的另一个角色或实体进行通信时执行了哪些操作.该角色与该角色分配给的业务角色不可知. 3.3.1功能定义3.3.1.1数据准备功能3.3.1.1.1非个性化profile创建非个性化profile创建包括基于MNO profile描述和eUICC目标类型构建非个性化profile. SM-DP使用目标eUICC的EUM提供的服务，脚本，工具或文档生成非个性化profile. SM-DP和EUM之间交换的信息不是标准化的，可能因不同实体而有所不同.假定SM-DP用目标eUICC的样本测试非个性化profile. MNO通过测试使用由SM-DP开发的非个性化profile创建的测试个性化profile个性化的目标eUICC的样本来验证非个性化profile. 3.3.1.1.2profile订购profile订购包括由SM-DP根据MNO向SM-DP提供的输入数据准备和生成个性化profile的过程.输入数据包括（但不限于）： 要生成的profile的数量; IMSI值或范围; ICCID值或范围; 非个性化的profile类型; 有关目标eUICC的信息，例如EID.MNO向SM-DP提供输入数据的方式和时间超出范围. 3.3.1.1.3个性化数据的生成该功能基于由MNO提供的输入数据（例如，IMSI，ICCID）在安全环境中创建证书和密钥值（例如，NAC，PIN，OTA密钥）. 3.3.1.1.4profile个性化SM-DP根据MNO下达的命令将个性化数据插入到非个性化profile中.此功能解决了确保创建的个性化profile只能安装在特定eUICC上的过程. 3.3.1.1.5 EUM服务，脚本，工具或文档为允许任何SM-DP在任何eUICC上承担上述功能，EUM提供的服务，脚本，工具或文档必须至少支持以下eUICC属性由MNO交付.某些属性与非个性化profile创建的功能有关，有些属性与profile个性化有关，在某些情况下，它们适用的功能可能取决于特定的eUICC.这些属性包括： 要加载的应用程序（和应用程序的分配） - 包括USIM，ISIM，CAT和第三方应用程序SSD; eUICC平台内的算法选择，算法参数分配和算法参数加载; 应用密钥和PIN分配和加载; USIM应用程序文件结构中的可选和可变数据字段; 支持其他应用程序的附加数据字段和文件结构 - 基于SIM和基于设备的应用程序. SM-DP和EUM之间交换的信息不是标准化的，可能因不同实体而有所不同. 3.3.1.2profile管理的功能3.3.1.2.1 eUICC资格验证功能eUICC资格验证功能包括以下几个方面：•验证目标eUICC是否正在安装profile.•验证eUICC认证. 3.3.1.2.2profile下载和安装功能这涉及将个性化profile下载和安装到目标eUICC中. 3.3.1.2.3profile内容更新功能这是通过MNO OTA平台实现的. 3.3.1.2.4策略规则更新功能这包括策略规则的更新.要更新的策略规则可能是SM-SR中的策略规则，或者是eUICC上的ISD-P中已安装的profile中的策略规则. 3.3.1.3平台管理功能3.3.1.3.1 ISD-P创建功能该功能用于在eUICC中创建ISD-P，以准备要加载的profile内容. 3.3.1.3.2 ISD-P删除功能这涉及删除ISD-P. ISD-P删除是ISD-P以及之前加载并安装在eUICC上的内容的永久性删除.只有在禁用状态时才能删除ISD-P（见3.2.3节的状态图）. 3.3.1.3.3主删除功能无论profile的策略规则如何，它都会处理删除没有设置回退属性的孤立profile.该功能将删除profile及其ISD-P.只有profile处于禁用状态时才能删除profile. 3.3.1.3.4profile启用功能这涉及启用profile.这将使profile中的应用程序和文件可见并可由机器选择，以便机器受到相关访问控制. 3.3.1.3.5profile禁用功能这涉及禁用profile.这将使profile中的所有应用程序和文件不可见，并且不被机器选择以加密设备. 3.3.1.3.6设置回退属性这涉及对所述eUICC 3.3.1.3.7传送功能运输功能的资料（或多个）的回退属性的设置是指SMSR之间的通信信道的建立和eUICC上的ISD-R.此功能也解决了SM-SR和eUICC之间传输通道的安全问题.注意：SM-SR可以通过不同类型的网络系统（如GSM，GPRS，UMTS或EPS）联系机器到机器设备中的eUICC.此外，SM-SR将需要与相关的网络系统进行相应的接口.例如，SM-SR需要使用SMPP才能与SMS通信，或者可能需要连接到IMS网关才能与eUICC建立基于IP的通信.这些通信由活动的订阅提供. 3.3.1.3.8策略执行功能介绍eUICC和SM-SR策略规则的实施. 3.3.1.4 eUICC管理的功能3.3.1.4.1 eUICC注册功能该功能用于处理SM-SR中的eUICC. 3.3.1.4.2 SM-SR变更功能处理eUICC的SM-SR变更. SM-SR变更是将eUICC的EIS从一个SM-SR转移到另一个SM-SR，并在新的SM-SR和eUICC之间在ISD-R中建立新的密钥集. 3.3.1.5 eUICC功能3.3.1.5.1回退功能这涉及启用具有回退属性设置的profile.此功能会自动禁用当前启用的profile并启用配置了“回退属性”的profile.例如，在启用profile的网络连接永久丢失的情况下. 3.3.2为相关角色和角色分配功能 3.4profile描述3.4.1安装在eUICC上的profile的一般内容以下数据是profile的一部分：•应用程序和（特别是3GPP TS 31.102 [31102]，3GPP TS 31.103 [31103]和ETSI TS 102 221 [102221]）中定义的文件.除上述内容外，以下数据未包含在上述标准中：•与其相应的网络访问应用程序相关的算法参数（例如Milenage：OPc，ri，ci值）;•profile附加的策略规则（POL1）. 3.4.2访问profile的内容对于机器设备，启用profile相当于UICC.对于一个MNO OTA平台，启用资料相当于一个UICC按照ETSI TS 102 225 [102225]，TS 102 226 [102226]和TS 102 223 [102223].根据profile的其余内容，附加到profile的策略规则POL1通过MNO OTA平台进行管理.根据相关的ETSI和3GPP标准，已启用profile中的小程序将按照与UICC中的小程序相同的方式工作. 3.5程序本节描述的程序涉及业务环境的角色（例如，客户和服务提供者之间）和远程供应架构的实体（例如，eUICC和SM-SR之间）之间的交互.对于每个程序，描述主要步骤以及相关的“启动条件”和“结束条件”. “开始条件”描述了在执行程序之前必须保留的一组先决条件. “结束条件”描述了一系列结果，这些结果将在程序执行后保留.确定了eUICC和相关profile的配置和生命周期管理的以下主要程序： 3.5.1 SMU-SR中的eUICC注册eUICC是根据给定标准制造的，一般独立于机器对机器设备制造商，移动运营商或服务提供商.机器制造商设备制造商可以选择符合其用途的任何认证的eUICC，并直接从EUM订购它所需的数量.作为生产过程和发货前的强制性步骤，EUM将eUICC注册到选定的SMSR.这意味着在其整个生命周期中相关的相关信息，特别是平台管理证书，供应MSISDN，都存储在SM-SR数据库中.没有这一步，就不可能远程访问eUICC.注意：假设在此阶段eUICC确实包含配给profile并链接到活动的配给订购.如何选择Provisioning运营商，并且EUM与Provisioning MNO之间的相关商业和技术协议的性质超出了本文档的范围.以下表示eUICC信息集的功能表示形式： 启动条件：生成eUICC，并在配给运营商的网络中加载并激活配给profile.他们已经过测试并准备发货.每个eUICC都有相应的EIS.过程： EUM向包含EIS的选定SM-SR发送eUICC注册请求. SM-SR将EIS存储在其数据库中，并以EID作为关键参数. SM-SR确认向EUM注册成功.确认消息包含EID. 结束条件：eUICC在SM-SR上注册并准备好下载profile.现在可以将其运送到机器以加工设备制造商. 每个eUICC只能在一个SM-SR上注册. EUM和SM-SR之间的通信链路应是安全的.在器件制造过程中，eUICCs在注册和发货后嵌入到机器到机器设备中. 3.5.2非个性化profile验证（专有）在eUICC中，UICC的当前功能范围由profile表示.类似于传统UICC的验证，profile应由创建profileSM-DP的实体验证.为了由SM-DP验证profile，应使用与典型UICC类似的程序.其中一个差异是物理测试eUICC只能由SM-DP进行个性化设置.注意：profile验证过程和接口不是标准化的，并且可能在MNO和SM-DP之间不同（profile验证策略，MNO可能执行哪些测试，可能由SM-DP完成，可能会在MNO和SM-DP，这个接口如何保护等）.例如，简档验证过程可以包括以下步骤：开始条件：a. MNO已向SM-DP提供了profile描述，SM-DP已通过单独的过程生成了非个人化profile.b.SM-DP具有特定类型的样本eUICC.过程： MNO向选定的SM-DP提供测试订阅，以及小应用程序，POL1和profile类型等数据.其他数据，例如密钥或ICCID可由SM-DP生成. SM-DP创建一个测试个性化profile（非个性化profile，包含从MNO收到的数据），然后将其下载并安装到eUICC样本中. 3. SM-DP执行必要的验证程序来验证eUICC样本和测试个性化profile的组合.结束条件：非个性化profile有效，现在已准备好用于eUICC类型的profile订购步骤. 3.5.3profile排序（专有）在eUICC中，UICC的当前功能范围由profile表示.正如目前的UICC一样，Profile在MNO的责任下下令.应用相同的程序，唯一的区别在于UICC不是以实物形式生产，而是作为简档保存在SM-DP中.注意：profile订购流程和界面不是标准化的，并且可能因MNO而不同.例如，简档排序可以包括例如，profile排序可以包括以下步骤： 开始条件：a. SM-DP根据MNO提供的profile描述创建了非个性化profile.b.MNO需要一定数量的eUICCprofile.C.非个性化profile已使用第3.5.2节中的非个性化profile验证程序在目标eUICC类型上进行了验证. 步骤： MNO向选定的SM-DP提供订单.该订单包含生产数据，例如数量和Start-IMSI，IMSI范围或IMSI列表以及对非个性化profile类型的引用.策略规则的POL1和POL2定义稍后将分别由eUICC和SM-SR应用，也可以在此背景下提供. 然后SM-DP开始生产，即使用从MNO接收到的数据对profile进行个性化.其他数据，例如密钥或ICCID，可以由SMDP在个性化过程中生成.profile存储在SM-DP中. 向MNO确认订单完成，包括在MNO后端系统中注册个人档案所需的所有数据.每个profile至少由其ICCID唯一标识. 4. MMNO在相关系统中安装简档，例如HLR，AuC，CRM.这些程序与MNO当前的UICC注册程序没有区别.结束条件：profile的订购数量现在已准备好用于profile下载过程. MNO可以使用相关的运营商凭证. 3.5.4profile下载和安装为了使机器能够将Device用于通信服务，eUICC必须至少加载一个Operational Profile.通常，这将通过使用由当前启用的profile表示的订阅进行无线传输完成.如果没有启用其他操作profile，则使用配置profile.profile下载和安装过程遵循以下步骤： 开始条件：a.客户已经订阅了选定的MNO.b.目标eUICC的EID和SRID为MNO所知.C.使用选定的SM-DP完成profile订购程序.d.目标eUICC被集成到一台机器中以加工设备并与SM-SR相关联.即MNO可以通过ICCID激活网络中的相关订阅. 过程： MNO向SM-DP发送profile下载请求.该请求必须包括相关信息，以便识别SM-SR，目标EID和ICCID.移动网络运营商可能会要求SM-DP在下载和安装后启用该profile. 根据MNO提供的信息，SM-DP识别eUICC当前注册的SM-SR. SM-SR和SM-DP如果尚未认证，则相互认证. SM-DP向SM-SR请求由EID识别的特定eUICC的EIS. 基于EID，SM-SR检索EIS. SM-SR将来自EIS的相关信息发送给请求的SM-DP.注：说“来自EIS的相关信息”的基本原理是SM-SR不会向SM-DP提供不适用于特定SM-DP的信息. SM-DP根据从EIS收到的信息检查eUICC的资格（例如类型，证书和存储器）. 如果在eUICC资格的情况下检测到问题，则SM-DP会中止该过程，并向请求的MNO和SM-SR返回错误消息. 如果未检测到eUICC资格问题，则SM-DP向SM-SR发出ISD-P的安装请求. SM-SR和eUICC使用ISD-R中的密钥集，如果尚未认证，则相互认证. SM-SR联系eUICC上的ISD-R进行ISD-P安装，并在eUICC中创建一个空的ISD-P.这被确认回SM-DP. SM-DP验证eUICC，并在ISD-P和SM-DP之间建立共享密钥集.密钥建立过程在安全部分4.5中描述. 现在SM-DP选择个性化profile（例如，基于ICCID或profile类型）并使用新的ISD-P密钥集保护它，产生加密和完整性保护的profileEncP. SM-DP要求SM-SR在eUICC上的ISD-R和SM-SR之间建立安全传输信道.此安全传输通道用于保护Profile Management命令，而不是Profile本身. SM-DP通过使用SM-DP与eUICC上新创建的ISD-P之间的安全通道将EncP发送至eUICC，并在已建立的SMSR与安全通道之间的安全传输通道内发起profile下载与安装eUICC上的ISD-R. eUICC将安装结果和ISD-P的状态发送给SM-DP.profile的MNO所有者决定是否在profile安装结束时profile的MNO所有者决定，在profile安装结束时，ISD-P中设置的SCP03密钥是否应由SM-DP移除，由SM-DP保留还是移交给MNO.注意：如果MNO决定密钥集由SM-DP保留，则MNO可以指示SM-DP在稍后的时间点切换或删除密钥集. SM-DP将安装结果和ISD-P的状态发送给SM-SR.此消息包含此profile的相关EIS元素. SM-SR更新其数据库.如果下载和安装成功，则SM-SR将新的Profile记录插入到EIS中，状态为“已禁用”. SM-SR确认profile下载和安装状态返回到SM-DP.此消息包含EIS的相关部分. 如果移动网络运营商要求SM-DP在下载和安装后启用profile，则SM-DP通过SM-DP程序执行profile启用（见3.5.7）. SM-DP确认下载和安装状态返回MNO.该消息可以包括EID和用于识别profile的信息. 结束条件：已在MNU的eUICC中创建ISD-P，其中包含禁用或启用状态的profile. SM-SR相应地更新了此eUICC的EIS. MNO可以激活网络中的相关订阅. 3.5.5主删除此过程将删除没有回退属性的孤立profile，无论profile的策略规则如何.该程序的成功执行需要发起者和SM-DP的授权.注意：需要确定扮演发起人角色的角色.在下面的例子中，我们可以假设发起人将成为获得客户授权的新MNO. 开始条件：a.在eUICC上有一个孤立的profile，例如，阻止加载另一个profile.b.无法使用正常ISD-P删除程序删除孤立profile.C.发起人决定删除eUICC上的孤立profile.d.孤立profile被禁用. 过程： 发起者向SM-SR发送主删除请求.该请求包括目标profile的目标EID和ICCID（或其他唯一标识符）.该请求包括主删除的发起者授权（Auth 1）. SM-SR将授权请求与发起者授权（Auth 1）一起发送到与目标profile相关联的SM-DP. SM-DP验证授权（验证1）. SM-DP还向目标profile的MNO所有者请求授权.注意：此接口的定义超出了本文的范围. 4.如果MNO授权删除或MNO没有响应，则SMDP向SM-SR发送包含SM-DP授权（Auth 2）的响应以用于主删除.如果SM-DP没有授予主要删除权限，SM-SR将通知发起者. 5. SM-SR和eUICC使用ISD-R中的密钥集，如果尚未通过身份验证，则彼此进行身份验证. SM-SR将主删除请求发送给eUICC上的ISD-R.该请求包括目标profile的ICCID（或其他唯一标识符）以及SM-DP的授权（Auth 2）. 目标profile的ISD-P验证授权，从而验证主删除命令. ISD-R在没有实施策略规则的情况下删除目标profile和相关的ISD-P. ISD-R将主删除的状态报告给SM-SR. SM-SR相应地更新EIS. SM-SR将主删除的状态报告给启动器.结束条件：目标profile从eUICC中删除. SM-SR中的EIS是最新的. 3.5.6profile启用两个profile之间的切换可以通过以下专用过程来实现.在这种情况下，请求由MNO直接发送到与目标eUICC相关联的SM-SR. 开始条件：a.目标profile在eUICC上被禁用.其他profile已启用.b.与目标profile相关的订阅在MNO的网络中处于活动状态.C.目标eUICC的EID，与目标简档相关联的SRID以及目标简档的ICCID为MNO所知. 过程： MNO向SM-SR发送profile启用请求.该请求包括目标EID和至少目标profile的ICCID（或其他唯一标识符）. SM-SR检查当前已启用profile和目标profile的POL2是否允许进行profile切换. 如果与POL2发生冲突，SM-SR将中止程序并相应地通知相关的MNO. SM-SR和eUICC使用ISD-R中的密钥集，如果尚未通过身份验证，则彼此进行身份验证.5.如果与POL2没有冲突，则SM-SR向eUICC上的ISD-R发出配置启用请求，包括至少目标profile的ISD-P AID. eUICC执行POL1检查. 如果与POL1发生冲突，ISD-R会中止程序并通知SMSR. 如果与POL1没有冲突，则ISD-R执行profile开关，导致启用目标profile并禁用先前启用的profile. ISD-R将profile切换结果报告给SM-SR. 10.如果交换机成功，则SM-SR在EIS中记录目标profile已启用且先前的profile已禁用. 11.SM-SR将profile切换结果报告给MNO.这些消息将包括其各自简档的EID和ICCID（或其他唯一标识符）.结束条件：目标profile在eUICC上启用.先前启用的profile被禁用. EIS是最新的. 3.5.7通过SM-DP启用profile通过以下专用程序可以实现两个profile之间的切换.在这种情况下，MNO向SM-DP发出请求，SM-DP将其转发给与目标eUICC相关联的SM-SR.这样，MNO就不必链接到SMSR，并依靠SM-DP进行连接. 开始条件：a.目标profile在eUICC上被禁用.其他profile已启用.b.与目标profile相关的订阅在MNO的网络中处于活动状态.C.目标eUICC的EID，目标profile的SRID和ICCID为MNO所知. 过程： MNO向SM-DP发送profile启用请求.该请求包括目标EID和至少目标profile的ICCID（或其他唯一标识符）. SM-DP识别相关的SM-SR. SM-SR和SM-DP如果尚未认证，则相互认证. SM-DP将profile启用请求转发给SM-SR. SM-SR检查当前启用的profile和目标profile的POL2是否允许profile切换发生. 如果与POL2发生冲突，SM-SR将中止该程序，并将请求的SM-DP和SM-DP或MNO通知禁用的profile. 如果与POL2发生冲突，错误消息由SM-DP转发给请求的MNO. SM-SR和eUICC使用ISD-R中的密钥设置，如果尚未认证，则相互验证. 如果与POL2没有冲突，则SM-SR向eUICC上的ISD-R发出配置启用请求，包括至少目标profile的ISD-P AID. eUICC执行POL1检查. 11.如果与POL1发生冲突，ISD-R将中止程序并通知SMSR. 如果与POL1没有冲突，则ISD-R执行profile开关，导致启用目标profile并禁用先前启用的profile. ISD-R将profile切换结果报告给SM-SR. 14.如果交换机成功，则SM-SR在EIS中记录目标profile已启用且先前profile已禁用. SM-SR将profile切换结果报告给请求的SM-DP以及禁用的profile的SM-DP或MNO.这些消息将包括其各自简档的EID和ICCID（或其他唯一标识符）. 16. profile切换结果被转发给请求的MNO. 结束条件：目标profile在eUICC上启用.先前启用的profile被禁用. EIS是最新的. 3.5.8profile禁用profile禁用可以通过以下过程来实现.该请求由MNO直接发送到与目标eUICC相关联的SM-SR. 开始条件：在eUICC上启用目标profile. 过程： MNO向SM-SR发送profile禁用请求.该请求包括目标EID和至少目标profile的ICCID. 如果用于禁用的目标profile是设置了回退属性的profile，则不会执行profile禁用. SM-SR检查已启用profile的POL2是否允许禁用profile 如果存在POL2冲突，则SM-SR中止该过程并向MNO发送错误消息. SM-SR和eUICC使用ISD-R中的密钥集，如果尚未通过身份验证，则彼此进行身份验证. 如果没有POL2冲突，则SM-SR向具有回退属性集的profile的eUICC上的ISDR发出profile启用请求. eUICC对当前启用的profile执行内部POL1检查.如果允许，则启用的profile将被禁用，ISD-R将启用配置了“回退属性”的profile. ISD-R向SM-SR发送profile禁用结果. 如果禁用成功，则SM-SR在EIS中记录目标profile被禁用. SM-SR将profile禁用结果报告给MNO.该消息包括profile的EID和ICCID. 结束条件：现在在eUICC上禁用了目标profile，并启用了具有故障预置属性集的profile. 3.5.9 ISD-P删除profile可以被其MNO删除. 启动条件：MNO决定永久删除eUICC上的profile. 过程： MNO向SM-SR发送ISD-P删除请求.该请求包括目标profile的目标EID和ICCID（或其他唯一标识符）. SM-SR检查目标profile的POL2. 如果与POL2发生冲突，则SM-SR中止该过程并相应地通知MNO 如果目标profile已启用，则SM-SR启动profile禁用过程. SM-SR和eUICC使用ISD-R中的密钥集，如果尚未通过身份验证，则彼此进行身份验证. SM-SR将ISD-P删除请求发送给eUICC上的ISD-R.该请求包括目标profile的ISD-P AID. eUICC执行POL1检查. 8.如果与POL1发生冲突，ISD-R会中止程序并通知SMSR. 如果没有冲突，则ISD-R会擦除目标profile和相关的ISD-P. ISD-R向SM-SR报告ISD-P删除的状态. SM-SR适当更新EIS. SM-SR向请求MNO报告ISD-P删除的状态. 结束条件：目标profile从eUICC中删除. SM-SR中的EIS是最新的. 3.5.10通过SM-DP删除ISD-Pprofile可以由其MNO删除. ISD-P删除将通过SM-DP请求.在这种情况下，MNO不必链接到所有SM-SR，并依靠SM-DP进行连接. 开始条件：MNO决定永久删除eUICC上的profile. 程序： MNO向SM-DP发送ISD-P删除请求.该请求包括目标profile的目标EID和ICCID（或其他唯一标识符）. MNO也可以提供SRID. 如果SM-SR和SM-DP尚未通过身份验证，则彼此进行身份验证. 如果SRID未由MNO提供，则SM-DP识别相关的SM-SR.该请求被传递给专用SM-SR. SM-SR检查目标profile的POL2. 如果与POL2发生冲突，SM-SR将中止该过程并相应地通知MNO 如果启用了目标profile，SM-SR将启动profile禁用过程. SM-SR和eUICC使用ISD-R中的密钥集，如果尚未认证，则相互验证. SM-SR向eUICC上的ISD-R发送ISD-P删除请求.该请求包括目标profile的ISD-P AID. eUICC执行POL1检查. 如果与POL1发生冲突，ISD-R会中止程序并通知SMSR. 如果不存在冲突，则ISD-R将删除目标profile和相关的ISD-P. ISD-R向SM-SR报告ISD-P删除的状态. SM-SR适当更新EIS. SM-SR向请求的SM-DP报告ISD-P删除的状态. SM-DP向请求MNO报告ISD-P删除的状态.结束条件：目标profile从eUICC中删除. SM-SR中的EIS是最新的. 3.5.11 SM-SR更改此程序假定在执行过程之前，相关eUICC上具有已安装profile的MNO可能会请求通知当前SM-SR（SM-SR1）所做的更改并被允许采取行动，因为它涉及到他们的个人资料的理想处置（例如，什么也不做，更新政策规则，删除个人资料）.在必须改变SM-SR的情况下，各个eUICC的证书必须保密. 开始条件：a. eUICC的EID已知b. SM-SR1和SM-SR2的SRID是已知的.C. ISD-R使用SM-SR1的钥匙进行个性化设置.d. SM-SR的变化是允许的. 过程： 发起者向SM-SR2发送请求以更改SM-SR. SM-SR2确认它可以接管这个角色. 发起方或代理发起方的SM-SR2请求从SM-SR1进行更改. SM-SR1将指定EID的EIS数据集发送到SM-SR2. 通过SM-SR1提供的安全通道，在SM-SR2和ISD-R之间建立新的共享密钥集.关键的建立程序在附件D.2中描述. 现在SM-SR2可以直接寻址ISD-R，SM-SR2请求eUICC删除与SM-SR1相关的密钥集. SM-SR2向SM-SR1和发起者发送变更确认. SM-SR1删除与eUICC相关的EIS数据集. SM-SR1向e-ICC相关的EIS数据集的删除结果发送通知给SM-SR2. SM-SR2直接或通过SM-DP向eUICC上的profile的MNO所有者发送通知，通知SM-SR的更改. 结束条件：a. ISD-R使用目标SM-SR（SM-SR2）的密钥进行个性化设置.b.eUICC在目标SM-SR（SM-SR2）中注册.C. EIS和EID驻留在目标SM-SR（SM-SR2）中.d. SM-SR1不再与eUICC相关.即profile的MNO所有者知道这一变化. 3.5.12 ISD-P密钥建立程序本程序在本文件的第4.5节中定义. 3.5.13回退机制在机器到机器设备检测到网络连接丢失的情况下，需要切换到具有回退属性集的profile.在这种情况下，eUICC禁用当前启用的profile（profileA）并启用具有回退属性的profile集（profileB）.出于安全原因，如果profileA的POL1规则设置为“禁用不允许”，则eUICC只能切换回profileA，直到profileA的POL1发生更改或使用主删除功能删除profileA.在这种情况下，profileA不能使用正常的删除命令删除. 开始条件：a.机器设备向eUICC报告网络丢失.b.如果机器向机器设备报告某些网络连接问题，则eUICC配置为执行回退机制.C.具有回退属性集的profile不是当前启用的profile. 过程： eUICC禁用当前已启用的profile（必要时取消POL1）并启用具有回退属性的profile集. eUICC将已启用profile更改为SM-SR. SM-SR更新EIS. SM-SR将变更报告给profile的所有者.结束条件：eUICC已启用具有回退属性集的profile，并且SM-SR的EIS是最新的. 3.5.14 eUICC证书验证此程序定义MNO如何验证eUICC是否通过认证，特别是如果eUICC是根据本规范设计的. 程序： 代表MNO的MNO或SM-DP应能够从以下位置获取eUICC证书：a.存储在eUICC注册的SM-SR中的EIS或b. EUM（注意：该界面超出了本文的范围）. MNO从eUICC证书中提取EUM信息（例如：证书，SAS认证等）. （注：目前eUICC的SAS认证计划供将来研究使用）. 利用步骤2中检索到的信息，MNO向SM-SR，EUM或GSMA请求EUM证书. （注意：EUM和GSMA的接口超出了本文的范围）. MNO验证EUM证书的有效性和签名. MNO验证eUICC证书的EUM签名. 结束条件：MNU检查了eUICC证书和EUM证书. 3.6策略控制3.6.1规则管理系统概述图下图表示策略规则管理系统： 3.6.2策略规则管理策略控制与profile相关，它是这是MNO要求的，并且是通过使用MNO制定的规则来实现的.此策略控制受单个MNO策略的控制（或管辖权）控制.本政策可能包含执行不同实体的子政策.有两种规则：•POL1 - 这些规则驻留在profile中，并由eUICC执行.•POL2 - 这些规则将存储在SM-SR中并由其执行. MNO将POL2直接发送到SM-SR或通过SM-DP作为元数据附加到profile. POL1和POL2是在不同地点/实体执行的共同MNO政策的代表. POL1和POL2的组合代表适用于profile的MNO和客户之间的合同.在本节中，所有命令都被视为更新;在第一次建立规则时被认为是更新的特例. 3.6.2.1 SM-SR策略规则管理引擎SM-SR的策略规则管理引擎在图中标识为“任务1”.任务1接受以下命令：1）根据MNO请求更新POL22）通过SM-DP按照MNO请求更新POL2任务1根据从SM-DP提供的profile设置POL2.任务1在安装相关profile后立即执行POL2规则.此外，任务1相应地更新相关的EIS.管理eUICC时，SM-SR负责执行POL2规则. 3.6.2.2 SM-DP策略规则管理引擎SM-DP的策略规则管理引擎在图中标识为“任务2”和“任务4”.任务2接受以下命令：1）根据MNO请求设置POL1并将其嵌入到profile中.任务4接受来自MNO的以下命令1）“更新POL2”，并且1）根据MNO请求设置POL1并将其嵌入到profile中.任务4接受来自MNO的以下命令1）“更新POL2”，并将其传递给SM-SR以更新EIS.2）从MNO设置POL2并将其作为元数据附加到profile以传输到SM-SR. 3.6.2.3 eUICC策略规则管理引擎eUICC的策略规则管理引擎在图中标识为“任务3”.任务3可以读取驻留在已安装profile中的POL1规则.此外，它在安装相关profile后立即执行POL1规则（请参阅第3.2.2节中的Platform Service Manager角色）.任务3接受以下命令：1）根据MNO请求读取/更新POL1（命令由MNO各自的OTA系统发送）. 3.6.2.4 OTA策略规则更新机制对于任务5，使用MNO OTA平台.在这种情况下，它接受来自MNO规则制作者的POL1更新命令，并向eUICC发布POL1更新. 3.6.3策略控制机制eUICC内的策略控制机制包括：•在MNO权限下存储在ISD-P内的策略规则;•策略规则执行者，这是执行策略执行功能的过程，驻留在平台服务管理器中.请参见第3.2.2节中的图 3.6.3.1策略规则在profile的不同状态更改时检查策略规则.它们可能会影响与规则关联的profile的状态以及其他profile的状态.根据规则的性质，策略执行可以在eUICC和/或SM-SR级别进行.只有profile所有者的MNO才能修改策略规则.在eUICC级别，规则是Profile软件包的一部分，并且由eUICC操作系统通过与Platform Service Manager的交互执行.移动网络运营商可以使用他自己的OTA平台更新他的个人资料中的政策规则.更新只能在profile处于启用状态时完成.本文档中定义的强制执行关于远程供应嵌入式SIM卡的合同条款的策略执行机制受制于适用的竞争和监管法律.以下原则适用于合同条款的执行：•参与运营商不得滥用策略实施机制来阻止或阻碍合法安装，启用，禁用和删除嵌入式SIM上的profile.•参与运营商可以执行政策规定，只要这些行为符合适用的竞争和监管法律.定义了以下策略规则：注意：这假定SM-SR通过了MNMA的GSMA认证和信任. POL1和POL2的设置可能不一样. POL1和POL2由不同的实体执行（eUICC为POL1; SM-SR为POL2），并将独立实施. POL1和POL2规则的显式设置是MNO的选择（例如，将POL1规则设置为空）. 3.6.3.2 eUICC策略规则强制实施器功能策略强制实施器能够读取和执行eUICC上存在的所有POL1. eUICC可以推翻POL1的唯一情况就是减速机制. 3.6.3.3 SM-SR策略规则强制实施器功能SM-SR策略强制实施器能够读取和执行目标eUICC的EIS中包含的策略规则.]]></content>
      <tags>
        <tag>GSMA</tag>
        <tag>SGP01</tag>
        <tag>eSIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GSMA SGP.01 第1/2章学习]]></title>
    <url>%2F2018%2F05%2F12%2FGSMA-SGP-01-%E7%AC%AC1-2%E7%AB%A0%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1简介1.1概述许多机器对机器设备将不易于达到供应订购的目的。这将需要一个新的解决方案来适应这种特殊情况。要求是在假定采用与今天相同或相似的认证协议的情况下，为具有获得移动网络访问所必需的凭证的“无线”远程配置机器对机器设备定义机制。 MNO必须能够响应请求，将订阅（合同）从一个MNO A更改为不同的MNO B，而无需物理访问相关设备中的嵌入式UICC。本文档描述了一种体系结构，该体系结构在实施时将启用远程供应和订阅管理，同时至少为网络运营商和客户保持与现有解决方案相同的安全级别。这包括MNO网络访问凭证的安全保存，例如加密功能的密钥，以及IMSI和其他客户身份标识符等标识符的使用。 1.2问题范围本文件涉及：•GSMA“嵌入式SIM任务组要求和用例”版本1.0 [1]中描述的机器对机器用例。该解决方案不适用于传统的消费电信设备，因为它们不关心上述问题陈述。•嵌入式UICC远程供应系统的体系结构，即其组件和相关接口。 GSMA的嵌入式UICC生态系统文件[2]以及第2节中所述的原则和假设将支持其定义。•嵌入式UICC的远程供应系统的安全性。•网络基础设施中的SM-SR和SM-DP集成选项。•嵌入式UICC架构及其外部接口的必要方面，以确保在交付ETSI标准之前与GSMA架构兼容。•在适当的地方标准化嵌入式UICC远程供应架构。 1.3文档目的本文档的目的是定义一个通用的全局体系结构框架，以实现机器设备中嵌入式UICC（eUICC）的远程供应和管理，这些设备不易到达。采用通用架构框架将为确保潜在的不同MNO部署方案之间的全球互用性提供基础，同时利用标准化的eUICC平台。本文档确定了各个角色和潜在的角色以及架构中每个角色之间的界面。 1.4目标读者在MNO，SIM解决方案提供商，机器对机器设备供应商，标准组织，网络基础设施供应商，服务提供商和其他行业机构内部工作的技术专家。 1.5术语定义1.6缩略语1.7参考资料2基本原理和假设本节包含与嵌入式UICC GSMA远程供应系统相关的原理和假设。 2.1基本原则BPR1解决方案应反映UICC相关最重要的使用案例，并在eUICC硬件不容易从机器到机器设备进行访问或移除的情况下给予充分支持。由于eUICC的性质不同，可能会涵盖并非所有的当前使用案例。BPR2解决方案的设计应能够提供新的商业机会，例如在M2M领域，同时保持现有UICC的成熟效益。BPR3 eUICC及其整体管理流程的安全必须在任何时候，在任何情况下都至少与目前可拆卸的UICC及其供应流程一样好。BPR4 eUICC上可以使用当前UICC上的任何功能，特性或服务。BPR5 eUICC对功能，特性或业务的访问应与当前UICC相同，即对终端和用户透明。BPR6对eUICC的功能，特性或服务的远程管理应对运营商现有的系统和基础设施产生最小的影响。这应通过尽可能使用现有的标准和规范来实现。BPR7保持简单。复杂性被理解为一个风险因素。合理有限的功能方法将支持产品上市时间的预期，并可能随着未来的需求和改进而发展。BPR8第三方应用程序在操作profile之外不属于本文档的范围。BPR9各实体应对其运营负责。BPR10禁用的操作profile中的应用程序和文件系统既不是本地的，也不是远程可选的。 2.2一般假设2.2.1现有标准的使用STD1 eUICC和相关供应系统的定义应当尽可能有效地体现所有相关方的努力和成本。这应通过尽可能使用现有的标准和规范来实现。STD2全球平台规范将被视为实施eUICC的首选框架。 2.2.2机器对机器设备的影响DEV1 eUICC生态系统的实施对设备的影响很小。DEV2没有安全认证要求将被放置在设备上。DEV3没有新的认证要求放置在设备上。DEV4任何设备批准的影响应包括在现有的设备型号认证或认证方案下，并且独立于eUICC的认证。DEV5设备内的通信模块应符合ETSI TS 102 221 [102221]内针对所有标准ETSI格式要素的终端要求。DEV6设备制造商应确保设备或服务提供商的所有者有权访问eUICC标识（EID）。DEV7设备制造商应该在设备上打印eUICC标识（EID），以便人类可读。 2.2.3安全性SEC1 eUICC的总体安全性与相关管理过程必须始终在任何情况下至少与当前的可拆卸UICC及其供应过程相当。SEC2 eUICC及其远程供应系统的体系结构符合3GPP TS 21.133 [21133]“3G安全，安全威胁和要求”的要求。SEC3体系结构必须支持与保护操作员证书有关的安全级别，该级别至少等于当前的安全级别。这尤其适用于：•密钥和认证参数的机密性。•订户身份的完整性（例如IMSI）。SEC4 对于eUICC，认证将成为强制性的，因为包含运营商证书的实体可能不再处于MNO的设计控制之下。SEC5远程供应架构必须避免损害客户数据的安全性。SEC6可信系统是一个依赖于特定范围的系统来执行指定的安全策略。信任模型被定义为安全相关项目可交付成果的一部分。SEC7对于平台和profile管理，涉及管理的所有实体都必须经过相互认证。 2.2.4 RegulatoryREG1监管问题被认为不在嵌入式SIM快速通道工作组的范围之内。监管问题将提交给GSMA监管团队。 2.3 eUICC生态系统ECO1订阅管理功能由两个角色 - SM-DP和SM-SR提供。ECO21.profile管理由MNOprofile和SM-SR中包含的策略规则管理。2.政策规则由eUICC和SM-SR代表MNO执行。3.政策规则的控制在于MNO。 2.3.1角色和实体2.3.1.1 eUICC制造商MAN11.eUICC的制造商提供包含profile和/或一个或多个操作profile的eUICC。2.eUICC交付给机器以加工设备制造商。3.相关平台管理证书被转发到SM-SR以与每个eUICC相关联。4.eUICC制造商负责eUICC的初始密码配置和安全架构。5.eUICC制造商的产品和流程的相关部分通过了GSMA认可的认证流程。MAN2 EUM应颁发eUICC证书以允许：•eUICC对其他实体的认证和认证;•在SM-DP和eUICC之间建立认证的密钥集;•在SM-SR和eUICC之间建立认证的密钥集。MAN3 EUM证书和根证书应使用可靠的存储和通信渠道交付给其他实体。MAN4 EUM应向SM-DP提供服务，工具，脚本或文档，以便为EUM生成的eUICC创建非个性化的profile。代表SM-DP创建非个性化profile不是EUM的作用。 2.3.1.2机器到机器设备制造商DMA11.设备制造商构建机器到机器包含通信模块和eUICC的设备。2.预配置profile和/或操作profile可以默认启用。注意：任何启用的profile都需要各自的MNO的同意。 2.3.1.3移动网络运营商（MNO）MNO11.MNO提供移动网络连接。2.MNO选择至少一个SM-DP。3.MNO应具有到SM-SR的直接接口。4.如果客户选择了移动网络运营商，则该移动网络运营商将根据当前的“策略规则”向特定的目标eUICC发起特定profile的下载。 5.移动运营商指定profile特征以及任何特征和应用，类似于当前的UICC。 MNO拥有该profile。6.profile可以在订购下载时生成。7.为了实现与现有UICC流程和接口的透明配合，profile也可以批量订购，然后安全存储在SM-DP中，直到订购下载为止。 SAS要求适用。8.当启用此profile时，MNO定义了控制profile管理的策略规则。9.命令下载后，MNO应能够在下载profile之前检查并验证目标eUICC的认证和功能（制造商，内存大小，算法等）。10.移动网络运营商将收到成功完成的下载和安装profile的确认。11.启用的MNO应能够使用OTA平台来管理eUICC中启用的profile的内容。MNO2应客户的请求，移动网络运营商应能向相关实体申报将设备加密机器被盗的机器，以便采取适当措施。MNO3移动网络运营商应该只使用profile向设备提供有限的服务; MNO用来执行这项有限服务的机制超出了这种架构的范围。 2.3.1.4 MNO客户CUS11.MNO客户是MNO订阅的实际合约伙伴。他可能与最终用户不一样。2.MNO客户使用一台机器加工来自设备制造商的装备有eUICC的设备和来自所选MNO的profile（订购）。3.在下载profile之前，MNO客户必须提供其隐含或明确的接受。4.MNO客户直接或间接识别机器以加工设备。机器识别机器设备应隐式或明确识别eUICC。 2.3.1.5最终用户END11.最终用户使用本机器加工设备以及与启用profile相关的服务。 2.最终用户可以与MNO客户相同。3.eUICC对最终用户是透明的。 4.最终用户与MNO客户或MNO直接相关。 2.3.1.6订购管理器 - 数据准备（SM-DP）SMDP11.SM-DP代表MNO行事。2.SM-DP从MNO接收profile描述并相应地创建非个人化profile。 SM-DP可能不得不利用EUM提供的工具来创建非个性化profile。 SM-DP和EUM之间交换的信息不是标准化的，可能因不同实体而有所不同。3.SM-DP基于来自MNO的输入数据为目标eUICC生成个性化数据（例如，网络访问证书和其他数据）。4.SM-DP为目标eUICC构建个性化profile。5.SM-DP应使用目标eUICC的Profile Installer证书保护Profile软件包。6.SM-DP通过SM-SR在eUICC上安装Personalized Profile。 SMDP2在MNO的请求下，SM-DP还启动profile启用，以及通过SM-SR向eUICC发送profile删除请求。SMDP3 SM-DP为eUICC建立一个安全和认证的通道，以下载和安装profile到eUICC。SMDP4 SM-DP和SM-SR之间的接口应具有适当的安全级别，以便支持向SM-SR安全传送profile。SMDP5 SM-DP必须始终接收来自MNO的通过SMSR发送profile到eUICC的请求。SMDP6 SM-DP至少应通过GSMA SAS认证。SMDP7鉴于任何eUICC，SM-DP应能够为此eUICC生成个性化profile。SMDP8 SM-DP和MNO是唯一允许为eUICC建立安全和认证通道来管理profile的实体。SMDP9 MNO应能够与MNO选择服务任何MNO批准的eUICC的SM-DP接口。SMDP10 SM-DP应能够生成可下载并安装在MNO所针对的eUICC上的个性化profile。SMDP11 SM-DP应支持本文档第3.5.3节中描述的profile订购程序。 2.3.1.7订购管理器 - 安全路由（SM-SR）SMSR1 SM-SR是唯一允许为eUICC建立安全和认证传输信道以管理eUICC平台的实体。SMSR2 SM-SR根据MNO的策略规则加载，启用，禁用和删除eUICC上的profile。SMSR3 SM-SR从eUICC制造商或以前的SM-SR获取eUICC的平台管理凭证。SMSR4在任何时间点，只有一个SM-SR可以与eUICC相关联，但可以在eUICC的生命周期中更改。SMSR5 SM-SR和eUICC之间的接口应具有适当的安全级别，以支持eUICC中的profile的安全传送和管理。SMSR61.SM-SR不得以明文形式处理操作员证书。2.SM-SR具有到SM-DP，eUICC和MNO的安全通信通道。3.SM-SR至少应通过GSMA SAS认证。 SMSR7 SM-SR应能够确定eUICC是否可用于远程管理。SMSR8 SM-SR对于生态系统内的其他实体不应具有歧视性。 2.3.1.8证书颁发者CIS1证书颁发者角色为嵌入式UICC远程供应系统实体颁发证书，并充当可信第三方，用于对系统实体进行身份验证。CIS2证书颁发者为EUM，SM-SR，SM-DP和MNO提供证书。CIS3证书颁发者通过超出本规范范围的接口与MNO，SM-SR，SM-DP和EUM进行通信。 2.3.1.9发起者INT1发起者是一个可以由各种实体承担的虚拟角色。发起人负责启动特定程序。INT2为了本文件中定义的程序的目的，发起者可以假定为MNO。INT3在任何时候，只有一个实体可以承担发起者角色。INT4发起方和SM-SR之间的接口基于本文档中定义的接口。INT5发起者应由SM-SR授权和认证。 2.4 eUICCEUICC1 eUICC是标准化ETSI规格中的分立硬件组件。EUICC2通常，eUICC是不可移动的。EUICC3从机器到机器设备的角度来看，eUICC的行为通常与UICC相同。EUICC4 1. eUICC可以包含一个或多个profile。 2.在任何时间点只能启用一个profile。 3. eUICC应包含一个具有回退属性集的profile。只有一个profile可以设置“回退属性”。 4.具有回退属性集的profile不能删除。 5.回退属性的设置由SM-SR管理。 6.适用所有相关的UICC规范。EUICC5 eUICC中的（U）SIM或ISIM在profile中的行为预计与当前（U）SIM或ISIM相同。预期不会更改现有的3GPP（U）SIM和ISIM规范。EUICC6 eUICC将实施Milenage网络认证算法。EUICC7当TUAK包含在3GPP规范中时，eUICC应该在Milenage之外实施TUAK算法。EUICC8物理eUICC的所有权可能会在其整个生命周期内发生变化。EUICC9 eUICC应包含其相关SM-SR的身份并具有对其进行鉴定的手段。 eUICC制造商交付的EUICC10 eUICC应始终注册到SMSR。EUICC11如果profile启用，profile禁用和profile下载和安装等任何命令未成功完成，则eUICC应在收到请求之前保持其所处的状态。 2.4.1简介PRO 1简介是发行MNO的财产。PRO 2profile应有唯一标识。PRO 3 1.在任何时间点只能启用一个profile。 2.嵌入式UICC上可能存在其他profile，但启用/禁用profile始终只是由代表运营商的SM-SR执行的操作。 3.应根据政策规定采取行动。PRO 4 1.简介由发行MNO控制。 2.profile与eUICC一起承载UICC的所有逻辑特性。所有相关的UICC规范应适用于eUICC规范定义的例外。PRO 5每个profile应在其专用安全容器内隔离。应考虑GlobalPlatform的安全域框架。PRO 6profile可用于配置（profile）或操作（操作profile）。他们显然是有区别的。 1.操作profile可以用作配置profile。 2.profile不能用作操作profile。PRO 7总是会有一个profile。PRO 8可能有几个操作profile。PRO 9已安装的profile可以具有以下状态之一：•已启用•已禁用PRO 10在所有操作使用中，eUICC应强制在任何时间点启用该profile并且只有一个profile已启用。PRO 11将有一个由eUICC启动的使用回退属性集启用profile的功能。具有回退属性集的profile将因此提供网络连接，以允许SM-SR远程管理eUICC。PRO 12机器不会对机器进行本地profile管理。PRO 13 Aprofile包含认证算法的参数（例如Milenage算法的OPc，ri，ci），但不包括算法本身。 PRO 14 eUICC可支持其他网络认证算法;如果支持这样的算法，eUICC应实现一种机制来配置其参数。注意：这些其他网络身份验证算法对profile的可访问性超出了本文的范围。 PRO 15 Aprofile包含策略规则的子集以控制外部profile管理操作。 PRO 16 Aprofile可能包含生态系统中实体的标识符，密钥，PIN，证书，算法参数以及第一和第二级应用程序。 （参考：ETSI TS 102 221 [102221]）PRO 17在当前UICC上可能的任何功能，特性或服务应该可以在eUICC上的操作profile中实现。PRO 18在eUICC上对profile中功能，特性或服务的访问应与当前的UICC相同，即对终端和用户透明。PRO 19在eUICC上对profile中的功能，特性或服务进行远程管理应该对运营商现有的系统和基础设施产生最小的影响。PRO 20profile仅存储在SM-DP中并安装在eUICC上;它们不存储在其他地方并且在传输中加密。 2.4.2策略和策略控制PPC1每个profile都有相关的策略。政策包含管理profile操作状态更改的规则。这些状态转换是：•禁用•启用•删除PPC2更新 - 对profile策略的访问仅限于发放MNO。PPC3禁用profile的策略规则只能应用于自身。禁用的profile的策略规则不能影响任何其他profile。]]></content>
      <tags>
        <tag>GSMA</tag>
        <tag>SGP01</tag>
        <tag>eSIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GSMA SGP.21 第1/2/3章学习]]></title>
    <url>%2F2018%2F05%2F12%2FGSMA-SGP-21-%E7%AC%AC1-2-3%E7%AB%A0%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1简介1.1概述本文档提供了一种体系结构方法，作为所有市场中设备的远程SIM配置的建议解决方案。体系结构的主要目标是为设备的远程SIM配置提供必要的凭据以获取移动网络访问权限。该版本专注于消费类市场的设备。请注意，SGP.21 V1.0 [23]尚未弃用。 1.2范围本文档的目的是定义一个通用架构框架，以实现设备中的嵌入式UICC（eUICC）的远程SIM卡配置和管理。此架构框架的采用旨在为确保运营商之间在不同部署方案中进行远程SIM配置的全球互操作性提供基础。 1.3目标读者在运营商，SIM解决方案提供商，设备供应商，标准组织，网络基础设施供应商，服务提供商和其他行业机构内部工作的技术专家。 1.4术语定义1.5缩略语1.6参考文献1.7惯例关键词“必须”，“不得”，“要求”，“应该”，“不应该”，“应该”，“不应该”，“推荐”，“可能“和”可选“在RFC2119 [6]中进行了解释。 “FFS”或“进一步研究”意味着它将包含在SGP.22 V2.1中。 2原则本节包含与嵌入式UICC的GSMA远程SIM配置系统相关的原则。基于本文档中描述的要求的解决方案必须以非歧视的方式提供。 2.1基本原则BAS1现有标准和规范应尽可能用于eUICC和相关供应系统的规范。BAS2 GlobalPlatform规范应作为实施eUICC的首选框架。BAS3 eUICC的总体安全性与相关的管理流程一起，在任何情况下都应至少与当前可拆卸的UICC及其供应流程相同。BAS4 eUICC及其远程SIM供应系统的体系结构应符合3GPP TS 21.133 [7]的要求。BAS5体系结构应该支持操作员证书保护水平，这至少与当前的安全水平相当。这特别适用于：密钥和认证参数的机密性; 订户身份（例如IMSI）的完整性。BAS6体系结构应支持所有Profile内容的安全级别，这至少与UICC当前的安全级别相同。BAS7架构不应损害用户数据的安全性和隐私，也不会损害最终用户数据的安全和隐私。取决于地域的示例包括可用于跟踪的身份，例如ICCID，MSISDN，EID，IMSI Ki等。BAS8监管问题被认为超出了本文的范围。但是，任何可用于识别个人身份的数据均应视为个人数据并受当地法规的约束。 EID，ICCID等。 2.2 Profile原则PRO1 Profile是发行运营商的财产并受其控制。PRO2 Profile不存在于eUICC之外。即 Profile始终位于特定的eUICC上。PRO3个人资料应由其ICCID唯一标识。PRO4启用 Profile与eUICC组合应能够承载UICC的所有逻辑特性。PRO5启用 Profile后，将应用ETSI 102 221 [2]规范中所述的所有相关UICC特性或功能，但本规范中定义的例外情况除外。PRO6除了eUICC存储器复位和eUICC测试存储器复位功能之外，只能在禁用状态下删除 Profile。PRO7 Profile Management应受政策约束。PRO8 Profile应该是操作 Profile， Profile或测试 Profile。 3角色3.1 eUICC制造商EUM1 eUICC制造商负责eUICC的初始密码配置和安全架构。EUM2 eUICC由eUICC制造商（EUM）提供。EUM3 eUICC制造商的产品和流程的相关部分通过了GSMA批准的认证流程。EUM4 EUM颁发eUICC证书以允许：eUICC认证和其他实体的认证证明; 在SM-DP +和eUICC之间建立认证的密钥集。EUM5 eUICC制造商负责实施驻留在eUICC中的任何LPA元素，并遵守LPA与第4.10.3节中的要求。 3.2设备制造商DM1设备制造商负责实施驻留在设备上的任何LPA元素以及LPA符合第4.10.2节的要求。DM2设备制造商负责实施驻留在主设备上的任何应用程序，以允许本地用户界面访问配套设备。 3.3运营商和服务提供商本节描述与该架构及其运营相关的运营商和服务提供商角色的特征。其他特征存在但被认为超出范围。OPE1操作员可通过ES2 +接口访问SM-DP +。 OPE2如果订户选择了服务提供商，该服务提供商将启动 Profile包的配置。OPE3运营商（可能代表服务提供商）规定了 Profile特征以及类似于可移动UICC的任何特征和应用。OPE4操作员能够使用OTA平台来管理eUICC（RAM，RFM）中已启用 Profile的内容。 3.5证书颁发者CIS1证书颁发者为远程SIM资源调配实体颁发证书，并作为可信第三方来验证系统的实体。 CIS2证书颁发者通过超出本规范范围的接口与SM-DP +，SM-DS和EUM进行通信。]]></content>
      <tags>
        <tag>GSMA</tag>
        <tag>eSIM</tag>
        <tag>SGP21</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GSMA SGP.21 附录B 学习]]></title>
    <url>%2F2018%2F05%2F12%2FGSMA-SGP-21-%E9%99%84%E5%BD%95B-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[附录Bprofile生产程序（资料性附录） B.1profile生产过程本节描述了一个通用实施.它应该被视为一个例子而已;可能需要特定的实施来解决特定的安全问题.在eUICC中，UICC的当前功能由一个profile表示.与当前的UICC一样，profile是运营商的责任，profile制作是根据他们的请求和许可（如果不是由运营商自己制作）执行的.应用与当前UICC相同的操作员程序. Snipaste_2018-05-12_16-06-49.png profile生成由三个步骤组成：profile描述定义：SM-DP +基于操作profile描述创建并注册profile描述.操作员证书生成：操作员要求SM-DP +生成将在下一步中使用的操作员证书.此过程是可选的，如果操作员想要在生成受保护的profile包期间生成操作员证书，则不会使用该过程. 受保护的profile包生成：profile包将被创建，保护和存储.此步骤（批次类型的操作或实时过程）仅在相应操作员下单后执行. 合同结论和链接profile：在合同结束时，将激活码发送给最终用户，并可为该合同分配profile.注意：绑定profile包的生成是profile下载的一部分，使用第5.2.2节中的激活码过程. B.1.1profile描述定义profile描述定义可以包含以下序列：Snipaste_2018-05-12_16-07-52.png 开始条件：a.运营商与SM-DP +之间的契约关系. 步骤：1.运营商定义其不同的profile类型（由[非标准化]profile描述ID标识），其中包含网络访问应用程序，如USIM，文件结构，数据和应用程序等. SM-DP +创建profile描述基于操作员输入和相应的profile描述ID. SM-DP +确认profile描述定义，例如通过发送相应的profile描述ID.注意：操作员可以使用SM-DP + 结束条件定义多个profile描述：a.操作员可以根据profile描述ID来订购受保护的profile包. B.1.2生成操作员证书此过程允许操作员在SM-DP +上分配一组操作员证书，而不将它们关联到特定的ProfileDescriptionID.操作员证书生成可以包含以下序列：Snipaste_2018-05-12_16-08-02.png 开始条件：a.运营商已经分配了IMSI，ICCID和其他资源. 步骤：3.运营商提供IMSI，ICCID，要创建的证书类型（例如Milenage [11]、[12]，TUAK [10]等）以及可能已分配给SM-DP +的其他资源.它要求SM-DP +安全地生成并存储一组操作员证书. SM-DP +根据运营商的输入以及相应的IMSI，ICCID和其他资源安全地生成并存储一组运营商凭证. SM-DP +确认操作员证书的生成并将其提供给操作员. B.1.3受保护的profile包生成受保护的profile包生成可以包含以下序列：此过程可以应用于profile描述定义，合同结论和链接profile之间，具体取决于受保护的profile包是按需创建还是准备好提前.Snipaste_2018-05-12_16-08-12.png 开始条件：a.profile描述定义 过程：1.操作员通过向SM-DP +提供profile描述ID和一些相应的操作员输入数据（证书，例如ICCID，IMSI）来生成受保护的profile包生成.操作员输入保护profile包生成所需的数据（由IMSI，ICCID，K / Ki，OTA密钥，PIN，PUK等）由操作员创建（并提供给SM-DP +）或由SM-DP +（并提供给操作员）. SM-DP +创建profile包. SM-DP +创建受保护的profile包. SM-DP +存储受保护的profile包（安全地）. SM-DP +确认受保护的profile包生成，并最终发送由SM-DP +创建的附加操作员输入数据.6.运营商在运营商系统（如HLR / AuC和BSS）中注册运营商数据. 结束条件：a.订购的受保护的profile包可在SM-DP +上找到.运营商能够激活这些订阅，并且可以在绑定到EID时触发profile下载. B.1.4合同结论和链接profile激活码必须提供给最终用户才能实现profile下载过程.合同结论和链接profile过程描述了将合同与激活码流程链接在一起的不同场景. 以下选项描述如下：具有已知EID的激活码：EID由订户在合同签订期间给予运营商.具有未知EID的激活码：订户在合同签订期间未向EID提供EID. EID只在profile下载过程中提供给SM-DP +，并从SM-DP +返回给运营商. 提供给运营商的EID激活码：订户在合同结束时不立即给出EID，但在步骤2中向运营商提供. 合同参考可以是但不一定是任何激活码参数（例如令牌），ICCID或IMSI.在任何情况下，SM-DP +都应能够在profile下载过程中分配和链接profile到相应的eUICC. B.1.4.1 具有已知EID的激活码Snipaste_2018-05-12_16-15-52.png 程序：图31中的步骤1-11：已知EID的合同结论1.订户与运营商签订合同，并在此过程中提供EID.2.至5.或者’在profile下载程序之前由运营商分配ICCID：运营商分配profile并将EID，IMSI和ICCID发送到SM-DP +. SM-DP +链接不同的参数并将其确认给操作员.6.至10.或者’在profile下载程序之前通过SM-DP +进行ICCID分配’：操作员将EID，IMSI和profile描述ID发送到SM-DP +. SM-DP +将ICCID分配给相应的profile，链接不同的参数并确认分配的ICCID和与运营商的链接. 11.运营商向订户确认合同结论以及相应的信息（合同参考）. 结束条件：a.认购人已与运营商签订合同和有效认购.b.通知SM-DP +未来的profile下载过程请求. B.1.4.2具有未知EID的激活码Snipaste_2018-05-12_16-16-06.png 过程：图32中的步骤1-6：没有EID的合同结论1.订户与运营商签订合同，但不知道目标eUICC（EID）.2.或者’运营商分配ICCID’：运营商分配profile（ICCID）3至5.或者’通过SM-DP +分配ICCID’：运营商将profile模板（ID）发送至SM-DP +. SM-DP +分配相应的profile（ICCID）并将分配的ICCID发送给运营商.6.运营商向订户确认合同结论以及相应信息（合同参考）. 结束条件：a.认购人已与运营商签订合同和有效认购. B.1.4.3 EID提供给操作员的激活码Snipaste_2018-05-12_16-16-17.png 步骤：图33中的步骤1-11：向运营商提供EID的激活码1.在不知道目标eUICC（EID）的情况下，用户与运营商签订合同.2.或者’运营商分配ICCID’：运营商分配profile（ICCID）3至5.或者’通过SM-DP +分配ICCID’：运营商将profile模板（ID）发送至SM-DP +. SM-DP +分配相应的profile（ICCID）并将分配的ICCID发送给运营商.6.运营商向订户确认合同结论以及相应信息（合同参考）.7.订户选择设备/ eUICC后，EID将与合同参考一起提供给运营商.8.至10.运营商请求SM-DP +链接eUICC（EID）和Profile（ICCID）. SM-DP +链接EID和ICCID并向运营商确认.11.运营商确认EID与相应的订户合同的链接. 结束条件：a.认购人已与运营商签订合同和有效认购.b.通知SM-DP +未来的profile下载过程请求.]]></content>
      <tags>
        <tag>GSMA</tag>
        <tag>eSIM</tag>
        <tag>SGP21</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GSMA SGP.21 附录A 学习]]></title>
    <url>%2F2018%2F05%2F12%2FGSMA-SGP-21-%E9%99%84%E5%BD%95A-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[附件A新安全威胁，风险和创建过程要求（资料性附录）新主设备上的新配置文件（关闭设备激活）INI1不完整或损坏的配置文件被推送到订阅服务器。INI2使用特权位置的恶意eUICC方为了将未经请求的配置文件推送到设备。 配置文件删除IND1由于长期存储已交付的配置文件而导致关键材料在禁用后长期收集。IND2丢弃的媒体支持中的敏感数据丢失（硬盘驱动器…）IND3恶意软件启动协调或单独删除一个或多个配置文件，导致与最终用户失去连接。IND4意外配置文件删除（例如无人照管的儿童…）导致与最终用户失去连接。IND5非技术专业人员或恶意订户反复删除配置文件并要求重新加载，导致配置服务器的附加费用。 配置文件切换INP1恶意配置文件切换源自内部方。INP2人为错误导致交替轮廓切换导致连接丢失。INP3恶意软件启动一个或多个配置文件的协调或隔离切换，导致连接丢失。INP4恶意软件启动一个或多个配置文件的协调或隔离切换，导致重大欺诈情况。 配置文件交换INS1争用条件导致停用所有配置文件并丧失连接。 加密相关风险INO1丢失或盗用一个或多个Profile Management组件中的私钥，导致整个链上的机密性丧失。INO2无法撤消已损坏的证书，导致整个证书链失去信任。INO3地方执法要求导致强制披露关键材料。INO4地方执法要求导致关键组件的有力妥协。INO5恶意或意外撤销证书，导致整个供应证书链上拒绝服务。INO6在配置文件创建，临时存储，传输或长期存储过程中使用临时对称密码或“通用”密钥材料，导致单点故障和攻击被创建。 服务质量QoS1配置文件创建突发导致eUICC平台无法提供预期的服务级别。QoS2交付平台上的拒绝服务导致无法提供预期的服务级别。QoS3无法从导致暂时或永久无法提供配置文件的管理通信故障中恢复。 非人为或不可预测的EXC1灾难性事件，如洪水，地震等，导致数据中心遭到破坏。EXC2导致数据中心遭到破坏的地缘政治/人类事件。EXC3更改法规导致供应交付链（操作员，OEM，SIM供应商…）的行为者部分或全部丧失信任。 用户旅程中的新配置文件EXN1使用无人照管的主设备或伴随设备恶意配对新设备。EXN2使用公共Wi-Fi进行互联网连接，导致在配置文件操作期间丧失机密性。EXN3使用公共Wi-Fi进行互联网连接，导致在配置文件操作期间篡改注册信息。EXN4社会工程导致向攻击者传播OTP材料。EXN5配置文件配置期间出现中间人或窃听导致机密性丢失的情况。EXN6“隐式认证”（例如，HTTP MSISDN加密）导致身份验证或配置文件材料丢失。 设备交换EXS1恶意用户使用争用情况导致配置文件在两台设备上被激活。EXS2使用弱交换程序的恶意实体为了破坏认证向量。 隐私权损失PRI1对EID或与用户有关的任何数据信息的处理，传输或披露不当，导致将后者用作“超级”用户跟踪标识符。PRI2 eUICC管理命令导致第三方使用意外和不可预测的“远程寻呼”或“远程控制”命令来间谍或危害设备或订户本身。 其他EXO1妥协配置文件管理角色之间的交换导致私钥严重丢失。EXO2由于特定场景的不可预测的实现例程导致的配置文件克隆。 创建过程无法创建CRE1配置文件应安全删除或至少清除认证向量。CRE2参与创建配置文件的系统之间的通信应受到完整性和机密性的保护。]]></content>
      <tags>
        <tag>GSMA</tag>
        <tag>eSIM</tag>
        <tag>SGP21</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GSMA SGP.21 第四章学习]]></title>
    <url>%2F2018%2F05%2F12%2FGSMA-SGP-21-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[第四章 远程SIM配置系统架构本节包含嵌入式UICC的Remote SIM Provisioning系统体系结构的功能描述。 4.1 eUICC架构4.1.1 eUICC架构概述本节介绍eUICC的内部高层架构。eUICC体系结构与GSMA远程SIM规范[8]中使用的相似。[SGP.02 GSMA Remote SIM Provisioning of Embedded UICC Technical specification]profile基于GlobalPlatform卡片规范[9]中定义的安全框架进行配置。[GPC_SPE_034 GlobalPlatform Card Specification with its Amendments] 4.1.1.1 ECASD嵌入式UICC控制权限安全域（ECASD）负责安全存储支持eUICC上所需安全域所需的凭证。在eUICC上只有一个ECASD。如[9]中所述，eUICC制造过程中ECASD应由EUM进行安装和个性化。 ECASD应具有以下属性： 用于创建签名的eUICC私钥。  用于eUICC认证的关联证书。  用于验证SM-DP +证书的证书颁发者（CI）根公钥。 eUICC制造商（EUM）密钥集，用于密钥/证书更新。此外，ECASD应提供在密钥建立和eUICC认证期间使用的安全功能。 4.1.1.2 ISD-RISD-R负责创建新的ISD-Ps和所有ISD-Ps的生命周期管理。 4.1.1.3 ISD-PISD-P是用于托管Profile的安全容器（安全域）。 ISD-P与Profile包解释器协作用于Profile下载和安装，以解码/解释接收到的绑定Profile包。 ISD-P是SM-DP +的卡上代表。 4.1.1.4 MNO-SDMNO-SD是运营商的卡上代表。它包含运营商的OverThe-Air（OTA）密钥并提供安全的OTA通道。 4.1.1.5 profile策略启动器提供profile策略规则验证和执行的eUICC操作系统（OS）服务。 4.1.1.6电信框架电信框架是一种操作系统服务，为ISD-Ps中托管的NAA提供标准化的网络认证算法。此外，它还提供了使用必要参数配置算法的功能。 4.1.1.7profile包解释器profile包解释器是一个eUICC操作系统服务，它使用目标eUICC的特定内部格式将profile包数据转换为已安装的profile。 4.1.1.8 LPA服务LPA服务提供对LPA功能所需的服务和数据的以下必要访问： 根SM-DS地址。 可选存储的默认SM-DP +地址。 促进接收从LPA转移的绑定profile包。 提供有关已安装profile及其profile元数据的信息。 提供本地profile管理。 为LPA提供功能，以对SM-DS进行身份验证和互动。 确保对EID的访问仅限于LPA。 4.2 eUICC需求EUICC1 eUICC应该是一个由硬件和软件组成的独立的防篡改组件，能够安全地托管应用程序以及机密和加密数据。 EUICC2可拆卸的eUICC采用标准ETSI规格[2]封装。 EUICC3 eUICC应该是可移动的或不可移动的。 EUICC4具有启用profile的eUICC的行为应与UICC相同。 EUICC5 eUICC应能够包含零个或多个profile。 EUICC6最多只能在任何时间点启用一个profile。 EUICC7在eUICC上，NAA USIM或ISIM中的行为应与可移动的UICC NAA USIM或ISIM相同。 注：预期不会更改现有的3GPP / 3GPP2 USIM，CSIM和ISIM规范。 EUICC8 eUICC应支持Milenage [11]/[12]和TUAK [10]算法集 EUICC9 eUICC的所有权可能随着设备的使用寿命而改变。 EUICC10如果任何Profile Management操作未成功完成，则eUICC应保持其收到请求之前的状态。 EUICC11 eUICC应包含在制造过程中安装和个性化的ECASD和ISD-R安全域。 EUICC12在eUICC生产之后，不可能删除或禁用ECASD。 EUICC13 ISD-R应负责创建新的ISD-Ps和所有ISD-Ps的生命周期管理。 EUICC14在[9]中描述的eUICC制造过程中，ISM-R应该由EUM进行安装和个性化。 EUICC15 eUICC应能够支持eUICC存储器复位。这只能由最终用户请求。 EUICC16如果eUICC支持测试profile，则eUICC应支持eUICC测试存储器复位。 EUICC17 eUICC应支持由SIMalliance [5]定义的eUICC Profile Package Interoperable格式。 EUICC18 ISD-R应该： 在制造时在eUICC内创建;  不被删除或禁用;  不能在ISD-P内执行任何操作。 EUICC19 eUICC可提供LPA功能。 EUICC20应SM-DP +的要求，ISD-R应由ISD-R创建。 EUICC21 eUICC和SM-DP +之间的通信应受到真实性，完整性和机密性的保护。 EUICC22 eUICC不应导出安装在eUICC上的profile。 EUICC23 eUICC应实施profile的隔离并防止profile在其执行环境之外运行，即profile应在沙箱中运行。 EUICC24在eUICC上安装时，应确保绑定profile包的完整性。 EUICC26profile密钥和算法参数不能从eUICC中提取。 EUICC27所有加密功能应以强大的防篡改方式实施，并能抵抗边信道攻击。 EUICC28运营商应能够以安全和保密的方式更新eUICC在其profile中的OTA密钥，重用现有的OTA平台机制。 EUICC29下载的profile包应安装在eUICC处于禁用状态。 EUICC30 eUICC应始终在SM-DP +或SM-DS每次会话开始时的首次通信中报告其eSVN。 EUICC31 EUM应在用于验证eUICC认证的eUICC中安装eUICC证书。 EUICC32 EUM应在用于验证eUICC证书的eUICC中安装EUM证书。 EUICC33 eUICC应具有向SM-DS进行认证的手段。 EUICC34 eUICC应保护自己免受未经授权的访问。 EUICC35在profile删除后，eUICC应确保完全删除与profile相关的所有数据。 EUICC36 eUICC只接受eUICC或设备中的LPA发送的profile管理操作。 EUICC37 eUICC应拒绝与相应profile的profile策略规则相冲突的任何profile管理命令。 EUICC38如果任何绑定profile包下载或安装未成功完成，则eUICC应保持其收到请求之前的状态。 EUICC39 eUICC应支持GlobalPlatform安全元件访问控制[15]。 EUICC40应该在eUICC中预先设置一个默认的SM-DP +地址。 EUICC41 eUICC应存储根SM-DS地址。 EUICC42 eUICC应能够向LPA发送删除通知，通知通知接收方该profile已被删除。 EUICC43在EUICC42中，如果连接不可用于向通知接收器发送删除通知，每当连接再次可用时，每个通知都应保留并发送。 EUICC44在eUICC存储器复位的情况下，对于每个已删除的profile也应该执行删除通知过程。 EUICC45 eUICC应支持一系列标准功能和服务，包括但不限于Java应用程序，USIM工具包功能和GlobalPlatform功能。支持的功能和服务列表（例如API包名称和版本）应在技术规范（SGP.22 [24]）中明确引用。根据附件D中定义的不同嵌入式UICC类别，可以定义/支持不同的一组功能和服务。 EUICC46 eUICC应至少支持以下USIM工具包命令： PROVIDE LOCAL INFORMATION，包括以下字段：本地信息，IMEI，网络测量结果，日期和时间，接入技术 终端profile TERMINAL PROFILE- ENVELOPE (SMS-PP DOWNLOAD)- SEND SHORT MESSAGE- DISPLAY TEXT- GET INPUT- RING TONE EUICC47 eUICC应支持至少两组椭圆曲线参数在eUICC制造过程中由EUM预装，定义见GSMA SGP.22 V2.0 [24]。 EUICC48每份通知都应有唯一标识，并由eUICC签署。 EUICC49每条通知（删除，预先删除，禁用）均应重新受到攻击保护并由eUICC签署。 EUICC50（FFS）可以通过Profile参数请求发送预删除通知，通知发送通知后，eUICC将执行删除操作。 EUICC51（FFS）在成功尝试预删除通知的情况下，eUICC应删除为其进行通知尝试的profile。如果此通知不成功，但无论如何都将删除profile，则应在通信连接再次可用时立即保留并发送通知。 EUICC52该profile应能够包含每种通知类型的零个或多个通知接收者列表。 4.3 eUICC资格检查eUICC资格检查使SM-DP +能够使用eUICC发送的信息验证eUICC是否有资格安装profile。 eUICC向SM-DP +发送的用于资格检查目的的信息在此被称为eUICC资格检查信息。 由于Device / eUICC必须支持并作为eUICC资格检查信息集的一部分交付的设备功能，可能需要某些eUICC资格检查参数。 注意：设备功能是指设备提供的设备功能或服务启用功能，它可能对profile的内容或用于下载profile的过程有直接影响，并且需要eUICC的支持。 4.3.1 eUICC资格检查要求ELG1 eUICC应指明其支持的规格版本。在eUICC资格检查期间，该参数应传送给SM-DP +。 ELG2 eUICC应在eUICC资格检查信息中包含可用内存。 ELG3 eUICC应在资格检查信息中声明它是否无法接受其他profile。 ELG4 eUICC应提供有效的当前证书给由EUM签署的SM-DP +。 ELG5 eUICC应提供EUM的标识。 ELG6 eUICC应提供当前的操作系统版本。 ELG7 UICC应提供与可能需要Profile支持的服务有关的设备使能器信息（例如NFC使能器）。 ELG8资格检查信息应由eUICC保护，以便将其发送到SM-DP +以保护其完整性和真实性。 ELG9 eUICC应指示eUICC资格检查信息中支持的应用程序运行时环境版本和库版本。 ELG10 eUICC应指明eUICC资格检查信息中支持的加密算法及其各自的密钥长度。 ELG12 eUICC应指出其当前的认证状态。在eUICC资格检查期间，该参数应传送给SM-DP +。 ELG13如果eUICC支持NFC（例如CAT3），则应表明其支持相关的NFC服务，包括其当前的认证状态。 ELG14 eUICC应指明其类别（见附件D）。在eUICC资格检查过程中，该参数应发送到SM-DP +。 注：假定EID通常以其他方式与SM-DP +共享，并可用于资格审查程序。 4.4设备要求DEV1设备应符合ETSI TS 102 221 [2]中的终端要求，但本规范中定义的例外情况除外。 DEV2应该有一种手段让最终用户通过设备软件获取EID。这只能通过LUI来实现。 DEV3如果eUICC在设备包装内，则EID应在设备包装上以机器可读形式打印。 DEV4配套设备与SM-DP +的承载连接只能由承载可用性决定。注意：伴侣设备可以使用任何可用的连接方法连接到SM-DP +。 DEV5符合GSMA NFC手持设备要求的设备[17]应支持设备应用程序使用的开放移动API [19]与在eUICC上启用的profile中运行的对应应用程序交换数据。 DEV6在设备中实施远程SIM卡配置规范不会影响3GPP TS 22.022 [16]中定义的SIM锁定机制的潜在用途。 DEV7当设备同时支持设备中的LPA和eUICC中的LPA时，设备应具有设置哪个LPA应使用的机制（设置或配置参数）。 DEV8最终用户应能修改DEV7中定义的参数。 DEV9在eUICC中支持不带LPA的嵌入式UICC的器件，应提供LPA功能。 DEV10在eUICC中仅支持带LPA的嵌入式UICC的设备，可以提供LPA功能。 DEV11如果器件支持器件测试模式，器件应支持eUICC测试存储器复位。 eUICC测试存储器复位只能在设备处于设备测试模式时由最终用户请求。 4.4.1设备能力要求DEVCAP1应该有一种机制能够为SM-DP +提供设备能力。 4.5器件启动要求4.5.1器件复位FAC1最终用户可以在不影响eUICC状态的情况下执行任何类型的器件复位。 FAC2设备应通过安全程序触发/请求eUICC存储器复位。 FAC3设备应通过安全程序触发/请求eUICC测试存储器复位。 4.5.2 eUICC存储器复位MEM1 UICC存储器复位应删除eUICC上除标记为永久的预先安装的profile外的所有profile。 MEM2 eUICC内存复位应删除eUICC上的所有profile，而不管其profile策略规则，但不要删除profile或预安装的测试profile。 MEM3认证确认应被验证以启动eUICC存储器复位。 MEM4除MEM3外，还可以使用其他安全手段来执行eUICC存储器复位功能。应用基于LUI的重置功能所提供的相同级别的安全性。用户意图和确认请求应适用。 4.5.3 eUICC测试存储器复位MEMT1 eUICC测试存储器复位应删除eUICC上的所有发布后安装的测试profile，包括已启用的测试profile（如果有）。 MEMT2简单确认应验证以启用eUICC测试存储器复位。 MEMT3如果测试profile不受支持，则不需要eUICC测试存储器复位。 4.6profile要求4.6.1测试profileTPRO1可移动eUICC支持本节中描述的测试profile的要求是可选的。如果测试profile不受支持，则不能将测试profile下载到eUICC中。 TPRO2测试profile不能使用Operator Credentials对运营商的移动网络进行认证。 eUICC应确保即使认证信息包含在测试profile中，这些profile也不能用于连接到任何运营商的移动网络。 TPRO3测试profile应该安装在它自己的ISD-P中。 TPRO4测试profile可以预先安装在eUICC上。 TPRO5当器件处于器件测试模式时，测试profile只能显示和使用。 TPRO6除eUICC存储器复位操作外，只能在器件测试模式下下载，安装，启用，禁用或删除eUICC中的测试profile。 TPRO7测试profile与任何其他profile一样，应通过经认证的SM-DP +进行管理。 TPRO8启用测试profile将覆盖不禁用profile策略规则。 TPRO9当设备测试模式被禁用时，LPA应禁用任何启用的测试profile。 TPRO10当测试profile被禁用时，eUICC应启用以前启用的操作profile（如果有）。 TPRO11设备测试模式激活应从最终用户模糊处理。 TPRO12退出设备测试模式时，将出现最终用户通知，提示测试仪执行eUICC测试存储器复位。设备可以实现一种连接外部SIM卡的机制，以便在设备修复的情况下进行测试，而不会影响eUICC的状态。 4.6.2授权profilePPRO1授权profile应基于与profile所述相同的格式结构（图2）。 PPRO2如果使用当前已启用profile建立连接不成功，那么LPA可以根据最终用户对PPRO6中定义的操作的请求启用配置profile。如果这导致操作profile被禁用，则最终用户应首先同意由启用profile提供的通信丢失。 PPRO3授权profile及其关联的profile元数据在LUI上对最终用户不可见。 PPRO4最终用户不能选择授权profile。 PPRO5通过最终用户的任何行动，包括使用eUICC存储器复位，授权profile不得被删除。 PPRO6授权profile只能用于profile下载和相关profile维护功能的预期用途。授权profile不得用作操作profile。 PPRO7 PPRO6应在RSP架构中强制执行。 4.7profile元数据要求META1所有profile都应具有关联的profile元数据。 META2profile元数据应存储在eUICC中。 META3无论profile的状态如何，profile元数据都可以访问。 META4profile元数据应包含一个用于服务提供商名称的字段。注意：EFSPN已经在本规范以外的不同环境中使用过，并且可能为空。 META5profile元数据应包含用于profile的ICCID的字段。 META6profile元数据应包含profile最终用户昵称的字段。 META7profile元数据应包含一个字段，用于包含由操作员/服务提供商定义的简档的简短描述。 META8昵称应由最终用户编辑。 META9profile元数据应始终提供给LUI。 META10profile元数据应包含一个可选字段，以允许显示由运营商/服务提供商为相应profile定义的图标。 META11profile元数据应能够包含与profile关联的profile策略规则的副本。 META12所有profile应在profile元数据中唯一标识为操作，配置或测试profile。 META13如果profile已启用，运营商应能够使用ES6界面访问和更新其profile的以下profile元数据： 服务提供商名称 profile的简短描述 profile的图标 4.8 NFC要求NFC设备和NFC eUICC应符合以下要求列表： NFC1 NFC设备应符合GSMA TS 26 [17]。 NFC2安装运营profile后，NFC eUICC应支持SGP.03 GSMA NFC UICC要求规范[20]中规定的所有要求。 NFC3 NFC设备应按照GlobalPlatform SEAC规范[15]中的规定检索并执行访问控制规则。 NFC4 eUICC应能够生成操作profile已被删除的证据。 NFC5所有NFC应用程序和NFC使能应用程序（例如ARA-M，PPSE，CRS，CREL等）附加到操作profile应包含在为profile创建的ISD-P下，可以在MNO-SD下或在SD层次结构，带有具有授权管理权限的自引导SSD。 NFC6 NFC eUICC解决方案应能够向NFC应用服务提供商保证eUICC和运营profile的组合是值得信赖的。该解决方案应基于CASD，该CASD是SGP.03 [20]规定的操作profile和场景Push 2B和场景3的一部分。 NFC7如果NFC eUICC符合M4M，则当包含M4M应用程序的profile被禁用时，eUICC应重置与该profile关联的所有M4M虚拟卡。 NFC8在eUICC资格审查期间，适当的NFC相关认证信息应作为与SM-DP +共享的信息的一部分。 NFC9 NFC设备应至少具有嵌入式eUICC，或者具备支持与CAT3和SGP.03 [20]兼容的可拆卸eUICC的能力。 4.9订阅管理器数据准备+（SM-DP +）4.9.1 SM-DP +概述根据运营商的输入/请求，SM-DP +负责创建，生成，管理和保护生成的profile。它还负责在Bound Profile Package包内提供profile，使Bound Profile Package包可用于安全传送。此外，SM-DP +负责请求在将要安装Profile的eUICC中创建ISD-P。 SM-DP +也将成为离卡实体，负责根据请求创建的ISD-P的生命周期管理。这是通过下面列出的不同功能执行的。 profile包生成创建profile包[即 来自Profile Descriptions的个性化profile，包括（IMSI，Ki，ICCID …）]与运营商达成一致。 这可以是脱机批处理或实时处理。 profile包保护根据创建Protected Profile Package包的安全流程来保护每个profile包。 profile包绑定使用安全流程将Protected Profile Package包绑定到目标eUICC，从而创建绑定profile包。 profile包存储临时存储Protected Profile Package包或绑定的profile包，以便随后传送给eUICC。 profile包交付通过LPA安全传输并安装绑定profile包到eUICC。 SM-DS事件注册通知SM-DS有关特定eUICC的挂起操作。 4.9.2 SM-DP+ 需求SMDP1 SM-DP +应代表运营商行事。 SMDP2 SM-DP +应能够启动ISD-P创建请求，作为Bound Profile Package包传送的一部分。 SMDP3 SM-DP +应建立eUICC的端到端安全通道，以在eUICC上下载和安装Bound Profile Package包。 SMDP4 SM-DP +应链接Protected Profile Package包，以便仅在相应运营商的请求下才能绑定到特定的eUICC。 SMDP5 SM-DP +应仅在相应eUICC的请求下从链接的Protected Profile Package创建Bound Profile Package。 SMDP6 SM-DP +应能够为任何认证的eUICC创建Bound Profile Package包。 SMDP7只有目标eUICC才能解密由SM-DP +传送的Bound Profile Package包的内容。 SMDP8profile包仅在完成所有生产步骤，profile包保护和绑定后才能离开SM-DP +。 SMDP9SM-DP +与LPA之间的通信会话应在执行预期操作后由SM-DP +终止。 SMDP10 SM-DP +与profile下载和安装中涉及的eUICC之间的端对端通信应受到完整性，真实性和机密性的保护。 SMDP11存储在SM-DP +中的profile包应始终通过加密进行保护。 SMDP12在SM-DP +上，profile创建和存储基础架构内的备份以及使用的数据应使用安全删除程序（逻辑和物理）丢弃。 SMDP13 SM-DP + / eUICC通信应包含完美前向保密（PFS）。 SMDP14用于Bound Profile Package包的传输应在SM-DP +和eUICC之间实现防重放机制。 SMDP15与SM-DP +的连接应当中止，并且在未能验证连接方的真实性时，由SM-DP +触发明确的错误消息。 （不应向连接方发送消息） SMDP16经过可配置次数的失败尝试将Bound Profile Package包下载到LPA后，传输加密过程应被更新。如果后续尝试下载Bound Profile Package包失败的次数超过可配置次数，配置事务将被终止，并且应通知运营商。 SMDP17 SM-DP +应使用互联网协议（如DNSSEC，DNSCurve等）的安全版本。 SMDP18 SM-DP +应按照SIMalliance [5]定义的eUICCprofile包互操作格式规范来准备profile包。 SMDP19 SM-DP +应能够按需创建Bound Profile Package包。 SMDP20 SM-DP +可以批量创建profile包。 SMDP21 SM-DP +应向操作员发送成功完成的下载和安装profile的确认。 SMDP22在成功安装profile后，应该有一种机制来消除任何SM-DP +和ISD-P之间的关系。这种机制应由运营商订购或由运营商自行执行。如果使用这种删除机制，则不会有负责管理已安装profile的ISD-P的离卡实体。 SMDP23 SM-DP +应由其SMDPid全局唯一标识。 SMDP24 SM-DP +证书应包含SMDPid。 SMDP25 SM-DP +应能够向运营商发送通知，通知他们特定的Bound Profile Package包下载即将开始。 SMDP26在下载eUICC Bound Profile Package包之前/之前，SM-DP +应能够向运营商发送eUICC资格检查信息报告和其他相关信息（例如激活码，ICCID等）。 SMDP27 SM-DP +应能够向SM-DS执行事件注册。 SMDP28 SM-DP +应能够从备选SM-DS请求不将事件注册传播到根SM-DS。 SMDP29当从eUICC收到相关的删除通知时，SM-DP +应能够向拥有profile的运营商发送profile删除通知。 SMDP30 SM-DP +应支持由profile所有者触发的profile包的以下状态： profile包下载时不会发布profile包。  profile包发布用于profile包下载。 SMDP31 SM-DP +应能够在profile下载过程中选择椭圆曲线参数。 SMDP32（FFS）SM-DP +可以对SM-DS（根或备用）进行事件记录查询，以审计其拥有的事件注册。 SMDP33（FFS）SM-DP +应能够通过ES12接口查询由EID或Event-ID标识的根SM-DS或替代SM-DS上的事件记录。 SMDP34（FFS）对SM-DP +事件记录查询的响应只应在根SM-DS或备选SM-DS验证事件记录所有权的情况下进行。 SMDP35（FFS）SM-DP +事件记录查询的所有权验证应仅针对所持有的事件记录的组件使用请求者地址或提交的事件ID。 SMDP36 SM-DP +应支持GSMA SGP.22 V2.0 [24]中定义的所有椭圆曲线参数集。 SMDP37如果Profile包尚未发布供下载，则应通过特定的错误代码通知LPA。 4.9.3 eUICC 上的默认SM-DP +地址DF1如果在呈现给LUI的AC中存在SM-DP +地址，则eUICC中的默认SM-DP +地址应该被忽略。 DF2 LPU可访问eUICC中的默认SM-DP +地址，以建立与此SM-DP +的连接。 DF3 eUICC中的默认SM-DP +地址可以留空。 DF4如果eUICC中的默认SM-DP +地址为空，则需要在AC中使用SM-DS发现过程或SM-DP +地址来建立目标SM-DP +。 DF5（FFS）不支持重定向到查询默认的SM-DP +地址。 4.10本地Profile助理（LPA） 4.10.1 LPA概述该角色既存在于设备中，也与eUICC提供的LPA服务一起存在，并在eUICC中与eUICC提供的LPA功能一起存在。 它提供三种不同的功能，如下所述的本地用户界面（LUI），本地Profile下载（LPD）和本地发现服务（LDS）。 如果没有设备交互，eUICC本身不能提供任何这些功能，交互的具体级别将取决于设备内的功能。 在不同的设备和设备类型中实现这种可变性的方式有待进一步研究。 本地发现服务（LDS）如有需要，LDS负责从SM-DS中检索未决的事件记录。 本地Profile下载（LPD）这对于以下两个阶段有效地下载Bound ProfilePackage包起到代理作用：（i）在单次交易中将Bound Profile Package包从SM-DP +下载到LPD;以及（ii） Bound Profile Package分段到eUICC。 该功能将取决于网络，设备和eUICC功能。 本地用户界面（LUI）该功能允许最终用户在设备上执行本地Profile管理。 用户意图应强制执行。 4.10.2 可选的LAP模式当设备和eUICC中有LPA时，要使用的LPA由设备设置（DEV7）指定：- LPA in the Device- LPA in the eUICC 4.10.2.1 LPA in the eUICCLPA功能是由eUICC提供. 4.10.2.2 LPA in the DeviceLPA功能是由设备提供. 4.10.3 LPA需求LPA1 LPA应负责指示eUICC根据最终用户请求执行本地Profile管理功能。 LPA2在eUICC之外的任何LPA单元和eUICC之间应实施一种机制，以确保通信不会在LPA所在的任何地方受到威胁。 LPA3应在LUI和设备上相关的显示或输入应用程序之间实施安全机制。 LPA4对LUI应用程序的访问应根据当前最佳实践进行保护。这将由Device OS强制执行。 LPA5所有本地Profile管理操作都需要用户意图。 LPA6 LUI访问需要用户意图。 LPA7最终用户应能够轻松访问已安装的Profile列表。 LPA8 LPA应保护个人资料元数据免受未经授权的访问。 LPA9本地Profile管理操作’enable’应被支持。此操作应允许最终用户选择Profile。 LPA10本地Profile管理操作“禁用”应受支持。 LPA11本地Profile管理操作’删除’应该被支持。此操作应允许最终用户从eUICC中删除已禁用的Profile。最终用户应确认删除Profile后果的消息。认证确认应执行。 LPA12应支持本地Profile管理操作“查询”。此操作应允许最终用户通过其Profile元数据查看eUICC上安装的操作Profile列表和相关的相关信息。 LPA13应支持本地Profile管理操作’编辑默认的SM-DP +地址’。该操作应允许最终用户编辑默认的SMDP +地址。简单确认应执行。 LPA14应支持本地Profile管理操作’eUICC Memory Reset’。该操作应按照第4.5.2节所述执行eUICC存储器复位。最终用户应确认’eUICC存储器复位’的结果信息。认证确认应执行。 LPA15应支持本地Profile管理操作’eUICC测试存储器复位’。该操作应执行第4.5.3节中所述的eUICC测试存储器复位。简单的确认将被强制执行。 LPA16应支持本地Profile管理操作的“设置/编辑昵称”。此操作应允许最终用户添加或修改所选Profile的昵称。该操作不应修改服务提供商名称。可以提供在LUI上区分Profile的其他方法。 LPA17应支持本地Profile管理操作“添加Profile”。此操作应允许LPA下载并安装新的Profile到eUICC。 LPA至少应支持三种机制，具体取决于具有技术能力的设备类型：从默认SM-DP +通过SM-DS服务发现下载Profile使用激活代码认证确认进行Profile下载，除初始设备设置（LPA62）外应强制执行。 LPA18 LPA不能由除LPA提供商提供的应用程序之外的任何应用程序访问，仅用于启用LPA的服务和功能。 LPA19 LPA提供商应执行安全且不可被认可的认证确认。 LPA20 LPA提供商应在设备上执行安全且不可拦截的简单确认。 LPA21对LUI的访问应受到认证确认的保护。 LPA22 LPA21中的机制应由最终用户选择/取消选择。 LPA23默认情况下会提示LPA21中的机制启用，但可以由最终用户跳过。 LPA24 LPA及其主机（即设备，如果LPA位于设备中; eUICC，如果LPA位于eUICC中）应实施一种机制，通过经过身份验证的确认来保护LPA访问。这个认证确认可以通过使用设备中实现的机制来实现，例如电话锁码，指纹输入等。 LPA25最终用户应该能够定义专用的个性化用户凭证来访问LPA。 LPA26如果最终用户选择保护对LUI（LPA23）的访问权限，则操作级别的后续认证确认可以用简单确认来替换。 LPA27强制执行时，任何确认请求都应允许最终用户取消本地Profile管理操作。 LPA28可以暴露配套设备的LUI，允许来自主设备上的最终用户界面的输入。 LPA29当配套设备LUI允许来自主设备的输入时，配套设备LUI应能够限制可应用的操作。例如：不提供eUICC存储器复位; 仅公开’启用’和’禁用’操作。 Profile启用仅在配套设备上未启用Profile的情况下公开。 LPA30伴随设备的LUI应能够在建立任何接近安全链路（用于从另一设备向LUI的输入）之前向伴随设备请求最终用户发起的动作。 LPA31由终端用户发起并提供机密性和完整性的点对点接近安全链接应在配套设备和主设备之间为从主设备执行的任何输入建立。 LPA32当从主设备操作配套设备LUI时，任何必需的用户意图或确认请求只能由配套设备上的LPA执行。物理最终用户输入可以在主设备或伴随设备中完成。 LPA33伴随设备的设备制造商应实施一项安全措施，以确保任何访问LUI的应用程序的完整性和资格。 LPA34用于用户意图保护的最终用户数据（例如PIN码，指纹）应存储在安全的环境中。 LPA35 LPA应能够利用任何设备上和现有的互联网连接，例如Wi-Fi或Wi-Fi直连，以接触SM-DP +。通过这种连接，可以建立ES8 +和ES9 +。 LPA36 LPA应能够通过其他连接机制（例如有线共享，本地共享Wi-Fi连接或蓝牙）利用其他连接机制提供的任何互联网连接，以便接触SM-DP +。通过这种连接，可以建立ES8 +和ES9 +。 LPA37 LPA应能够确定是否可以通过任何方式连接到SM-DP +。 LPA38 LPA应能通知最终用户没有连接到互联网，或者没有连接到SM-DP +，以便允许最终用户启用或排除所需的连接。 LPA39如果分配了权限，LPA只能访问eUICC。 LPA40设备上只能有一个LPA。 LPA41 LPA只应执行本规范中描述的操作。 LPA42 LPA程序不得由任何外部（非LPA）程序调用。 LPA43安装多个操作Profile时，本地Profile管理操作“启用”应在启动所选Profile的“启用”操作之前首先启动任何已启用Profile的“禁用”操作。 LPA44 LPA应能读取Profile策略规则。 LPA45当安装了Profile策略规则的Profile时，在请求最终用户同意的情况下，LPA应向最终用户显示Profile策略规则的结果。此信息应以描述性和非歧视性方式制定（例如，对于“非删除”Profile策略规则：“您将要安装的Profile不能根据您与服务提供商商定的条款删除。 YES / NO）。认证确认应以LPA17中列出的例外执行。 LPA46在下载新Profile之前，LPA应检查已启用Profile（如果有）是否已启用POL RULE1的条件。如果是这种情况，应该显示一条专用信息，标识最终用户的后果。可能显示的信息示例如下：由于当前启用的Profile无法禁用，因此无法启用新的Profile。 已启用Profile的Profile名称。 有关更多信息，最终用户应联系此Profile的Profile所有者。通过显示此消息，最终用户应能决定是继续下载还是取消操作。该对话可以与常规最终用户意图结合以确认简档下载。 LPA47主设备的最终用户界面和伴随设备的LUI之间的通信应受到保护（机密性，完整性和认证）。 LPA48如果最终用户退出LPA菜单或在一段时间内未执行操作，以避免滥用为连续的本地Profile管理操作绕过已认证的确认 LPA49确认请求，则应有机制限制LPA26的有效性只要向最终用户明确解释不同的行为，就可以一步完成。例如，在安装新的Profile时，LPA可以建议’添加Profile’和’启用’为一个单一的步骤，只有一个确认（例如“你想在你的设备上安装Profile’ProfileName’并启用它？是/否/仅安装“） LPA50当在一个单一步骤（LPA49）中实现连续操作时，应用最高级别的确认 - 即在两个操作分别具有已验证和简单确认请求的情况下，单步骤使用已认证的确认请求。 LPA51本地Profile管理操作’启用’（LPA9），’禁用’（LPA10），’删除’（LPA11）应能够触发通知到被管理的相应Profile的通知接收器，以指示该操作已被执行。这些通知以尽力而为的方式发送，并且不会影响操作。 LPA52 LPA应通过LUI提供从最终用户到eUICC的可信链路。 LPA53最终用户应能够配置LPA，使得可以禁用从SM-DS中检索自动事件记录。 LPA54 LPA应能读取eUICC中配置的任何SM-DS和SM-DP +地址。 LPA55应该可以检查LPA完整性。如果完整性检查失败，eUICC和LPA之间的通信将不会发生。 LPA56 LPA完整性应确保在目标平台上使用最佳实践方法。见附录G. LPA57 LPA中的轮询机制应有两种类型的触发器：那些基于事件的，以及最终用户发起的。应提供 LPA58用于轮询的基于事件的触发器。至少应包括设备加电;此外可以提供其他触发器。基于事件的触发器可以由最终用户禁用。 LPA59最终用户启动的轮询触发器应包括：’添加Profile’操作以触发默认SM-DP +（如果已配置）和根SM-DS。 另外，可以提供其他手动触发器。 LPA61应该实现LPA轮询机制的错误/重试处理。建议最终用户根据需要重试或自动重试。相应的确认需要在重试案例中执行。 LPA62在初始设备设置期间，如果尚未安装操作Profile，则应按以下顺序执行：1.如果配置了默认的SM-DP +地址，则LPA应联系SM-DP +以检查是否有正在等待的Profile。 2.如果（1）中没有任何Profile正在等待，则应联系根SM-DS地址以检查等待Profile的事件。简单确认应针对上述程序执行。 LPA63如果没有默认的SM-DP +地址，最终用户应始终能够通过LPA手动请求检索任何等待的事件记录。注：这可以通过与现有操作的组合来实现 - 例如，按“添加Profile”将联系服务器以检索事件。 LPA64在启动下载Profile并在下载Profile之前向最终用户显示时，操作员/服务提供商名称应在从SM-DP +到LPA的信令信息中给出。简单的确认将被强制执行。 LPA65 LPA应当将EID作为文本和定义的可扫描格式（例如QR码）呈现给最终用户。 LPA66（FFS）对于在组合操作中要禁用并删除的Profile提供唯一可用连接的情况，应在Profile禁用之前发送预删除通知。这种尝试的失败不应该阻止删除或连接拆解。 LPA67如果SM-DP +停止Profile下载过程，则LPA应能通知最终用户。 LPA68本地Profile管理操作的自动化应该可以访问，除非在LPA43中描述的情况。 4.10.4 LDS需求LDS1LDS应能读出EUICC中描述的地址。 并仅使用（se）地址连接到SM-DS 4.11订阅管理器 - 发现服务（SM-DS）4.11.1 SM-DS概述SM-DS的作用是提供允许SM-DP +在任何设备内通知SM-DP +希望进行通信的LDS用它。 SMDS与LDS通信的目的应该是通知LDS一个未决事件。所有用例的操作原理都是一样的。 SM-DP +会将目标设备的事件注册消息发送给SM-DS。在简单部署中，只有根SM-DS在eUICC上配置。根SM-DS地址是唯一的，并填写在eUICC中。目标设备中的LDS使用相同的逻辑位置轮询Root SMDS。当根SM-DS具有目标设备的事件ID时，它将使用SM-DP +地址进行响应，或者如果没有事件ID，响应将为空响应。在具有级联SM-DS的部署中，SM-DP +将向另一个SM-DS发送事件注册，该SM-DS可能未在eUICC上配置为根SM-DS。此替代SM-DS将将事件注册级联到根SM-DS。目标设备中的LDS轮询根SM-DS并将接收替代SM-DS地址。然后它将请求替代SM-DS中的事件，该SM-DS将用SM-DP +地址进行响应。 4.11.2 SM-DS的实施eUICC上的两个SM-DS地址配置可能存在：- 根SM-DS地址- 可选的SM-DS地址 图11显示了这两种配置。 根SM-DS在设备制造时配置并且是不变的。 4.11.3 SM-DS实施指南在定义技术实现时应考虑以下声明： 提供SM-DS服务的竞争环境应该受到该方法的青睐。  不应该有单点失败。  实现应该固有地提供纵向和横向性能/可伸缩性。  根据SGP.02 [8]（GSMA嵌入式SIM for SM-SR）的要求，在特定SM-DS上不需要预先注册设备或eUICC。 4.11.4 SM-DS功能SM-DS有以下三个功能: 活动注册存储从SM-DP +接收到的事件记录的过程。 事件删除SM-DP +可以删除自己的事件记录的过程。 事件检索提供所有注册的事件记录，根据任何查询的LDS发现请求。 4.11.5 SM-DS 需求SMDS1 SM-DS应使LDS能够发现由SM-DP +（s）或备选SM-DS（s）注册的自己的事件记录。 SMDS2 SM-DS将无法识别事件的性质。注：事件的性质可能是’可供下载的Profile包’。 SMDS3所有有效的发现请求和事件注册均应以无歧视的方式进行处理。 SMDS4 SM-DS只接受来自具有有效证书的任何经授权和认证的SM-DP +（s）的事件注册。 任何具有有效证书的授权和认证SM-DS。 SMDS5 SM-DS只接受由相应的eUICC通过LDS认证的发现请求。 SMDS6 SM-DS和SM-DP +以及连接的SM-DS应相互认证。 SMDS7 SM-DS不可见任何可能用于危害最终用户隐私的数据。 SMDS8 SM-DS应支持每个eUICC的多个并发事件注册，并应按照与SM-DS（先入先出）相同的顺序向LDS提供所有当前有效的事件记录。 SMDS9 SM-DS只能存储指定给特定EID的事件记录。 SMDS10用户特定数据和Profile相关内容不应存储在SM-DS中。 SMDS11 SM-DS不允许收集任何信息，例如运营商，EID，设备制造商，设备等。 SMDS12 SM-DS应仅返回LDS，与所服务的eUICC相关的事件记录。 SMDS13 SM-DS不会与Profile包有任何联系，例如不得存储或处理任何Profile包。 SMDS14无论查询设备的状态如何（即时间和地理位置一致），SM-DS都应提供相同的数据。 SMDS15 SM-DS不应该严重影响端到端的供应时间。 SMDS16 SM-DS将提供针对DoS攻击的防御。 SMDS17所有与SM-DS实体之间以及之间的通信都应加密。 SMDS18 SM-DP +应能够删除在SM-DS上注册的任何自己的事件记录。 SMDS19另一种SM-DS应能够删除在根SM-DS上注册的任何自己的事件记录（响应SMDS18中定义的SM-DP +删除操作）。 SMDS20如果SM-DP +有请求，SM-DS的替代方案应将事件记录传播到根SM-DS。 SMDS21如果在SM-DS上为一个eUICC注册了多个事件记录，则这些应全部作为单个响应发送。 SMDS22 SM-DP +应能够通过根SM-DS或通过SM-DP +选择的备选方法向LDS发送事件记录。如果选择了替代方案，则LDS的事件记录应来自此替代SM-DS。 SMDS23应该有一个独特的根SM-DS。注意：此要求不禁止此根SM-DS的潜在负载平衡。 SMDS24根SM-DS应由GSMA管理。 SMDS25（FFS）替代SM-DS可以对根SM-DS进行事件记录查询，以审计其拥有的事件注册。 SMDS26（FFS）对事件记录查询的SM-DS响应应仅确认事件记录的存在，并且不应包含其他信息。 SMDS27（FFS）备选SM-DS应能够通过ES15接口查询EID或Event-ID所标识的根SM-DS上事件记录的存在。 SMDS28（FFS）对SM-DS事件记录查询的响应应仅在响应者验证事件记录所有权时发生。 SMDS29（FFS）SM-DS事件记录查询的所有权验证应仅针对所持有的事件记录的组件使用请求者地址或提交的事件ID。 SMDS30（FFS）SM-DS（根或备选方案）可以直接或通过另一个SM-DS通知SM-DP +，通过发布事件记录来解答来自授权LDS的发现请求。 SMDS31（FFS）SM-DS只应通知事件记录拥有的SM-DP +或SMDS它已回复发现请求。 4.11.6事件注册/删除程序下图显示了使用根SM-DS和替代SM-DS（级联模式）进行部署的过程。 起始条件：a. SM-DP +具有等待由EID识别的目标eUICC的动作。程序：1.SM-DP +与Profile所有者选择的替代SM-DS建立安全连接。2.SM-DP +通知备选SM-DS有关未决动作。3.至4.替代SM-DS注册并确认事件注册。5.替代SM-DS建立到根SM-DS的安全连接。6.可选SM-DS通知根SM-DS，对于给定的EID，事件记录正在等候替代SM-DS。7.根SM-DS确认收到的信息。4.11.7发现请求程序下图显示了使用替代SM-DS和根SM-DS（级联模式）进行部署的过程。 程序：1.至3.为了生成发现请求，LDS请求eUICC生成包含（至少）eUICC证书并由eUICC签名的eUICC授权。4.到5.LDS建立到根SM-DS的安全通信。6.根SM-DS通过检查eUICC授权来验证eUICC的真实性。7.如果eUICC是可信的并且事件记录正在等待，它会返回：一个。 SM-DP +的地址，正在等待一个动作。要么湾以下其他操作：I。替代SM-DS的地址，可以检索事件记录。II。 LDS建立到替代SM-DS的安全连接。III。替代SM-DS通过检查eUICC授权来验证eUICC的真实性。IV。如果eUICC是真实的并且已收到事件记录，则它将传回SM-DP +的地址，在该处等待一个动作。 LPA建立到SM-DP +的连接，并且可以执行等待操作。 4.12 接口 4.12.1运营商 - SM-DP +（ES2 +）运营商使用ES2 +接口为特定eUICC以及其他管理功能订购Profile。 4.12.2运营商 - 最终用户（ESop）这个接口超出了本规范的范围。 4.12.3最终用户 - LUI（ESeu）ESeu是最终用户和LUI之间的接口。在主/伴随设备场景中，所使用的LUI只能位于伴侣设备或其eUICC内。ESeu接口用于支持以下要求：ESeu1本地Profile管理操作只能通过ESeu接口执行。ESeu2每个本地Profile管理操作应由最终用户明确发起，并由用户意图进行验证。ESeu3 ESeu接口应支持触发和确认Profile下载和安装操作。 4.12.4运营商 - eUICC（ES6）运营商使用ES6接口通过OTA服务管理运营商服务。 4.12.5 SM-DP + - LPD（ES9 +）ES9 +接口用于为SM-DP +和LPD之间的绑定Profile包提供安全传输。 4.12.6 SM-DP + - eUICC（ES8 +）ES8 +接口在SM-DP +和eUICC之间提供安全的端到端通道，用于在下载和安装期间管理ISD-P和关联的Profile。它是一个提供完美向前保密的界面。 4.12.7 SM-DP + - SM-DS（ES12）ES12接口允许任何SM-DP +发布或删除SMDS上的事件注册。 4.12.8 LDS - SM-DS（ES11）ES11接口允许LDS检索相应eUICC的事件记录。 4.12.9 EUM - eUICC（欧洲共同体）这个接口超出了本规范的范围。 4.12.10 LDS - LPA服务（ES10a）设备中的LPA使用ES10a接口从root用户SM-DS的eUICC以及可选的默认SM-DP +获取配置的地址。 4.12.11 LPD - LPA服务（ES10b）设备中的LPD使用ES10b接口，LPA服务将绑定Profile包传输到eUICC。 4.12.12 LUI - LPA服务（ES10c）ES10c接口用于设备中的LUI与最终用户的本地Profile管理的LPA服务之间。 4.12.13 SM-DS - SM-DS（ES15）在部署级联SM-DS的情况下，ES15接口用于连接SM-DS。 4.12.14设备 - SM-DP +（已建立连接）该连接将通过以下方式提供：可用的互联网连接或在LPA所在的同一设备上提供的互联网连接要么通过本地中继连接从另一台设备共享的互联网连接 4.12.15通用接口要求INT1 eUICC的所有接口都应指示eSVN。INT2所有接口的行为应支持指定的eSVN。INT3在从eUICC到SMDP +的支持eSVN的指示期间，应使用eUICC版本或该过程失败。 见下表。INT4涉及远程SIM配置的所有通信实体应相互认证。 Device和eUICC在这方面被视为一个实体。 4.13Profile策略管理4.13.1简介Profile策略管理功能提供了一些机制，通过这些机制，服务提供商可以加强向订户提供服务的条件或政策（运营和业务）。在某些情况下，这可能还包括强制执行订户设定的政策。Profile策略管理也可以与其他已有的策略执行技术一起使用，这些技术也需要订户同意。Profile策略管理功能的实现基于两个关键要素。第一个元素是eUICC中包含的Profile Policy Enabler。第二个元素是一组定义的Profile策略规则，这些规则是特定策略的实际执行所必需的。 4.13.2Profile策略管理要求POL1Profile策略规则只能在Profile中配置。POL2每个Profile可能有与其自身相关的Profile策略规则。POL3Profile策略规则只适用于包含它的Profile。POL4Profile策略实施应在各个实施中保持一致。POL5Profile策略执行应能解决任何Profile策略规则冲突.POL6更新Profile的策略规则应限于Profile所有者。POL7用于更新Profile策略规则的机制应为原子。POL8Profile策略规则集将可扩展用于将来的版本。POL9应该有一个Profile策略规则方案，以允许策略规则的可扩展性，例如如’操作命令，应用范围，资格描述POL10Profile策略规则应当在尝试Profile状态更改时执行。POL11使用Profile策略下载并安装Profile规则’不要禁用’只有当前没有安装其他操作Profile时才可以。POL12 LPA和eUICC应阻止下载和安装包含与已安装Profile的Profile策略规则冲突的Profile策略规则的Profile。注意：技术规范应详尽地描述可能发生的每个冲突。 POL13如果Profile已启用，运营商应能够使用ES6接口停用其Profile的Profile策略规则。注意：在ES6接口上激活Profile策略规则是未来版本的潜在功能。POL14在Profile与Profile策略规则一起安装之前，最终用户应该能够得到有关Profile策略规则的通知，并且如果得到通知，安装将以最终用户身份验证确认为条件。如果RAT直接允许安装，则可能不需要此提示。POL15最终用户同意安装Profile策略规则和Profile下载的请求可以合并为单个提示，因此需要最终用户的单一确认。POL16Profile策略规则应由eUICC中的Profile策略启动器强制执行。POL17Profile策略启动器应仅支持本规范中定义的Profile策略规则。POL18Profile策略启动器应能够支持本规范中定义的所有Profile策略规则。POL19在所有情况下POLAR POL RULE3都是可执行的，但启用Profile除外。注意：POL RULE3被定义为用于尚未完全定义的特定用例，并且不适用于此版本的规范。POL20允许安装具有Profile策略规则的Profile应符合当地法规要求。 4.13.3策略规则POL RULE1应支持Profile策略规则’禁止禁止Profile’。POL RULE2应支持Profile策略规则“不允许删除此Profile”。POL RULE3Profile策略规则“应该在成功禁用时删除此Profile”应该被支持。注意：POL RULE3被定义为用于尚未完全定义的特定用例，并且不适用于此版本的规范。 4.13.4Profile策略启动器要求POLPPE1规则授权表（RAT）应存储在eUICC的Profile策略启动器中。POLPPE2Profile策略启用程序应仅在Profile安装时强制安装RAT的内容（如果有）。POLPPE3 RAT应允许多个Profile所有者在Profile中启用Profile策略规则。POLPPE4 RAT应能够支持特定的配置，允许任何配置文件所有者使用一组或全部配置文件策略规则。POLPPE5 RAT只能在发行前或在初始设备设置期间安装，前提是没有安装操作配置文件。POLPPE6 RAT不受eUICC Memory Reset功能的影响。POLPPE7为了支持可识别的监管要求，RAT应该能够支持特定的配置，该配置可以禁止任何配置文件所有者设置特定的配置文件策略规则。POLPPE8如果设置了POLPPE7，则此信息应为SM-DP +与eUICC共享的资格检查信息的一部分。POLPPE9如果RAT允许安装配置文件的配置文件策略规则，安装应按照POL14中的规定进行。POLPPE10在安装配置文件之前，RAT应能够支持设置以显示配置文件策略规则对最终用户的影响。POLPPE11 OEM或EUM应负责提供RAT。 POLPPE12固定RAT应在eUICC中实施。注意：允许的RAT配置在附件H中有详细说明。 4.14认证4.14.1 eUICC认证CERTEU1 EUM应通过GSMA SAS认证[13]。CERTEU2 EUM应被要求声明eUICC产品符合GSMA SGP.22 V2.0 [24]。CERTEU3 eUICC应根据GSMA（TBD）定义的保护配置文件进行认证。CERTEU4 eUICC保护配置文件至少应包含以下要素：平台服务管理器，ISD-R，配置文件存储和配置文件隔离。CERTEU5 eUICC保护配置文件应与SGP.05 [21]中定义的eUICC保护配置文件相同。CERTEU6 eUICC保护配置文件的评估保证级别应至少（至少）EAL4增加AVA_VAN.5和ALC_DVS.2（EAL 4+）或同等级别。注：FASG需要对保证水平进行研究。CERTEU7用于身份验证的eUICC公钥证书应包含EID。CERTEU8 eUICC公钥证书应包含产品的技术参考，例如Common Criteria认证报告编号。CERTEU9 EUM公钥证书应由GSMA CI签署。CERTEU10 eUICC证书应由EUM使用其EUM证书进行签名。CERTEU11 eUICC私钥不应该是可修改的。CERTEU12如果eUICC私钥是可修改的，则应使用GlobalPlatform规范中定义的机制，使用密钥长度为128位的AES算法对应的最低安全级别。CERTEU13 eUICC应该支持一个安全的机制来更新其EUM证书。CERTEU14 eUICC应该支持更新其CI公钥的安全机制。CERTEU15 eUICC应该支持更新其eUICC证书的安全机制。 4.14.2设备符合性CERTDEV1根据GSMA，对于本地配置文件管理实施的所有部分应该有合规流程。 4.14.3 SM-DP +认证CERTDP1 SM-DP +提供商应被要求声明符合GSMA SGP.22 V2.0 [24]的产品（SM-DP +）。CERTDP2 SM-DP +应根据GSMA SAS [22]进行认证。CERTDP3 SM-DP +元件应使用硬件安全模块（HSM）进行密码相关操作（密钥存储，派生，加密操作）。注意：这将由SAS文档“根据FIPS 140-2 3级或更高级别认证的HSM”涵盖CERTDP4 SM-DP +应实现权限隔离（日志，审计，操作和管理）。CERTDP5 SM-DP +应实施操作系统强化机制。CERTDP6 SM-DP +应实现控制，用户和管理平面的分离。CERTDP7 SM-DP +应使用多重身份验证和管理操作。用于存储配置文件的CERTDP8 SM-DP +硬盘和备份介质将被加密。CERTDP9用于与eUICC进行双向认证的SM-DP +证书私钥应根据CERTDP3进行保护并存储在HSM中。CERTDP10 SM-DP +应实施速率限制机制以减轻DoS攻击。CERTDP11 SM-DP +应记录所有证书认证失败。CERTDP12 SM-DP +公钥证书应由GSMA CI签名。 4.14.4 SM-DS认证CERTDS1 SM-DS提供商应被要求声明产品符合GSMA SGP.22 [24]。CERTDS2 SM-DS应根据相关的GSMA SAS进行认证。CERTDS3 SM-DS应实现特权的隔离（日志，审计，操作和管理）。CERTDS4 SM-DS应实施操作系统强化机制。CERTDS5 SM-DS应实施控制，用户和管理平面的分离。CERTDS6 SM-DS应使用多因素身份验证和管理操作。CERTDS7 SM-DS硬盘驱动器和备份介质应加密。CERTDS8 SM-DS证书应由GSMA CI签署。 4.14.5 LPA认证CERTLPA1对于与远程SIM供应实体通信的所有LPA元素，应该有一个认证过程。CERTLPA2认证过程应确保本地配置文件管理操作仅由授权的LPA元素发送。CERTLPA3认证过程应确保存在阻止受损LPA的机制。CERTLPA4 LPD应在TLS会话期间对SM-DP +进行身份验证。CERTLPA5 LDS应在TLS会话期间对SM-DS进行身份验证。CERTLPA6 LPA应仅接受由GSMA CI签署的证书以进行服务器身份验证。 4.14.6公钥证书管理CERTPK1 eUICC应验证SM-DP +的公钥证书。CERTPK2 LPD应验证SM-DP +的公钥证书。CERTPK3 LDS应验证SM-DS的公钥证书。CERTPK4使用无效公钥证书的SM-DS的LDS身份验证将失败（请参见CERTPK11），并且正在进行的通信应停止。CERTPK5使用无效公钥证书的SM-DP +的LPD认证失败（参见CERTPK11CERTPK1），并且正在进行的通信应停止。CERTPK6使用无效公钥证书的eUICC的SM-DP +认证应失败（参见CERTPK11），并且正在进行的通信应停止。CERTPK7使用无效公钥证书的SM-DP +的eUICC认证应失败（参见CERTPK11），并且正在进行的通信应停止。CERTPK8 GSMA CI应当撤销任何实体（SMDP +，SM-DS，EUM）的公钥证书（如果私钥被盗用）。CERTPK9 eUICC应能够支持一组GSMA CI。CERTPK10在下列情况下，公钥证书应被视为有效：它具有有效签名由GSMA CI或可信任的证书链直至GSMA CI进行签名。证书路径验证应遵循RFC 5280中定义的过程。尚未撤销，且信任链中没有证书已被撤销尚未到期如果这些适用的验证失败，公钥证书应被视为无效。CERTPK11 eUICC，LPA，SM-DS和SM-DP +应知晓撤销的公钥证书。]]></content>
      <tags>
        <tag>GSMA</tag>
        <tag>eSIM</tag>
        <tag>SGP21</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GSMA SGP.21 第五章学习]]></title>
    <url>%2F2018%2F05%2F12%2FGSMA-SGP-21-%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[5操作程序5.1 LPA启动的下载5.1.1 LPA启动的下载要求LID1如果激活码尚未提供，则LPA应使用eUICC上填充的任何Root SM-DS或默认SM-DP +地址.LID2在LID1的上下文中，如果同时填充了根SM-DS和默认SM-DP +地址，则LPA应先联系SM-DP +，然后再联系SM-DS以启动远程SIM配置事务. 5.1.2 LPA启动的下载过程以下过程描述了属于由LPA启动的profile包下载和安装过程的一部分的事件. GSMA-SGP-21-第五章学习 开始条件：a.订户已完成所选运营商/服务提供商优惠的订购流程.b.与此订阅相关的profile订购过程已完成（即，分配的受保护profile包存储在SM-DP +上）. 程序：1.LPA启动profile包下载并识别profile存储并可供下载（通过例如URL，QR码，手动输入等）以及提供的其他信息（例如，令牌，SMDPId，确认码）.2.LPA通过与SM-DP +建立TLS连接来认证SM-DP +，并验证SMDID是否已提供此类信息.3.至4.LPA得到eUICC挑战5.至6. LPA将eUICC质询和任何其他相关信息发送至SM-DP +.7.至9. SM-DP +签署eUICC挑战，并生成一个DP_Challenge发送回eUICC.10.LPA将SM-DP +和AC令牌收到的资料发送给eUICC; eUICC检查SMDPid并验证SM-DP +.11.eUICC将包括DP_Challenge，AC令牌，EID及其证书在内的一组签名信息发送回LPA.12.最终用户确认profile的下载，可选择显示运营商的profile名称.13.LPA将步骤11中收到的一组信息从eUICC发送到SM-DP +.14.SM-DP +验证签名; eUICC已通过认证.15.至16.可选：eUICC资格检查和profile绑定功能由SM-DP +执行.17.至22.可选17.将向运营商通知即将下载的profile包.18.如果操作员已收到通知，可以通过向SM-DP +指示错误代码来请求停止下载过程.19.如果操作员向SM-DP +发送错误代码，则SM-DP +将停止下载过程并向LPA指示错误代码. LPA通知最终用户一个适当的消息.21.至22.SM-DP +可以接收来自运营商的信息以准备适当的profile包.23.至25.绑定的profile包被发送到eUICC并安装在eUICC上.26.profile包下载报告从SM-DP +发送给运营商. 结束条件：a.profile在禁用状态下安装在eUICC中 5.2使用激活码下载profile5.2.1激活码要求AC1如果使用，激活码应触发从特定SM-DP +下载绑定profile包.AC2激活码应包含以下参数：SM-DP +地址激活码令牌（包括可选确认码必需标志）SMDPid（可选）AC3激活码令牌应能够包含一个参数，该参数指示确认码是否需要.如果需要此确认码，则LPA应要求最终用户输入确认码.SM-DP +在交付绑定profile包之前应验证确认码.注意：如何创建确认码并将其提供给最终用户超出了本规范的范围.AC4在交付绑定profile包之前，激活代码应由SM-DP +进行验证.AC5最终用户在LPA中的激活码输入应至少支持手动输入和QR码扫描.AC6所有激活码程序应作为LPA的一部分原生实施.AC7激活码程序应有条件地在初始设备设置期间自动提供给最终用户.如果已经设置了profile，则此自动设置不适用.不需要验证确认.注意：例如，这可能不适用于开放市场cellularenabled笔记本电脑.AC8按照激活码过程，应使用profile包下载程序.AC9激活码程序应保护用户意图的生态系统安全性，隐私和验证.AC10激活码程序应仅用于将profile包下载到目标eUICC的唯一目的.激活码程序应防止将IMEI和EID信息发送给未经认证的SM-DP +.AC11激活码应唯一标识运营商/服务提供商.AC12对特定SM-DP +进行认证后，对SM-DP +的激活码请求应由LPA用EID进行扩展. 5.2.2使用激活码下载profile过程激活码过程定义了一项通用功能，允许用户或最终用户代表用户通过请求从设备本身下载操作profile来“激活”设备. 开始条件：a.认购人已订立认购协议.b.激活码已经提供给最终用户和可选的确认码（旁道）. 过程：1.最终用户通过LUI将激活码输入到LPA.2.LPA解析激活码参数以识别SM-DP +地址，激活码令牌，LPA模式和可选的SMDPid.另外，LPA可以在激活令牌中解析需要确认码的信息.3.如果激活码令牌中的确认码参数设置为“需要确认码”，则会提示最终用户输入由发卡运营商/服务提供商提供给他们的确认码.4.激活码下载程序由LPA启动.LPA向eUICC请求nonceeUICC.5.eUICC创建与支持的eUICC规范版本号（eSVN）关联的nonceeUICC. eUICC将与支持的eSVN相关联的nonceeUICC传输给LPA. LPA将与支持的eSVN关联的nonceeUICC发送到SMDP +.注意：在此步骤之前，应根据存储在设备中的根证书的公钥，在LPA和SM-DP +之间建立一个HTTP会话，其中包括使用TLS证书进行身份验证，并检查是否存在SMDPid用于TLS会话的TLS证书.8.在接收到nonceeUICC和相关的eSVN后，SM-DP +创建nonceSMDP并签署nonceSMDP和nonceeUICC. SM-DP +将签名的nonceeUICC和nonceSMDP发送给LPA. LPA收集激活码参数以及资格程序和可选的确认码所需的设备信息，并将它们与签名的nonceeUICC和nonceSMDP一起发送给eUICC.11.eUICC检查附属于nonceeUICC的签名.如果在AC中配置SMDPid，则eUICC检查LPA提供的SMDPid和SM-DP +证书中的SMDPid是否一致.SM-DP +在此阶段由eUICC认证.eUICC生成将用于会话密钥建立的密钥材料.eUICC使用eUICC私钥签署一系列信息，其中包括：a.nonceSMDPb.eUICC为计算绑定profile包的准备计算会话密钥创建的关键材料c.激活代码参数d.设备和eUICC信息e.可选地，确认码12.除了以下之外，eUICC还将签名的一组信息发送给LPA：a.nonceSMDPb.eUICC为计算绑定profile包的准备计算会话密钥创建的关键材料c.激活代码参数d.设备和eUICC信息e.包含EID的eUICC证书f.EUM证书g.可选的确认码13.LPA将从eUICC收到的全部信息发送给SMDP +.14.SM-DP +使用CI公钥检查EUM证书.SM-DP +检查nonceSMDP的签名; eUICC目前正处于SM-DP +认证阶段.15.SM-DP +根据传输的信息（EID，设备信息，eUICC信息，eSVN）进行资格审查. SM-DP +检查激活码参数和可选的确认码以检索引用的profile包.17.profile包下载到eUICC：a.SM-DP +与eUICC建立会话密钥.b.绑定的profile包基于eUICC会话密钥材料准备并下载并安装在eUICC上.C.确认成功在eUICC上安装profile，并由SM-DP +通知操作员.d.eUICC向LPA确认profile在eUICC上的成功安装，通知最终用户状态. 结束条件：a.绑定的profile包已经下载并安装在处于禁用状态的eUICC上.b.LPA可能会提供最终用户启用的profile. 5.3本地profile管理5.3.1本地profile管理程序5.3.1.1启用profile此过程执行目标profile的启用.该请求由最终用户给予LPA. 开始条件：a.目标profile在eUICC上被禁用.b.目标profile已由最终用户选择.C. LPA向eUICC认证为合法执行本地profile管理. 过程：1.最终用户在LPA上发出profile启用请求.2.用户意图已验证.3.LPA将目标profile的profile启用操作发送给eUICC上的ISD-R.4.ISD-R检查在目标profile上应用的profile策略规则是否允许启用profile5.如果与profile策略规则存在冲突，则ISD-R中止该过程并通过LPA通知最终用户.6.目标profile已启用. ISD-R通知LPA启用profile.8.最终用户通过LPA通知. 结束条件：a.目标profile已启用. 5.3.1.2禁用profile禁用profile可以通过以下步骤来实现.该请求由LPA上的最终用户提供. 开始条件：a.目标profile在eUICC上启用.b.目标profile已由最终用户选择.C. LPA向eUICC认证为合法执行本地profile管理. 过程：1.最终用户在LPA上发出profile禁用请求.2.用户意图已验证.3.LPA向eUICC上的ISD-R发送profile禁用操作.4.ISD-R检查在目标profile上应用的profile策略规则是否允许profile被禁用.5.如果与profile策略规则有冲突，ISD-R将中止该过程并通过LPA通知最终用户. ISD-R禁用目标profile. ISD-R通知LPA禁用profile.8.最终用户通过LPA通知.结束条件：a.目标profile被禁用. 5.3.1.3删除profile通过以下步骤可以实现profile删除.该请求由LPA上的最终用户提供. 开始条件：a.目标profile被禁用.b.目标profile已由最终用户选择c. LPA向eUICC认证为合法执行本地profile管理. 过程：1.最终用户在LPA上发出profile删除请求.2.用户意图已验证.3.LPA将目标profile的profile删除操作发送给eUICC上的ISD-R.该请求包括目标profile的ISD-P AID.4.ISD-R检查是否应用profile策略规则允许删除profile.5.如果与profile策略规则有冲突，ISD-R将中止该过程并通过LPA通知最终用户.6.ISD-R擦除目标profile和相关的ISD-P.7.ISD-R通知LPA删除profile.8.目标profile的profile元数据被删除.9.最终用户通过LPA通知. LPA向profile中删除profile的通知接收器发送删除通知. 结束条件：a.目标profile被删除. 5.3.1.4添加/更新profile昵称添加/更新昵称将允许订户或最终用户将昵称归属到profile以便于使用.请注意，添加或更改昵称不会影响该profile的任何其他数据或其他profile元数据. 开始条件：a.用户意图已被验证.b.目标profile已由最终用户选择.C. LPA向eUICC认证为合法执行本地profile管理. 过程：1.最终用户请求更新LPA上的昵称.2.LPA使用eUICC中最终用户选择的昵称更新目标profile的profile元数据. 结束条件：a.profile目标profile的元数据已更新为最终用户选择的昵称. 5.3.1.5查询profile元数据此过程将允许最终用户查询最终用户可访问的profile的profile元数据.结果应在查询时在eUICC上显示所选profile的全部（或部分）profile元数据.作为此过程的结果，不会对eUICC上的任何数据进行更改. 开始条件：a. LPA被认证为eUICC合法执行本地profile管理.b.最终用户可访问的profile列表由LPA（LUI）显示. 过程：1.最终用户选择要查询的profile.2.LPA收到来自最终用户的查询请求.3.LPA向eUICC请求profile元数据.4.LPA在LUI上向最终用户显示profile元数据. 结束条件：a.没有更改profile元数据. 5.3.1.6 eUICC存储器复位此过程执行eUICC的eUICC存储器复位，包括其关联的profile元数据.该请求由最终用户给予LPA.注意：执行eUICC的eUICC测试存储器复位也将采用类似的步骤. 开始条件：a. LPA向eUICC认证为合法执行本地profile管理.b.eUICC Memory Reset选项由LPA（LUI）显示. 过程：1.最终用户在LPA（LUI）上发出eUICC存储器重置请求.2.用户意图已验证.3.LPA（LUI）向最终用户显示’eUICC Memory Reset’的结果消息.4.最终用户确认符合对LPA的后果.5.LPA向eUICC发送eUICC存储器复位操作. eUICC即使是包含与其关联的profile元数据的已启用profile，也会删除eUICC上的profile. eUICC通知LPA eUICC的eUICC存储器复位.8.通过LPA（LUI）通知最终用户. LPA向profile中删除profile的所有通知接收器发送删除通知. 结束条件：a.profile已从eUICC中删除. 5.3.1.7添加具有激活码的profile此步骤将允许订户添加单个profile.此过程不会启用下载的profile，也不会禁用已启用的profile.假定网络连接.下载可以通过输入激活码来启动. 开始条件：a.用户意图已被验证.b.eUICC允许下载新的profile.C. LPA向eUICC认证为合法执行profile下载.过程：1.最终用户获得激活码以将profile添加到其设备.2.LPA请求最终用户输入激活码.3.按照第5.2.2节开始所述的激活码程序下载profile. 结束条件：a.该profile已安装在最终用户的设备上.b.profile元数据已从profile更新. 5.3.1.8编辑SM-DP +地址此过程将允许最终用户编辑到eUICC的默认SM-DP +地址. 开始条件：a.LPA中有一个默认的SM-DP +地址.b.最终用户愿意编辑默认的SM-DP +地址程序：1.最终用户通过LPA编辑SM-DP +地址.2.需要最终用户的简单确认.3.LPA发送默认的SM-DP +地址以存储在LPA服务中.4.LPA服务通知LPA存储默认SM-DP +地址.5.最终用户通过LPA通知.结束条件：a.目标默认SM-DP +地址在LPA服务中编辑.]]></content>
      <tags>
        <tag>GSMA</tag>
        <tag>eSIM</tag>
        <tag>SGP21</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Osmocom SIMtrace简介]]></title>
    <url>%2F2018%2F05%2F10%2FOsmocom-SIMtrace%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[简介Osmocom SIMtrace是用于被动跟踪SIM卡和手机之间SIM-ME通信的软件和硬件系统。 它通过使用支持USB的AT91SAM7微控制器的T = 0兼容USART工作。 USART在SIM卡和手机之间的ISO 7816-3 / TS 11.11接口上交换时被动接收字节。 接收到的字节通过USB发送到PC，PC上的程序称为simtrace从USB设备收集数据，解析APDU并通过GSMTAP将它们转发到wireshark协议分析器。 特征 完全无源扫描仪 RST和ATR检测 支持PPS / PTS自动波特率 APDU的分割SIMtrace可以用于监视ME-SIM通信，但也可以模拟手机或SIM卡，也可以是MitM。虽然硬件支持所有这些模式，但只有监控方面已经在软件中实现。 TODOSIMtrace是一个社区项目，帮助不仅仅是欢迎。 有些任务需要不需要电子或SIM卡协议方面的知识，只需要非常基本的C编程技能： 使用libusb热插拔API来保持程序跨SIMrtace断开连接一些任务不需要微控制器编程技巧： 扩展/完成SIM协议的wireshark解剖器。以下是其他一些可以改进的方面： 检查奇偶校验错误 验证TCK / PCK校验字节 实施MITM 硬件第一种实现方式使用Olimex SAM7-P64开发板，其中一些I / O线连接到来自RebelSIM_Scanner的机械SIM卡适配器。 如果使用RebelSIM扫描仪，即使只使用线路，也要连接USB。 它需要供电，否则真正的读者往往无法初始化卡。 现在我们有专门的PCB设计。 原理图和Gerber文件是作为开源硬件发布的，并且可以由所有人制作。 但是，那些对从零开始构建它不感兴趣的人可以从http://shop.sysmocom.de/products/simtrace 购买完整的工厂生产，测试和闪存PCB组件 它也可以通过一个独立的适配器与全尺寸SIM卡连接. 链接 SIMtrace_Hardware提供更多详细信息 固件AT91SAM7S器件的固件是通过重复使用OpenPCD的许多代码编写的RFID阅读器。 详细信息可在SIMtrace固件上找到。 文档请检查用户手册的附件。 在那里，你会发现一些提示安装现成的软件包你最喜欢的Linux发行版。 主机PC软件simtrace程序是git：//git.osmocom.org/simtrace.git存储库的一部分。 它将绑定到USB设备并使用UDP / IPv4发送GSMTAP帧到localhost：4729。 前提条件libosmocore和头文件（simtrace_usb.h）。 其他软件包：1sudo apt-get install libusb-1.0-0-dev 编译：123git clone git://git.osmocom.org/simtrace.gitcd simtrace/host/make 访问它添加udev规则，以便能够使用simtrace并以非root用户身份访问设备（只需要在osmocom组中）12345678sudo groupadd osmocomsudo adduser $USERNAME osmocomsudo tee /etc/udev/rules.d/10-osmocom.rules &lt;&lt; EOF# to use, install this file in /etc/udev/rules.d as 10-osmocom.rules# rule to grant read/write access on SIMtrace to group named osmocom.SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idProduct&#125;==&quot;0762&quot;, ATTRS&#123;idVendor&#125;==&quot;16c0&quot;, MODE=&quot;0660&quot;, GROUP=&quot;osmocom&quot; EOFsudo service udev reload 您必须注销并重新登录才能生效。 使用它简单地开始simtrace。它将发送GSMTAP帧到UDP / IPv4 localhost：4729。 它还会将帧的hexdumps打印到控制台，如下所示：1234567891011121314151617181920sudo ./simtraceAPDU: (9): a0 a4 00 00 02 6f 07 9f 0fAPDU: (22): a0 c0 00 00 0f 00 00 00 09 6f 07 04 00 15 00 15 01 02 00 00 91 78APDU: (9): a0 a4 00 00 02 6f 38 9f 0fAPDU: (22): a0 c0 00 00 0f 00 00 00 09 6f 38 04 00 15 00 55 01 02 00 00 91 78APDU: (16): a0 b0 00 00 09 ff 3f ff ff 00 00 3f 03 00 91 78APDU: (9): a0 a4 00 00 02 6f ad 9f 0fAPDU: (8): a0 b0 00 00 01 00 91 78APDU: (9): a0 a4 00 00 02 6f 07 9f 0fAPDU: (16): a0 b0 00 00 09 08 49 06 20 11 49 00 11 06 91 78APDU: (9): a0 a4 00 00 02 6f 7e 9f 0fAPDU: (18): a0 b0 00 00 0b ff ff ff ff 64 f0 00 ff fe 00 03 91 78APDU: (9): a0 a4 00 00 02 6f 78 9f 0fAPDU: (9): a0 b0 00 00 02 00 01 91 78APDU: (9): a0 a4 00 00 02 6f 74 9f 0fAPDU: (23): a0 b0 00 00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 91 78APDU: (9): a0 a4 00 00 02 6f 20 9f 0fAPDU: (16): a0 b0 00 00 09 ff ff ff ff ff ff ff ff 07 91 78APDU: (9): a0 a4 00 00 02 6f 30 9f 0fAPDU: (22): a0 c0 00 00 0f 00 00 00 f0 6f 30 04 00 11 00 55 01 02 00 00 91 78 Wireshark集成有一个实验补丁，也是simtrace.git软件包的一部分。 它也包含在wireshark开发者版本中（因为wireshark 1.7.1）。 在wireshark中查看APDU： 在本地主机上SIMtrace自动在本地打开一个UDP接收器，不需要做任何事情 在另一台机器上获取数据 在另一台机器上启动一个用于GSMTAP的UDP接收器（不要在netcat“连接”时使用） 1socat -u udp-recv：4729 / dev / null 告诉SIMtrace要转发哪台机器 1./simtrace -i 192.168.0.1 协议解析远远没有完成，补丁总是受欢迎的！ 其他软件simlabTrace似乎能够使用MITM，并且似乎也有一个使用SIMtrace作为读卡器的CCID驱动程序。 联系人/邮件列表对于任何与开发或使用有关的问题，都有一个邮件列表[mailto：simtrace@lists.osmocom.org]，您可以在http://lists.osmocom.org/mailman/listinfo/simtrace 订阅/取消订阅它并阅读 档案在http://lists.osmocom.org/pipermail/simtrace/ 请确保您在开始发布之前阅读MailingListRules。 Osmocom SIMtrace Hardware此页面专门用于Osmocom SIMtrace的硬件，如下所示： 您可以在sysmocom商店购买该设备。 连接器 USB：USB mini-B连接器。主要连接器。主机软件通过USB与电路板进行通信（嗅探，…）。它也可以用来闪存微控制器（使用DFU）。 串行：2.5毫米插孔串行电缆，由osmocomBB使用。用于调试设备的端口（printf去那里）。 调试（P2）：与串行相同，但使用FTDI串行电缆。建议在将电缆插入simtrace之前，先切断6pin FTDI连接器的电压线。 jtag（P1）：JTAG 20针连接器，用于进行硬件辅助调试。 BT1：电池连接器（4.5-6V DC）。通常USB提供电源，但电池端口可用于自主使用SIMtrace。嗅探的数据可以保存在闪存（U1）中。 FFC_SIM（P3）：将扁平柔性电缆与SIM端连接起来用于电话。 SIM（P4）：将您的SIM卡放在那里（而不是在手机中） 重置（SW1）：重置主板（不擦除固件）。如果你太懒惰拔掉并重新插上USB。 引导加载程序（SW2）：用于启动引导加载程序以使用DFU闪存设备。插入USB时按下。 测试（JP1）：使用SAM-BA使用跳线短路闪烁。 擦除（JP2）：使用跳线短路以完全擦除固件。 电路图原理图，Gerber文件等可以在simtrace.git存储库的’hardware’子目录中找到：http://cgit.osmocom.org/cgit/simtrace/tree/hardware （网页浏览）git：//git.osmocom.org/simtrace（git clone URL）我们使用Kicad作为EDA工具。大部分关于原理图和Gerber文件的工作都由Kevin Redon完成，基于Harald Welte的原始设计。 最新原理图的PDF格式图也可作为此页的附件。 互连硬件原理图非常非常简单： 将SIM-RST与PA7连接 将SIM-I / O与PA6和PA1连接 将SIM-CLK与PA2和PA4连接 将SIM-GND与GND连接 操作模式AT91SAM7S的USART能够T = 0。文档只提及它在时钟主模式，就像你一样会在智能卡读卡器中运行，积极与智能卡通话。但是，通过使用USART输入时钟多路复用器，您可以使用外部生成的CLK，如手机SIM卡插槽中的那个。 不幸的是，USART的Rx超时功能在T = 0模式下不工作，所以我不得不重新实现Rx超时（等待时间）通过TC（定时器/计数器）模块0进行处理。由于技术限制，我们将等待最多一个字节（12 etu）比我们应该。 ModiSIMtrace可以用作： 嗅探器 读卡器 卡模拟器 人在这方面的中间人SAM7S提供2个T = 0的USART端口。一个连接到手机（PA21-PA27），另一个连接到SIM（PA1-PA7）。线路通过总线开关从手机传输到SIM卡（IC4 = CB3Q3244）。总线交换机提供4条线路的2条总线： 第一个用于转发RST，CLK和VPP（在SIM和电话之间）。它由SC_SW（PA20）控制， 第二个用于转发I / O（在SIM和电话之间）。它由SC_I / O（PA19）控制，各种修改需要中断不同的线路： SW_SC（PA20）|SC_I / O（PA19）|描述|方式L| L|电话和SIM直接连接|嗅探器（使用任何USART端口）L| H|只有I / O中断|MitM（使用两个USART端口）H| H|手机和SIM卡未连接|读卡器，仿真器（使用每个USART端口）截至目前，仍然只有嗅探器在固件中实现 SIM卡支持各种类别（电压等级）：A类= 5.0V，B类= 3.0V，C类= 1.8V。SIMtrace v1.x仅支持B类（3.0V），所有实际SIM卡和手机也支持。为确保使用B类，SIMtrace通过将VCC线保持在该电压下强制3.3V（在3.0V±10％规格内）。SIMtrace v2将支持所有3个类。]]></content>
      <tags>
        <tag>SIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SIM APDU学习]]></title>
    <url>%2F2018%2F05%2F10%2FSIM-APDU%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[APDU指令集合——http://wenku.baidu.com/link?url=izxxB9oST52KgsxYxmPuZL61ahylkzptrTuj5hz8aMoZBvGcC6bMWl2Yu1OtpNerBW-py2sh3bor7CP91SxsyMeThs5OC_f0HNsAGRg5fCy apdu基本命令——http://www.xuebuyuan.com/584607.html SIM之APDU指令格式——http://blog.csdn.net/s762888517/article/details/7033603 简单apdu指令返回局分析——http://blog.sina.com.cn/s/blog_8887f2c30101dn3a.html APDU经验——http://wenku.baidu.com/link?url=8jiHwXGYc80Q1-wizcbCqxq47zeq1mQblaXNd4iyHzznfqMK0dTcWJ3G4eO6a3R9IjngrnFg6I4ItbUEmk_s-h6f0cnsSonTXv4eaAJRFQW 智能卡APDU命令格式及分析——http://befairy.iteye.com/blog/908473 IC卡完整交易APDU命令附分析 ——http://download.csdn.net/download/albinzhiyu/8045337]]></content>
      <tags>
        <tag>SIM</tag>
        <tag>APDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eSIM 简介]]></title>
    <url>%2F2018%2F05%2F10%2FeSIM-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[翻译自eSIM eSIMeSIM被称为许多不同的名字。 有人说嵌入式SIM，有人说电子SIM和其他的说eSIM。 在行业标准最终确定并在该地区广泛采用之前，还会有其他名称出现。 无论我们称之为什么，此SIM的基本思想是将SIM（UICC）作为用户设备（例如，M2M终端，移动电话等）的不可移除/固定组件分发。设备制造商对SIM卡进行编程以加载特定情况所需的不同信息集（例如位置，网络运营商等）。 Why eSIM ?对于一些正在从事现代开发和设备测试工作的人来说，这听起来像是违反直觉的演变路径，因为“任何固定/不可移动”可能意味着“灵活性较低，可控性较差”。那么这种概念如何越来越频繁地被讨论（截至2015年8月）。 在工程方面，对于任何重新出现的事情，都有一些原因/动机。SIM这个新概念的原因/动机是什么？ 我认为最大的动机与M2M/IoT设备有关。 与手机（智能手机）不同，大多数M2M/物联网设备不易重新连接，即使可以重新连接，也可能无法轻松切换并插入SIM卡。因此，将UICC作为附属于每个设备的固定芯片组提出了一个新想法。如果我们把它作为一个固定的芯片来实现，我们会碰到一个很大的问题。在大多数情况下，在设备制造之前，您不知道芯片（SIM）中应存储哪种信息。您不知道该设备销售给哪个网络运营商以及它们安装在哪个位置。所以你必须使它可编程，所以我们只是根据不同的需求进行编程而不是更换SIM卡。还有一些机械问题。由于可移动卡的电接触不如具有焊接电接触的eSIM卡那样坚固，所以可移除类型的SIM将不适合于那些在汽车或某些工业环境中一致振动的产品。eSIM卡的另一个重要动机是成本问题。根据GSMA的报告，可移动SIM卡的成本几乎是eSIM卡的10倍最后，我们也可以考虑物流问题。想想当你想把手机带到没有漫游或者漫游过于昂贵的地区时你需要做什么。在这种情况下，您需要从当地运营商处订购本地SIM卡，并手动更换手机上的SIM卡。当你想更改订阅网络运营商时也会发生类似的情况。如果您的车与移动连接的情况相似，情况可能会更加麻烦。您需要订购一张新的SIM卡，并将汽车送至经销商店以更换SIM卡。由于SIM卡更换不当，汽车制造商不允许您自行更换这些卡。总之，无论如何，似乎有很多理由向eSIM卡迈进。 它是否仅用于M2M设备？它似乎不仅仅局限于M2M/物联网设备，而且似乎也有将这项技术应用于移动电话的趋势。阅读以下文章。苹果，三星将采用GSMA支持的电子SIM卡 苹果，三星正在与电信集团谈判推出e-Sim卡 如何编程（提供）SIM卡现在的问题是如何将信息（配置文件）加载到设备中的每个eSIM卡？ 最简单的想法是实现一个直接连接到eSIM的特殊编程端口并将信息加载到其中，但理想的（最终目标）是通过无线方式加载信息（配置文件）（这称为“远程配置”）。 关键问题是如何设计/实施远程配置。 由于这种远程配置应适用于不同供应商的设备并适用于不同的网络运营商，因此应该制定一些国际标准和非常详细的程序（协议）。 目前，GSMA正在领导这项活动。 尽管规范尚未最终确定（截至2015年8月），但您可以从GSMA文档中了解到远程供应流程的详细信息：嵌入式SIM远程供应架构（访问参考资料1查找文档） eUICC架构/信息流以下是根据GSMA技术规范修改的整体架构和信息流程。 （我只是虚线下方的一些项目，虚线以上的所有内容与GSMA技术规范中的完全相同：GSMA-Embedded-SIM-Remote-Provisioning-Architecture-Version-1.1中的图1）。 现在大多数读者（包括我自己）可能都不熟悉这些实体（2015年8月），并且这些实体之间的相互关系也相当复杂。 大多数人只会对这里显示的几条路线感兴趣（或参与）。 我将继续更新这些实体之间可能的路径组合（交互）的描述。图1：eSIM操作的功能架构 &lt; Path Example 1 : (1), (2), (3) &gt;可能这可能是一种最小的功能流。首先，SM-DP应从EUM（eUICC制造商）那里获得编程eUICC所需的必要工具或服务。接下来，SM-DP应从MNO（移动网络运营商）获取输入数据，该数据将用于为目标eUICC创建配置文件（或多个配置文件）。输入数据的一些例子如下: 要创建的配置文件数量 IMSI值或范围 ICCID值或范围 非个人化的配置文件类型 关于目标eUICC的信息，例如EID SM-SR如何与eUICC通信？SM-SR如何与eUICC通信？这是我个人最感兴趣的地方（您可能对其他部分更感兴趣）。这种沟通应该是无线的？然后你可能会问’哪种OTA技术’以及哪个特定的无线电消息将被用来传输这些信息。 我认为这应该由每个MNO决定，每个MNO将使用不同的技术。 GSMA规范提到了一些可能的机制如下。 （在参考文献[1]中，A.2节MNO-SM-DP接口部分描述如下）。 目标eUICC及其SM-SR上的所有相关已知信息，例如：SM-SR支持与eUICC通信的方法（例如，通过LTE / EPS支持通过HTTP的SMS和/或RAM）一旦确定了这种OTA机制，在参考文献[1]的以下部分的以下章节中将较高层协议相对清楚地定义，3.5.1 SMU SR上的eUICC注册3.5.3配置文件排序3.5.4配置文件下载和安装3.5.5主删除3.5.6配置文件启用3.5.7配置文件通过SM-DP启用3.5.8配置文件禁用3.5.9 ISD-P删除3.5.10通过SM-DP删除ISD-P3.5.11 SM-SR更改 配置文件中有什么？配置文件是一组UICC参数，需要附加网络并执行设备订阅的各种功能。大致有三类信息如下。 （根据GSMA规范（参考文献[1]）第3.4.1节） i）认证/安全算法参数：算法在大部分现场网络中都是Milenage。或者如果它被配置用于测试，它可以是3GPP测试算法。参数如下。OPC/RI/CI/ķii）配置文件附带的政策规则iii）描述的其他UICC参数TS 31.102（其中许多参数可能与策略规则相关） 常见用例截至目前（2015年9月），即使在某些情况下eUICC用于硬件方面，也没有通用的eUICC Profile更新方法的国际标准。所以，这里列出的使用模式将是一种想法级别。 情况1：eSIM被嵌入在设备中，并且IMEI（设备ID）和ICCID（UICC序列号）被通知给最终用户（或特定的服务中心）。然后，最终用户（或服务中心）可以要求网络运营商（MNO）激活eUICC。 参考：[1]机器对机器的远程SIM配置：GSMA站点发布大部分信息[2] TS 31.102通用用户识别模块（USIM）应用的特性：本文档描述UICC参数的所有参数和格式。[3] TS 31.103 IP多媒体业务标识模块（ISIM）应用的特性：格式类似于31.102，但它携带有关IMS业务的信息/参数[4] 2015年M2M峰会| Patrick Biget - “GSMA eUICC远程供应架构”（YouTube）[5] GSMA Connected Living：嵌入式SIM卡简介[6] GSMA嵌入式SIM规范：标准化和SIM互操作性[7]嵌入式UICC技术规范3.0版 - 2015年6月30日的远程供应架构]]></content>
      <tags>
        <tag>eSIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google I/O 2018: Google Keynote]]></title>
    <url>%2F2018%2F05%2F09%2FGoogle-I-O-2018-Google-Keynote%2F</url>
    <content type="text"><![CDATA[Google AI链接诊断糖尿病视网膜病变 预测心血管风险 预测医疗事件 智能语音分离这个在Andrew NG的课程中已经有的。 支持莫尔斯电码输入 Gmail Tab智能补全 Google Photos自动识别并处理 TPU更新 google assistants链接任何时候hey google唤醒，支持更加自然的对话，并且支持连续的上下文。 Google News Android P 更加智能 更加简单 更加顺手 更加智能推出ML KitML Kit beta以强大且易于使用的软件包为移动开发人员带来Google的机器学习专业知识。链接 Google MapsVPS—结合摄像头和地图，更加真实 Google Lens文字OCR识别，并自动查询 识别物体 Google自动驾驶即使下雪天也能很好的识别 AndroidAndroid APP Bundle innovative distribution faster development increased engagement app dynamic delivery Android Jetpack链接Jetpack是一套库，工具和体系结构指南，可帮助轻松快捷地构建卓越的Android应用程序。提供了常见的基础架构代码，Android Jetpack加速Android开发。 Android Slices链接Slices是UI模板，可以在Google搜索应用中显示来自应用的丰富，动态和交互式内容，以及之后在其他位置显示Google智能助理。 通过在全屏应用体验之外启用参与，切片可以帮助用户更快地执行任务。 您可以将切片构建为应用操作的增强。 Android Jetpack内置了对Slices的支持，并可以一直延伸到Android 4.4，大约占所有Android用户的95％。 lighthouseLighthouse 是一个开源的自动化工具，用于改进网络应用的质量。 您可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 您为 Lighthouse 提供一个您要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。 AMP链接AMP项目是一项开源计划，目的是使网络更好。 该项目能够创建在设备和分销平台上始终如一地快速，美观和高性能的网站和广告。 material themingGoogle设计链接 cloud TPU在 Cloud TPU 上运行机器学习工作负载，并从 Google Cloud Platform 领先业界的存储、网络和数据分析技术中获益。链接 cloud AI链接Google Cloud 的 AI 提供最新的机器学习服务、预先训练的模型以及一项可让您生成定制模型的服务。与其他大规模机器学习系统相比，我们基于神经网络的 ML 服务具有更好的训练性能，准确性更高。我们的服务具有速度快、可扩展以及易于使用的特点。主要的 Google 应用都在使用 Cloud Machine Learning，包括 Google 照片（图片搜索）、Google 应用（语音搜索）、翻译和 Inbox（智能回复）。我们的平台现以云服务的形式提供，可为您的业务应用带来无与伦比的规模和速度。 大规模机器学习服务 强大的职位搜索和发现 强大的视频分析 强大的图片分析 强大的语音识别 强大的文字分析 快速的动态翻译 tensorflowTensorFlow.js链接 TensorFlowLiteTensorFlowLite+Raspberry Pi链接 ML KitML Kit beta以强大且易于使用的软件包为移动开发人员带来Google的机器学习专业知识。链接 FireBase + fabricfabricFireBase.Firebase 可以帮助您构建更出色的移动应用并推动业务增长。 ARCoreARCore借助ARCore，构建新的增强现实体验，无缝融合数字世界和物理世界。 以Google的规模改变人们玩，购物，学习，创造和体验世界的方式。]]></content>
      <tags>
        <tag>google IO</tag>
        <tag>新技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scipy找不到lena]]></title>
    <url>%2F2018%2F05%2F03%2Fscipy%E6%89%BE%E4%B8%8D%E5%88%B0lena%2F</url>
    <content type="text"><![CDATA[scipy.misc.lena AttributeError: ‘module’ object has no attribute ‘lena’在数据可视化的那本书上看到的demo，不过运行不通过，然后出现上面的那个错误，lena函数看起来被移除了。 123456import scipy.misclena=scipy.misc.lena()plt.gray()plt.imshow(lena)plt.colorbar()plt.show() Error：lena=scipy.misc.lena()AttributeError: ‘module’ object has no attribute ‘lena’ 在scipy 1.0.0版本上已经移除了lena图的数据了。 不过替换了一张其他的图片。 在misc目录下看到一个叫ascent的data， 替换这个函数后：scipy.misc.ascent()后，显示一个楼梯的图片。只能凑合着用吧。 lena图自己上网找一张然后数字化就好了。]]></content>
      <tags>
        <tag>scipy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美国算什么-薛涌-云图]]></title>
    <url>%2F2018%2F05%2F02%2F%E7%BE%8E%E5%9B%BD%E7%AE%97%E4%BB%80%E4%B9%88-%E8%96%9B%E6%B6%8C-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[《美国算什么》作者薛涌，以自己对美国政治及整个国民生存状态的敏锐关注，捕捉到了美国作为世界大国面临的种种问题及对中国某些现状的启示。书中涉猎到美国大选，美国的基础设施，美国的精神分裂，“新美国”是个什么样子等等为人关注的问题。]]></content>
      <tags>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笑傲江湖-金庸-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E7%AC%91%E5%82%B2%E6%B1%9F%E6%B9%96-%E9%87%91%E5%BA%B8-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[《笑傲江湖》是金庸1967年写的一部武侠小说，属于金庸的后期作品。]]></content>
      <tags>
        <tag>小说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自卑与超越-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E8%87%AA%E5%8D%91%E4%B8%8E%E8%B6%85%E8%B6%8A-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[《自卑与超越》内容简介：阿尔弗雷德·阿德勒是与弗洛伊德齐名的心理学大师，他的心理学观点不仅适用于父母和了女间的关系，而且也可以涵盖师生关系。在维也纳，阿德勒有众多的追随者。1927年，他受聘为哥伦比亚大学讲座教授。1932年，他又受聘为日本长岛医学院教授。1935年，他创办了国际个体心理学学刊。1937年，阿德勒受聘赴欧洲讲学。由于四处争聘，他有时甚至一天之内要分赴两个城市演讲。由于过分劳累，他终于因为心脏病发作，猝死在苏格兰亚伯丁市的街道上。]]></content>
      <tags>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丑陋的中国人-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E4%B8%91%E9%99%8B%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[我们的丑陋，来自我们不知道自己丑陋。台湾著名作家柏杨以恨铁不成钢的态度，强烈批判中国人的脏、乱、吵、窝里斗、不能团结、死不认错等，指出中国传统文化有一种滤过性疾病使我们的子子孙孙受感染，到今天也不能痊愈。]]></content>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人工智能-李开复-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD-%E6%9D%8E%E5%BC%80%E5%A4%8D-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[第一章人工智能来了人类，你好！无处不在的人工智能到底什么是人工智能？ 第二章AI复兴：深度学习+大数据=人工智能第三次AI热潮：有何不同？图灵测试与第一次AI热潮语音识别与第二次AI热潮深度学习携手大数据引领第三次AI热潮 第三章人机大战：AI真的会挑战人类？AlpaG带给人类的启示究竟是什么？奇点来临？今天的人工智能还不能做什么？ 第四章AI时代：人类将如何变革？从工业革命到文艺复兴AI会让人类大量失业吗？自动驾驶：AI最大的应用场景智慧金融：AI目前最被看好的落地领域智慧生活：从机器翻译到智能超市智慧医疗：AI将成为医生的好帮手艺术创作：AI与人类各擅胜场人类将如何变革？ 第五章机遇来临：AI先行的创新与创业大时代，大格局AI创业是时代的最强音AI是中国创新、创业的最好机会创新工场的AI布局第六章迎接未来：AI时代的教育和个人发展AI时代该如何学习？AI时代该学什么？AI时代的教育要关注什么？有了AI，人生还有意义吗？]]></content>
      <tags>
        <tag>科技</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑客与画家-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[《黑客与画家:硅谷创业之父Paul Graham文集》是硅谷创业之父Paul Graham的文集，主要介绍黑客即优秀程序员的爱好和动机，讨论黑客成长、黑客对世界的贡献以及编程语言和黑客工作方法等所有对计算机时代感兴趣的人的一些话题。书中的内容不但有助于了解计算机编程的本质、互联网行业的规则，还会帮助读者了解我们这个时代，迫使读者独立思考。 《黑客与画家:硅谷创业之父Paul Graham文集》适合所有程序员和互联网创业者，也适合一切对计算机行业感兴趣的读者。]]></content>
      <tags>
        <tag>科技</tag>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人民的名义-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E4%BA%BA%E6%B0%91%E7%9A%84%E5%90%8D%E4%B9%89-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[为充分展现中央“坚持以零容忍态度惩治腐败”的反腐精神和国家当前轰轰烈烈、气势如虹的反腐斗争局面，素有“中国政治小说第一人”美誉的著名作家、编剧周梅森先生潜心八年，于2017年再次推出大型现实主义题材长篇力作——《人民的名义》，一部反腐高压下中国政治和官场生态的长幅画卷。本书讲述了最高人民检察院反贪总局侦查处处长侯亮平临危受命，调任地方检察院审查某贪腐案件，与腐败分子进行殊死较量的故事，艺术再现了新时代、新形势下党和国家反腐征程的惊心动魄，深情讴歌了反腐斗士的坚定信仰和无畏勇气，并最终揭示出党的领导干部应如何树立正确的权力观这一宏大的政治主题。]]></content>
      <tags>
        <tag>小说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[管道的故事-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E7%AE%A1%E9%81%93%E7%9A%84%E6%95%85%E4%BA%8B-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[我们都生活在一个“提桶”的世界里：干一天的活儿拿一天的工钱，干一个月的工作领一个月的薪水。无论你是年收入不到1万元的洗碗工，还是年薪过百万的白领，你都是用一份时间去换一份金钱。如果你被解雇，或因患病、受伤无法继续工作，你的收入就会马上停止。不提桶，就没有收入！ 如何摆脱时间换金钱的陷阱？如何获得真正的财务保障？只有管道！ 本书将告诉你，为什么要建造管道，以及如何建造管道，让你彻底摆脱“提桶人”的命运，实现真正的财务自由！]]></content>
      <tags>
        <tag>理财</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Python写网络爬虫-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E7%94%A8Python%E5%86%99%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[《用Python写网络爬虫》作为使用Python来爬取网络数据的杰出指南，讲解了从静态页面爬取数据的方法以及使用缓存来管理服务器负载的方法。此外，本书还介绍了如何使用AJAX URL和Firebug扩展来爬取数据，以及有关爬取技术的更多真相，比如使用浏览器渲染、管理cookie、通过提交表单从受验证码保护的复杂网站中抽取数据等。本书使用Scrapy创建了一个高级网络爬虫，并对一些真实的网站进行了爬取。 《用Python写网络爬虫》介绍了如下内容： 通过跟踪链接来爬取网站；使用lxml从页面中抽取数据；构建线程爬虫来并行爬取页面；将下载的内容进行缓存，以降低带宽消耗；解析依赖于JavaScript的网站；与表单和会话进行交互；解决受保护页面的验证码问题；对AJAX调用进行逆向工程；使用Scrapy创建高级爬虫。 本书读者对象本书是为想要构建可靠的数据爬取解决方案的开发人员写作的，本书假定读者具有一定的Python编程经验。当然，具备其他编程语言开发经验的读者也可以阅读本书，并理解书中涉及的概念和原理。]]></content>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R语言实战-云图]]></title>
    <url>%2F2018%2F04%2F28%2FR%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[目录第一部分 入门第2章 创建数据集第3章 图形初阶第4章 基本数据管理第5章 高级数据管理 第二部分 基本方法第6章 基本图形第7章 基本统计分析 第三部分 中级方法第8章 回归第9章 方差分析第10章 功效分析第11章 中级绘图第12章 重抽样与自助法 第四部分 高级方法第13章 广义线性模型第14章 主成分和因子分析第15章 处理缺失数据的高级方法第16章 高级图形进阶后记：探索R的世界 357附录A 图形用户界面 359附录B 自定义启动环境 362附录C 从R中导出数据 364附录D 制作出版级品质的输出 366附录E R中的矩阵运算 374附录F 本书中用到的扩展包 376附录G 处理大数据 381附录H 更新R 383]]></content>
      <tags>
        <tag>R语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拆掉思维里的墙-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E6%8B%86%E6%8E%89%E6%80%9D%E7%BB%B4%E9%87%8C%E7%9A%84%E5%A2%99-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[第一章 你是不是安全感的奴隶第二章 让有趣的生命扑面而来第三章 心智模式决定我们的命运第四章 成功学不能学第五章 如何找到热衷一生的事业第六章 原来我还可以这样活第七章 幸福是一种转换力第八章 上天不需要你成功，它只需要你尝试第九章 成长为自己的样子——给残酷世界的温暖规划]]></content>
      <tags>
        <tag>励志</tag>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老人与海-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E8%80%81%E4%BA%BA%E4%B8%8E%E6%B5%B7-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[故事讲述了一个老人独自在海上捕鱼，接连几个月没有收获，后来他钓到一条很大的旗鱼，跟它缠斗了两天两夜，用鱼枪把它刺死；但在返回的途中遇到鲨鱼的袭击，缺乏帮手和工具的老人虽然杀了几条鲨鱼，但旗鱼被其他鲨鱼吃光了，等他进港时，旗鱼只剩下一副骨头。 《老人与海》出版后引发巨大轰动，海明威凭此作品荣获第54届诺贝尔文学奖。]]></content>
      <tags>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[白夜行-东野圭吾-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E7%99%BD%E5%A4%9C%E8%A1%8C-%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[日本第一畅销书作家，文坛天王东野圭吾里程碑力作。日本亚马逊、纪伊国屋、三省堂畅销排行第1名，韩国阿拉丁、YES24、教保文库畅销排行第1名。同名日剧创造日本2007年度收视率纪录。绝望的念想，非恸的守望！我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。我从来就没有太阳，所以不怕失去。只希望能手牵手在太阳下散步，这个象征故事内核的绝望念想，有如一个美丽的幌子，随着无数凌乱、压抑、悲凉的故事片段像纪录片一样。]]></content>
      <tags>
        <tag>文学</tag>
        <tag>小说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平凡的世界-路遥-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E5%B9%B3%E5%87%A1%E7%9A%84%E4%B8%96%E7%95%8C-%E8%B7%AF%E9%81%A5-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[一个农村家庭的十年奋斗史。一种精神会成为你的信仰，一部作品会照亮你的一生！劳动与爱情，挫折与追求，痛苦与欢乐，日常生活与巨大社会冲突……《平凡的世界》，不平凡的人生！全景式地表现中国当代城乡社会生活，高度浓缩了中国西北农村的历史变迁过程，深刻地展示了普通人在大时代历史进程中所走过的艰难曲折的道路，这就是路遥和他的《平凡的世界》。]]></content>
      <tags>
        <tag>文学</tag>
        <tag>小说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小王子-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E5%B0%8F%E7%8E%8B%E5%AD%90-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[小王子是一个超凡脱俗的仙童，他住在一颗只比他大一丁点儿的小行星上。陪伴他的是一朵他非常喜爱的小玫瑰花。但玫瑰花的虚荣心伤害了小王子对她的感情。小王子告别小行星，开始了遨游太空的旅行。他先后访问了六个行星，各种见闻使他陷入忧伤，他感到大人们荒唐可笑、太不正常。只有在其中一个点灯人的星球上，小王子才找到一个可以作为朋友的人。但点灯人的天地又十分狭小，除了点灯人他自己，不能容下第二个人。在地理学家的指点下，孤单的小王子来到人类居住的地球。 小王子发现人类缺乏想象力，只知像鹦鹉那样重复别人讲过的话。小王子这时越来越思念自己星球上的那枝小玫瑰。后来，小王子遇到一只小狐狸，小王子用耐心征服了小狐狸，与它结成了亲密的朋友。小狐狸把自己心中的秘密——肉眼看不见事务的本质，只有用心灵才能洞察一切——作为礼物，送给小王子。用这个秘密，小王子在撒哈拉大沙漠与遇险的飞行员一起找到了生命的泉水。最后，小王子在蛇的帮助下离开地球，重新回到他的B612号小行星上。 童话描写小王子没有被成人那骗人的世界所征服，而最终找到自己的理想。这理想就是连结宇宙万物的爱，而这种爱又是世间所缺少的。因此，小王子常常流露出一种伤感的情绪。作者圣埃克絮佩里在献辞中说：这本书是献给长成了大人的从前那个孩子。 《小王子》不仅赢得了儿童读者，也为成年人所喜爱，作品凝练的语言渗透了作者对人类及人类文明深邃的思索。它所表现出的讽刺与幻想，真情与哲理，使之成为法国乃至世界上最为著名的一部童话小说。]]></content>
      <tags>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致加西亚的信-哈伯德-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E8%87%B4%E5%8A%A0%E8%A5%BF%E4%BA%9A%E7%9A%84%E4%BF%A1-%E5%93%88%E4%BC%AF%E5%BE%B7-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[《致加西亚的信》主要内容：美西战争爆发以后，美国必须立即与古巴起义军的首领加西亚取得联系，并获得他的合作。加西亚在古巴的深山里——没有人知道他的确切地点，所以无法与他取得联系。有人向总统推荐：“有一个名叫罗文的人，有办法找到加西亚，也只有他才能找得到。”他们找来罗文，交给他一封写给加西亚的信。三周后，罗文徒步走过一个危机四伏的国家，把那封信交给了加西亚。罗文的事迹也被传为佳话。]]></content>
      <tags>
        <tag>文学</tag>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苏菲的世界-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E8%8B%8F%E8%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[以小说的形式，通过一名哲学导师向一个叫苏菲的女孩传授哲学知识的经过，揭示了西方哲学史发展的历程。由前苏格拉底时代到萨特，以及亚里士多德、笛卡儿、黑格尔等人的思想都通过作者生动的笔触跃然纸上，并配以当时的历史背景加以解释，引人入胜。评论家认为，对于那些从未读过哲学课程的人而言此书是最为合适的入门书，而对于那些以往读过一些哲学而已忘得一干二净的人士，也可起到温故知新的作用。]]></content>
      <tags>
        <tag>文学</tag>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个人的朝圣-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9C%9D%E5%9C%A3-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[哈罗德·弗莱，六十岁，在酿酒厂干了四十年销售代表后默默退休，没有升迁，既无朋友，也无敌人，退休时公司甚至连欢送会都没开。他跟隔阂很深的妻子住在英国的乡间，生活平静，夫妻疏离，日复一日。 一天早晨，他收到一封信，来自二十年未见的老友奎妮。她患了癌症，写信告别。震惊、悲痛之下，哈罗德写了回信，在寄出的路上，他由奎妮想到了自己的人生，经过了一个又一个邮筒，越走越远，最后，他从英国最西南一路走到了最东北，横跨整个英格兰。87天，627英里，只凭一个信念：只要他走，老友就会活下去！ 这是哈罗德千里跋涉的故事。从他脚步迈开的那一刻起，与他六百多英里旅程并行的，是他穿越时光隧道的另一场旅行。]]></content>
      <tags>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[麦田里的守望者-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E9%BA%A6%E7%94%B0%E9%87%8C%E7%9A%84%E5%AE%88%E6%9C%9B%E8%80%85-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[《麦田里的守望者》的主人公，１６岁的中学生霍尔顿·考尔菲德是当代美国文学中最早出现的反英雄形象之一。霍尔顿出身在纽约一个富裕的中产阶级的家庭。学校里的老师和自己的家长强迫他好好读书，为的是“出人头地，而他看不惯周围的一切，根本没心思用功读书，因而老是挨罚。他的内心又十分苦闷、彷徨，这种精神上无法调和的极度矛盾最终令他彻底崩溃，躺倒在精神病院里。]]></content>
      <tags>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[因为痛所以叫青春-金兰都-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E5%9B%A0%E4%B8%BA%E7%97%9B%E6%89%80%E4%BB%A5%E5%8F%AB%E9%9D%92%E6%98%A5-%E9%87%91%E5%85%B0%E9%83%BD-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[这是韩国青年导师金兰都 “因为痛，所以叫青春系列”的第一部。 《因为痛所以叫青春——写给独自站在人生路口的你》内容简介： 漫漫人生路，一直在迷路。 在一个讲究拼爹的时代，要拼什么才能拼出未来？ 改变亚洲亿万年轻人的疗愈经典。 一位导师父亲写给迷茫孩子的疼痛共鸣。 全亚洲重印512次，10个月销售破150万，45周横扫各大排行榜榜首。 很多时候，在学业上，在工作上，甚至在感情问题上，这些年轻人甚至还没有迈出踏进社会的第一步，就已经沦为一个“loser（失败者）”。在《因为痛所以叫青春——写给独自站在人生路口的你》中作者金兰都如实地把为人父母的成年人们所不曾来得及去了解的这代年轻人的困苦和不安展现了出来。作者帮助他们诊视这些无法向他人倾诉的苦痛，并告诉他们如何才能从这种苦找到为未来打拼的能量。]]></content>
      <tags>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[追风筝的人-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E8%BF%BD%E9%A3%8E%E7%AD%9D%E7%9A%84%E4%BA%BA-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[封面 简介 12岁的阿富汗富家少爷阿米尔与仆人哈桑情同手足。然而，在一场风筝比赛后，发生了一件悲惨不堪的事，阿米尔为自己的懦弱感到自责和痛苦，无法面对哈桑，于是用计逼走了哈桑。不久阿富汗爆发战争，阿米尔被迫与父亲逃亡美国。成年后的阿米尔始终无法原谅自己当年对哈桑的背叛。为了赎罪，阿米尔再次回到故乡，希望能为不幸的好友尽最后一点心力，却发现一个惊天谎言，儿时好友竟然是和自己同父异母的兄弟，为了救赎，他把哈桑的儿子带到美国，在一次聚会上，阿米尔再次放起了风筝。小说如此残忍而又美丽，作者以温暖细腻的笔法勾勒人性的本质与救赎，读来令人荡气回肠。 云图]]></content>
      <tags>
        <tag>文学</tag>
        <tag>小说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美国怎么了-一个自由主义者的良知-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E7%BE%8E%E5%9B%BD%E6%80%8E%E4%B9%88%E4%BA%86-%E4%B8%80%E4%B8%AA%E8%87%AA%E7%94%B1%E4%B8%BB%E4%B9%89%E8%80%85%E7%9A%84%E8%89%AF%E7%9F%A5-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[封面 简介本书深入地探讨了美国主张自由放任资本主义的”保守主义运动”对美国经济、社会和政治的不良影响，呼吁重新展开社会政策的公共辩论，主张政府应发挥好维护社会稳定和社会公正的作用，同时警醒世人不要冷漠对待社会经济不平等议题，以至错失改革良机。本书对于我们了解美国、以及对我国当前的社会现实都有重要的启示意义。 云图]]></content>
      <tags>
        <tag>政治</tag>
        <tag>经济</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[云图]大数据时代]]></title>
    <url>%2F2018%2F04%2F28%2F%E4%BA%91%E5%9B%BE-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3%2F</url>
    <content type="text"><![CDATA[封面 简介《大数据时代》是国外大数据研究的先河之作，本书作者维克托•迈尔•舍恩伯格被誉为“大数据商业应用第一人”，拥有在哈佛大学、牛津大学、耶鲁大学和新加坡国立大学等多个互联网研究重镇任教的经历，早在2010年就在《经济学人》上发布了长达14页对大数据应用的前瞻性研究。 维克托•迈尔•舍恩伯格在书中前瞻性地指出，大数据带来的信息风暴正在变革我们的生活、工作和思维，大数据开启了一次重大的时代转型，并用三个部分讲述了大数据时代的思维变革、商业变革和管理变革。 维克托最具洞见之处在于，他明确指出，大数据时代最大的转变就是，放弃对因果关系的渴求，而取而代之关注相关关系。也就是说只要知道“是什么”，而不需要知道“为什么”。这就颠覆了千百年来人类的思维惯例，对人类的认知和与世界交流的方式提出了全新的挑战。 本书认为大数据的核心就是预测。大数据将为人类的生活创造前所未有的可量化的维度。大数据已经成为了新发明和新服务的源泉，而更多的改变正蓄势待发。书中展示了谷歌、微软、亚马逊、IBM、苹果、facebook、twitter、VISA等大数据先锋们最具价值的应用案例。 云图]]></content>
      <tags>
        <tag>科技</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最好的我们-八月长安-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E6%9C%80%E5%A5%BD%E7%9A%84%E6%88%91%E4%BB%AC-%E5%85%AB%E6%9C%88%E9%95%BF%E5%AE%89-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[封面 简介内容推荐 你总是说青春从不曾永远，而那时候的我们，就是最好的我们。 这一次，让我们和耿耿、余淮、余周周、林杨、洛枳、盛淮南一起和整个青春做告别。 八月长安全新力作。 你还记得高中时的同桌吗？那个少年有世界上最明朗的笑容，那个女生有世界上最好看的侧影。高中三年，两个人的影子和粉笔灰交织在一起，黑白分明，在记忆里面转圈。本书以怀旧的笔触讲述了女主角耿耿和男主角余淮同桌三年的故事，耿耿余淮，这么多年一路走过的成长故事极为打动人心，整个故事里有的都是在成长过程中细碎的点点滴滴，将怀旧写到了极致，将记忆也写到了极致。 云图]]></content>
      <tags>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1988我想和这个世界谈谈-韩寒-云图]]></title>
    <url>%2F2018%2F04%2F28%2F1988%E6%88%91%E6%83%B3%E5%92%8C%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E8%B0%88%E8%B0%88-%E9%9F%A9%E5%AF%92-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[封面 简介系列主题：《我想和这个世界谈谈》 在韩寒主编的杂志《独唱团》中连载，这是韩寒预谋已久的一个系列，也是国内首度实际尝试“公路小说”这一概念的第一本——《1988》。 所谓“公路小说”就是以路途为载体反应人生观，现实观的小说。 如果说一件真正的艺术品的面世具有任何重大意义的话，韩寒新书的出版将会在中国创造一个历史事件，文章开头“空气越来越差，我必须上路了。我开着一台1988年出厂的旅行车，在说不清是迷雾还是毒气的夜色里拐上了318国道。”用一部旅行车为载体，通过在路上的见闻、过去的回忆、扑朔迷离的人物关系等各种现实场景，以韩寒本人对路上所见、所闻引发自己的观点，这场真正的旅途在精神层面；如果说似乎逾越了部分法律和道德的界限，但出发点也仅仅是希望在另一侧找到信仰。韩寒是“叛逆的”，他“试图用能给世界一些新意的眼光来看世界。试图寻找令人信服的价值”。他认为这一切通过文学都可以实现，产生了要创造一种批判现有一切社会习俗的“新幻象”的念头——《1988》就此问世。 目前“公路小说”的系列已经开始策划，韩寒的作品首当其冲，韩寒表示将会撰写三部作品与聚石文华联合打造“公路小说”这一品牌。 云图]]></content>
      <tags>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[活着-余华-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E6%B4%BB%E7%9D%80-%E4%BD%99%E5%8D%8E-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[封面 简介余华我和现实关系紧张，说得严重一些，我一直是以敌对的态度看待现实。随着时间的推移，我内心的愤怒渐渐平息，我开始意识到一位真正的作家所寻找的是真理，是一种排斥道德判断的真理。作家的使命不是发泄，不是控诉或者揭露，他应该向人们展示高尚。这里所说的高尚不是那种单纯的美好，而是对一切事物理解之后的超然，对善与恶一视同仁，用同情的目光看待世界。 正是在这样的心态下，我听到了一首美国民歌《老黑奴》，歌中那位老黑奴经历了一生的苦难，家人都先他而去，而他依然友好地对待世界，没有一句抱怨的话。这首歌深深打动了我，我决定写下一篇这样的小说，就是这篇《活着》，写人对苦难的承受能力，对世界乐观的态度。写作过程让我明白，人是为活着本身而活着的，而不是为活着之外的任何事物所活着。我感到自己写下了高尚的作品。 云图]]></content>
      <tags>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[江城-何伟-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E6%B1%9F%E5%9F%8E-%E4%BD%95%E4%BC%9F-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[封面 简介一个27岁的牛津大学英语文学硕士；一个曾经自助旅游跑完半个地球的美国年轻人，于1996年参加和平队深入中国腹地，在四川涪陵师专担任了两年英语老师。《江城》这本书就是作者何伟对这段特殊经历的纪录和思考。 在仅仅因为是外国人就可以上电视的90年代中期，何伟所深入的涪陵是一个闭塞的西南小城，几乎没有外国人路过，在一段时间内，何伟和另外一位“和平队”志愿者亚当是仅有的两个，他们的出现让当地人极为好奇，仅仅是用餐和购物就会引起“恐怖的”多达三十人的围观。但何伟没有因此把自己的活动范围局限在校园内，而是努力和当地百姓接触，带着同样的好奇和善意。在对面条店小老板、神父、农民、“小姐”各色人等仔细而准确的社会学家式观察中，何伟绘制了一幅90年代中期中国西南小城的社会景象，折射出小人物在文革、计划生育、改革开放、国有企业改革、三峡大坝建设等各种社会大事件中的命运沉浮。 在本书中，即能看到何伟与他学生的思想交流对撞，看他们如何在在文学中发现跨越语言和种族的共鸣；也能看到何伟对政治体制是怎样限制学生思维的观察和思考，书中所引用的一些学生的写作习作，足以唤起任何经历了那个时代的人的集体记忆。 云图]]></content>
      <tags>
        <tag>文学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国历代政治得失-钱穆-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E4%B8%AD%E5%9B%BD%E5%8E%86%E4%BB%A3%E6%94%BF%E6%B2%BB%E5%BE%97%E5%A4%B1-%E9%92%B1%E7%A9%86-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[封面 简介我很早以前，就想写一部中国政治制度史。一则我认为政治乃文化体系中一要目。尤其如中国，其文化精神偏重在人文界。更其是儒家的抱负，一向着重修齐治平。要研究中国传统文化，绝不该忽略中国传统政治。辛亥前后，由于革命宣传，把秦以后政治传统，用专制黑暗四字一笔抹杀。因于对传统政治之忽视，而加深了对传统文化之误解。我们若要平心客观地来检讨中国文化，自该检讨传统政治，这是我想写中国政治制度史之第一因。再则我认为政治制度，必然得自根自生。纵使有些可以从国外移来，也必然先与其本国传统，有一番融合媾通，才能真实发生相当的作用。否则无生命的政治，无配合的制度，决然无法长成。换言之，制度必须与人事相配合。辛亥前后，人人言变法，人人言革命，太重视了制度，好像只要建立制度，一切人事自会随制度而转变。因此只想把外国现成制度，模仿抄袭。甚至不惜摧残人事来迁就制度。在新文化运动时期，一面高唱民主，一面痛斥旧传统，旧文化。我们试问是否民主政治可以全不与此一民族之文化传统有关联，而只经几个人的提倡，便可安装得上呢？而且制度是死的，人事是活的，死的制度绝不能完全配合上活的人事。就历史经验论，任何一制度，绝不能有利而无弊。任何一制度，亦绝不能历久而不变。历史上一切以往制度俱如是，当前的现实制度，也何尝不如是。我们若不着重本身人事，专求模仿别人制度，结果别人制度，势必追随他们的人事而变，我们也还得追随而变，那是何等的愚蠢。其实中国历史上以往一切制度传统，只要已经沿袭到一百两百年的，也何尝不与当时人事相配合。又何尝是专出于一二人之私心，全可用专制黑暗四字来抹杀？这是我想写一部中国政治制度史之第二因。但由于国家大局之动荡，私人生活之不安定，而自中国历代政治得失 序己想写的，感到比这一部书更重要的也还有，因此此书终于没有写。一九五二年三四月间，承何敬之先生要我讲演中国历代政治得失，但讲期只有五次，每次只限两小时，又为旅途匆忙，以及其他条件，并不能对历史上传统制度详细陈述，精密发挥，只择汉唐宋明清五代略举大纲。本来想再就讲演记录把在讲演时未及提到的，略事增补。不幸讲演完成，我及负伤养病，在此期间，没有精力对此讲稿，再事改进。只得就原记录稿有与原讲义旨走失处稍稍校正，而其他不再润饰了。将来若偿宿愿，能写出一部较详备的中国政治制度史，则属至幸，而此书得以抢先呈教于读者之前，亦可稍自欣慰，并在此致谢何先生之美意。若无何先生这一番督命，连此小书，也不会有仓促完成之望的。此稿初成，在一九五二年八月我在台中养病时。嗣后又有邀约，请写一本“研究中国历代政治制度”的教材，截稿期限甚迫，乃就此稿稍加修改，如唐代的两税制，明代的赋税制度等，均有若干新资料补入，较原稿稍微充实，然恐尚多疏漏谬误，切盼读者之指正。一九五五年八月钱穆于香港 云图]]></content>
      <tags>
        <tag>云图</tag>
        <tag>历史</tag>
        <tag>人文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈美-朱光潜-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E8%B0%88%E7%BE%8E-%E6%9C%B1%E5%85%89%E6%BD%9C-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[封面 简介《谈美》是朱光潜先生以书信体形式为青年写的一本美学入门书，自问世以来即深受好评，被视为学术性与普及性兼备的经典之作。全书从“要求人生净化，先要求人生美化”的理念出发，顺着美感态度的特性、艺术与人生的距离、美感经验与移情的关系、美感与快感、自然美与艺术美等问题次第展开，最后呼吁人们“慢慢走，欣赏啊”，因为“欣赏之中都寓有创造，创造之中也都寓有欣赏”。 云图]]></content>
      <tags>
        <tag>文学</tag>
        <tag>艺术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[智能时代 吴军 云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E6%99%BA%E8%83%BD%E6%97%B6%E4%BB%A3-%E5%90%B4%E5%86%9B-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[封面 简介大数据和机器智能的出现，对我们的技术发展、商业和社会都会产生重大的影响。作者吴军在《智能时代：大数据与智能革命重新定义未来》中指出，首先，我们在过去认为非常难以解决的问题，会因为大数据和机器智能的使用而迎刃而解，比如解决癌症个性化治疗的难题。同时，大数据和机器智能还会彻底改变未来的商业模式，很多传统的行业都将采用智能技术实现升级换代，同时改变原有的商业模式。大数据和机器智能对于未来社会的影响是全方位的。目录 现象、 数据、 信息和知识 数据的作用： 文明的基石 相关性： 使用数据的钥匙 统计学： 点石成金的魔棒 数学模型： 数据驱动方法 的基础 什么是机器智能 鸟飞派： 人工智能1.0 另辟蹊径： 统计+数据 数据创造奇迹： 量变到质 变 大数据的特征 变智能问题为数据问题 思维方式决定科学成就： 从欧几里得、 托勒密到牛 顿 工业革命， 机械思维的结 果 大数据的本质 从因果关系到强相关关系 从大数据中找规律巨大的商业利好:相关性、 时效性和个性化的重要性 把控每一个细节 重新认识穷举法 完备 从历史经验看大数据的作 用 技术改变商业模式 加（+)大数据缔造新产业 技术的拐点 数据收集： 看似简单的难 题 数据存储的压力和数据表 示的难题 并行计算和实时处理： 并 非增加机器那么简单 数据挖掘： 机器智能的关 键 数据安全的技术 保护隐私： 靠大数据长期 挣钱的必要条件 未来的农业 未来的体育 未来的制造业 未来的医疗 未来的律师业 未来的记者和编辑 智能化社会 精细化社会 无隐私的社会 机器抢掉人的饭碗 争当2%的人 云图]]></content>
      <tags>
        <tag>云图</tag>
        <tag>科技</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人月神话-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[封面 简介我自己的结论体现在下面的文字中，送给职业程序员、职业经理、特别是程序员的职业经理。虽然写出来的是分离的章节， 还是有一个中心的论点， 特别包含在第 2-7 章。 简言之，我相信由于人员的分工，编程项目碰到的管理问题和小项目区别很大； 我相信关键需要是维持产品自身的概念完整性。 这些章节探讨了其中的困难和解决的方法。 后续的章节探讨软件工程管理的其他方面。 云图]]></content>
      <tags>
        <tag>云图</tag>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[精通python设计模式 云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E7%B2%BE%E9%80%9Apython%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[封面 简介本书内容第一部分，创建型模式，介绍处理对象创建的设计模式。 第1章，工厂模式 介绍如何使用工厂设计模式（工厂方法和抽象工厂）来初始化对象，并说明与直接实例化对象相比，使用工厂设计模式的优势。 第2章，建造者模式 对于由多个相关对象构成的对象，介绍如何简化其创建过程。 第3章，原型模式 介绍如何通过完全复制（也就是克隆）一个已有对象来创建一个新对象。 第二部分，结构型模式，介绍处理一个系统中不同实体（类、对象等）之间关系的设计模式。 第4章，适配器模式 介绍如何以最小的改变实现已有代码与外来接口（例如，一个外部代码库）的兼容。 第5章，修饰器模式 介绍如何无需使用继承也能增强对象的功能。 第6章，外观模式 介绍如何创建单个入口点来隐藏系统的复杂性。 第7章，享元模式 介绍如何通过复用一个对象池中的对象来提高内存利用率及应用性能。 第8章，模型—视图—控制器模式 介绍如何避免业务逻辑与用户界面代码的耦合，提高应用的可维护性。 第9章，代理模式 介绍如何增加额外的保护层，提高应用的安全性。 第三部分，行为型模式，介绍处理系统实体之间通信的设计模式。 第10章，责任链模式 介绍如何向多个接收者发送请求。 第11章，命令模式 介绍如何让应用能够取消已经执行的操作。 第12章，解释器模式 介绍如何基于Python创建一种简单的语言，便于领域专家使用，而无需学习Python编程。 第13章，观察者模式 介绍如何在对象发生变化时，通知已注册的相关者。 第14章，状态模式 介绍如何创建一个状态机以对问题进行建模，并说明这种技术的优势。 第15章，策略模式 介绍如何基于某些输入标准（例如，元素大小）在程序运行期间从多个可用算法中选择一个。 第16章，模板模式 介绍如何明确区分一个算法的通用与不通用部分，以避免不必要的代码复制。 云图]]></content>
      <tags>
        <tag>python</tag>
        <tag>云图</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计思维-程序员数学之概率统计-云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E7%BB%9F%E8%AE%A1%E6%80%9D%E7%BB%B4-%E7%A8%8B%E5%BA%8F%E5%91%98%E6%95%B0%E5%AD%A6%E4%B9%8B%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[封面 简介本书是一本全新的概率统计入门教材，重点介绍如何用统计学方法分析大型数据集。本书会介绍如何使用计算机实现各种统计方法，这有诸多优点。 学生可以通过编写程序来深化和检查自己对概念的理解。 例如， 编写计算最小二乘拟合、 残差和判定系数的函数， 编写和测试这些代码需要他们正确理解相关概念，消除各种可能的误解。 学生能够通过计算实验来验证统计学上的一些定理。 例如， 生成服从各种分布的样本来验证中心极限定理（Central Limit Theorem，CLT）。 当发现服从帕累托分布的样本并没有收敛到正态分布时， 他们肯定会记住中心极限定理的前提条件。 有些从数学上很难理解的概念可以很容易地用模拟方法来阐述。 例如，通过蒙特卡罗模拟近似求出 p 值，就能说明 p 值的含义。 使用离散分布和计算方法可以把贝叶斯模拟之类在入门课程中很少见的内容讲清楚。 例如， 本书中有个练习要求学生计算“德国坦克问题”（German tank problem） 的后验分布， 通过理论分析很难得到答案，但用计算手段却很容易得出结果。 因为学生使用的是通用编程语言 Python， 所以他们可以导入各种来源的数据，并不局限于那些已经为特定统计工具整理好的数据。本书内容是按项目来组织的。 为了演示我想要学生做的分析， 本书会有一个贯穿全书的实例。 它所使用的数据主要有以下两个来源。 由美国疾病控制与预防中心（Centers for Disease Control and Prevention，CDC） 主持的全国家庭成长调查（National Survey of Family Growth，NSFG） 项目，该项目是为了收集美国人的“家庭生活、婚姻状况、生育、避孕和男女健康等信息”。 由全国慢性病预防和健康促进中心主导的行为风险因素监测系统（theBehavioral Risk Factor Surveillance System， BRFSS）， 该系统旨在跟踪“美国人的健康状况和危险行为” 。 其他例子所使用的数据则来自 IRS（美国国税局）、 美国人口普查和波士顿马拉松比赛。 云图]]></content>
      <tags>
        <tag>python</tag>
        <tag>云图</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习 周志华 云图]]></title>
    <url>%2F2018%2F04%2F28%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%91%A8%E5%BF%97%E5%8D%8E-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[封面 简介该书有以下特点： 内容系统全面。全书16章，覆盖了机器学习几乎所有的主要分支领域，覆盖面超过了该领域国际著名书籍如ESL与PRML：第1 部分（第1-3 章）介绍机器学习的基础知识；第2 部分（第4-10 章）介绍一些经典而常用的机器学习方法（决策树、神经网络、支持向量机、贝叶斯分类器、集成学习、聚类、降维与度量学习）；第3 部分（第11-16 章）为进阶知识，内容涉及特征选择与稀疏学习、计算学习理论、半监督学习、概率图模型、规则学习以及强化学习。此外，书中每章都提供了精心总结的阅读文献，对读者进一步深造提供了极大帮助。 行文通畅易读。作者文笔精彩，全书思路清晰、文字活泼通畅，每章附带的小故事让读者在轻松之余了解学科相关历史。尤为难得的是，作者很善于把复杂的事情说得简单明白，避免数学公式的堆砌，重在说清技术内容的来龙去脉，让读者不仅“知其然”，还要“知其所以然”。这不仅对初学者有益，对本领域研究者了解学科全局的发展思路也很有帮助。另外，该书对关键的公式又有具体详尽的推导分析。 叙述立场客观。作为入门教科书，尽可能不带偏见地对材料进行客观介绍重要。以往的一些书籍在此方面有失偏颇，如PRML把所有机器学习材料都从贝叶斯角度来诠释描述，这对高水平读者很有益，能让人看到各种内容均可以从不同学派的角度来理解；但是对入门读者，先入为主地强化单一学派的思路和价值观，对深入理解整个学科未必有益。周教授《机器学习》书各种材料均从其本源产生的角度来介绍，令细心读者对各学派的优点都能有所体会，对入门者有益。 设计装帧精美。该书近似方形开本，注释以边注形式出现，侧边空白便于读者写笔记，设计很人性化。文字、公式、数学符号混排格式美观精致。特别是，彩图是彩印的！纸张也相当好，足以看出作者和出版社的用心。封面设计清新文艺。该书可谓技术类书籍中的艺术品，令人爱不释手。 云图]]></content>
      <tags>
        <tag>python</tag>
        <tag>云图</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会 云图]]></title>
    <url>%2F2018%2F04%2F28%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[图书封面 目录本书的读者对象是这样一些人： 他没有学过SQL； 他刚开始用MySQL，并希望一举成功； 他想迅速地、尽可能多地学会使用MySQL； 他希望学习怎样在自己的应用程序开发中使用MySQL； 他希望通过使用MySQL轻松快速地提高工作效率，而不用劳烦他人帮忙。 目 录第1章 了解SQL第2章 MySQL简介第3章 使用MySQL第4章 检索数据第5章 排序检索数据第6章 过滤数据第7章 数据过滤第8章 用通配符进行过滤第9章 用正则表达式进行搜索第10章 创建计算字段第11章 使用数据处理函数第12章 汇总数据第13章 分组数据第14章 使用子查询第15章 联结表第16章 创建高级联结第17章 组合查询第18章 全文本搜索第19章 插入数据第20章 更新和删除数据第21章 创建和操纵表第22章 使用视图第23章 使用存储过程第24章 使用游标第25章 使用触发器第26章 管理事务处理第27章 全球化和本地化第28章 安全管理第29章 数据库维护第30章 改善性能附录A MySQL入门附录B 样例表附录C MySQL语句的语法附录D MySQL数据类型附录E MySQL保留字 云图 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from collections import Counterfrom zhon import hanziimport stringimport reimport osimport matplotlib.pyplot as pltimport jiebafrom wordcloud import WordCloud, ImageColorGeneratorwith open('mysql必知应会.txt','r', encoding='utf-8') as fp: alltext = ' '.join(fp.readlines())alltext = re.sub("[%s]+" % hanzi.punctuation, " ", alltext)alltext = re.sub("[%s]+" % string.punctuation, " ", alltext)seg_list = jieba.cut(alltext, cut_all=False)seg_list = list(seg_list)counter = Counter(seg_list)top = counter.most_common(1000)top_dict = dict(top)stopwords_list = []pwd = os.path.abspath('.')for file in os.listdir(os.path.join(pwd,'stopwords')): filename = os.path.join(pwd,'stopwords',file) with open(filename,'r') as fp: stopwords_list.extend(fp.readlines())stopwords_list = list(set(stopwords_list))for stopword in stopwords_list: try: top_dict.pop(stopword.strip()) except: passwc = WordCloud(background_color="white", #背景颜色max_words=2000,# 词云显示的最大词数 font_path='simfang.ttf', max_font_size=50, #字体最大值 random_state=42)wc.generate_from_frequencies(top_dict)plt.imshow(wc)plt.axis('off')plt.show()]]></content>
      <tags>
        <tag>python</tag>
        <tag>云图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python编程快速上手 让繁琐工作自动化 云图]]></title>
    <url>%2F2018%2F04%2F28%2FPython%E7%BC%96%E7%A8%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-%E8%AE%A9%E7%B9%81%E7%90%90%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96-%E4%BA%91%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[图书封面 本书简介本书的第一部分介绍了基本 Python 编程概念，第二部分介绍了一些不同的任务，你可以让计算机自动完成它们。第二部分的每一章都有一些项目程序，供你学习。下面简单介绍一下每章的内容。第一部分： Python 编程基础“第 1 章： Python 基础”介绍了表达式、 Python 指令的最基本类型，以及如何使用 Python 交互式环境来尝试运行代码。“第 2 章：控制流”解释了如何让程序决定执行哪些指令，以便代码能够智能地响应不同的情况。“第 3 章：函数”介绍了如何定义自己的函数，以便将代码组织成可管理的部分。“第 4 章：列表”介绍了列表数据类型，解释了如何组织数据。“第 5 章：字典和结构化数据”介绍了字典数据类型，展示了更强大的数据组织方法。“第 6 章：字符串操作”介绍了处理文本数据（在 Python 中称为字符串）。 第二部分：自动化任务“第 7 章：模式匹配与正则表达式”介绍了 Python 如何用正则表达式处理字符串，以及查找文本模式。“第 8 章：读写文件”解释了程序如何读取文本文件的内容，并将信息保存到硬盘的文件中。“第 9 章：组织文件”展示了 Python 如何用比手工操作快得多的速度，复制、移动、重命名和删除大量的文件，也解释了压缩和解压缩文件。“第 10 章：调试”展示了如何使用 Python 的缺陷查找和缺陷修复工具。“第 11 章：从 Web 抓取信息”展示了如何编程来自动下载网页，解析它们，获取信息。这称为从 Web 抓取信息。“第 12 章：处理 Excel 电子表格”介绍了编程处理 Excel 电子表格，这样你就不必去阅读它们。如果你必须分析成百上千的文档，这是很有帮助的。“第 13 章：处理 PDF 和 Word 文档”介绍了编程读取 Word 和 PDF 文档。“第 14 章：处理 CSV 文件和 JSON 数据”解释了如何编程操作 CSV 和 JSON 文件。“第 15 章：保持时间、计划任务和启动程序”解释了 Python 程序如何处理时间和日期，如何安排计算机在特定时间执行任务。这一章也展示了 Python 程序如何启动非 Python 程序。“第 16 章：发送电子邮件和短信”解释了如何编程来发送电子邮件和短信。“第 17 章：操作图像”解释了如何编程来操作 JPG 或 png) 这样的图像。“第 18 章：用 GUI 自动化控制键盘和鼠标”解释了如何编程控制鼠标和键盘，自动化鼠标点击和击键。 云图 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from collections import Counterfrom zhon import hanziimport stringimport reimport osimport matplotlib.pyplot as pltimport jiebafrom wordcloud import WordCloud, ImageColorGeneratorwith open('Python编程快速上手.txt','r', encoding='utf-8') as fp: alltext = ' '.join(fp.readlines())alltext = re.sub("[%s]+" % hanzi.punctuation, " ", alltext)alltext = re.sub("[%s]+" % string.punctuation, " ", alltext)seg_list = jieba.cut(alltext, cut_all=False)seg_list = list(seg_list)counter = Counter(seg_list)top = counter.most_common(1000)top_dict = dict(top)stopwords_list = []pwd = os.path.abspath('.')for file in os.listdir(os.path.join(pwd,'stopwords')): filename = os.path.join(pwd,'stopwords',file) with open(filename,'r') as fp: stopwords_list.extend(fp.readlines())stopwords_list = list(set(stopwords_list))for stopword in stopwords_list: try: top_dict.pop(stopword.strip()) except: passwc = WordCloud(background_color="white", font_path='simfang.ttf', max_font_size=50, random_state=42)wc.generate_from_frequencies(top_dict)plt.imshow(wc)plt.axis('off')plt.show()]]></content>
      <tags>
        <tag>python</tag>
        <tag>云图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE 参数CQI RI PMI]]></title>
    <url>%2F2018%2F04%2F23%2FLTE-%E5%8F%82%E6%95%B0CQI-RI-PMI%2F</url>
    <content type="text"><![CDATA[原文链接：http://lteuniversity.com/get_trained/expert_opinion1/b/hongyanlei/archive/2009/08/06/cqi-reporting-in-lte.aspx CQI = Channel Quality Indicator;信道质量指示;RI = rank indication;秩指示;PMI = Precoding Matrix Indicator;预编码矩阵指示; CQI用来反映下行PDSCH的信道质量。用0~15来表示PDSCH的信道质量。0表示信道质量最差，15表示信道质量最好。—&gt;UE在PUCCH/PUSCH上发送CQI给eNB。eNB得到了这个CQI值，就质量当前PDSCH无线信道条件好不好。 这样就可以有根据的来调度PDSCH。—&gt;换句话说，LTE中下行的自适应编码调制（AMC）的依据是什么？其中一个依据就是CQI。—&gt;再通俗一点的说法：信道质量好，那eNB就多发送点数据；信道质量不好，那就保险点，少发送点数据。 RI用来指示PDSCH的有效的数据层数。用来告诉eNB，UE现在可以支持的CW数。也就是说RI=1，1CW，RI&gt;1，2 CW. CW-Code Word码字 PMI用来指示码本集合的index。由于LTE应用了多天线的MIMO技术。在PDSCH物理层的基带处理中，有一个预编码技术。—&gt;这里的预编码简单的说，就是乘以各种不同的precoding矩阵。而这个矩阵，可以采用TM3这样没有反馈的方式。—&gt;也可以采用TM4这样通过UE上报PMI来决定这个预编码矩阵。从原理上说，这样使得PDSCH信号是最优的。 下行的传输模式(TM)很多，在R9版本下行定义了TM1~TM8；其中TM4,6,8的情况下，才需要有PMI的反馈。 更多详细的内容参见36.211、213。 CQI（信道质量指示）报告是LTE的一个重要因素，并具有对系统性能显著影响。有两种类型的CQI报告在LTE中：周期性和非周期性。周期性CQI报告是由PUCCH携带。但是，如果UE需要在同一子帧发送的UL数据，周期性CQI报告将使用的PUSCH，连同UL数据传输。这是因为UE不能PUCCH和PUSCH的同时发送。在此情况下，周期性PUCCH资源将是空闲的。由于定期CQI报告带来了“永远在线”的信令开销，报告粒度相对粗糙。为了获得更详细的CQI报告，则eNB可以在需要时触发不定期CQI报告。非周期性CQI报告被发送PUSCH上，连同UL数据或独自发送。 CQI报告的粒度可分为三个层次：宽带，UE选择的子带，和更高层配置的子带。宽带报告为整个下行链路系统带宽一个CQI值。该UE选择子带CQI报告将系统带宽划分为多个子带，选择一组优选子带（最好的M个子带）中，然后报告了宽带和一个差分CQI值设定一个CQI值（假设传输只能通过选择M个子带）。高层配置的子带报告提供了最高的粒度。它将整个系统带宽划分为多个子带，然后报告一个宽带CQI值和多个差分CQI值，每个子带一个。 在闭环MIMO的情况下，PMI（预编码矩阵指示符）和RI（秩指示）也报告。基于对接收的参考信号的评价，PMI指示在eNB应该使用多个天线进行数据传输中的码本（预先约定的参数）。 RI指示传输层，该UE能够区分的数目。只有当RI&gt; 1，空间复用可被支持。对于空间复用，CQI是基于每码字的报告。码字的LTE中的最大数目是2。 在LTE中有七种传输模式，每一个对应于某多天线技术。对于每个传输模式下，CQI报告的某些组合在规范中定义的基础上，定期/不定期，宽带/ UE选择的子带/更高层配置的子带，没有PMI /单PMI /多PMI。因为RI变化比CQI / PMI慢，所以用一个较长的时间间隔报告。它与CQI / PMI报告一起在非周期性的报告，因为PUSCH资源是有限的。]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-9-人数]]></title>
    <url>%2F2018%2F04%2F23%2FOpenCV-9-%E4%BA%BA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[OpenCV-9-人数上次我向你展示了如何跟踪一个对象的移动，虽然实际上它只是保存了该对象之前坐标的列表。 现在，我们必须查看该列表并确定对象在图像中上下移动。为此，我将首先创建两条假想线，指示何时评估对象的方向（line_up，line_down）。我还设置了两条限制线来告诉我的代码何时停止跟踪一个对象（up_limit，down_limit）。 我还在Person类中使用了两个方法：going_UP（a，b）和going_DOWN（a，b）。 都会收到line_down和line_up，并返回true，它们会评估对象是否已沿正确方向越过line_up或line_down。 如果是这样，那么计数器会递增……而我们正在计数人数。 此外，Person类还具有一个State属性，用于了解对象何时位于映像的计数限制之外并释放分配的内存。 这是代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200##Contador de personas##Federico Mejiaimport numpy as npimport cv2import Personimport time#Contadores de entrada y salidacnt_up = 0cnt_down = 0#Fuente de video#cap = cv2.VideoCapture(0)cap = cv2.VideoCapture('peopleCounter.avi')#Propiedades del video##cap.set(3,160) #Width##cap.set(4,120) #Height#Imprime las propiedades de captura a consolafor i in range(19): print(i, cap.get(i))w = cap.get(3)h = cap.get(4)frameArea = h*wareaTH = frameArea/250print('Area Threshold', areaTH)#Lineas de entrada/salidaline_up = int(2*(h/5))line_down = int(3*(h/5))up_limit = int(1*(h/5))down_limit = int(4*(h/5))print("Red line y:",str(line_down))print("Blue line y:", str(line_up))line_down_color = (255,0,0)line_up_color = (0,0,255)pt1 = [0, line_down];pt2 = [w, line_down];pts_L1 = np.array([pt1,pt2], np.int32)pts_L1 = pts_L1.reshape((-1,1,2))pt3 = [0, line_up];pt4 = [w, line_up];pts_L2 = np.array([pt3,pt4], np.int32)pts_L2 = pts_L2.reshape((-1,1,2))pt5 = [0, up_limit];pt6 = [w, up_limit];pts_L3 = np.array([pt5,pt6], np.int32)pts_L3 = pts_L3.reshape((-1,1,2))pt7 = [0, down_limit];pt8 = [w, down_limit];pts_L4 = np.array([pt7,pt8], np.int32)pts_L4 = pts_L4.reshape((-1,1,2))#Substractor de fondofgbg = cv2.createBackgroundSubtractorMOG2(detectShadows = True)#Elementos estructurantes para filtros morfoogicoskernelOp = np.ones((3,3),np.uint8)kernelOp2 = np.ones((5,5),np.uint8)kernelCl = np.ones((11,11),np.uint8)#Variablesfont = cv2.FONT_HERSHEY_SIMPLEXpersons = []max_p_age = 5pid = 1while(cap.isOpened()):##for image in camera.capture_continuous(rawCapture, format="bgr", use_video_port=True): #Lee una imagen de la fuente de video ret, frame = cap.read()## frame = image.array for i in persons: i.age_one() #age every person one frame ######################### # PRE-PROCESAMIENTO # ######################### #Aplica substraccion de fondo fgmask = fgbg.apply(frame) fgmask2 = fgbg.apply(frame) #Binariazcion para eliminar sombras (color gris) try: ret,imBin= cv2.threshold(fgmask,200,255,cv2.THRESH_BINARY) ret,imBin2 = cv2.threshold(fgmask2,200,255,cv2.THRESH_BINARY) #Opening (erode-&gt;dilate) para quitar ruido. mask = cv2.morphologyEx(imBin, cv2.MORPH_OPEN, kernelOp) mask2 = cv2.morphologyEx(imBin2, cv2.MORPH_OPEN, kernelOp) #Closing (dilate -&gt; erode) para juntar regiones blancas. mask = cv2.morphologyEx(mask , cv2.MORPH_CLOSE, kernelCl) mask2 = cv2.morphologyEx(mask2, cv2.MORPH_CLOSE, kernelCl) except: print('EOF') print('UP:',cnt_up) print('DOWN:',cnt_down) break ################# # CONTORNOS # ################# # RETR_EXTERNAL returns only extreme outer flags. All child contours are left behind. _, contours0, hierarchy = cv2.findContours(mask2,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE) for cnt in contours0: area = cv2.contourArea(cnt) if area &gt; areaTH: ################# # TRACKING # ################# #Falta agregar condiciones para multipersonas, salidas y entradas de pantalla. M = cv2.moments(cnt) cx = int(M['m10']/M['m00']) cy = int(M['m01']/M['m00']) x,y,w,h = cv2.boundingRect(cnt) new = True if cy in range(up_limit,down_limit): for i in persons: if abs(cx-i.getX()) &lt;= w and abs(cy-i.getY()) &lt;= h: # el objeto esta cerca de uno que ya se detecto antes new = False i.updateCoords(cx,cy) #actualiza coordenadas en el objeto and resets age if i.going_UP(line_down,line_up) == True: cnt_up += 1; print("ID:",i.getId(),'crossed going up at',time.strftime("%c")) elif i.going_DOWN(line_down,line_up) == True: cnt_down += 1; print("ID:",i.getId(),'crossed going down at',time.strftime("%c")) break if i.getState() == '1': if i.getDir() == 'down' and i.getY() &gt; down_limit: i.setDone() elif i.getDir() == 'up' and i.getY() &lt; up_limit: i.setDone() if i.timedOut(): #sacar i de la lista persons index = persons.index(i) persons.pop(index) del i #liberar la memoria de i if new == True: p = Person.MyPerson(pid,cx,cy, max_p_age) persons.append(p) pid += 1 ################# # DIBUJOS # ################# cv2.circle(frame,(cx,cy), 5, (0,0,255), -1) img = cv2.rectangle(frame,(x,y),(x+w,y+h),(0,255,0),2) #cv2.drawContours(frame, cnt, -1, (0,255,0), 3) #END for cnt in contours0 ######################### # DIBUJAR TRAYECTORIAS # ######################### for i in persons:## if len(i.getTracks()) &gt;= 2:## pts = np.array(i.getTracks(), np.int32)## pts = pts.reshape((-1,1,2))## frame = cv2.polylines(frame,[pts],False,i.getRGB())## if i.getId() == 9:## print str(i.getX()), ',', str(i.getY()) cv2.putText(frame, str(i.getId()),(i.getX(),i.getY()),font,0.3,i.getRGB(),1,cv2.LINE_AA) ################# # IMAGANES # ################# str_up = 'UP: '+ str(cnt_up) str_down = 'DOWN: '+ str(cnt_down) frame = cv2.polylines(frame,[pts_L1],False,line_down_color,thickness=2) frame = cv2.polylines(frame,[pts_L2],False,line_up_color,thickness=2) frame = cv2.polylines(frame,[pts_L3],False,(255,255,255),thickness=1) frame = cv2.polylines(frame,[pts_L4],False,(255,255,255),thickness=1) cv2.putText(frame, str_up ,(10,40),font,0.5,(255,255,255),2,cv2.LINE_AA) cv2.putText(frame, str_up ,(10,40),font,0.5,(0,0,255),1,cv2.LINE_AA) cv2.putText(frame, str_down ,(10,90),font,0.5,(255,255,255),2,cv2.LINE_AA) cv2.putText(frame, str_down ,(10,90),font,0.5,(255,0,0),1,cv2.LINE_AA) cv2.imshow('Frame',frame) #cv2.imshow('Mask',mask) #preisonar ESC para salir k = cv2.waitKey(30) &amp; 0xff if k == 27: break#END while(cap.isOpened()) ################## LIMPIEZA ##################cap.release()cv2.destroyAllWindows()]]></content>
      <categories>
        <category>OpenCV</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-8-跟踪移动]]></title>
    <url>%2F2018%2F04%2F23%2FOpenCV-8-%E8%B7%9F%E8%B8%AA%E7%A7%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[OpenCV-8-跟踪移动您现在已经知道图像中有人的时候，您想知道他们正朝哪个方向移动（上/下）。在第一帧中，您检测到某人需要为该人提供一个ID并将其存储在图像中的初始位置。然后，在以下帧中，要跟踪该人，需要将后面帧中的人物轮廓与首次出现时设置的ID相匹配，并保存该人的坐标。然后，在该人穿过图像中的限制（或一定数量的限制）之后，您需要使用所有存储的位置评估他/她是否向上或向下移动。为了处理所有这些ID和存储坐标，我创建了一个名为Person的类。 它可能没有被优化，但你可以在这里看看它。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# Person.pyfrom random import randintimport timeclass MyPerson: tracks = [] def __init__(self, i, xi, yi, max_age): self.i = i self.x = xi self.y = yi self.tracks = [] self.R = randint(0,255) self.G = randint(0,255) self.B = randint(0,255) self.done = False self.state = '0' self.age = 0 self.max_age = max_age self.dir = None def getRGB(self): return (self.R,self.G,self.B) def getTracks(self): return self.tracks def getId(self): return self.i def getState(self): return self.state def getDir(self): return self.dir def getX(self): return self.x def getY(self): return self.y def updateCoords(self, xn, yn): self.age = 0 self.tracks.append([self.x,self.y]) self.x = xn self.y = yn def setDone(self): self.done = True def timedOut(self): return self.done def going_UP(self,mid_start,mid_end): if len(self.tracks) &gt;= 2: if self.state == '0': if self.tracks[-1][1] &lt; mid_end and self.tracks[-2][1] &gt;= mid_end: #cruzo la linea state = '1' self.dir = 'up' return True else: return False else: return False def going_DOWN(self,mid_start,mid_end): if len(self.tracks) &gt;= 2: if self.state == '0': if self.tracks[-1][1] &gt; mid_start and self.tracks[-2][1] &lt;= mid_start: #cruzo la linea state = '1' self.dir = 'down' return True else: return False else: return False def age_one(self): self.age += 1 if self.age &gt; self.max_age: self.done = True return Trueclass MultiPerson: def __init__(self, persons, xi, yi): self.persons = persons self.x = xi self.y = yi self.tracks = [] self.R = randint(0,255) self.G = randint(0,255) self.B = randint(0,255) self.done = False 这里有一个你应该尝试的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import numpy as npimport cv2import Personimport time# http://docs.opencv.org/master/d3/dc0/group__imgproc__shape.html#ga17ed9f5d79ae97bd4c7cf18403e1689a&amp;gsc.tab=0##http://docs.opencv.org/master/d4/d73/tutorial_py_contours_begin.html#gsc.tab=0cap = cv2.VideoCapture('peopleCounter.avi') #Open video filefgbg = cv2.createBackgroundSubtractorMOG2(detectShadows = True) #Create the background substractorkernelOp = np.ones((3,3),np.uint8)kernelCl = np.ones((11,11),np.uint8)#Variablesfont = cv2.FONT_HERSHEY_SIMPLEXpersons = []max_p_age = 5pid = 1areaTH = 500while(cap.isOpened()): ret, frame = cap.read() #read a frame fgmask = fgbg.apply(frame) #Use the substractor try: ret,imBin= cv2.threshold(fgmask,200,255,cv2.THRESH_BINARY) #Opening (erode-&gt;dilate) para quitar ruido. mask = cv2.morphologyEx(imBin, cv2.MORPH_OPEN, kernelOp) #Closing (dilate -&gt; erode) para juntar regiones blancas. mask = cv2.morphologyEx(mask , cv2.MORPH_CLOSE, kernelCl) except: #if there are no more frames to show... print('EOF') break _, contours0, hierarchy = cv2.findContours(mask,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_NONE) for cnt in contours0: cv2.drawContours(frame, cnt, -1, (0,255,0), 3, 8) area = cv2.contourArea(cnt) if area &gt; areaTH: ################# # TRACKING # ################# M = cv2.moments(cnt) cx = int(M['m10']/M['m00']) cy = int(M['m01']/M['m00']) x,y,w,h = cv2.boundingRect(cnt) new = True for i in persons: if abs(x-i.getX()) &lt;= w and abs(y-i.getY()) &lt;= h: # el objeto esta cerca de uno que ya se detecto antes new = False i.updateCoords(cx,cy) #actualiza coordenadas en el objeto and resets age break if new == True: p = Person.MyPerson(pid,cx,cy, max_p_age) persons.append(p) pid += 1 ################# # DIBUJOS # ################# cv2.circle(frame,(cx,cy), 5, (0,0,255), -1) img = cv2.rectangle(frame,(x,y),(x+w,y+h),(0,255,0),2) cv2.drawContours(frame, cnt, -1, (0,255,0), 3) ######################### # DIBUJAR TRAYECTORIAS # ######################### for i in persons: if len(i.getTracks()) &gt;= 2: pts = np.array(i.getTracks(), np.int32) pts = pts.reshape((-1,1,2)) frame = cv2.polylines(frame,[pts],False,i.getRGB()) if i.getId() == 9: print(str(i.getX()), ',', str(i.getY())) cv2.putText(frame, str(i.getId()),(i.getX(),i.getY()),font,0.3,i.getRGB(),1,cv2.LINE_AA) cv2.imshow('Frame',frame) #Abort and exit with 'Q' or ESC k = cv2.waitKey(30) &amp; 0xff if k == 27: breakcap.release() #release video filecv2.destroyAllWindows() #close all openCV windows 寻找一个检测到的轮廓的坐标，并尝试将它们与以前检测到的人物进行匹配。 如果没有人匹配，那么我们创建一个新的。]]></content>
      <categories>
        <category>OpenCV</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-7-确定一个人]]></title>
    <url>%2F2018%2F04%2F23%2FOpenCV-7-%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AA%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[OpenCV-7-确定一个人我们如何将轮廓归类为一个人？一个简单但有效的步骤可能是定义轮廓必须具有的最小区域： 为每个轮廓定义一个最小区域，查找轮廓，获取该区域，如果超过阈值，则执行一些操作。阈值不是通用的，这意味着取决于您的视频流，您需要测试不同的值，直到它与视频一起工作。例如，设置一个较低的阈值会让你感觉像这样：虽然设置得太高会让你： 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import numpy as npimport cv2cap = cv2.VideoCapture('peopleCounter.avi') #Open video filefgbg = cv2.createBackgroundSubtractorMOG2(detectShadows = True) #Create the background substractorkernelOp = np.ones((3,3),np.uint8)kernelCl = np.ones((11,11),np.uint8)areaTH = 500while(cap.isOpened()): ret, frame = cap.read() #read a frame fgmask = fgbg.apply(frame) #Use the substractor try: ret,imBin= cv2.threshold(fgmask,200,255,cv2.THRESH_BINARY) #Opening (erode-&gt;dilate) para quitar ruido. mask = cv2.morphologyEx(imBin, cv2.MORPH_OPEN, kernelOp) #Closing (dilate -&gt; erode) para juntar regiones blancas. mask = cv2.morphologyEx(mask , cv2.MORPH_CLOSE, kernelCl) except: #if there are no more frames to show... print('EOF') break _, contours0, hierarchy = cv2.findContours(mask,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_NONE) for cnt in contours0: cv2.drawContours(frame, cnt, -1, (0,255,0), 3, 8) area = cv2.contourArea(cnt) print(area) if area &gt; areaTH: ################# # TRACKING # ################# M = cv2.moments(cnt) cx = int(M['m10']/M['m00']) cy = int(M['m01']/M['m00']) x,y,w,h = cv2.boundingRect(cnt) cv2.circle(frame,(cx,cy), 5, (0,0,255), -1) img = cv2.rectangle(frame,(x,y),(x+w,y+h),(0,255,0),2) cv2.imshow('Frame',frame) #Abort and exit with 'Q' or ESC k = cv2.waitKey(30) &amp; 0xff if k == 27: breakcap.release() #release video filecv2.destroyAllWindows() #close all openCV windows]]></content>
      <categories>
        <category>OpenCV</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-6-计数]]></title>
    <url>%2F2018%2F04%2F23%2FOpenCV-6-%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[OpenCV-6-计数123456789101112131415161718192021222324252627282930313233343536373839import numpy as npimport cv2# http://docs.opencv.org/master/d3/dc0/group__imgproc__shape.html#ga17ed9f5d79ae97bd4c7cf18403e1689a&amp;gsc.tab=0##http://docs.opencv.org/master/d4/d73/tutorial_py_contours_begin.html#gsc.tab=0cap = cv2.VideoCapture('peopleCounter.avi') #Open video filefgbg = cv2.createBackgroundSubtractorMOG2(detectShadows = True) #Create the background substractorkernelOp = np.ones((3,3),np.uint8)kernelCl = np.ones((11,11),np.uint8)while(cap.isOpened()): ret, frame = cap.read() #read a frame fgmask = fgbg.apply(frame) #Use the substractor try: ret,imBin= cv2.threshold(fgmask,200,255,cv2.THRESH_BINARY) #Opening (erode-&gt;dilate) para quitar ruido. mask = cv2.morphologyEx(imBin, cv2.MORPH_OPEN, kernelOp) #Closing (dilate -&gt; erode) para juntar regiones blancas. mask = cv2.morphologyEx(mask , cv2.MORPH_CLOSE, kernelCl) except: #if there are no more frames to show... print('EOF') break _, contours0, hierarchy = cv2.findContours(mask,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_NONE) for cnt in contours0: cv2.drawContours(frame, cnt, -1, (0,255,0), 3, 8) cv2.imshow('Frame',frame) #Abort and exit with 'Q' or ESC k = cv2.waitKey(30) &amp; 0xff if k == 27: breakcap.release() #release video filecv2.destroyAllWindows() #close all openCV windows 我们赋予函数我们的掩码，cv2.RETR_EXTERNAL表示我们只关心外部轮廓（轮廓内的轮廓不会被检测到），而cv2.CHAIN_APPROX_NONE是用于“制作”轮廓的算法（您可以将其更改为另一个）。 绘制轮廓仅用于直观地欣赏所显示图像上的轮廓。]]></content>
      <categories>
        <category>OpenCV</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-5-形态改变]]></title>
    <url>%2F2018%2F04%2F23%2FOpenCV-5-%E5%BD%A2%E6%80%81%E6%94%B9%E5%8F%98%2F</url>
    <content type="text"><![CDATA[OpenCV-5-形态改变首先了解一下转换的内容及其用途（您只需要阅读关于侵蚀和扩张(Erosion and Dilation)，打开和关闭）。 本质上，我们将在二值化图像上使用侵蚀和扩张(Erosion and Dilation)（黑白）。 以非常普遍的方式，侵蚀(Erosion)将图像的黑色部分扩展成白色部分。 另一方面，扩张(Dilation)将图像的白色部分扩大成黑色部分。 要做这个操作，你还需要指定一个内核或结构元素（strel）。 这是一个在n * n大小的图像上进行卷积的矩阵，用于定义在计算每个像素的值时要使用的区域。 让我们试试这张图片： 1234567891011121314import cv2import numpy as npimg = cv2.imread("noise.png")ret,thresh1 = cv2.threshold(img,127,255,cv2.THRESH_BINARY)kernel = np.ones((3,3),np.uint8)erosion = cv2.erode(img,kernel,iterations = 1)dilation = cv2.dilate(img,kernel,iterations = 1)cv2.imwrite("erode.png",erosion)cv2.imwrite("dilate.png",dilation) 我们使用阈值方法来二值化图像。 将其从颜色转换为黑白两种值（不同于灰度）。 运行它并查看输出图像。 另外，尝试更改内核的大小（例如5,5或9,9），看看会发生什么。您也可以将两个操作相结合，一个接一个地运行。 先做侵蚀，然后扩张被称为Openning。先做扩张，然后侵蚀被称为Closing。 让我们试试这张图片： 1234567891011121314import cv2import numpy as npimg = cv2.imread("noise.png")ret,thresh1 = cv2.threshold(img,127,255,cv2.THRESH_BINARY)kernel = np.ones((3,3),np.uint8)erosion = cv2.erode(img,kernel,iterations = 1)dilation = cv2.dilate(img,kernel,iterations = 1)cv2.imwrite("erode.png",erosion)cv2.imwrite("dilate.png",dilation) 看看输出结果，并试图了解关闭和打开过程中发生的事情。 现在，尝试将此代码合并到我们的代码中，在背景减除后，将阴影（灰色）取出并使视频流清晰（取出任何噪音），从中取出：]]></content>
      <categories>
        <category>OpenCV</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-4-视频背景消除]]></title>
    <url>%2F2018%2F04%2F23%2FOpenCV-4-%E8%A7%86%E9%A2%91%E8%83%8C%E6%99%AF%E6%B6%88%E9%99%A4%2F</url>
    <content type="text"><![CDATA[OpenCV-4-视频背景消除背景减法可以识别图像的前景和背景。 背景被认为是一系列图像中的任何东西，任何东西都是静态的。 前景是变化（移动）的一切。 在OpenCV中做背景减法只需要2行： 123456789101112131415161718192021222324252627import numpy as npimport cv2cap = cv2.VideoCapture('peopleCounter.avi') #Open video filefgbg = cv2.createBackgroundSubtractorMOG2(detectShadows = True) #Create the background substractorwhile(cap.isOpened()): ret, frame = cap.read() #read a frame fgmask = fgbg.apply(frame) #Use the substractor try: cv2.imshow('Frame',frame) cv2.imshow('Background Substraction',fgmask) except: #if there are no more frames to show... print('EOF') break #Abort and exit with 'Q' or ESC k = cv2.waitKey(30) &amp; 0xff if k == 27: breakcap.release() #release video filecv2.destroyAllWindows() #close all openCV windows 运行结果如下图 在新图像中，黑色代表背景，白色是前景中的物体，灰色是这些物体投射的阴影。 MOG2减法器在OpenCV中使用MOG2减法器的好处是背景不断被计算，这意味着照明的细微变化（例如由太阳引起的变化）不会影响您的计算结果。]]></content>
      <categories>
        <category>OpenCV</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-3-在视频中绘制图像]]></title>
    <url>%2F2018%2F04%2F23%2FOpenCV-3-%E5%9C%A8%E8%A7%86%E9%A2%91%E4%B8%AD%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F%2F</url>
    <content type="text"><![CDATA[OpenCV-3-在视频中绘制图像在视频中插入helloworld123456789101112131415161718192021222324252627282930313233import numpy as npimport cv2cap = cv2.VideoCapture('peopleCounter.avi') #Open video filew = cap.get(3) #get widthh = cap.get(4) #get heightmx = int(w/2)my = int(h/2)count = 0while(cap.isOpened()): ret, frame = cap.read() #read a frame try: count = count + 1 text = "Hello World " + str(count) cv2.putText(frame, text ,(mx,my),cv2.FONT_HERSHEY_SIMPLEX ,1,(255,255,255),1,cv2.LINE_AA) cv2.imshow('Frame',frame) except: #if there are no more frames to show... print('EOF') break #Abort and exit with 'Q' or ESC k = cv2.waitKey(30) &amp; 0xff if k == 27: breakcap.release() #release video filecv2.destroyAllWindows() #close all openCV windows 首先，我们使用cap.get（）方法计算视频中的中间坐标（宽度/ 2，高度/ 2）。 然后，在我们调用imshow（）之前，我们使用cv2.putText（）这种方法在视频帧上写入文本。 用法是：cv.PutText（img，text，org，font，color），其中org是要编写的文本的原点（左下角）。 如果你运行代码，你会看到这个： 我们也可以在视频框架中绘制直线，圆圈等，OpenCV有很多绘制几何形状的方法。 让我们画一些线：123456789101112131415161718192021222324252627282930import numpy as npimport cv2cap = cv2.VideoCapture('peopleCounter.avi') #Open video filewhile(cap.isOpened()): ret, frame = cap.read() #read a frame try: cv2.imshow('Frame',frame) frame2 = frame except: #if there are no more frames to show... print('EOF') break line1 = np.array([[100,100],[300,100],[350,200]], np.int32).reshape((-1,1,2)) line2 = np.array([[400,50],[450,300]], np.int32).reshape((-1,1,2)) frame2 = cv2.polylines(frame2,[line1],False,(255,0,0),thickness=2) frame2 = cv2.polylines(frame2,[line2],False,(0,0,255),thickness=1) cv2.imshow('Frame 2',frame2) #Abort and exit with 'Q' or ESC k = cv2.waitKey(30) &amp; 0xff if k == 27: breakcap.release() #release video filecv2.destroyAllWindows() #close all openCV windows 这一次，我们在try块外工作，并使用两个视频窗口，一个用于显示原始视频，另一个用线条显示修改的视频。 为了使多段线正常工作，它需要为线段中的每个点（在我们的例子中为起点和终点）接收一个包含坐标对（x和y）的numpy数组。 如果你想像我一样指定点，你还需要调用reshape（-1,1,2）来使用多段线（）。 如果你运行这个代码，你会看到： 这里是OpenCV的绘图功能文档。]]></content>
      <categories>
        <category>OpenCV</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-2-读取视频流]]></title>
    <url>%2F2018%2F04%2F23%2FOpenCV-2-%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E6%B5%81%2F</url>
    <content type="text"><![CDATA[OpenCV-2-读取视频流视频链接 读取视频文件123456789101112131415161718192021import numpy as npimport cv2cap = cv2.VideoCapture('peopleCounter.avi') #Open video filewhile(cap.isOpened()): ret, frame = cap.read() #read a frame try: cv2.imshow('Frame',frame) except: #if there are no more frames to show... print('EOF') break #Abort and exit with 'Q' or ESC k = cv2.waitKey(30) &amp; 0xff if k == 27: breakcap.release() #release video filecv2.destroyAllWindows() #close all openCV windows 然后我们用VideoCapture对象打开视频文件，将视频文件的位置作为参数。 我们从视频中读取相框并逐一展示，直到我们到达结尾。 此时，我们退出while循环并关闭视频文件和视频窗口。使用网络摄像头非常相似.唯一的区别是我们如何创建VideoCapture对象。 这次我们将它作为参数传递给它。 这表示我们要使用ID为0的网络摄像头。您的计算机上是否有多个网络摄像头，例如USB网络摄像头，另一个嵌入了您的屏幕上，您需要传递0或1，具体取决于您想要哪一个使用。 VideoCapture对象有几个属性，您可以访问并且有时会更改. 从摄像头读取视频12345678910111213141516171819import numpy as npimport cv2cap = cv2.VideoCapture(0) while(cap.isOpened()): ret, frame = cap.read() try: cv2.imshow('Frame',frame) except: print('EOF') break k = cv2.waitKey(30) &amp; 0xff if k == 27: breakcap.release()cv2.destroyAllWindows() 下面是一个示例，显示所有属性的值并更改网络摄像头中视频流的宽度和高度. 1234567891011121314151617181920212223242526import numpy as npimport cv2cap = cv2.VideoCapture(0)#show all video propertiesfor i in range(19): print(i, cap.get(i))cap.set(3,160) #set widthcap.set(4,120) #set height while(cap.isOpened()): ret, frame = cap.read() try: cv2.imshow('Frame',frame) except: print('EOF') break k = cv2.waitKey(30) &amp; 0xff if k == 27: breakcap.release()cv2.destroyAllWindows()]]></content>
      <categories>
        <category>OpenCV</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV-1-图片处理]]></title>
    <url>%2F2018%2F04%2F23%2FOpenCV-1-%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[OpenCV-1-图片处理下载图片12345678910111213141516import cv2import numpy as npimg = cv2.imread('Lenna.png') #load RGB imageimgGS = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #convert RGB to grayscalecv2.imwrite("LennaGS.png",imgGS) #save grayscale imageret,imgBW = cv2.threshold(imgGS,127,255,cv2.THRESH_BINARY) #binarizationcv2.imwrite("LennaBW.png",imgBW) #save binary imagecv2.imshow('Original image', img) #Display original imagecv2.imshow('Grayscale image', imgGS) #Display grayscale imagecv2.imshow('Binary image', imgBW) #Display binarized imagecv2.waitKey(0) #exit with 'Q' or ESCcv2.destroyAllWindows()]]></content>
      <categories>
        <category>OpenCV</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>OpenCV</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow实战-第11章-TF.Contrib的其他组件]]></title>
    <url>%2F2018%2F04%2F18%2FTensorFlow%E5%AE%9E%E6%88%98-%E7%AC%AC11%E7%AB%A0-TF-Contrib%E7%9A%84%E5%85%B6%E4%BB%96%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow实战-第10章-TF.Learn从入门到精通]]></title>
    <url>%2F2018%2F04%2F18%2FTensorFlow%E5%AE%9E%E6%88%98-%E7%AC%AC10%E7%AB%A0-TF-Learn%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow实战-第9章-TensorBoard-多GPU并行及分布式并行]]></title>
    <url>%2F2018%2F04%2F18%2FTensorFlow%E5%AE%9E%E6%88%98-%E7%AC%AC9%E7%AB%A0-TensorBoard-%E5%A4%9AGPU%E5%B9%B6%E8%A1%8C%E5%8F%8A%E5%88%86%E5%B8%83%E5%BC%8F%E5%B9%B6%E8%A1%8C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow实战-第8章-TensorFlow实现深度请强化学习]]></title>
    <url>%2F2018%2F04%2F18%2FTensorFlow%E5%AE%9E%E6%88%98-%E7%AC%AC8%E7%AB%A0-TensorFlow%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%BA%A6%E8%AF%B7%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow实战-第7章-TensorFlow实现循环神经网络RNN及Word2Vec]]></title>
    <url>%2F2018%2F04%2F18%2FTensorFlow%E5%AE%9E%E6%88%98-%E7%AC%AC7%E7%AB%A0-TensorFlow%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CRNN%E5%8F%8AWord2Vec%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow实战-第6章-TensorFlow实现经典卷积神经网络]]></title>
    <url>%2F2018%2F04%2F18%2FTensorFlow%E5%AE%9E%E6%88%98-%E7%AC%AC6%E7%AB%A0-TensorFlow%E5%AE%9E%E7%8E%B0%E7%BB%8F%E5%85%B8%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow实战-第5章-TensorFlow实现卷积神经网络CNN]]></title>
    <url>%2F2018%2F04%2F18%2FTensorFlow%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%AB%A0-TensorFlow%E5%AE%9E%E7%8E%B0%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN%2F</url>
    <content type="text"><![CDATA[第5章-TensorFlow实现卷积神经网络CNN5.1 卷积神经网络简介卷积神经网络CNN最初是为了解决图像识别等问题设计的，当然现在的应用已经不限于图像和视频，也可以用于时间序列信号，比如音频信号、文本数据等。 在深度学习出现之前，必须借助SIFT、HoG等算法提取出有效而丰富的特征，再集合SVM等机器学习算法进行图像识别。Snipaste_2018-04-18_17-11-33.png CNN作为一个深度学习架构被提出来最初的诉求是降低对图像数据预处理的要求，以及避免复杂的特征工程。CNN最大的特点是在于卷积的权值共享结构，可以大幅减少神经网络的参数量，方式过拟合的同时又降低了神经网络模型的复杂度。 卷积神经网络的历史感受野 —&gt; 神经认知机(S-cells/C-cells) 卷积神经网络可以利用空间结构关系减少需要学习的参数量，从而提高方向传播算法的训练效率。在卷积神经网络中，第一个卷积层直接接受图像像素的输入，每一个卷积操作只处理一小块图像，进行卷积变化后再传到后面的网络，每一层卷积都会提取数据中最有效的特征。这种方法可以提取到图像中最基本的特征，而后再进行组合和抽象形成更高阶的特征。 一般卷积神经网络由多个卷积层构成，每个卷积层中通常会进行如下几个操作。 图像通过多个不同的卷积核的滤波，并加偏置，提取出局部特征，每一个卷积核会映射出一个新的2D图像 将前面卷积核的滤波输出结果，进行非线性的激活函数处理。目前最常见的是使用ReLUctant函数，而以前sigmoid函数用的比较多。 再激活函数的结果再进行池化操作(即降采样)，目前一般是使用最大池化，保留最显著的特征，并提高模型的畸变容忍能力。这几个步骤构成了最常见的卷积层，当然也可以加上一个LRN（局部响应归一化层）层，目前非常流程的trick还有batch normalization等。 一个卷积层中可以有多个不同的卷积核，而每一个卷积核都对应一个滤波后映射的新图像，同一个新图像中每一个像素都来自完全相同的卷积核，这就是卷积核的权值共享。我们为什么要共享卷积核的权值参数呢？答案很简单，降低模型复杂度，减轻过拟合并降低计算量。Snipaste_2018-04-18_17-29-12.png 每一个卷积核滤波得到的图像就是一类特征的映射，即一个Feature map。参数量和隐含节点个数或者图片大小无关，只跟卷积核的大小有关，这就是所谓的权值共享。Snipaste_2018-04-18_17-32-56.png 总结一下就是，卷积神经网络的要点就是局部连接、权值共享、池化层中的降采样。 LeNet5LeNet5是最早的深层卷积神经网络之一LeNet5特性有如下几点： 每个卷积层包含三部分，卷积、池化和非线性激活函数 使用卷积提取空间特征 降采样的平均池化层 双曲正切tanh或者s型sigmoid的激活函数 MLP多层感知机作为最后的分类器 层与层之间的稀疏连接减少计算复杂度 LeNet5结构图如下所示：Snipaste_2018-04-18_17-47-25.png 5.2 TensorFlow实现简单的卷积网络]]></content>
      <categories>
        <category>机器学习</category>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>TensorFlow</tag>
        <tag>CNN</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow实战-第4章-TensorFlow实现自编码器及多层感知机]]></title>
    <url>%2F2018%2F04%2F18%2FTensorFlow%E5%AE%9E%E6%88%98-%E7%AC%AC4%E7%AB%A0-TensorFlow%E5%AE%9E%E7%8E%B0%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8%E5%8F%8A%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[第4章-TensorFlow实现自编码器及多层感知机4.1 自编码器简介深度学习在早期一度被认为是一种无监督的特征学习，模仿了人脑的对特征逐层抽象提取的过程。这其中两点很重要，一是无监督学习，即我们不需要标注数据就可以对数据进行一定程度的学习，这种学习是对数据内容的组织形式的学习，抽取的是频繁出现的特征，二是逐层抽象，特征是需要不断抽象的，就像人总是从简单基础的概念开始学习，再到复杂的概念。 简单的特征是可以不断抽象转化为高一级的特征的，那我们如何找到这些结构呢，然后如何抽象呢？如果我们有狠毒哦标注的数据，就可以训练一个深层的神经网络。如果没有标注的数据呢？这种情况下，我们依然可以使用无监督的自编码器来提取特征。自编码器，就是可以使用自身的高阶特征编码自己。自编码器也是一种神经网络，它的输入和输出是一直的，它借助稀疏编码的思想，目标是使用稀疏的一些高阶特征重新组合来重构自己。因此特点非常明显，第一，期望输入和输出一直，第二，希望使用高阶特征重构自己，而不是复制像素点。 自编码器通常希望使用少量稀疏的高阶特征来重构输入，所以我们可以加入几种限制： 如果限制中间隐含层节点的数据量，比如让中间银行曾节点的数量小于输入/输出节点的数据量，就相当于一个降维过程。 如果给数据加入噪声，那么就是denoising antuoencoder去噪自编码器，我们将从噪声中学习数据的特征。 去噪自编码器中最常使用的是加性高斯噪声AGN，其结构图如下： 当然也可以使用masking noise，即有随机遮挡的噪声，这样图像中的一部分像素被置为0，模型需要从其他像素结构推测出这些被遮挡的像素是什么，因此模型依然需要学习图像中抽象的高阶特征。 如果自编码器的隐含层只有一层，其原理类似于主成分PCA。 Hinton教授提出了基于深度信念网络（DBN），由多层RBM堆叠而成。我们可能很难直接训练极深的网络，但是可以用无监督的朱岑个训练提取特征，将网络的权重初始化到一个比较好的位置，辅助后面的监督训练。在DBN模型中，含有多个隐含层，每一个隐含层都是限制性玻尔兹曼RBM（一种具有特殊连接分布分神经网络）。DBN训练时，需要先对每两层见进行无监督的预训练，这个过程相当于一个多层的自编码器，可以将整个网络的权重初始化到一个理想的分布。最后通过反向传播算法调整模型权重，这个步骤会使用经过标注的信息来做监督性的分类训练，也解决了网络过深带来的梯度弥散问题。简单的说，hinton的思路是先用自编码器的方法进行无监督的预训练，提取特征并初始化权重，然后使用标注信息进行监督式的训练。 4.2 TensorFlow实现自编码器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# 依然使用mnist数据集import numpy as npimport sklearn.preprocessing as prepimport tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_data#一种初始化方法xavier_init，模型的权重初始化太小容易在层间传递时逐渐缩小而难以起到作用，如果太大，在层间传递时将逐渐放大而导致发散或者失效。#最好的方法是不大也不小，从数学角度就是满足方差是2/(n_in+n_out)均匀或者高斯分布。#下面就是构建了一个均匀分布。方差刚好是2/(n_in+n_out)#fan_in是输入节点的个数，fan_out是输出节点的个数def xavier_init(fan_in, fan_out, constant = 1): low = -constant * np.sqrt(6.0 / (fan_in + fan_out)) high = constant * np.sqrt(6.0 / (fan_in + fan_out)) return tf.random_uniform((fan_in, fan_out), minval = low, maxval = high, dtype = tf.float32)class AdditiveGaussianNoiseAutoencoder(object): #n_input:输入变量数 #n_hidden:隐含层节点数 #transfer_function:隐含层激活函数，默认是softplus #optimizer:优化器，默认是adam #scale:高斯噪声系数，默认是0.1 def __init__(self, n_input, n_hidden, transfer_function = tf.nn.softplus, optimizer = tf.train.AdamOptimizer(), scale = 0.1): self.n_input = n_input self.n_hidden = n_hidden self.transfer = transfer_function self.scale = tf.placeholder(tf.float32) self.training_scale = scale network_weights = self._initialize_weights() self.weights = network_weights # model #self.x 输入 # self.transfer对w1*(x+n)+b1进行几乎偶函数处理 #经过隐含层后，需要在输出层上进行数据复原、重建操作。h*w2+b2 self.x = tf.placeholder(tf.float32, [None, self.n_input]) self.hidden = self.transfer(tf.add(tf.matmul(self.x + scale * tf.random_normal((n_input,)), self.weights['w1']), self.weights['b1'])) self.reconstruction = tf.add(tf.matmul(self.hidden, self.weights['w2']), self.weights['b2']) # cost #这里使用平方误差作为cost，1/2*sum((x'-x)^2) self.cost = 0.5 * tf.reduce_sum(tf.pow(tf.subtract(self.reconstruction, self.x), 2.0)) self.optimizer = optimizer.minimize(self.cost) #初始化模型所有参数 init = tf.global_variables_initializer() self.sess = tf.Session() self.sess.run(init) #创建一个存储各个参数的字典，其中w1使用xavier_init初始化，其余初始化为0 def _initialize_weights(self): all_weights = dict() all_weights['w1'] = tf.Variable(xavier_init(self.n_input, self.n_hidden)) all_weights['b1'] = tf.Variable(tf.zeros([self.n_hidden], dtype = tf.float32)) all_weights['w2'] = tf.Variable(tf.zeros([self.n_hidden, self.n_input], dtype = tf.float32)) all_weights['b2'] = tf.Variable(tf.zeros([self.n_input], dtype = tf.float32)) return all_weights #执行一步训练的函数partial_fit def partial_fit(self, X): cost, opt = self.sess.run((self.cost, self.optimizer), feed_dict = &#123;self.x: X, self.scale: self.training_scale &#125;) return cost #只求损失函数的calc_total_cost def calc_total_cost(self, X): return self.sess.run(self.cost, feed_dict = &#123;self.x: X, self.scale: self.training_scale &#125;) #transform函数只返回自编码器隐含层的输出结果 def transform(self, X): return self.sess.run(self.hidden, feed_dict = &#123;self.x: X, self.scale: self.training_scale &#125;) #通过重建层提取到高阶特征复原为原始数据 def generate(self, hidden = None): if hidden is None: hidden = np.random.normal(size = self.weights["b1"]) return self.sess.run(self.reconstruction, feed_dict = &#123;self.hidden: hidden&#125;) #reconstruct = transform+generate def reconstruct(self, X): return self.sess.run(self.reconstruction, feed_dict = &#123;self.x: X, self.scale: self.training_scale &#125;) def getWeights(self): return self.sess.run(self.weights['w1']) def getBiases(self): return self.sess.run(self.weights['b1']) 1234567891011#standard_scale对输入数据进行标准化处理def standard_scale(X_train, X_test): preprocessor = prep.StandardScaler().fit(X_train) X_train = preprocessor.transform(X_train) X_test = preprocessor.transform(X_test) return X_train, X_test#获取随机block数据的函数def get_random_block_from_data(data, batch_size): start_index = np.random.randint(0, len(data) - batch_size) return data[start_index:(start_index + batch_size)] 12345678910111213141516171819202122232425262728293031323334#获取数据集mnist = input_data.read_data_sets('MNIST_data', one_hot = True)#对输入数据进行标准化处理X_train, X_test = standard_scale(mnist.train.images, mnist.test.images)n_samples = int(mnist.train.num_examples)training_epochs = 20batch_size = 128display_step = 1autoencoder = AdditiveGaussianNoiseAutoencoder(n_input = 784, n_hidden = 200, transfer_function = tf.nn.softplus, optimizer = tf.train.AdamOptimizer(learning_rate = 0.001), scale = 0.01)for epoch in range(training_epochs): avg_cost = 0.0 total_batch = int(n_samples / batch_size) # Loop over all batches for i in range(total_batch): #获取随机block数据 batch_xs = get_random_block_from_data(X_train, batch_size) # Fit training using batch data cost = autoencoder.partial_fit(batch_xs) # Compute average loss avg_cost += cost / n_samples * batch_size # Display logs per epoch step if epoch % display_step == 0: print("Epoch:", '%04d' % (epoch + 1), "cost=", "&#123;:.9f&#125;".format(avg_cost))print("Total cost: " + str(autoencoder.calc_total_cost(X_test))) Extracting MNIST_data/train-images-idx3-ubyte.gz Extracting MNIST_data/train-labels-idx1-ubyte.gz Extracting MNIST_data/t10k-images-idx3-ubyte.gz Extracting MNIST_data/t10k-labels-idx1-ubyte.gz Epoch: 0001 cost= 18799.158003409 Epoch: 0002 cost= 12072.621204545 Epoch: 0003 cost= 10246.132863636 Epoch: 0004 cost= 10029.809239205 Epoch: 0005 cost= 9912.949165341 Epoch: 0006 cost= 9418.074565341 Epoch: 0007 cost= 9859.652969318 Epoch: 0008 cost= 9497.867059659 Epoch: 0009 cost= 9283.955078409 Epoch: 0010 cost= 8127.477447727 Epoch: 0011 cost= 9125.452381818 Epoch: 0012 cost= 8159.187385227 Epoch: 0013 cost= 8330.580655682 Epoch: 0014 cost= 8220.359098295 Epoch: 0015 cost= 8393.369086932 Epoch: 0016 cost= 8835.428011932 Epoch: 0017 cost= 7937.553089205 Epoch: 0018 cost= 8520.666870455 Epoch: 0019 cost= 7843.604306818 Epoch: 0020 cost= 8403.237051705 Total cost: 643869.4 至此，去噪自编码器实现就全部完成了。自编码器作为一种无监督学习的方法，它与其他无监督学习的主要不同是，它不是对数据进行聚类，而是提取其中最有用、最频繁出现的高阶特征，根据这些高阶特征重构数据。 4.3 多层感知机简介为了拟合复杂的场景，需要隐含层，但是过深的神经网络会遇到过拟合、参数难以调试、梯度弥散等问题。对于这些问题我们徐亚哦很多的trick来解决。 过拟合是指在模型预测准确率在训练集上升高了，但是在测试集上却小江了，通常意味着泛化能力不好，模型只是记忆了当前数据的特征，不具备推广能力。Hilton团队提出来一个dropout方法，它的大致思路是在训练时，将神将网络的某一层的输出节点数据随机丢弃一部分。dropout也算是一种bagging方法，可以理解为每次丢弃节点数据是对特征的一种采样。 参数难以调试是另外一个痛点，尤其是SGD参数。 梯度弥散，之前的sigmoid容易在层间传播误差，直到ReLU出现才比较完美解决了梯度弥散问题。ReLU是一个简单的非线性函数y=max(0,x) ReLU相对于sigmoid主要变化有三个： 单侧抑制 相对宽阔的兴奋边界 稀疏激活性 当然，深加工年网络的额输出层一般都还是sigmoid函数，因为它最接近概率输出分布。 说了那么多，隐含层到底有什么用呢。隐含层代表性的功能是可以解决XOR问题。没有隐含层的神经网络是线性的，这是早期神经网络的致命缺陷，当引入了隐含层并使用了非线性的激活函数后我们可以使用曲线划分样本，解决XOR异或函数的分类问题。神经网络的隐含层越多，就可以对原有特征进行越抽象的变换，模型的拟合能力越强，这就是多层感知机MLP的功能所在。 4.4 TensorFlow实现多层感知机加入隐含层 123456789101112131415161718192021222324252627282930313233343536373839# Create the model#载入MNIST_datafrom tensorflow.examples.tutorials.mnist import input_dataimport tensorflow as tfmnist = input_data.read_data_sets("MNIST_data/", one_hot=True)sess = tf.InteractiveSession()in_units = 784 #输入节点个数h1_units = 300 #隐含层节点个数#tf.truncated_normal截断为正态分布W1 = tf.Variable(tf.truncated_normal([in_units, h1_units], stddev=0.1))b1 = tf.Variable(tf.zeros([h1_units]))W2 = tf.Variable(tf.zeros([h1_units, 10]))b2 = tf.Variable(tf.zeros([10]))x = tf.placeholder(tf.float32, [None, in_units])#dropout比率keep_prob在训练和预测时是不同的，训练小于1，预测等于1keep_prob = tf.placeholder(tf.float32)hidden1 = tf.nn.relu(tf.matmul(x, W1) + b1)hidden1_drop = tf.nn.dropout(hidden1, keep_prob)y = tf.nn.softmax(tf.matmul(hidden1_drop, W2) + b2)# Define loss and optimizery_ = tf.placeholder(tf.float32, [None, 10])cross_entropy = tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(y), reduction_indices=[1]))train_step = tf.train.AdagradOptimizer(0.3).minimize(cross_entropy)# Traintf.global_variables_initializer().run()for i in range(3000): batch_xs, batch_ys = mnist.train.next_batch(100) train_step.run(&#123;x: batch_xs, y_: batch_ys, keep_prob: 0.75&#125;)# Test trained modelcorrect_prediction = tf.equal(tf.argmax(y, 1), tf.argmax(y_, 1))accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))print(accuracy.eval(&#123;x: mnist.test.images, y_: mnist.test.labels, keep_prob: 1.0&#125;)) Extracting MNIST_data/train-images-idx3-ubyte.gz Extracting MNIST_data/train-labels-idx1-ubyte.gz Extracting MNIST_data/t10k-images-idx3-ubyte.gz Extracting MNIST_data/t10k-labels-idx1-ubyte.gz 0.979 在测试集上可以达到大约98%的准确率，相当于第三章的92%提升了不少。]]></content>
      <categories>
        <category>机器学习</category>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>TensorFlow</tag>
        <tag>神经网络</tag>
        <tag>自编码器</tag>
        <tag>多层感知机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow实战-第3章-TensorFlow第一步]]></title>
    <url>%2F2018%2F04%2F17%2FTensorFlow%E5%AE%9E%E6%88%98-%E7%AC%AC3%E7%AB%A0-TensorFlow%E7%AC%AC%E4%B8%80%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[3 TensorFlow第一步 393.1 TensorFlow的编译及安装 39 install ancondalink CPU versionconda install tensorflow GPU versionconda install tensorflow-gpu 3.2 TensorFlow实现SoftmaxRegression识别手写数字 46导入数据MNIST是一个非常简单的机器视觉数据集，由几万张28x28像素的手写数字组成，这些图片只包含灰度信息。 123456from tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets("MNIST_data/", one_hot=True)print(mnist.train.images.shape, mnist.train.labels.shape)print(mnist.test.images.shape, mnist.test.labels.shape)print(mnist.validation.images.shape, mnist.validation.labels.shape) Extracting MNIST_data/train-images-idx3-ubyte.gz Extracting MNIST_data/train-labels-idx1-ubyte.gz Extracting MNIST_data/t10k-images-idx3-ubyte.gz Extracting MNIST_data/t10k-labels-idx1-ubyte.gz (55000, 784) (55000, 10) (10000, 784) (10000, 10) (5000, 784) (5000, 10) 可以看到数据集中，训练集有55000个样本，测试集有10000个样本，验证集有5000个样本。这里的数据全部丢弃了图片的二维结构信息，只是把一张图片变成了一个很长的一维向量。我们可以使用matplotlib把一维数据还原为原来的图像。如下所示。 1234567from matplotlib import pyplot as plt% matplotlib inlinedata = mnist.train.images[0].reshape((28,28))plt.imshow(data)print(mnist.train.labels[0]) [0. 0. 0. 0. 0. 0. 0. 1. 0. 0.] ) 训练数据(55000, 784)，第一维是图片的编号，第二维是图片中像素点的编号。对10个种类的标签进行了onehot编码，如上所示，[0. 0. 0. 0. 0. 0. 0. 1. 0. 0.] 代表为7 准备好数据以后，接下来就要设计算法了这里使用了一个叫做softmax regression的算法来训练分类模型。 当我们处理分类任务时，通常需要使用softmax regression模型。即使后面章节中的CNN或者RNN，如果是分类模型，最后一层同样也是softmax regression。它的工作原理很简单，将可以判定为某类的特征想加，然后将这些特征转化为判定为这一类的概率。这些特征可以通过一些简单的方法得到，比如对所有像素求一个加权和，而权重是根据数据自动学习、训练出来的。比如某一个像素的灰度值大代表可能是数字n的概率越大。 如下公式： feature_i = \sum_j W_{ij} x_j + b_i其中i为第i类，j代表一张图片的第j个像素。b_i是bias。 接下来计算所有特征的softmax，简单的说就是计算一个exp函数，然后再进行标准化（让所有类别的输出的概率值和为1）。 softmax(x) = normalize(exp(x))其中判定为第i类的概率是： softmax(x)\_i = \frac {exp(x)}{\sum_j exp(x_j)} 可以用下面一行简洁的表达： y = softmax(Wx + b)cross_entropy的定义如下： H_{y'}(y) = - \sum_i {y_i'} log(y_i)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import tensorflow as tf# 创建InteractiveSession，使用这个命令会将这个session注册为默认的session，# 之后的计算也默认跑在这个session里面。# 不同session之间的数据和运算都是相互独立的。sess = tf.InteractiveSession()# 创建用于输入数据的placeholder，第一个参数是数据类型，第二个参数代表tensor的shape。# None表示不限制条数，784是表示一个784维的向量。x = tf.placeholder(tf.float32, [None, 784])#接下来要为softmax regression模型中的weight和biases创建Variable对象。#Variable中的数据是持久化的，长期存在并且在每轮迭代中被更新。#这里把weight和bias全部初始化为0，因为模型训练时会自动学习合适的值，所以对这个简单模型来说初始值不太重要。#但是对于复杂CNN RNN或者其他比较深的全连接网络来说，初始化的方法比较重要，甚至至关重要。W = tf.Variable(tf.zeros([784, 10]))b = tf.Variable(tf.zeros([10]))# 实现公式y = softmax(Wx + b)#tf.nn包含了大量的神经网络组件，softmax是其中之一。#tf.matmul是矩阵乘法函数y = tf.nn.softmax(tf.matmul(x, W) + b)# 为了训练模型，需要定义一个loss function来描述模型对问题的分类精度。#loss越小，代表模型分类结果和真实值的偏差越小，也就是说模型越准确。#对于多分类问题，通常使用cross-entrpopy作为loss function.#其中y是预测的概率分布，y'是真是的概率分布。#tf.reduce_mean用来对每个batch数据结果求平均值。y_ = tf.placeholder(tf.float32, [None, 10])cross_entropy = tf.reduce_mean(-tf.reduce_sum(y_ * tf.log(y), reduction_indices=[1]))#有了softmax regression和损失函数cross-entropy的定义，只需要再定义一个优化算法就可以开始训练。#我们常见的是随机梯度下降SGD，定义好优化算法后，TensorFlow就可以根据我们定义的整个计算图自动求导，并根据反向传播算法进行训练，在每一轮迭代时更新参数来减少loss。在后台TensorFlow会自动天津爱很多运算操作来实现刚才提到的返现爱你过传播和梯度下降，而给我们提供的是一个封装好的优化器。我们直接调用tf.train.GradientDescentOptimizer，并设置学习速率为0.5，优化目标设定为cross-entropy，得到进行训练的操作train_step。#下一步使用TensorFlow的全局参数初始化器tf.global_variables_initializer，并直接实行run方法。train_step = tf.train.GradientDescentOptimizer(0.5).minimize(cross_entropy)tf.global_variables_initializer().run()#最后一步，开始迭代执行训练操作train_step，这里每次都随机从训练集中抽取100条样本过程一个mini-batch，并feed给placehodler，然后调用train_step对这些样本进行训练。#使用一小部分数据进行随机梯度下降，这样绝大多数比全量样本训练的收敛速度更快，而且计算量不太大。#只有把数据feed时，并运行run方法时，计算才开始执行。for i in range(1000): batch_xs, batch_ys = mnist.train.next_batch(100) train_step.run(&#123;x: batch_xs, y_: batch_ys&#125;)#现在完成了训练，需要对模型的准确性进行验证。#tf.argmax是从一个tensor中找最大值的序号#tf.argmax(y, 1)是求各个预测的数字钟概率最大的那一个。#tf.argmax(y_, 1)则是找样本的真是数字类别。#tf.equal是判断预测的数字是否是真正的类别。#tf.cast将correct_prediction输出的bool值转换为float32correct_prediction = tf.equal(tf.argmax(y, 1), tf.argmax(y_, 1))accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))#最后计算模型的在测试集上的准确率，并打印出来结果。print(accuracy.eval(&#123;x: mnist.test.images, y_: mnist.test.labels&#125;)) 0.9194 总结从上面的例子，我们可以总结一下整个流程。 定义算法公式，也就是神经网络forward时的计算 定义loss，选定优化器，并指定优化器优化loss 迭代地对数据进行训练 在测试集或者验证集上对准确率进行评测。]]></content>
      <categories>
        <category>机器学习</category>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow实战-第2章-TensorFlow和其他深度学习框架的对比]]></title>
    <url>%2F2018%2F04%2F17%2FTensorFlow%E5%AE%9E%E6%88%98-%E7%AC%AC2%E7%AB%A0-TensorFlow%E5%92%8C%E5%85%B6%E4%BB%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[2 TensorFlow和其他深度学习框架的对比 182.1 主流深度学习框架对比 18 2.2 各深度学习框架简介 20TensorFlowTensorFlow是相对高阶的机器学习库，用户㐓方便地用它设计神经网络结构，而不必为了追求高效率的实现亲自写C++或者CUDA代码。 TensorFlow另外一个特点是灵活的移植性。TensorFlow还提供了TensorBoard，TensorBoard是TensorFlow的一组web应用，用来监控TensorFlow的运行过程，或可视化计算图。 caffe官方网址 链接github网址 链接 caffe的主要优势有以下几点： 容易上手，网络结构都是以配置文件形式定义，不需要用代码设计网络 训练速度快，能够训练state-of-the-art的模型与大规模的数据。 组件模块化，可以方便的拓展到新的模型和学习任务上。 caffe的一大优势是拥有大量的训练好的经典模型（AlexNet/VGG/Inception）乃至其他state-of-the-art(ResNet等)的模型。收藏在它的model zoo里。 Theano官方网址 链接github网址 链接 Theano的主要优势如下： 集成numpy，可以直接使用numpy的ndarray，API接口学习成本低。 计算稳定性好 动态的生成C或者cuda代码，用以编译成高效率的机器代码。 Theano是一个完全基于python的符号计算库。 Torch官方网址 链接github网址 链接 Torch是LuaJIT上的一个高效的科学计算库，支持大量的机器学习算法，同事以GPU上的计算优先。 Lasagne官方网址 链接github网址 链接 Lasagne是一个基于Theano的轻量级的神经网络库。 Keras官方网址 链接github网址 链接 Keras是崇尚极简、高度模块化的神经网络库，使用python实现，并可以同事运行在TensorFlow和Theano上。 MXNet官方网址 链接github网址 链接 MXNet是DMLC开发的一款开源的、轻量级、可移植的、灵活的深度学习库，它让用户可以混合使用符号编程模式和指令式编程模式来最大化效率和灵活性。 DIGITS官方网址 链接github网址 链接 DIGITS不是一个标准的深度学习库，它可以算是caffe的高级封装。 CNTK官方网址 链接github网址 链接 CNTK是微软研究院开源的深度学习框架。CNTK设计是性能导向的。 Deepelearning4J官方网址 链接github网址 链接 Deepelearning4J是一个基于java和scala的开源的分布式深度学习库，其核心目标是创建一个即插即用的解决方案原型。 chainer官方网址 链接github网址 链接 chainer特性描述： powerfull 支持cuda计算 flexible 支持多种前馈神经网络 intuitive 前馈计算可以引入python的各种控制流 leaf官方网址 链接github网址 链接 leaf是一个基于Rust语言的直观的跨平台的深度学习乃至机器智能框架。 DSSTNEgithub网址 链接 DSSTNE是亚马逊开源的稀疏神经网络框架，在训练稀疏的数据时具有很大优势。]]></content>
      <categories>
        <category>机器学习</category>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow实战-第1章-TensorFlow基础]]></title>
    <url>%2F2018%2F04%2F17%2FTensorFlow%E5%AE%9E%E6%88%98-%E7%AC%AC1%E7%AB%A0-TensorFlow%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[第1章-TensorFlow基础1.1 TensorFlow概要TensorFlow官方网站 链接TensorFlow github网站 链接TensorFlow模型仓库网站 链接 TensorFlow既是一个实现机器学习算法的接口，同时也是执行机器学习算法的框架。 TensorFlow使用数据流式图来规划计算流程的，它可以将计算映射到不同硬件和操作系统平台。 1.2 TensorFlow编程模型简介1.2.1 核心概念TensorFlow中的计算可以表示为一个有向图，或者称为计算图，其中的每一个计算操作将作为一个节点，节点和节点之间的连接称为边。计算图的每一个节点可以有任意个输入和任意个输出，每一个节点描述了一种运算操作，节点可以算是运算操作的实例化。在计算图边中流动的数据被称为张量(tensor)。 session是用户使用TensorFlow时的交互式接口。 1.2.2 实现原理TensorFlow有一个重要的组件是client即客户端，它通过session的接口和master以及多个work相连。其中每一个work可以与多个硬件设备相连，并负责管理这些硬件。而master则负责指导所有的work按照流程执行计算图。TensorFlow分为单机好分布式两种。 TensorFlow为CPU和GPU提供了管理设备的对象接口，每一个对象负责分配、释放设备的内存，以及执行节点的运算核。 在只有一个硬件设备的情况下，计算图会按照依赖关系被顺序执行。当有多个设备时，情况变得复杂，难点有二： 每一个节点该让什么硬件设备来执行 如何管理节点之间的数据通信。第一个问题，TensorFlow设计了一套为节点分配资源的策略。第二个问题，在多个设备上，计算图会被划分为许多子图，子图通过发送节点和接收节点通信。 1.2.3 拓展功能 TensorFlow原生支持自动求导，但是也会给TensorFlow的优化带来麻烦。 TensorFlow还支持单独执行子图。 TensorFlow支持计算图的控制流。（if/while etc.) input node可以让用户直接输入文件系统路径 队列是TensorFlow任务调度的一个重要特性 容器是TensorFlow中一种特殊的管理长期变量的机制 1.2.4 性能优化 TensorFlow能自动识别重复计算，并改写计算图 可以巧妙的安排计算的顺序来改善数据传输和内存占用的问题 支持异步计算 第三方高度优化库，eg. cuDNN,cuda-convenet 支持对数据精度进行压缩 TensorFlow提供了三种不同的加速神经网络训练的并行计算模式 数据并行 模型并行 流水线并行]]></content>
      <categories>
        <category>机器学习</category>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql导入导出]]></title>
    <url>%2F2018%2F04%2F16%2Fmysql%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%2F</url>
    <content type="text"><![CDATA[导入导出 1.导入用文本形式插入数据 LOAD DATA LOCAL INFILE ‘d:/mysql.txt’ INTO TABLE mytable;导入.sql use database;source d:/mysql.sql从另外一张表往这张表插入 INSERT INTO tab1(f1,f2)SELECT a.f1, a.f2FROM a WHERE a.f1=’a’ 2.备份导出要用到MySQL的mysqldump工具，基本用法是： mysqldump [OPTIONS] database [tables]备份MySQL数据库的命令 mysqldump -hhostname -uusername -ppassword databasename backupfile.sql备份MySQL数据库为带删除表的格式，能够让该备份覆盖已有数据库而不需要手动删除原有数据库。 mysqldump -–add-drop-table -uusername -ppassword databasename backupfile.sql直接将MySQL数据库压缩备份 mysqldump -hhostname -uusername -ppassword databasename | gzip backupfile.sql.gz备份MySQL数据库某个(些)表 mysqldump -hhostname -uusername -ppassword databasename specific_table1 specific_table2 backupfile.sql同时备份多个MySQL数据库 mysqldump -hhostname -uusername -ppassword –databases databasename1 databasename2 databasename3 multibackupfile.sql仅仅备份数据库结构 mysqldump –no-data –databases databasename1 databasename2 databasename3 structurebackupfile.sql备份服务器上所有数据库 mysqldump –all-databases allbackupfile.sql还原 3.还原MySQL数据库的命令mysql -hhostname -uusername -ppassword databasename &lt; backupfile.sqlmysql -hhostname -ppassword databasename tablename &lt; backuptablefile.sql还原压缩的MySQL数据库 gunzip &lt; backupfile.sql.gz | mysql -uusername -ppassword databasename将数据库转移到新服务器 mysqldump -uusername -ppassword databasename | mysql –host=... -C databasename将查询结果导入外部文件 SELECT a,b,a+bFROM test_tableINTO OUTFILE ‘/tmp/result.txt’FIELDS TERMINATED BY ‘,’ OPTIONALLY ENCLOSED BY ‘“‘LINES TERMINATED BY ‘\n’ 或者 mysql -u you -p -e “SELECT …” file_name]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第30章-改善性能]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC30%E7%AB%A0-%E6%94%B9%E5%96%84%E6%80%A7%E8%83%BD%2F</url>
    <content type="text"><![CDATA[第30章-改善性能本章将复习与MySQL性能有关的某些要点。 30.1 改善性能数据库管理员把他们生命中的相当一部份时间花在了调整、试验以改善DBMS性能之上。在诊断应用的滞缓现象和性能问题时，性能不良的数据库（以及数据库查询）通常是最常见的祸因。可以看出，下面的内容并不能完全决定MySQL的性能。我们只是想回顾一下前面各章的重点，提供进行性能优化探讨和分析的一个出发点。 首先， MySQL（与所有DBMS一样）具有特定的硬件建议。在学习和研究MySQL时，使用任何旧的计算机作为服务器都可以。但对用于生产的服务器来说，应该坚持遵循这些硬件建议。 一般来说，关键的生产DBMS应该运行在自己的专用服务器上。 MySQL是用一系列的默认设置预先配置的，从这些设置开始通常是很好的。但过一段时间后你可能需要调整内存分配、缓冲区大小等。（为查看当前设置，可使用 SHOW VARIABLES;和 SHOWSTATUS;。） MySQL一个多用户多线程的DBMS，换言之，它经常同时执行多个任务。如果这些任务中的某一个执行缓慢，则所有请求都会执行缓慢。如果你遇到显著的性能不良，可使用SHOW PROCESSLIST显示所有活动进程（以及它们的线程ID和执行时间）。你还可以用KILL命令终结某个特定的进程（使用这个命令需要作为管理员登录）。 总是有不止一种方法编写同一条SELECT语句。 应该试验联结、并、子查询等，找出最佳的方法。 使用EXPLAIN语句让MySQL解释它将如何执行一条SELECT语句。 一般来说，存储过程执行得比一条一条地执行其中的各条MySQL语句快。 应该总是使用正确的数据类型。 决不要检索比需求还要多的数据。换言之，不要用SELECT *（除非你真正需要每个列）。 有的操作（包括INSERT）支持一个可选的DELAYED关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。 在导入数据时，应该关闭自动提交。你可能还想删除索引（包括FULLTEXT索引），然后在导入完成后再重建它们。 必须索引数据库表以改善数据检索的性能。确定索引什么不是一件微不足道的任务，需要分析使用的SELECT语句以找出重复的WHERE和ORDER BY子句。如果一个简单的WHERE子句返回结果所花的时间太长，则可以断定其中使用的列（或几个列）就是需要索引的对象。 你的SELECT语句中有一系列复杂的OR条件吗？通过使用多条SELECT语句和连接它们的UNION语句，你能看到极大的性能改进。 索引改善数据检索的性能，但损害数据插入、删除和更新的性能。如果你有一些表，它们收集数据且不经常被搜索，则在有必要之前不要索引它们。（索引可根据需要添加和删除。） LIKE很慢。一般来说，最好是使用FULLTEXT而不是LIKE。 数据库是不断变化的实体。一组优化良好的表一会儿后可能就面目全非了。由于表的使用和内容的更改，理想的优化和配置也会改变。 最重要的规则就是，每条规则在某些条件下都会被打破。27830.2 小结 211浏览文档 位于MySQL文档有许多提示和技巧（甚至有用户提供的评论和反馈）。一定要查看这些非常有价值的资料。 30.2 小结本章回顾了与MySQL性能有关的某些提示和说明。当然，这只是一小部分，不过，既然你已经完成了本书的学习，你应该能试验和掌握自己觉得最适合的内容。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第29章-数据库维护]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC29%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4%2F</url>
    <content type="text"><![CDATA[第29章-数据库维护本章学习如何进行常见的数据库维护。 29.1 备份数据像所有数据一样， MySQL的数据也必须经常备份。由于MySQL数据库是基于磁盘的文件，普通的备份系统和例程就能备份MySQL的数据。但是，由于这些文件总是处于打开和使用状态，普通的文件副本备份不一定总是有效。下面列出这个问题的可能解决方案。 使用命令行实用程序mysqldump转储所有数据库内容到某个外部文件。在进行常规备份前这个实用程序应该正常运行，以便能正确地备份转储文件。 可用命令行实用程序mysqlhotcopy从一个数据库复制所有数据（并非所有数据库引擎都支持这个实用程序）。 可以使用MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，此系统文件必须不存在，否则会出错。数据可以用RESTORETABLE来复原。首先刷新未写数据 为了保证所有数据被写到磁盘（包括索引数据），可能需要在进行备份前使用FLUSH TABLES语句。 29.2 进行数据库维护MySQL提供了一系列的语句，可以（应该）用来保证数据库正确和正常运行。以下是你应该知道的一些语句。 ANALYZE TABLE，用来检查表键是否正确。 ANALYZE TABLE返回如下所示的状态信息： CHECK TABLE用来针对许多问题对表进行检查。在MyISAM表上还对索引进行检查。 CHECK TABLE支持一系列的用于MyISAM表的方式。CHANGED检查自最后一次检查以来改动过的表。 EXTENDED执行最彻底的检查， FAST只检查未正常关闭的表， MEDIUM检查所有被删除的链接并进行键检验， QUICK只进行快速扫描。如下所示， CHECKTABLE发现和修复问题： 如果MyISAM表访问产生不正确和不一致的结果，可能需要用REPAIR TABLE来修复相应的表。这条语句不应该经常使用，如果需要经常使用，可能会有更大的问题要解决。 如果从一个表中删除大量数据，应该使用OPTIMIZE TABLE来收回输入输出输入27429.4 查看日志文件 207所用的空间，从而优化表的性能。 29.3 诊断启动问题服务器启动问题通常在对MySQL配置或服务器本身进行更改时出现。 MySQL在这个问题发生时报告错误，但由于多数MySQL服务器是作为系统进程或服务自动启动的，这些消息可能看不到。在排除系统启动问题时，首先应该尽量用手动启动服务器。 MySQL服务器自身通过在命令行上执行mysqld启动。下面是几个重要的mysqld命令行选项： —help显示帮助——一个选项列表； —safe-mode装载减去某些最佳配置的服务器； —verbose显示全文本消息（为获得更详细的帮助消息与—help联合使用）； —version显示版本信息然后退出。几个另外的命令行选项（与日志文件的使用有关）在下一节列出。 29.4 查看日志文件MySQL维护管理员依赖的一系列日志文件。主要的日志文件有以下几种。 错误日志。它包含启动和关闭问题以及任意关键错误的细节。此日志通常名为hostname.err，位于data目录中。此日志名可用—log-error命令行选项更改。 查询日志。它记录所有MySQL活动，在诊断问题时非常有用。此日志文件可能会很快地变得非常大，因此不应该长期使用它。此日志通常名为hostname.log，位于data目录中。此名字可以用—log命令行选项更改。 二进制日志。它记录更新过数据（或者可能更新过数据）的所有语句。此日志通常名为hostname-bin，位于data目录内。此名字可以用—log-bin命令行选项更改。注意， 这个日志文件是MySQL275208 第 29 章 数据库维护5中添加的，以前的MySQL版本中使用的是更新日志。 缓慢查询日志。顾名思义，此日志记录执行缓慢的任何查询。这个日志在确定数据库何处需要优化很有用。此日志通常名为hostname-slow.log ， 位 于 data 目 录 中 。 此 名 字 可 以 用—log-slow-queries命令行选项更改。在使用日志时，可用FLUSH LOGS语句来刷新和重新开始所有日志文件。 29.5 小结本章介绍了MySQL数据库的某些维护工具和技术。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第28章-安全管理]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC28%E7%AB%A0-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[第28章-安全管理数据库服务器通常包含关键的数据，确保这些数据的安全和完整需要利用访问控制。本章将学习MySQL的访问控制和用户管理。 28.1 访问控制MySQL服务器的安全基础是：用户应该对他们需要的数据具有适当的访问权，既不能多也不能少。换句话说，用户不能对过多的数据具有过多的访问权。考虑以下内容： 多数用户只需要对表进行读和写，但少数用户甚至需要能创建和删除表； 某些用户需要读表，但可能不需要更新表； 你可能想允许用户添加数据，但不允许他们删除数据； 某些用户（管理员）可能需要处理用户账号的权限，但多数用户不需要； 你可能想让用户通过存储过程访问数据，但不允许他们直接访问数据； 你可能想根据用户登录的地点限制对某些功能的访问。这些都只是例子，但有助于说明一个重要的事实，即你需要给用户提供他们所需的访问权，且仅提供他们所需的访问权。这就是所谓的访问控制，管理访问控制需要创建和管理用户账号。263198 使用MySQL Administrator MySQL Administrator （在第2章中描述）提供了一个图形用户界面，可用来管理用户及账号权限。MySQL Administrator在内部利用本章介绍的语句，使你能交互地、方便地管理访问控制。回忆一下第3章的内容，我们知道，为了执行数据库操作，需要登录MySQL。 MySQL创建一个名为root的用户账号，它对整个MySQL服务器具有完全的控制。你可能已经在本书各章的学习中使用root进行过登录，在对非现实的数据库试验MySQL时，这样做很好。不过在现实世界的日常工作中，决不能使用root。应该创建一系列的账号，有的用于管理，有的供用户使用，有的供开发人员使用，等等。防止无意的错误 重要的是注意到，访问控制的目的不仅仅是防止用户的恶意企图。数据梦魇更为常见的是无意识错误的结果，如错打MySQL语句，在不合适的数据库中操作或其他一些用户错误。通过保证用户不能执行他们不应该执行的语句，访问控制有助于避免这些情况的发生。不要使用root 应该严肃对待root登录的使用。仅在绝对需要时使用它（或许在你不能登录其他管理账号时使用）。不应该在日常的MySQL操作中使用root。 28.2 管理用户MySQL用户账号和信息存储在名为mysql的MySQL数据库中。一般不需要直接访问mysql数据库和表（你稍后会明白这一点），但有时需要直接访问。需要直接访问它的时机之一是在需要获得所有用户账号列表时。为此，可使用以下代码：mysql数据库有一个名为user的表， 它包含所有用户账号。user表有一个名为user的列，它存储用户登录名。新安装的服务器可能只有一个用户（如这里所示）， 过去建立的服务器可能具有很多用户。用多个客户机进行试验 试验对用户账号和权限进行更改的最好办法是打开多个数据库客户机（如mysql命令行实用程序的多个副本），一个作为管理登录，其他作为被测试的用户登录。 28.2.1 创建用户账号为了创建一个新用户账号，使用CREATE USER语句，如下所示：CREATE USER创建一个新用户账号。在创建用户账号时不一定需要口令，不过这个例子用IDENTIFIED BY ‘p@$$wOrd’给出了一个口令。如果你再次列出用户账号，将会在输出中看到新账号。指定散列口令 IDENTIFIED BY指定的口令为纯文本， MySQL将在保存到user表之前对其进行加密。为了作为散列值指定口令，使用IDENTIFIED BY PASSWORD。使用GRANT或INSERT GRANT语句（稍后介绍）也可以创建用户账号，但一般来说CREATE USER是最清楚和最简单的句子。此外， 也可以通过直接插入行到user表来增加用户， 不过为安全起见，一般不建议这样做。 MySQL用来存储用户账号信息的表（以及表模式等）极为重要，对它们的任何毁坏都可能严重地伤害到MySQL服务器。因此，相对于直接处理来说，最好是用标记和函数来处理这些表。为重新命名一个用户账号，使用RENAME USER语句，如下所示： MySQL 5之前 仅MySQL 5或之后的版本支持RENAME USER。为了在以前的MySQL中重命名一个用户，可使用UPDATE直接更新user表。 28.2.2 删除用户账号为了删除一个用户账号（以及相关的权限），使用DROP USER语句，如下所示：MySQL 5之前 自MySQL 5以来， DROP USER删除用户账号和所有相关的账号权限。在MySQL 5以前， DROP USER只能用来删除用户账号，不能删除相关的权限。因此，如果使用旧版本的MySQL，需要先用REVOKE删除与账号相关的权限，然后再用DROP USER删除账号。 28.2.3 设置访问权限在创建用户账号后，必须接着分配访问权限。新创建的用户账号没有访问权限。它们能登录MySQL，但不能看到数据，不能执行任何数据库操作。为看到赋予用户账号的权限，使用SHOW GRANTS FOR，如下所示： 输出结果显示用户bforta有一个权限USAGE ON *.*。 USAGE表示根本没有权限（我知道，这不很直观），所以，此结果表示在任意数据库和任意表上对任何东西没有权限。用户定义为user@host MySQL的权限用用户名和主机名结合定义。如果不指定主机名，则使用默认的主机名%（授予用户访问权限而不管主机名）。为设置权限，使用GRANT语句。 GRANT要求你至少给出以下信息： 要授予的权限； 被授予访问权限的数据库或表； 用户名。以下例子给出GRANT的用法： 此GRANT允许用户在crashcourse.*（crashcourse数据库的所有表）上使用SELECT。通过只授予SELECT访问权限，用户bforta对crashcourse数据库中的所有数据具有只读访问权限。每个GRANT添加（或更新）用户的一个权限。 MySQL读取所有授权，并根据它们确定权限。GRANT的反操作为REVOKE，用它来撤销特定的权限。下面举一个例子：这条REVOKE语句取消刚赋予用户bforta的SELECT访问权限。 被撤销的访问权限必须存在，否则会出错。GRANT和REVOKE可在几个层次上控制访问权限： 整个服务器，使用GRANT ALL和REVOKE ALL； 整个数据库，使用ON database.*； 特定的表，使用ON database.table； 特定的列； 特定的存储过程。 表28-1列出可以授予或撤销的每个权限。使用GRANT和REVOKE，再结合表28-1中列出的权限，你能对用户可以就你的宝贵数据做什么事情和不能做什么事情具有完全的控制。未来的授权 在使用GRANT和REVOKE时，用户账号必须存在，但对所涉及的对象没有这个要求。这允许管理员在创建数据库和表之前设计和实现安全措施。这样做的副作用是，当某个数据库或表被删除时（用DROP语句），相关的访问权限仍然存在。而且，如果将来重新创建该数据库或表，这些权限仍然起作用。简化多次授权 可通过列出各权限并用逗号分隔，将多条GRANT语句串在一起，如下所示： 28.2.4 更改口令为了更改用户口令，可使用SET PASSWORD语句。新口令必须如下加密：SET PASSWORD更新用户口令。新口令必须传递到Password()函数进行加密。270204 SET PASSWORD还可以用来设置你自己的口令：set password = password(‘myownpassword’); 在不指定用户名时， SET PASSWORD更新当前登录用户的口令。 28.3 小结本章学习了通过赋予用户特殊的权限进行访问控制和保护MySQL服务器。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第27章-全球化和本地化]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC27%E7%AB%A0-%E5%85%A8%E7%90%83%E5%8C%96%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%8C%96%2F</url>
    <content type="text"><![CDATA[第27章-全球化和本地化本章介绍MySQL处理不同字符集和语言的基础知识。 27.1 字符集和校对顺序数据库表被用来存储和检索数据。不同的语言和字符集需要以不同的方式存储和检索。因此， MySQL需要适应不同的字符集（不同的字母和字符），适应不同的排序和检索数据的方法。在讨论多种语言和字符集时，将会遇到以下重要术语： 字符集为字母和符号的集合； 编码为某个字符集成员的内部表示； 校对为规定字符如何比较的指令。校对为什么重要 排序英文正文很容易，对吗？或许不。考虑词APE、 apex和Apple。它们处于正确的排序顺序吗？这有赖于你是否想区分大小写。使用区分大小写的校对顺序，这些词有一种排序方式，使用不区分大小写的校对顺序有另外一种排序方式。这不仅影响排序（如用ORDER BY排序数据），还影响搜索（例如 ，寻找 apple 的 WHERE子 句 是 否能 找到APPLE）。在使用诸如法文à或德文?这样的字符时，情况更复杂，在使用不基于拉丁文的字符集（日文、希伯来文、俄文等）时，情况更为复杂。在MySQL的正常数据库活动（SELECT、 INSERT等）中，不需要操心太257194 全球化和本地化多的东西。使用何种字符集和校对的决定在服务器、数据库和表级进行。 27.2 使用字符集和校对顺序MySQL支持众多的字符集。为查看所支持的字符集完整列表，使用以下语句：这条语句显示所有可用的字符集以及每个字符集的描述和默认校对。为了查看所支持校对的完整列表，使用以下语句： 此语句显示所有可用的校对，以及它们适用的字符集。可以看到有的字符集具有不止一种校对。例如， latin1对不同的欧洲语言有几种校对，而且许多校对出现两次，一次区分大小写（由_cs表示），一次不区分大小写（由_ci表示）。通常系统管理在安装时定义一个默认的字符集和校对。此外，也可以在创建数据库时，指定默认的字符集和校对。为了确定所用的字符集和校对，可以使用以下语句：实际上，字符集很少是服务器范围（甚至数据库范围）的设置。不同的表，甚至不同的列都可能需要不同的字符集，而且两者都可以在创建表时指定。为了给表指定字符集和校对，可使用带子句的CREATE TABLE（参见第21章）：create mytable ( column1 int, column2 varchar(10) ) default character set hebrew collate hebrew_general_ci;此语句创建一个包含两列的表，并且指定一个字符集和一个校对顺序。输入分析输入分析输入输入分析25827.2 使用字符集和校对顺序 195这个例子中指定了CHARACTER SET和COLLATE两者。一般， MySQL如下确定使用什么样的字符集和校对。 如果指定CHARACTER SET和COLLATE两者，则使用这些值。 如果只指定CHARACTER SET，则使用此字符集及其默认的校对（如SHOW CHARACTER SET的结果中所示）。 如果既不指定CHARACTER SET，也不指定COLLATE，则使用数据库默认。除了能指定字符集和校对的表范围外， MySQL还允许对每个列设置它们，如下所示：create mytable ( column1 int, column2 varchar(10) character set latin1 collate latin1_general_ci ) default character set hebrew collate hebrew_general_ci;这里对整个表以及一个特定的列指定了CHARACTER SET和COLLATE。如前所述，校对在对用ORDER BY子句检索出来的数据排序时起重要的作用。如果你需要用与创建表时不同的校对顺序排序特定的SELECT语句，可以在SELECT语句自身中进行：select * from customers order by lastname,firstname collate latin1_general_cs;此SELECT使用COLLATE指定一个备用的校对顺序（在这个例子中，为区分大小写的校对）。这显然将会影响到结果排序的次序。临时区分大小写 上面的SELECT语句演示了在通常不区分大小写的表上进行区分大小写搜索的一种技术。当然，反过来也是可以的。输入分析输入分析259260196 全球化和本地化SELECT的其他COLLATE子句 除了这里看到的在ORDER BY子句中使用以外， COLLATE还可以用于GROUP BY、 HAVING、聚集函数、别名等。最后，值得注意的是，如果绝对需要，串可以在字符集之间进行转换。为此，使用Cast()或Convert()函数。 27.3 小结本章中，我们学习了字符集和校对的基础知识，还学习了如何对特261 定的表和列定义字符集和校对，如何在需要时使用备用的校对。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第26章-管理事务处理]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC26%E7%AB%A0-%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[第26章-管理事务处理本章介绍什么是事务处理以及如何利用COMMIT和ROLLBACK语句来管理事务处理。 26.1 事务处理并非所有引擎都支持事务处理 正如第21章所述， MySQL支持几种基本的数据库引擎。正如本章所述，并非所有引擎都支持明确的事务处理管理。 MyISAM和InnoDB是两种最常使用的引擎。前者不支持明确的事务处理管理，而后者支持。这就是为什么本书中使用的样例表被创建来使用InnoDB而不是更经常使用的MyISAM的原因。如果你的应用中需要事务处理功能，则一定要使用正确的引擎类型。事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。正如第15章所述，关系数据库设计把数据存储在多个表中，使数据更容易操纵、维护和重用。不用深究如何以及为什么进行关系数据库设计，在某种程度上说，设计良好的数据库模式都是关联的。前面章中使用的orders表就是一个很好的例子。订单存储在orders和orderitems两个表中： orders存储实际的订单，而orderitems存储订购的各项物品。这两个表使用称为主键（参阅第1章）的唯一ID互相关联。这两个表又与包含客户和产品信息的其他表相关联。249188 管理事务处理给系统添加订单的过程如下。(1) 检查数据库中是否存在相应的客户（从customers表查询），如果不存在，添加他/她。(2) 检索客户的ID。(3) 添加一行到orders表，把它与客户ID关联。(4) 检索orders表中赋予的新订单ID。(5) 对于订购的每个物品在orderitems表中添加一行，通过检索出来的ID把它与orders表关联（以及通过产品ID与products表关联）。现在，假如由于某种数据库故障（如超出磁盘空间、安全限制、表锁等）阻止了这个过程的完成。数据库中的数据会出现什么情况？如果故障发生在添加了客户之后， orders表添加之前，不会有什么问题。某些客户没有订单是完全合法的。在重新执行此过程时，所插入的客户记录将被检索和使用。可以有效地从出故障的地方开始执行此过程。但是，如果故障发生在orders行添加之后， orderitems行添加之前，怎么办呢？现在，数据库中有一个空订单。更糟的是，如果系统在添加orderitems行之中出现故障。结果是数据库中存在不完整的订单，而且你还不知道。如何解决这种问题？这里就需要使用事务处理了。事务处理是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果。利用事务处理，可以保证一组操作不会中途停止，它们或者作为整体执行，或者完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态。因此，请看相同的例子，这次我们说明过程如何工作。(1) 检查数据库中是否存在相应的客户，如果不存在，添加他/她。(2) 提交客户信息。(3) 检索客户的ID。(4) 添加一行到orders表。250 26.2 控制事务处理如果在添加行到orders表时出现故障，回退。(6) 检索orders表中赋予的新订单ID。(7) 对于订购的每项物品，添加新行到orderitems表。(8) 如果在添加新行到orderitems时出现故障，回退所有添加的orderitems行和orders行。(9) 提交订单信息。在使用事务和事务处理时，有几个关键词汇反复出现。下面是关于事务处理需要知道的几个术语： 事务（transaction）指一组SQL语句； 回退（rollback）指撤销指定SQL语句的过程； 提交（commit）指将未存储的SQL语句结果写入数据库表； 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。 26.2 控制事务处理既然我们已经知道了什么是事务处理，下面讨论事务处理的管理中所涉及的问题。管理事务处理的关键在于将SQL语句组分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退。MySQL使用下面的语句来标识事务的开始： 26.2.1 使用ROLLBACKMySQL的ROLLBACK命令用来回退（撤销） MySQL语句，请看下面的语句： 这个例子从显示ordertotals表（此表在第24章中填充）的内容开始。首先执行一条SELECT以显示该表不为空。然后开始一个事务处理，用一条DELETE语句删除ordertotals中的所有行。另一条SELECT语句验证ordertotals确实为空。这时用一条ROLLBACK语句回退START TRANSACTION之后的所有语句，最后一条SELECT语句显示该表不为空。显然， ROLLBACK只能在一个事务处理内使用（在执行一条STARTTRANSACTION命令之后）。哪些语句可以回退？ 事务处理用来管理INSERT、 UPDATE和DELETE语句。你不能回退SELECT语句。（这样做也没有什么意义。）你不能回退CREATE或DROP操作。事务处理块中可以使用这两条语句，但如果你执行回退，它们不会被撤销。 26.2.2 使用COMMIT一般的MySQL语句都是直接针对数据库表执行和编写的。这就是所谓的隐含提交（implicit commit），即提交（写或保存）操作是自动进行的。但是，在事务处理块中，提交不会隐含地进行。为进行明确的提交，使用COMMIT语句，如下所示： 在这个例子中，从系统中完全删除订单20010。因为涉及更新两个数据库表orders和orderItems，所以使用事务处理块来保证订单不被部分删除。最后的COMMIT语句仅在不出错时写出更改。如果第一条DELETE起作用，但第二条失败，则DELETE不会提交（实际上，它是被自动撤销的）。分析分析输入25226.2 控制事务处理 191隐含事务关闭 当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）。 26.2.3 使用保留点简单的ROLLBACK和COMMIT语句就可以写入或撤销整个事务处理。但是，只是对简单的事务处理才能这样做，更复杂的事务处理可能需要部分提交或回退。例如，前面描述的添加订单的过程为一个事务处理。如果发生错误，只需要返回到添加orders行之前即可，不需要回退到customers表（如果存在的话）。为了支持回退部分事务处理，必须能在事务处理块中合适的位置放置占位符。这样，如果需要回退，可以回退到某个占位符。这些占位符称为保留点。为了创建占位符，可如下使用SAVEPOINT语句：savepoint delete1;每个保留点都取标识它的唯一名字，以便在回退时， MySQL知道要回退到何处。为了回退到本例给出的保留点，可如下进行：rollback to delete1;保留点越多越好 可以在MySQL代码中设置任意多的保留点，越多越好。为什么呢？因为保留点越多，你就越能按自己的意愿灵活地进行回退。释放保留点 保留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放。自MySQL 5以来，也可以用RELEASESAVEPOINT明确地释放保留点。输入输入253254192 管理事务处理 26.2.4 更改默认的提交行为正如所述，默认的MySQL行为是自动提交所有更改。换句话说，任何时候你执行一条MySQL语句，该语句实际上都是针对表执行的，而且所做的更改立即生效。为指示MySQL不自动提交更改，需要使用以下语句： autocommit标志决定是否自动提交更改，不管有没有COMMIT语句。设置autocommit为0（假）指示MySQL不自动提交更改（直到autocommit被设置为真为止）。标志为连接专用 autocommit标志是针对每个连接而不是服务器的。 26.3 小结本章介绍了事务处理是必须完整执行的SQL语句块。我们学习了如何使用COMMIT和ROLLBACK语句对何时写数据，何时撤销进行明确的管理。还学习了如何使用保留点对回退操作提供更强大的控制。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第25章-使用触发器]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC25%E7%AB%A0-%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[第25章-使用触发器本章学习什么是触发器，为什么要使用触发器以及如何使用触发器。本章还介绍创建和使用触发器的语法。 25.1 触发器需要MySQL 5 对触发器的支持是在MySQL 5中增加的。因此，本章内容适用于MySQL 5或之后的版本。MySQL语句在需要时被执行，存储过程也是如此。但是，如果你想要某条语句（或某些语句）在事件发生时自动执行，怎么办呢？例如： 每当增加一个顾客到某个数据库表时，都检查其电话号码格式是否正确，州的缩写是否为大写； 每当订购一个产品时，都从库存数量中减去订购的数量； 无论何时删除一行，都在某个存档表中保留一个副本。所有这些例子的共同之处是它们都需要在某个表发生更改时自动处理。这确切地说就是触发器。 触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）： DELETE； INSERT； UPDATE。使用触发器其他MySQL语句不支持触发器。 25.2 创建触发器在创建触发器时，需要给出4条信息： 唯一的触发器名； 触发器关联的表； 触发器应该响应的活动（DELETE、 INSERT或UPDATE）； 触发器何时执行（处理之前或之后）。保持每个数据库的触发器名唯一 在MySQL 5中，触发器名必须在每个表中唯一，但不是在每个数据库中唯一。这表示同一数据库中的两个表可具有相同名字的触发器。这在其他每个数据库触发器名必须唯一的DBMS中是不允许的，而且以后的MySQL版本很可能会使命名规则更为严格。因此，现在最好是在数据库范围内使用唯一的触发器名。触发器用CREATE TRIGGER语句创建。下面是一个简单的例子： CREATE TRIGGER用来创建名为newproduct的新触发器。触发器可在一个操作发生之前或之后执行，这里给出了AFTER INSERT，所以此触发器将在INSERT语句成功执行后执行。这个触发器还指定FOREACH ROW，因此代码对每个插入行执行。在这个例子中，文本Productadded将对每个插入的行显示一次。为了测试这个触发器，使用INSERT语句添加一行或多行到products中，你将看到对每个成功的插入，显示Product added消息。仅支持表 只有表才支持触发器，视图不支持（临时表也不支持）。触发器按每个表每个事件每次地定义，每个表每个事件每次只允许输入分析24225.4 使用触发器 183一个触发器。因此，每个表最多支持6个触发器（每条INSERT、 UPDATE和DELETE的之前和之后）。单一触发器不能与多个事件或多个表关联，所以，如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器。触发器失败 如果BEFORE触发器失败，则MySQL将不执行请求的操作。此外，如果BEFORE触发器或语句本身失败， MySQL将不执行AFTER触发器（如果有的话）。 25.3 删除触发器现在，删除触发器的语法应该很明显了。为了删除一个触发器，可使用DROP TRIGGER语句，如下所示：drop tigger newproduct; 触发器不能更新或覆盖。为了修改一个触发器，必须先删除它，然后再重新创建。 25.4 使用触发器在有了前面的基础知识后，我们现在来看所支持的每种触发器类型以及它们的差别。 25.4.1 INSERT触发器INSERT触发器在INSERT语句执行之前或之后执行。需要知道以下几点： 在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行； 在BEFORE INSERT触发器中， NEW中的值也可以被更新（允许更改被插入的值）； 对于AUTO_INCREMENT列， NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。使用触发器下面举一个例子（一个实际有用的例子）。 AUTO_INCREMENT列具有MySQL自动赋予的值。第21章建议了几种确定新生成值的方法，但下面是一种更好的方法： 此代码创建一个名为neworder的触发器，它按照AFTER INSERTON orders执行。在插入一个新订单到orders表时， MySQL生成一个新订单号并保存到order_num中。触发器从NEW. order_num取得这个值并返回它。此触发器必须按照AFTER INSERT执行，因为在BEFOREINSERT语句执行之前，新order_num还没有生成。对于orders的每次插入使用这个触发器将总是返回新的订单号。为测试这个触发器，试着插入一下新行，如下所示： mysql5之后的版本不再支持触发器返回结果集 orders 包 含 3 个 列 。 order_date 和 cust_id 必 须 给 出 ，order_num由MySQL自动生成，而现在order_num还自动被返回。BEFORE或AFTER？ 通常，将BEFORE用于数据验证和净化（目的是保证插入表中的数据确实是需要的数据）。本提示也适用于UPDATE触发器。 25.4.2 DELETE触发器DELETE触发器在DELETE语句执行之前或之后执行。需要知道以下两点： 在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行； OLD中的值全都是只读的，不能更新。下面的例子演示使用OLD保存将要被删除的行到一个存档表中： 在任意订单被删除前将执行此触发器。它使用一条INSERT语句将OLD中的值（要被删除的订单）保存到一个名为archive_orders的存档表中（为实际使用这个例子，你需要用与orders相同的列创建一个名为archive_orders的表）。使用BEFORE DELETE触发器的优点（相对于AFTER DELETE触发器来说）为，如果由于某种原因，订单不能存档， DELETE本身将被放弃。多语句触发器 正如所见，触发器deleteorder使用BEGIN和END语句标记触发器体。这在此例子中并不是必需的，不过也没有害处。使用BEGIN END块的好处是触发器能容纳多条SQL语句（在BEGIN END块中一条挨着一条）。 25.4.3 UPDATE触发器UPDATE触发器在UPDATE语句执行之前或之后执行。需要知道以下几点： 在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值； 在BEFORE UPDATE触发器中， NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）； OLD中的值全都是只读的，不能更新。下面的例子保证州名缩写总是大写（不管UPDATE语句中给出的是大写还是小写）： 显然， 任 何数据净化都需要在UPDATE语句之前进行，就像这个 例 子 中一样。每次更新一个行时， NEW.vend_state中的值（将用来更新表行的值）都用Upper(NEW.vend_state)替换。 25.4.4 关于触发器的进一步介绍在结束本章之前，我们再介绍一些使用触发器时需要记住的重点。 与其他DBMS相比， MySQL 5中支持的触发器相当初级。未来的MySQL版本中有一些改进和增强触发器支持的计划。 创建触发器可能需要特殊的安全访问权限，但是，触发器的执行是自动的。如果INSERT、 UPDATE或DELETE语句能够执行，则相关的触发器也能执行。 应该用触发器来保证数据的一致性（大小写、格式等）。在触发器中执行这种类型的处理的优点是它总是进行这种处理，而且是透明地进行，与客户机应用无关。 触发器的一种非常有意义的使用是创建审计跟踪。使用触发器，把更改（如果需要，甚至还有之前和之后的状态）记录到另一个表非常容易。 遗憾的是， MySQL触发器中不支持CALL语句。这表示不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内。 25.5 小结本章介绍了什么是触发器以及为什么要使用触发器，学习了触发器的类型和何时执行它们，列举了几个用于INSERT、 DELETE和UPDATE操作的触发器例子。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第24章-使用游标]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC24%E7%AB%A0-%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87%2F</url>
    <content type="text"><![CDATA[第24章-使用游标本章将讲授什么是游标以及如何使用游标。 24.1 游标需要MySQL 5 MySQL 5添加了对游标的支持，因此，本章内容适用于MySQL 5及以后的版本。由前几章可知， MySQL检索操作返回一组称为结果集的行。这组返回的行都是与SQL语句相匹配的行（零行或多行）。使用简单的SELECT语句，例如，没有办法得到第一行、下一行或前10行，也不存在每次一行地处理所有行的简单方法（相对于成批地处理它们）。有时，需要在检索出来的行中前进或后退一行或多行。这就是使用游标的原因。 游标（cursor） 是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。只能用于存储过程 不像多数DBMS， MySQL游标只能用于存储过程（和函数）。 24.2 使用游标使用游标涉及几个明确的步骤。第 24 章23124.2 使用游标 175 在能够使用游标前，必须声明（定义）它。这个过程实际上没有检索数据，它只是定义要使用的SELECT语句。 一旦声明后，必须打开游标以供使用。这个过程用前面定义的SELECT语句把数据实际检索出来。 对于填有数据的游标，根据需要取出（检索）各行。 在结束游标使用时，必须关闭游标。在声明游标后，可根据需要频繁地打开和关闭游标。在游标打开后，可根据需要频繁地执行取操作。 24.2.1 创建游标游标用DECLARE语句创建（参见第23章）。 DECLARE命名游标，并定义相应的SELECT语句，根据需要带WHERE和其他子句。例如，下面的语句定义了名为ordernumbers的游标，使用了可以检索所有订单的SELECT语句。 这个存储过程并没有做很多事情， DECLARE语句用来定义和命名游标，这里为ordernumbers。 存储过程处理完成后，游标就消失（因为它局限于存储过程）。在定义游标之后，可以打开它。 24.2.2 打开和关闭游标游标用OPEN CURSOR语句来打开：open ordernumbers;在处理OPEN语句时执行查询，存储检索出的数据以供浏览和滚动。游标处理完成后，应当使用如下语句关闭游标：close ordernumbers;CLOSE释放游标使用的所有内部内存和资源，因此在每个游标不再需要时都应该关闭。在一个游标关闭后，如果没有重新打开，则不能使用它。但是，使用声明过的游标不需要再次声明，用OPEN语句打开它就可以了。隐含关闭 如果你不明确关闭游标， MySQL将会在到达END语句时自动关闭它。下面是前面例子的修改版本：这个存储过程声明、打开和关闭一个游标。但对检索出的数据什么也没做。 24.2.3 使用游标数据在一个游标被打开后，可以使用FETCH语句分别访问它的每一行。FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行（不重复读取同一行）。第一个例子从游标中检索单个行（第一行）：其中FETCH用来检索当前行的order_num列（将自动从第一行开始）到一个名为o的局部声明的变量中。对检索出的数据不做任何处理。在下一个例子中，循环检索数据，从第一行到最后一行： 与前一个例子一样，这个例子使用FETCH检索当前order_num到声明的名为o的变量中。但与前一个例子不一样的是，这个例子中的FETCH是在REPEAT内，因此它反复执行直到done为真（由UNTILdone END REPEAT;规定）。为使它起作用，用一个DEFAULT 0（假，不结束）定义变量done。那么， done怎样才能在结束时被设置为真呢？答案是用以下语句：这条语句定义了一个CONTINUE HANDLER，它是在条件出现时被执行的代码。这里， 它指出当SQLSTATE ‘02000’出现时， SET done=1。SQLSTATE’02000’是一个未找到条件， 当REPEAT由于没有更多的行供循环而不能继续时，出现这个条件。 MySQL的错误代码 关于MySQL 5使用的MySQL错误代码列表，请参阅文档。DECLARE语句的次序 DECLARE语句的发布存在特定的次序。用DECLARE语句定义的局部变量必须在定义任意游标或句柄之前定义，而句柄必须在游标之后定义。不遵守此顺序将产生错误消息。如 果 调 用 这 个 存 储 过 程 ， 它 将 定 义 几 个 变 量 和 一 个 CONTINUEHANDLER，定义并打开一个游标，重复读取所有行，然后关闭游标。如果一切正常，你可以在循环内放入任意需要的处理（在FETCH语句分析23624.2 使用游标 179之后，循环结束之前）。重复或循环？ 除这里使用的REPEAT语句外， MySQL还支持循环语句，它可用来重复执行代码，直到使用LEAVE语句手动退出为止。通常REPEAT语句的语法使它更适合于对游标进行循环。为了把这些内容组织起来，下面给出我们的游标存储过程样例的更进一步修改的版本，这次对取出的数据进行某种实际的处理： 在这个例子中，我们增加了另一个名为t的变量（存储每个订单的合计）。 此存储过程还在运行中创建了一个新表（如果它不存在的话），名为ordertotals。这个表将保存存储过程生成的结果。FETCH像以前一样取每个order_num，然后用CALL执行另一个存储过程（我们在前一章中创建）来计算每个订单的带税的合计（结果存储到t）。最后，用INSERT保存每个订单的订单号和合计。此存储过程不返回数据，但它能够创建和填充另一个表，可以用一条简单的SELECT语句查看该表： 这样，我们就得到了存储过程、游标、逐行处理以及存储过程调用其他存储过程的一个完整的工作样例。 24.3 小结本章介绍了什么是游标以及为什么要使用游标，举了演示基本游标使用的例子，并且讲解了对游标结果进行循环以及逐行处理的技术。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第23章-使用存储过程]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC23%E7%AB%A0-%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[第23章-使用存储过程本章介绍什么是存储过程，为什么要使用存储过程以及如何使用存储过程，并且介绍创建和使用存储过程的基本语法。 23.1 存储过程需要MySQL 5 MySQL 5添加了对存储过程的支持，因此，本章内容适用于MySQL 5及以后的版本。迄今为止，使用的大多数SQL语句都是针对一个或多个表的单条语句。并非所有操作都这么简单，经常会有一个完整的操作需要多条语句才能完成。例如，考虑以下的情形。 为了处理订单，需要核对以保证库存中有相应的物品。 如果库存有物品，这些物品需要预定以便不将它们再卖给别的人，并且要减少可用的物品数量以反映正确的库存量。 库存中没有的物品需要订购，这需要与供应商进行某种交互。 关于哪些物品入库（并且可以立即发货）和哪些物品退订，需要通知相应的客户。这显然不是一个完整的例子，它甚至超出了本书中所用样例表的范围，但足以帮助表达我们的意思了。执行这个处理需要针对许多表的多条MySQL语句。此外，需要执行的具体语句及其次序也不是固定的，它们可能会（和将）根据哪些物品在库存中哪些不在而变化。那么，怎样编写此代码？可以单独编写每条语句，并根据结果有条217164 使用存储过程件地执行另外的语句。在每次需要这个处理时（以及每个需要它的应用中）都必须做这些工作。可以创建存储过程。存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理。 23.2 为什么要使用存储过程既然我们知道了什么是存储过程，那么为什么要使用它们呢？有许多理由，下面列出一些主要的理由。 通过把处理封装在容易使用的单元中，简化复杂的操作（正如前面例子所述）。 由于不要求反复建立一系列处理步骤，这保证了数据的完整性。如果所有开发人员和应用程序都使用同一（试验和测试）存储过程，则所使用的代码都是相同的。这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误保证了数据的一致性。 简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化。这一点的延伸就是安全性。通过存储过程限制对基础数据的访问减少了数据讹误（无意识的或别的原因所导致的数据讹误）的机会。 提高性能。因为使用存储过程比使用单独的SQL语句要快。 存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码（在下一章的例子中可以看到。）换句话说，使用存储过程有3个主要的好处，即简单、安全、高性能。显然，它们都很重要。不过，在将SQL代码转换为存储过程前，也必须知道它的一些缺陷。 一般来说，存储过程的编写比基本SQL语句复杂，编写存储过程需要更高的技能，更丰富的经验。218 你可能没有创建存储过程的安全访问权限。许多数据库管理员限制存储过程的创建权限，允许用户使用存储过程，但不允许他们创建存储过程。尽管有这些缺陷，存储过程还是非常有用的，并且应该尽可能地使用。不能编写存储过程？你依然可以使用 MySQL将编写存储过程的安全和访问与执行存储过程的安全和访问区分开来。这是好事情。即使你不能（或不想）编写自己的存储过程，也仍然可以在适当的时候执行别的存储过程。 23.3 使用存储过程使用存储过程需要知道如何执行（运行）它们。存储过程的执行远比其定义更经常遇到，因此，我们将从执行存储过程开始介绍。然后再介绍创建和使用存储过程。 23.3.1 执行存储过程MySQL称存储过程的执行为调用，因此MySQL执行存储过程的语句为CALL。 CALL接受存储过程的名字以及需要传递给它的任意参数。请看以下例子：call productpricing(@pricelow,@pricehigh,@priceaverage);其中，执行名为productpricing的存储过程，它计算并返回产品的最低、最高和平均价格。存储过程可以显示结果，也可以不显示结果，如稍后所述。 23.3.2 创建存储过程正如所述，编写存储过程并不是微不足道的事情。为让你了解这个过程，请看一个例子——一个返回产品平均价格的存储过程。以下是其代码： 使用存储过程我们稍后介绍第一条和最后一条语句。此存储过程名为productpricing，用CREATE PROCEDURE productpricing()语句定义。如果存储过程接受参数，它们将在()中列举出来。此存储过程没有参数，但后跟的()仍然需要。 BEGIN和END语句用来限定存储过程体，过程体本身仅是一个简单的SELECT语句（使用第12章介绍的Avg()函数）。在MySQL处理这段代码时，它创建一个新的存储过程productpricing。没有返回数据，因为这段代码并未调用存储过程，这里只是为以后使用而创建它。mysql命令行客户机的分隔符 如果你使用的是mysql命令行实用程序，应该仔细阅读此说明。默认的MySQL语句分隔符为;（正如你已经在迄今为止所使用的MySQL语句中所看到的那样）。 mysql命令行实用程序也使用;作为语句分隔符。如果命令行实用程序要解释存储过程自身内的;字符，则它们最终不会成为存储过程的成分，这会使存储过程中的SQL出现句法错误。解决办法是临时更改命令行实用程序的语句分隔符，如下所示：其中， DELIMITER //告诉命令行实用程序使用//作为新的语句结束分隔符，可以看到标志存储过程结束的END定义为END//而不是END;。这样，存储过程体内的;仍然保持不动，并且正确地传递给数据库引擎。最后，为恢复为原来的语句分隔符，22022123.3 使用存储过程 167可使用DELIMITER ;。除\符号外，任何字符都可以用作语句分隔符。如果你使用的是mysql命令行实用程序，在阅读本章时请记住这里的内容。那么，如何使用这个存储过程？如下所示：CALL productpricing();执行刚创建的存储过程并显示返回的结果。因为存储过程实际上是一种函数，所以存储过程名后需要有()符号（即使不传递参数也需要）。 23.3.3 删除存储过程存储过程在创建之后，被保存在服务器上以供使用，直至被删除。删除命令（类似于第21章所介绍的语句）从服务器中删除存储过程。为删除刚创建的存储过程，可使用以下语句：这条语句删除刚创建的存储过程。请注意没有使用后面的()，只给出存储过程名。仅当存在时删除 如果指定的过程不存在，则DROP PROCEDURE将产生一个错误。当过程存在想删除它时（如果过程不存在也不产生错误）可使用DROP PROCEDURE IF EXISTS。 23.3.4 使用参数productpricing只是一个简单的存储过程，它简单地显示SELECT语句的结果。一般，存储过程并不显示结果，而是把结果返回给你指定的输入输出分析222168 使用存储过程变量。变量（variable） 内存中一个特定的位置，用来临时存储数据。以下是productpricing的修改版本（如果不先删除此存储过程，则不能再次创建它）：此存储过程接受3个参数： pl存储产品最低价格， ph存储产品最高价格， pa存储产品平均价格。每个参数必须具有指定的类型，这里使用十进制值。关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）。 MySQL支持IN（传递给存储过程）、 OUT（从存储过程传出，如这里所用）和INOUT（对存储过程传入和传出）类型的参数。存储过程的代码位于BEGIN和END语句内，如前所见，它们是一系列SELECT语句，用来检索值，然后保存到相应的变量（通过指定INTO关键字）。参数的数据类型 存储过程的参数允许的数据类型与表中使用的数据类型相同。附录D列出了这些类型。注意，记录集不是允许的类型，因此，不能通过一个参数返回多个行和列。这就是前面的例子为什么要使用3个参数（和3条SELECT语句）的原因。为调用此修改过的存储过程，必须指定3个变量名，如下所示：由于此存储过程要求3个参数，因此必须正好传递3个参数，不多也不少。所以，这条CALL语句给出3个参数。它们是存储过程将保存结果的3个变量的名字。变量名 所有MySQL变量都必须以@开始。在调用时，这条语句并不显示任何数据。它返回以后可以显示（或在其他处理中使用）的变量。为了显示检索出的产品平均价格，可如下进行：为了获得3个值，可使用以下语句：下面是另外一个例子，这次使用IN和OUT参数。 ordertotal接受订单号并返回该订单的合计：输入输出输入输出输入224225170 使用存储过程onumber定义为IN，因为订单号被传入存储过程。 ototal定义为OUT，因为要从存储过程返回合计。 SELECT语句使用这两个参数， WHERE子句使用onumber选择正确的行， INTO使用ototal存储计算出来的合计。为调用这个新存储过程，可使用以下语句：必须给ordertotal传递两个参数；第一个参数为订单号，第二个参数为包含计算出来的合计的变量名。为了显示此合计，可如下进行：@total已由ordertotal的CALL语句填写， SELECT显示它包含的值。为了得到另一个订单的合计显示，需要再次调用存储过程，然后重新显示变量： 23.3.5 建立智能存储过程迄今为止使用的所有存储过程基本上都是封装MySQL简单的SELECT语句。虽然它们全都是有效的存储过程例子，但它们所能完成的工作你直接用这些被封装的语句就能完成（如果说它们还能带来更多的东西，分析输入输出分析输入22623.3 使用存储过程 171那就是使事情更复杂）。只有在存储过程内包含业务规则和智能处理时，它们的威力才真正显现出来。考虑这个场景。你需要获得与以前一样的订单合计，但需要对合计增加营业税，不过只针对某些顾客（或许是你所在州中那些顾客）。那么，你需要做下面几件事情： 获得合计（与以前一样）； 把营业税有条件地添加到合计； 返回合计（带或不带税）。存储过程的完整工作如下： 此存储过程有很大的变动。首先，增加了注释（前面放置—）。在存储过程复杂性增加时，这样做特别重要。添加了另外一个参数taxable，它是一个布尔值（如果要增加税则为真，否则为假）。在存储过程体中，用DECLARE语句定义了两个局部变量。 DECLARE要求指定变量名和数据类型，它也支持可选的默认值（这个例子中的taxrate的默认被设置为6%）。 SELECT语句已经改变，因此其结果存储到total（局部变量）而不是ototal。 IF语句检查taxable是否为真，如果为真，则用另一SELECT语句增加营业税到局部变量total。最后，用另一SELECT语句将total（它增加或许不增加营业税）保存到ototal。COMMENT关键字 本例子中的存储过程在CREATE PROCEDURE语句中包含了一个COMMENT值。它不是必需的，但如果给出，将在SHOW PROCEDURE STATUS的结果中显示。这显然是一个更高级，功能更强的存储过程。为试验它，请用以下两条语句：BOOLEAN值指定为1表示真，指定为0表示假（实际上，非零值都考虑为真，只有0被视为假）。通过给中间的参数指定0或1，可以有条件地将营业税加到订单合计上。IF语句 这个例子给出了MySQL的IF语句的基本用法。 IF语句还支持ELSEIF和ELSE子句（前者还使用THEN子句，后者不使用）。在以后章节中我们将会看到IF的其他用法（以及其他流控制语句）。 23.3.6 检查存储过程为显示用来创建一个存储过程的CREATE语句，使用SHOW CREATE PROCEDURE语句：为了获得包括何时、由谁创建等详细信息的存储过程列表， 使用SHOWPROCEDURE STATUS。限制过程状态结果 SHOW PROCEDURE STATUS列出所有存储过程。为限制其输出，可使用LIKE指定一个过滤模式，例如： 23.4 小结本章介绍了什么是存储过程以及为什么要使用存储过程。我们介绍了存储过程的执行和创建的语法以及使用存储过程的一些方法。下一章我们将继续这个话题。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第22章-使用视图]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC22%E7%AB%A0-%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[第22章-使用视图本章将介绍视图究竟是什么，它们怎样工作，何时使用它们。我们还将看到如何利用视图简化前面章节中执行的某些SQL操作。 22.1 视图需要MySQL 5 MySQL 5添加了对视图的支持。因此，本章内容适用于MySQL 5及以后的版本。视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。理解视图的最好方法是看一个例子。第15章中用下面的SELECT语句从3个表中检索数据： 此查询用来检索订购了某个特定产品的客户。任何需要这个数据的人都必须理解相关表的结构，并且知道如何创建查询和对表进行联结。为了检索其他产品（或多个产品）的相同数据，必须修改最后的WHERE子句。现在，假如可以把整个查询包装成一个名为productcustomers的虚拟表，则可以如下轻松地检索出相同的数据：select cust_name,cust_contact from productcustomers where prod_id=’TNT2’;这就是视图的作用。 productcustomers是一个视图，作为视图，它不包含表中应该有的任何列或数据，它包含的是一个SQL查询（与上面用以正确联结表的相同的查询）。 22.1.1 为什么使用视图我们已经看到了视图应用的一个例子。下面是视图的一些常见应用。 重用SQL语句。 简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。 使用表的组成部分而不是整个表。 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。在视图创建之后，可以用与表基本相同的方式利用它们。可以对视图执行SELECT操作，过滤和排序数据，将视图联结到其他视图或表，甚至能添加和更新数据（添加和更新数据存在某些限制。关于这个内容稍后还要做进一步的介绍）。重要的是知道视图仅仅是用来查看存储在别处的数据的一种设施。视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。性能问题 因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。 22.1.2 视图的规则和限制下面是关于视图创建和使用的一些最常见的规则和限制。 与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。 对于可以创建的视图数目没有限制。 为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。 ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。 视图不能索引，也不能有关联的触发器或默认值。 视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句。 22.2 使用视图在理解什么是视图（以及管理它们的规则及约束）后，我们来看一下视图的创建。 视图用CREATE VIEW语句来创建。 使用SHOW CREATE VIEW viewname；来查看创建视图的语句。 用DROP删除视图，其语法为DROP VIEW viewname;。 更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。 22.2.1 利用视图简化复杂的联结视图的最常见的应用之一是隐藏复杂的SQL，这通常都会涉及联结。请看下面的例子： 这条语句创建一个名为productcustomers的视图， 它联结三个表，以返回已订购了任意产品的所有客户的列表。如果执行SELECT * FROM productcustomers，将列出订购了任意产品的客户。为检索订购了产品TNT2的客户，可如下进行： 这条语句通过WHERE子句从视图中检索特定数据。在MySQL处理此查询时，它将指定的WHERE子句添加到视图查询中的已有WHERE子句中，以便正确过滤数据。可以看出，视图极大地简化了复杂SQL语句的使用。利用视图，可一次性编写基础的SQL，然后根据需要多次使用。创建可重用的视图 创建不受特定数据限制的视图是一种好办法。例如，上面创建的视图返回生产所有产品的客户而不仅仅是生产TNT2的客户。扩展视图的范围不仅使得它能被重用，而且甚至更有用。这样做不需要创建和维护多个类似视图。 22.2.2 用视图重新格式化检索出的数据如上所述，视图的另一常见用途是重新格式化检索出的数据。下面的SELECT语句（来自第10章）在单个组合计算列中返回供应商名和位置： 现在，假如经常需要这个格式的结果。不必在每次需要时执行联结，创建一个视图，每次需要时使用它即可。为把此语句转换为视图，可按如下进行：这条语句使用与以前的SELECT语句相同的查询创建视图。为了检索出以创建所有邮件标签的数据，可如下进行： 22.2.3 用视图过滤不想要的数据视 图 对 于 应 用 普 通 的 WHERE 子 句 也 很 有 用 。 例 如 ， 可 以 定 义customeremaillist视图，它过滤没有电子邮件地址的客户。为此目的，可使用下面的语句：显然，在发送电子邮件到邮件列表时，需要排除没有电子邮件地址的用户。这里的WHERE子句过滤了cust_email列中具有NULL值的那些行，使他们不被检索出来。现在，可以像使用其他表一样使用视图customeremaillist。WHERE子句与WHERE子句 如果从视图检索数据时使用了一条WHERE子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。 22.2.4 使用视图与计算字段视图对于简化计算字段的使用特别有用。下面是第10章中介绍的一条SELECT语句。它检索某个特定订单中的物品，计算每种物品的总价格：为将其转换为一个视图，如下进行：分析输出输出21321422.2 使用视图 161为检索订单20005的详细内容（上面的输出），如下进行：可以看到，视图非常容易创建，而且很好使用。正确使用，视图可极大地简化复杂的数据处理。 22.2.5 更新视图迄今为止的所有视图都是和SELECT语句使用的。然而，视图的数据能否更新？答案视情况而定。通常，视图是可更新的（即，可以对它们使用INSERT、 UPDATE和DELETE）。更新一个视图将更新其基表（可以回忆一下，视图本身没有数据）。如果你对视图增加或删除行，实际上是对其基表增加或删除行。但是，并非所有视图都是可更新的。基本上可以说，如果MySQL不能正确地确定被更新的基数据，则不允许更新（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新： 分组（使用GROUP BY和HAVING）； 联结； 子查询； 并； 聚集函数（Min()、 Count()、 Sum()等）； DISTINCT； 导出（计算）列。换句话说，本章许多例子中的视图都是不可更新的。这听上去好像是一个严重的限制，但实际上不是，因为视图主要用于数据检索。可能的变动 上面列出的限制自MySQL 5以来是正确的。不过，未来的MySQL很可能会取消某些限制。将视图用于检索 一般，应该将视图用于检索（ SELECT语句）而不用于更新（ INSERT、 UPDATE和DELETE）。 22.3 小结视图为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。视图提供了一种MySQL的SELECT语句层次的封装，可用来简化数据216 处理以及重新格式化基础数据或保护基础数据。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第21章-创建和操纵表]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC21%E7%AB%A0-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[第21章-创建和操纵表本章讲授表的创建、更改和删除的基本知识。 21.1 创建表MySQL不仅用于表数据操纵，而且还可以用来执行数据库和表的所有操作，包括表本身的创建和处理。一般有两种创建表的方法： 使用具有交互式创建和管理表的工具（如第2章讨论的工具）； 表也可以直接用MySQL语句操纵。 为了用程序创建表，可使用SQL的CREATE TABLE语句。值得注意的是，在使用交互式工具时，实际上使用的是MySQL语句。但是，这些语句不是用户编写的，界面工具会自动生成并执行相应的MySQL语句（更改现有表时也是这样）。另外的例子 关于表创建脚本的另外例子，请参阅本书中用来创建样例表的代码。 21.1.1 表创建基础为利用CREATE TABLE创建表，必须给出下列信息： 新表的名字，在关键字CREATE TABLE之后给出； 表列的名字和定义，用逗号分隔。 CREATE TABLE语句也可能会包括其他关键字或选项，但至少要包括表的名字和列的细节。下面的MySQL语句创建本书中所用的customers表： 从上面的例子中可以看到，表名紧跟在CREATE TABLE关键字后面。实际的表定义（所有列）括在圆括号之中。各列之间用逗号分隔。这个表由9列组成。每列的定义以列名（它在表中必须是唯一的）开始，后跟列的数据类型（关于数据类型的解释，请参阅第1章。此外，附录D列出了MySQL支持的数据类型）。表的主键可以在创建表时用PRIMARY KEY关键字指定。这里，列cust_id指定作为主键列。整条语句由 右 圆 括 号 后 的 分 号 结 束 。（ 现 在 先 忽 略 ENGINE=InnoDB 和AUTO_INCREMENT，后面会对它们进行介绍。）语句格式化 可回忆一下，以前说过MySQL语句中忽略空格。语句可以在一个长行上输入，也可以分成许多行。它们的作用都相同。这允许你以最适合自己的方式安排语句的格式。前面的CREATE TABLE语句就是语句格式化的一个很好的例子，它被安排在多个行上，其中的列定义进行了恰当的缩进，以便阅读和编辑。以何种缩进格式安排SQL语句没有规定，但我强烈推荐采用某种缩进格式。处理现有的表 在创建新表时，指定的表名必须不存在，否则将出错。如果要防止意外覆盖已有的表， SQL要求首先手工删除该表（请参阅后面的小节），然后再重建它，而不是简单地用创建表语句覆盖它。如果你仅想在一个表不存在时创建它，应该在表名后给出IFNOT EXISTS。这样做不检查已有表的模式是否与你打算创建的表模式相匹配。它只是查看表名是否存在，并且仅在表名不存在时创建它。 21.1.2 使用NULL值第6章中说过， NULL值就是没有值或缺值。允许NULL值的列也允许在插入行时不给出该列的值。不允许NULL值的列不接受该列没有值的行，换句话说，在插入或更新行时，该列必须有值。每个表列或者是NULL列，或者是NOT NULL列，这种状态在创建时由表的定义规定。请看下面的例子： 这条语句创建本书中所用的orders表。 orders包含3个列，分别是订单号、订单日期和客户ID。所有3个列都需要，因此每个列的定义都含有关键字NOT NULL。这将会阻止插入没有值的列。如果试图插入没有值的列，将返回错误，且插入失败。下一个例子将创建混合了NULL和NOT NULL列的表： 这条语句创建本书中使用的vendors表。供应商ID和供应商名字列是必需的，因此指定为NOT NULL。其余5个列全都允许NULL值，所以不指定NOT NULL。 NULL为默认设置，如果不指定NOT NULL，则认为指定的是NULL。理解NULL 不要把NULL值与空串相混淆。 NULL值是没有值，它不是空串。如果指定’’（两个单引号，其间没有字符），这在NOT NULL列中是允许的。空串是一个有效的值，它不是无值。 NULL值用关键字NULL而不是空串指定。 21.1.3 主键再介绍正如所述，主键值必须唯一。即，表中的每个行必须具有唯一的主键值。如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一。迄今为止我们看到的CREATE TABLE例子都是用单个列作为主键。其中主键用以下的类似的语句定义：primary key (vend_id)为创建由多个列组成的主键，应该以逗号分隔的列表给出各列名，如下所示： orderitems表包含orders表中每个订单的细节。每个订单有多项物品，但每个订单任何时候都只有1个第一项物品， 1个第二项物品，如此等等。因此，订单号（order_num列）和订单物品（order_item列）的组合是唯一的，从而适合作为主键，其定义为：primary key (order_num, order_item) 主键可以在创建表时定义（如这里所示）， 或者在创建表之后定义（本章稍后讨论）。 主键和NULL值 第1章介绍过，主键为其值唯一标识表中每个行的列。主键中只能使用不允许NULL值的列。允许NULL值的列不能作为唯一标识。 21.1.4 使用AUTO_INCREMENT让我们再次考察customers和orders表。 customers表中的顾客由列cust_id唯一标识，每个顾客有一个唯一编号。类似， orders表中的每个订单有一个唯一的订单号，这个订单号存储在列order_num中。这些编号除它们是唯一的以外没有别的特殊意义。在增加一个新顾客或新订单时，需要一个新的顾客ID或订单号。这些编号可以任意，只要它们是唯一的即可。显然，使用的最简单的编号是下一个编号，所谓下一个编号是大于当前最大编号的编号。例如，如果cust_id的最大编号为10005，则插入表中的下一个顾客可以具有等于10006的cust_id。简单吗？不见得。你怎样确定下一个要使用的值？当然，你可以使用SELECT语句得出最大的数（使用第12章介绍的Max()函数），然后对它加1。但这样做并不可靠（你需要找出一种办法来保证，在你执行SELECT和INSERT两条语句之间没有其他人插入行，对于多用户应用，这种情况是很有可能出现的），而且效率也不高（执行额外的MySQL操作肯定不是理想的办法）。这就是AUTO_INCREMENT发挥作用的时候了。请看以下代码行（用来创建customers表的CREATE TABLE语句的组成部分）：cust_id int not null auto_increment, AUTO_INCREMENT告诉MySQL，本列每当增加一行时自动增量。每次执行一个INSERT操作时， MySQL自动对该列增量（从而才有这个关键字AUTO_INCREMENT），给该列赋予下一个可用的值。这样给每个行分配一个唯一的cust_id，从而可以用作主键值。每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如，通过使它成为主键）。覆盖AUTO_INCREMENT 如果一个列被指定为AUTO_INCREMENT，则它需要使用特殊的值吗？你可以简单地在INSERT语句中指定一个值，只要它是唯一的（至今尚未使用过）即可，该值将被用来替代自动生成的值。后续的增量将开始使用该手工插入的值。（相关的例子请参阅本书中使用的表填充脚本。）确定AUTO_INCREMENT值 让MySQL生成（通过自动增量）主键的一个缺点是你不知道这些值都是谁。考虑这个场景：你正在增加一个新订单。这要求在orders表中创建一行， 然后在orderitms表中对订购的每项物品创建一行。 order_num在orderitems表中与订单细节一起存储。这就是为什么orders表和orderitems表为相互关联的表的原因。这显然要求你在插入orders行之后，插入orderitems行之前知道生成的order_num。那么，如何在使用AUTO_INCREMENT列时获得这个值呢？可使用last_insert_id()函数获得这个值，如下所示：select last_insert_id()此语句返回最后一个AUTO_INCREMENT值，然后可以将它用于后续的MySQL语句。 21.1.5 指定默认值如果在插入行时没有给出值， MySQL允许指定此时使用的默认值。默认值用CREATE TABLE语句的列定义中的DEFAULT关键字指定。请看下面的例子： 这条语句创建包含组成订单的各物品的orderitems表（订单本身存储在orders表中）。 quantity列包含订单中每项物品的数量。在此例子中，给该列的描述添加文本DEFAULT 1指示MySQL，在未给出数量的情况下使用数量1。不允许函数 与大多数DBMS不一样， MySQL不允许使用函数作为默认值，它只支持常量。使用默认值而不是NULL值 许多数据库开发人员使用默认值而不是NULL列，特别是对用于计算或数据分组的列更是如此。 21.1.6 引擎类型你可能已经注意到，迄今为止使用的CREATE TABLE语句全都以ENGINE=InnoDB语句结束。与其他DBMS一样， MySQL有一个具体管理和处理数据的内部引擎。在你使用CREATE TABLE语句时，该引擎具体创建表，而在你使用SELECT语句或进行其他数据库处理时，该引擎在内部处理你的请求。多数时候，此引擎都隐藏在DBMS内，不需要过多关注它。但MySQL与其他DBMS不一样，它具有多种引擎。它打包多个引擎，这些引擎都隐藏在MySQL服务器内，全都能执行CREATE TABLE和SELECT等命令。为什么要发行多种引擎呢？因为它们具有各自不同的功能和特性，为不同的任务选择正确的引擎能获得良好的功能和灵活性。 当然，你完全可以忽略这些数据库引擎。如果省略ENGINE=语句，则使用默认引擎（很可能是MyISAM），多数SQL语句都会默认使用它。但并不是所有语句都默认使用它，这就是为什么ENGINE=语句很重要的原因（也就是为什么本书的样列表中使用两种引擎的原因）。以下是几个需要知道的引擎： InnoDB是一个可靠的事务处理引擎（参见第26章），它不支持全文本搜索； MEMORY在功能等同于MyISAM， 但由于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表）； MyISAM是一个性能极高的引擎，它支持全文本搜索（参见第18章），但不支持事务处理。 更多知识 所支持引擎的完整列表（及它们之间的不同），请参阅链接。引擎类型可以混用。除productnotes表使用MyISAM外，本书中的样例表都使用InnoDB。 原因是作者希望支持事务处理（因此，使用InnoDB），但也需要在productnotes中支持全文本搜索（因此，使用MyISAM）。外键不能跨引擎 混用引擎类型有一个大缺陷。外键（用于强制实施引用完整性，如第1章所述）不能跨引擎，即使用一个引擎的表不能引用具有使用不同引擎的表的外键。那么， 你应该使用哪个引擎？这有赖于你需要什么样的特性。 MyISAM由于其性能和特性可能是最受欢迎的引擎。但如果你不需要可靠的事务处理，可以使用其他引擎。 21.2 更新表21.2 更新表为更新表定义，可使用ALTER TABLE语句。但是，理想状态下，当表中存储数据以后，该表就不应该再被更新。在表的设计过程中需要花费大量时间来考虑，以便后期不对该表进行大的改动。为了使用ALTER TABLE更改表结构，必须给出下面的信息： 在ALTER TABLE之后给出要更改的表名（该表必须存在，否则将出错）； 所做更改的列表。 下面的例子给表添加一个列： 这条语句给vendors表增加一个名为vend_phone的列，必须明确其数据类型。 删除刚刚添加的列，可以这样做： ALTER TABLE的一种常见用途是定义外键。下面是用来定义本书中的表所用的外键的代码： 这里，由于要更改4个不同的表，使用了4条ALTER TABLE语句。为了对单个表进行多个更改，可以使用单条ALTER TABLE语句，每个更改用逗号分隔。复杂的表结构更改一般需要手动删除过程，它涉及以下步骤： 用新的列布局创建一个新表； 使用INSERT SELECT语句（关于这条语句的详细介绍，请参阅第输入分析输入20321.4 重命名表 15319章）从旧表复制数据到新表。如果有必要，可使用转换函数和计算字段； 检验包含所需数据的新表； 重命名旧表（如果确定，可以删除它）； 用旧表原来的名字重命名新表； 根据需要，重新创建触发器、存储过程、索引和外键。小心使用ALTER TABLE 使用ALTER TABLE要极为小心，应该在进行改动前做一个完整的备份（模式和数据的备份）。数据库表的更改不能撤销，如果增加了不需要的列，可能不能删除它们。类似地，如果删除了不应该删除的列，可能会丢失该列中的所有数据。 21.3 删除表删除表（删除整个表而不是其内容）非常简单，使用DROP TABLE语句即可：drop table customers2; 输入这条语句删除customers （假设它存在）。删除表没有确认，也不能撤销，执行这条语句将永久删除该表。 21.4 重命名表使用RENAME TABLE语句可以重命名一个表：rename table customers2 to customers;RENAME TABLE所做的仅是重命名一个表。可以使用下面的语句对多个表重命名：rename table backup_customers to customers, backup_vendors to vendors, backup_products to products; 21.5 小结本章介绍了几条新SQL语句。 CREATE TABLE用来创建新表， ALTERTABLE用来更改表列（或其他诸如约束或索引等对象），而DROP TABLE用来完整地删除一个表。这些语句必须小心使用，并且应在做了备份后使用。本章还介绍了数据库引擎、定义主键和外键，以及其他重要的表和列选项。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第20章-更新和删除数据]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC20%E7%AB%A0-%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[第20章-更新和删除数据本章介绍如何利用UPDATE和DELETE语句进一步操纵表数据。 20.1 更新数据为了更新（修改）表中的数据，可使用UPDATE语句。可采用两种方式使用UPDATE; 更新表中特定行; 更新表中所有行。下面分别对它们进行介绍。不要省略WHERE子句 在使用UPDATE时一定要注意细心。因为稍不注意，就会更新表中所有行。在使用这条语句前，请完整地阅读本节。UPDATE与安全 可以限制和控制UPDATE语句的使用，更多内容请参见第28章。 UPDATE语句非常容易使用，甚至可以说是太容易使用了。基本的UPDATE语句由3部分组成，分别是; 要更新的表; 列名和它们的新值;140 更新和删除数据 确定要更新行的过滤条件。 举一个简单例子。客户10005现在有了电子邮件地址，因此他的记录需要更新，语句如下 UPDATE语句总是以要更新的表的名字开始。在此例子中，要更新的表的名字为customers。 SET命令用来将新值赋给被更新的列。如这里所示， SET子句设置cust_email列为指定的值: set cust_email=’elmer@fudd@com’ UPDATE语句以WHERE子句结束，它告诉MySQL更新哪一行。没有WHERE子句， MySQL将会用这个电子邮件地址更新customers表中所有行，这不是我们所希望的。更新多个列的语法稍有不同; 在更新多个列时，只需要使用单个SET命令，每个“列=值”对之间用逗号分隔（最后一列之后不用逗号）。在此例子中，更新客户10005的cust_name和cust_email列。 在UPDATE语句中使用子查询 UPDATE语句中可以使用子查询，使得能用SELECT语句检索出的数据更新列数据。关于子查询及使用的更多内容，请参阅第14章。 IGNORE关键字 如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE操作被取消（错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使用IGNORE关键字，如下所示;UPDATE IGNORE customers…为了删除某个列的值，可设置它为NULL（假如表定义允许NULL值）。如下进行;其中NULL用来去除cust_email列中的值。 20.2 删除数据为了从一个表中删除（去掉）数据，使用DELETE语句。可以两种方式使用DELETE; 从表中删除特定的行; 从表中删除所有行。下面分别对它们进行介绍。不要省略WHERE子句 在使用DELETE时一定要注意细心。因为稍不注意，就会错误地删除表中所有行。在使用这条语句前，请完整地阅读本节。DELETE与安全 可以限制和控制DELETE语句的使用，更多内容请参见第28章。前面说过， UPDATE非常容易使用，而DELETE更容易使用。下面的语句从customers表中删除一行; 这条语句很容易理解。 DELETE FROM要求指定从中删除数据的表名。WHERE子句过滤要删除的行。在这个例子中，只删除客户10006。如果省略WHERE子句，它将删除表中每个客户。DELETE不需要列名或通配符。 DELETE删除整行而不是删除列。为了删除指定的列，请使用UPDATE语句。 删除表的内容而不是表 DELETE语句从表中删除行，甚至是删除表中所有行。但是， DELETE不删除表本身。 更快的删除 如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATE TABLE语句，它完成相同的工作，但速度更快（ TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）。 20.3 更新和删除的指导原则前一节中使用的UPDATE和DELETE语句全都具有WHERE子句，这样做的理由很充分。如果省略了WHERE子句，则UPDATE或DELETE将被应用到表中所有的行。换句话说，如果执行UPDATE而不带WHERE子句，则表中每个行都将用新值更新。类似地，如果执行DELETE语句而不带WHERE子句，表的所有数据都将被删除。下面是许多SQL程序员使用UPDATE或DELETE时所遵循的习惯。 除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句。 保证每个表都有主键（如果忘记这个内容，请参阅第15章），尽可能像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）。 在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。 使用强制实施引用完整性的数据库（关于这个内容，请参阅第15章），这样MySQL将不允许删除具有与其他表相关联的数据的行。 小心使用 MySQL没有撤销（ undo）按钮。应该非常小心地使用UPDATE和DELETE，否则你会发现自己更新或删除了错误的数据。19020.4 小结 143 20.4 小结我们在本章中学习了如何使用UPDATE和DELETE语句处理表中的数据。我们学习了这些语句的语法，知道了它们固有的危险性。本章中还讲解了为什么WHERE子句对UPDATE和DELETE语句很重要，并且给出了应该遵循的一些指导原则，以保证数据的安全。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第19章-插入数据]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC19%E7%AB%A0-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[第19章-插入数据本章介绍如何利用SQL的INSERT语句将数据插入表中。 19.1 数据插入毫无疑问， SELECT是最常使用的SQL语句了（这就是为什么前17章讲的都是它的原因）。但是，还有其他3个经常使用的SQL语句需要学习。第一个就是INSERT（下一章介绍另外两个）。顾名思义， INSERT是用来插入（或添加）行到数据库表的。插入可以用几种方式使用： 插入完整的行； 插入行的一部分； 插入多行； 插入某些查询的结果。下面将介绍这些内容。插入及系统安全 可针对每个表或每个用户，利用MySQL的安全机制禁止使用INSERT语句，这将在第28章介绍。 19.2 插入完整的行把数据插入表中的最简单的方法是使用基本的INSERT语法，它要求177132 指定表名和被插入到新行中的值。下面举一个例子： 没有输出 INSERT语句一般不会产生输出。此例子插入一个新客户到customers表。存储到每个表列中的数据在VALUES子句中给出，对每个列必须提供一个值。如果某个列没有值（如上面的cust_contact和cust_email列），应该使用NULL值（假定表允许对该列指定空值）。各个列必须以它们在表定义中出现的次序填充。第一列cust_id也为NULL。这是因为每次插入一个新行时，该列由MySQL自动增量。你不想给出一个值（这是MySQL的工作），又不能省略此列（如前所述，必须给出每个列），所以指定一个NULL值（它被MySQL忽略， MySQL在这里插入下一个可用的cust_id值）。虽然这种语法很简单，但并不安全，应该尽量避免使用。上面的SQL语句高度依赖于表中列的定义次序，并且还依赖于其次序容易获得的信息。即使可得到这种次序信息，也不能保证下一次表结构变动后各个列保持完全相同的次序。因此，编写依赖于特定列次序的SQL语句是很不安全的。如果这样做，有时难免会出问题。编写INSERT语句的更安全（不过更烦琐）的方法如下： 此例子完成与前一个INSERT语句完全相同的工作，但在表名后的括号里明确地给出了列名。在插入行时， MySQL将用VALUES列表中的相应值填入列表中的对应项。 VALUES中的第一个值对应于第一个指定的列名。第二个值对应于第二个列名，如此等等。因为提供了列名， VALUES必须以其指定的次序匹配指定的列名，不一定按各个列出现在实际表中的次序。其优点是，即使表的结构改变，此INSERT语句仍然能正确工作。你会发现cust_id的NULL值是不必要的，cust_id列并没有出现在列表中，所以不需要任何值。下面的INSERT语句填充所有列（与前面的一样），但以一种不同的次序填充。因为给出了列名，所以插入结果仍然正确： 总是使用列的列表 一般不要使用没有明确给出列的列表的INSERT语句。使用列的列表能使SQL代码继续发挥作用，即使表结构发生了变化。 仔细地给出值 不管使用哪种INSERT语法，都必须给出VALUES的正确数目。如果不提供列名，则必须给每个表列提供一个值。如果提供列名，则必须对每个列出的列给出一个值。如果不这样，将产生一条错误消息，相应的行插入不成功。使用这种语法，还可以省略列。这表示可以只给某些列提供值，给其他列不提供值。（事实上你已经看到过这样的例子：当列名被明确列出时， cust_id可以省略。） 省略列 如果表的定义允许，则可以在INSERT操作中省略某些列。省略的列必须满足以下某个条件。 该列定义为允许NULL值（无值或空值）。 在表定义中给出默认值。这表示如果不给出值，将使用默认值。如果对表中不允许NULL值且没有默认值的列不给出值，则MySQL将产生一条错误消息，并且相应的行插入不成功。 提高整体性能 数据库经常被多个客户访问，对处理什么请求以及用什么次序处理进行管理是MySQL的任务。 INSERT操作可能很耗时（特别是有很多索引需要更新时），而且它可能降低等待处理的SELECT语句的性能。如果数据检索是最重要的（通常是这样），则你可以通过在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级，如下所示：INSERT LOW_PRIORITY INTO顺便说一下，这也适用于下一章介绍的UPDATE和DELETE语句。 19.3 插入多个行INSERT可以插入一行到一个表中。但如果你想插入多个行怎么办？可以使用多条INSERT语句，甚至一次提交它们，每条语句用一个分号结束，如下所示： 或者，只要每条INSERT语句中的列名（和次序）相同，可以如下组合各语句： 其中单条INSERT语句有多组值，每组值用一对圆括号括起来，用逗号分隔。提高INSERT的性能 此技术可以提高数据库处理的性能，因为MySQL用单条INSERT语句处理多个插入比使用多条INSERT语句快。 19.4 插入检索出的数据INSERT一般用来给表插入一个指定列值的行。但是， INSERT还存在另一种形式，可以利用它将一条SELECT语句的结果插入表中。这就是所谓的INSERT SELECT，顾名思义，它是由一条INSERT语句和一条SELECT语句组成的。假如你想从另一表中合并客户列表到你的customers表。 不需要每次读取一行，然后再将它用INSERT插入，可以如下进行：新例子的说明 这个例子把一个名为custnew的表中的数据导入customers表中。为了试验这个例子，应该首先创建和填充custnew表。 custnew表的结构与附录B中描述的customers表的相同。在填充custnew时，不应该使用已经在customers中使用过的cust_id值（如果主键值重复，后续的INSERT操作将会失败）或仅省略这列值让MySQL在导入数据的过程中产生新值。 这个例子使用INSERT SELECT从custnew中将所有数据导入customers。 SELECT语句从custnew检索出要插入的值，而不是列出它们。 SELECT中列出的每个列对应于customers表名后所跟的列表中的每个列。这条语句将插入多少行有赖于custnew表中有多少行。如果这个表为空，则没有行被插入（也不产生错误，因为操作仍然是合法的）。如果这个表确实含有数据，则所有数据将被插入到customers。这个例子导入了cust_id（假设你能够确保cust_id的值不重复）。你也可以简单地省略这列（从INSERT和SELECT中），这样MySQL就会生成新值。INSERT SELECT中的列名 为简单起见，这个例子在INSERT和SELECT语句中使用了相同的列名。但是，不一定要求列名匹配。事实上， MySQL甚至不关心SELECT返回的列名。它使用的是列的位置，因此SELECT中的第一列（不管其列名）将用来填充表列中指定的第一个列，第二列将用来填充表列中指定的第二个列，如此等等。这对于从使用不同列名的表中导入数据是非常有用的。INSERT SELECT中SELECT语句可包含WHERE子句以过滤插入的数据。更多例子 如果想看INSERT用法的更多例子，请参阅附录B中给出的样例表填充脚本，这主要用于创建本书中使用的样例表。 19.5 小结本章介绍如何将行插入到数据库表。我们学习了使用INSERT的几种方法，以及为什么要明确使用列名，学习了如何用INSERT SELECT从其他表中导入行。下一章讲述如何使用UPDATE和DELETE进一步操纵表数据。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第18章-全文本搜索]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC18%E7%AB%A0-%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[第18章-全文本搜索本章将学习如何使用MySQL的全文本搜索功能进行高级的数据查询和选择。 18.1 理解全文本搜索并非所有引擎都支持全文本搜索 正如第21章所述， MySQL支持几种基本的数据库引擎。并非所有的引擎都支持本书所描述的全文本搜索。两个最常使用的引擎为MyISAM和InnoDB，前者支持全文本搜索，而后者不支持。这就是为什么虽然本书中 创建的多数样例表使用InnoDB，而有一个样例表（ productnotes表）却使用MyISAM的原因。如果你的应用中需要全文本搜索功能，应该记住这一点。第8章介绍了LIKE关键字，它利用通配操作符匹配文本（和部分文本）。使用LIKE，能够查找包含特殊值或部分值的行（不管这些值位于列内什么位置）。在第9章中，用基于文本的搜索作为正则表达式匹配列值的更进一步的介绍。使用正则表达式，可以编写查找所需行的非常复杂的匹配模式。虽然这些搜索机制非常有用，但存在几个重要的限制。 性能——通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行（而且这些搜索极少使用表索引）。因此，由于被搜索行数不断增加，这些搜索可能非常耗时。 明确控制——使用通配符和正则表达式匹配，很难（而且并不总是能）明确地控制匹配什么和不匹配什么。例如，指定一个词必须匹配，一个词必须不匹配，而一个词仅在第一个词确实匹配的情况下才可以匹配或者才可以不匹配。 智能化的结果——虽然基于通配符和正则表达式的搜索提供了非常灵活的搜索，但它们都不能提供一种智能化的选择结果的方法。例如，一个特殊词的搜索将会返回包含该词的所有行，而不区分包含单个匹配的行和包含多个匹配的行（按照可能是更好的匹配来排列它们）。类似，一个特殊词的搜索将不会找出不包含该词但包含其他相关词的行。 所有这些限制以及更多的限制都可以用全文本搜索来解决。在使用全文本搜索时， MySQL不需要分别查看每个行，不需要分别分析和处理每个词。 MySQL创建指定列中各词的一个索引，搜索可以针对这些词进行。这样， MySQL可以快速有效地决定哪些词匹配（哪些行包含它们），哪些词不匹配，它们匹配的频率，等等。 18.2 使用全文本搜索为了进行全文本搜索，必须索引被搜索的列，而且要随着数据的改变不断地重新索引。在对表列进行适当设计后， MySQL会自动进行所有的索引和重新索引。在索引之后， SELECT可与Match()和Against()一起使用以实际执行搜索。 18.2.1 启用全文本搜索支持一般在创建表时启用全文本搜索。 CREATE TABLE语句（第21章中介绍）接受FULLTEXT子句，它给出被索引列的一个逗号分隔的列表。下面的CREATE语句演示了FULLTEXT子句的使用： 第21章将详细考察CREATE TABLE语句。现在，只需知道这条CREATE TABLE语句定义表productnotes并列出它所包含的列即可。这些列中有一个名为note_text的列，为了进行全文本搜索，MySQL根据子句FULLTEXT(note_text)的指示对它进行索引。这里的FULLTEXT索引单个列，如果需要也可以指定多个列。在定义之后， MySQL自动维护该索引。在增加、更新或删除行时，索引随之自动更新。可以在创建表时指定FULLTEXT，或者在稍后指定（在这种情况下所有已有数据必须立即索引）。 不要在导入数据时使用FULLTEXT 更新索引要花时间，虽然不是很多，但毕竟要花时间。如果正在导入数据到一个新表，此时不应该启用FULLTEXT索引。应该首先导入所有数据，然后再修改表， 定义FULLTEXT。 这样有助于更快地导入数据（而且使索引数据的总时间小于在导入每行时分别进行索引所需的总时间）。 18.2.2 进行全文本搜索在索引之后，使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列， Against()指定要使用的搜索表达式。下面举一个例子： 此SELECT语句检索单个列note_text。由于WHERE子句，一个全文本搜索被执行。 Match(note_text)指示MySQL针对指定的列进行搜索， Against(‘rabbit’)指定词rabbit作为搜索文本。由于有两行包含词rabbit，这两个行被返回。 使 用 完 整 的 Match() 说 明传 递 给 Match() 的 值 必 须 与FULLTEXT()定义中的相同。如果指定多个列，则必须列出它们（而且次序正确）。搜索不区分大小写 除非使用BINARY方式（本章中没有介绍），否则全文本搜索不区分大小写。事实是刚才的搜索可以简单地用LIKE子句完成，如下所示： 这条SELECT语句同样检索出两行，但次序不同（虽然并不总是出现这种情况）。上述两条SELECT语句都不包含ORDER BY子句。后者（使用LIKE）以不特别有用的顺序返回数据。前者（使用全文本搜索）返回以文本匹配输出分析输入输出分析16416518.2 使用全文本搜索 123的良好程度排序的数据。两个行都包含词rabbit，但包含词rabbit作为第3个词的行的等级比作为第20个词的行高。这很重要。全文本搜索的一个重要部分就是对结果排序。具有较高等级的行先返回（因为这些行很可能是你真正想要的行）。为演示排序如何工作，请看以下例子： 这里， 在SELECT而不是WHERE子句中使用Match()和Against()。这使所有行都被返回（因为没有WHERE子句）。Match()和Against()用来建立一个计算列（别名为rank），此列包含全文本搜索计算出的等级值。等级由MySQL根据行中词的数目、唯一词的数目、整个索引中词的总数以及包含该词的行的数目计算出来。正如所见，不包含词rabbit的行等级为0（因此不被前一例子中的WHERE子句选择）。确实包含词rabbit的两个行每行都有一个等级值，文本中词靠前的行的等级值比词靠后的行的等级值高。这个例子有助于说明全文本搜索如何排除行（排除那些等级为0的行），如何排序结果（按等级以降序排序）。 排序多个搜索项 如果指定多个搜索项，则包含多数匹配词的那些行将具有比包含较少词（或仅有一个匹配）的那些行高的等级值。正如所见，全文本搜索提供了简单LIKE搜索不能提供的功能。而且，由于数据是索引的，全文本搜索还相当快。 18.2.3 使用查询扩展查询扩展用来设法放宽所返回的全文本搜索结果的范围。考虑下面的情况。你想找出所有提到anvils的注释。只有一个注释包含词anvils，但你还想找出可能与你的搜索有关的所有其他行，即使它们不包含词分析16718.2 使用全文本搜索 125anvils。这也是查询扩展的一项任务。在使用查询扩展时， MySQL对数据和索引进行两遍扫描来完成搜索： 首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行； 其次， MySQL检查这些匹配行并选择所有有用的词（我们将会简要地解释MySQL如何断定什么有用，什么无用）。 再其次， MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词。 利用查询扩展，能找出可能相关的结果，即使它们并不精确包含所查找的词。只用于MySQL版本4.1.1或更高级的版本 查询扩展功能是在MySQL 4.1.1中引入的，因此不能用于之前的版本。下面举一个例子，首先进行一个简单的全文本搜索，没有查询扩展： 只有一行包含词anvils，因此只返回一行。下面是相同的搜索，这次使用查询扩展： 这次返回了7行。第一行包含词anvils，因此等级最高。第二行与anvils无关，但因为它包含第一行中的两个词（customer和recommend），所以也被检索出来。第3行也包含这两个相同的词，但它们在文本中的位置更靠后且分开得更远，因此也包含这一行，但等级为第三。第三行确实也没有涉及anvils（按它们的产品名）。正如所见，查询扩展极大地增加了返回的行数，但这样做也增加了你实际上并不想要的行的数目。行越多越好 表中的行越多（这些行中的文本就越多），使用查询扩展返回的结果越好。 18.2.4 布尔文本搜索MySQL支持全文本搜索的另外一种形式，称为布尔方式（booleanmode）。以布尔方式，可以提供关于如下内容的细节： 要匹配的词； 要排斥的词（如果某行包含这个词，则不返回该行，即使它包含其他指定的词也是如此）； 排列提示（指定某些词比其他词更重要，更重要的词等级更高）； 表达式分组； 另外一些内容。 即使没有FULLTEXT索引也可以使用 布尔方式不同于迄今为止 使 用 的 全 文 本 搜 索 语 法 的 地 方 在 于 ， 即 使 没 有 定 义FULLTEXT索引，也可以使用它。但这是一种非常缓慢的操作（其性能将随着数据量的增加而降低）。为演示IN BOOLEAN MODE的作用，举一个简单的例子： 此全文本搜索检索包含词heavy的所有行（有两行）。其中使用了关键字IN BOOLEAN MODE，但实际上没有指定布尔操作符，因此，其结果与没有指定布尔方式的结果相同。IN BOOLEAN MODE的行为差异 虽然这个例子的结果与没有IN BOOLEAN MODE的相同，但其行为有一个重要的差别（即使在这个特殊的例子没有表现出来）。我们将在18.2.5节指出。为了匹配包含heavy但不包含任意以rope开始的词的行， 可使用以下查询： 这次只返回一行。这一次仍然匹配词heavy，但-rope*明确地指示MySQL排除包含rope*（任何以rope开始的词，包括ropes）的行，这就是为什么上一个例子中的第一行被排除的原因。 在MySQL 4.x中所需的代码更改 如果你使用的是MySQL4.x，则上面的例子可能不返回任何行。这是*操作符处理中的一个错误。为在MySQL 4.x中使用这个例子，使用-ropes而不是-rope*（排除ropes而不是排除任何以rope开始的词）。 我们已经看到了两个全文本搜索布尔操作符-和*， -排除一个词，而*是截断操作符（可想象为用于词尾的一个通配符）。 下面举几个例子，说明某些操作符如何使用：这个搜索匹配包含词rabbit和bait的行。 没有指定操作符，这个搜索匹配包含rabbit和bait中的至少一个词的行。 这个搜索匹配短语rabbit bait而不是匹配两个词rabbit和bait。 匹配rabbit和carrot，增加前者的等级，降低后者的等级。 这个搜索匹配词safe和combination，降低后者的等级。 排列而不排序 在布尔方式中，不按等级值降序排序返回的行。 18.2.5 全文本搜索的使用说明在结束本章之前，给出关于全文本搜索的某些重要的说明。 在索引全文本数据时，短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。 MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表（请参阅MySQL文档以了解如何完成此工作）。 许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此， MySQL规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。 50%规则不用于IN BOOLEANMODE。 如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词或者不出现，或者至少出现在50%的行中）。 忽略词中的单引号。例如， don’t索引为dont。 不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。 如前所述，仅在MyISAM数据库引擎中支持全文本搜索。 没有邻近操作符 邻近搜索是许多全文本搜索支持的一个特性，它能搜索相邻的词（在相同的句子中、相同的段落中或者在特定数目的词的部分中，等等）。 MySQL全文本搜索现在还不支持邻近操作符，不过未来的版本有支持这种操作符的计划。 18.3 小结本章介绍了为什么要使用全文本搜索，以及如何使用MySQL的Match()和Against()函数进行全文本搜索。我们还学习了查询扩展（它能增加找到相关匹配的机会）和如何使用布尔方式进行更细致的查找控制。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第17章-组合查询]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC17%E7%AB%A0-%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[第17章-组合查询本章讲述如何利用UNION操作符将多条SELECT语句组合成一个结果集。 17.1 组合查询多数SQL查询都只包含从一个或多个表中返回数据的单条SELECT语句。 MySQL也允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（ union） 或复合查询（compound query）。有两种基本情况，其中需要使用组合查询： 在单个查询中从不同的表返回类似结构的数据； 对单个表执行多个查询，按单个查询返回数据。 组合查询和多个WHERE条件 多数情况下，组合相同表的两个查询完成的工作与具有多个WHERE子句条件的单条查询完成的工作相同。换句话说，任何具有多个WHERE子句的SELECT语句都可以作为一个组合查询给出，在以下段落中可以看到这一点。这两种技术在不同的查询中性能也不同。因此，应该试一下这两种技术，以确定对特定的查询哪一种性能更好。 17.2 创建组合查询可用UNION操作符来组合数条SQL查询。利用UNION，可给出多条SELECT语句，将它们的结果组合成单个结果集。 17.2.1 使用UNIONUNION的使用很简单。所需做的只是给出每条SELECT语句，在各条语句之间放上关键字UNION。举一个例子，假如需要价格小于等于5的所有物品的一个列表，而且还想包括供应商1001和1002生产的所有物品（不考虑价格）。当然，可以利用WHERE子句来完成此工作，不过这次我们将使用UNION。正如所述，创建UNION涉及编写多条SELECT语句。首先来看单条语句： 第一条SELECT检索价格不高于5的所有物品。第二条SELECT使用IN找出供应商1001和1002生产的所有物品。为了组合这两条语句，按如下进行： 这条语句由前面的两条SELECT语句组成，语句中用UNION关键字分隔。 UNION指示MySQL执行两条SELECT语句，并把输出组合成单个查询结果集。作为参考，这里给出使用多条WHERE子句而不是使用UNION的相同查询： 在这个简单的例子中，使用UNION可能比使用WHERE子句更为复杂。但对于更复杂的过滤条件，或者从多个表（而不是单个表）中检索数据的情形，使用UNION可能会使处理更简单。 17.2.2 UNION规则正如所见，并是非常容易使用的。但在进行并时有几条规则需要注意。 UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个UNION关键字）。 UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过155 各个列不需要以相同的次序列出）。 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。如果遵守了这些基本规则或限制，则可以将并用于任何数据检索任务。 17.2.3 包含或取消重复的行请返回到17.2.1节，考察一下所用的样例SELECT语句。我们注意到，在分别执行时，第一条SELECT语句返回4行，第二条SELECT语句返回5行。但在用UNION组合两条SELECT语句后，只返回了8行而不是9行。UNION从查询结果集中自动去除了重复的行（换句话说，它的行为与单条SELECT语句中使用多个WHERE子句条件一样）。因为供应商1002生产的一种物品的价格也低于5，所以两条SELECT语句都返回该行。在使用UNION时，重复的行被自动取消。这是UNION的默认行为，但是如果需要，可以改变它。事实上，如果想返回所有匹配行，可使用UNION ALL而不是UNION。请看下面的例子： 使用UNION ALL， MySQL不取消重复的行。因此这里的例子返回9行，其中有一行出现两次。UNION与WHERE 本章开始时说过， UNION几乎总是完成与多个WHERE条件相同的工作。 UNION ALL为UNION的一种形式，它完成WHERE子句完成不了的工作。如果确实需要每个条件的匹配行全部出现（包括重复行），则必须使用UNION ALL而不是WHERE。 17.2.4 对组合查询结果排序SELECT语句的输出用ORDER BY子句排序。在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。对于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况，因此不允许使用多条ORDER BY子句。下面的例子排序前面UNION返回的结果： 这条UNION在最后一条SELECT语句后使用了ORDER BY子句。虽然ORDER BY子句似乎只是最后一条SELECT语句的组成部分，但实际上MySQL将用它来排序所有SELECT语句返回的所有结果。 组合不同的表 为使表述比较简单，本章例子中的组合查询使用的均是相同的表。但是其中使用UNION的组合查询可以应用不同的表。 17.3 小结本章讲授如何用UNION操作符来组合SELECT语句。利用UNION，可把多条查询的结果作为一条组合查询返回，不管它们的结果中包含还是不包含重复。使用UNION可极大地简化复杂的WHERE子句，简化从多个表中检索数据的工作。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第16章-创建高级联结]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC16%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93%2F</url>
    <content type="text"><![CDATA[第16章-创建高级联结本章将讲解另外一些联结类型（包括它们的含义和使用方法），介绍如何对被联结的表使用表别名和聚集函数。 16.1 使用表别名第10章中介绍了如何使用别名引用被检索的表列。给列起别名的语法如下： 别名除了用于列名和计算字段外， SQL还允许给表名起别名。这样做有两个主要理由： 缩短SQL语句； 允许在单条SELECT语句中多次使用相同的表。 请看下面的SELECT语句。它与前一章的例子中所用的语句基本相同，但改成了使用别名： 可以看到， FROM子句中3个表全都具有别名。 customers AS c建立c作为customers的别名，等等。这使得能使用省写的c而不是全名customers。在此例子中，表别名只用于WHERE子句。但是，表别名不仅能用于WHERE子句，它还可以用于SELECT的列表、 ORDER BY子句以及语句的其他部分。应该注意，表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户机。 16.2 使用不同类型的联结迄今为止，我们使用的只是称为内部联结或等值联结（ equijoin） 的简单联结。现在来看3种其他联结，它们分别是自联结、自然联结和外部联结。 16.2.1 自联结如前所述，使用表别名的主要原因之一是能在单条SELECT语句中不止一次引用相同的表。下面举一个例子。假如你发现某物品（其ID为DTNTR）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。此查询要求首先找到生产ID为DTNTR的物品的供应商，然后找出这个供应商生产的其他物品。下面是解决此问题的一种方法： 这是第一种解决方案，它使用了子查询。内部的SELECT语句做了一个简单的检索，返回生产ID为DTNTR的物品供应商的vend_id。该ID用于外部查询的WHERE子句中，以便检索出这个供应商生产的所有物品（第14章中讲授了子查询的所有内容。更多信息请参阅该章）。现在来看使用联结的相同查询： 此查询中需要的两个表实际上是相同的表，因此products表在FROM子句中出现了两次。虽然这是完全合法的，但对products的引用具有二义性，因为MySQL不知道你引用的是products表中的哪个实例。为解决此问题，使用了表别名。 products的第一次出现为别名p1，第二次出现为别名p2。现在可以将这些别名用作表名。例如， SELECT语句使用p1前缀明确地给出所需列的全名。如果不这样， MySQL将返回错误，因为分别存在两个名为prod_id、 prod_name的列。 MySQL不知道想要的是哪一个列（即使它们事实上是同一个列）。 WHERE（通过匹配p1中的vend_id和p2中的vend_id）首先联结两个表，然后按第二个表中的prod_id过滤数据，返回所需的数据。 用自联结而不用子查询 自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的，但有时候处理联结远比处理子查询快得多。应该试一下两种方法，以确定哪一种的性能更好。 16.2.2 自然联结无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。标准的联结（前一章中介绍的内部联结）返回所有数据，甚至相同的列多次出现。 自然联结排除多次出现，使每个列只返回一次。怎样完成这项工作呢？答案是，系统不完成这项工作，由你自己完成它。自然联结是这样一种联结，其中你只能选择那些唯一的列。这一般是通过对表使用通配符（SELECT *），对所有其他表的列使用明确的子集来完成的。下面举一个例子： 在这个例子中，通配符只对第一个表使用。所有其他列明确列出，所以没有重复的列被检索出来。事实上，迄今为止我们建立的每个内部联结都是自然联结，很可能我们永远都不会用到不是自然联结的内部联结。 16.2.3 外部联结许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。例如，可能需要使用联结来完成以下工作： 对每个客户下了多少订单进行计数，包括那些至今尚未下订单的客户； 列出所有产品以及订购数量，包括没有人订购的产品； 计算平均销售规模，包括那些至今尚未下订单的客户。在上述例子中，联结包含了那些在相关表中没有关联行的行。这种类型的联结称为外部联结。下面的SELECT语句给出一个简单的内部联结。它检索所有客户及其订单： 外部联结语法类似。为了检索所有客户，包括那些没有订单的客户，可如下进行： 类似于上一章中所看到的内部联结，这条SELECT语句使用了关键字OUTER JOIN来指定联结的类型（而不是在WHERE子句中指定）。但是，与内部联结关联两个表中的行不同的是，外部联结还包括没有关联行的行。在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）。上面的例子使用LEFT OUTER JOIN从FROM子句的左边表（customers表）中选择所有行。为了从右边的表中选择所有行，应该使用RIGHT OUTER JOIN，如下例所示： 没有*=操作符 MySQL不支持简化字符*=和=*的使用，这两种操作符在其他DBMS中是很流行的。 外部联结的类型 存在两种基本的外部联结形式：左外部联结和右外部联结。它们之间的唯一差别是所关联的表的顺序不同。换句话说，左外部联结可通过颠倒FROM或WHERE子句中表的顺序转换为右外部联结。因此，两种类型的外部联结可互换使用，而究竟使用哪一种纯粹是根据方便而定。 16.3 使用带聚集函数的联结正如第12章所述，聚集函数用来汇总数据。虽然至今为止聚集函数的所有例子只是从单个表汇总数据，但这些函数也可以与联结一起使用。为说明这一点，请看一个例子。如果要检索所有客户及每个客户所下的订单数，下面使用了COUNT()函数的代码可完成此工作： 此SELECT语句使用INNER JOIN将customers和orders表互相关联。GROUP BY子句按客户分组数据 ， 因 此 ， 函 数 调 用 COUNT(orders.order_num)对每个客户的订单计数，将它作为num_ord返回。聚集函数也可以方便地与其他联结一起使用。请看下面的例子： 这个例子使用左外部联结来包含所有客户，甚至包含那些没有任何下订单的客户。结果显示也包含了客户Mouse House，它有0个订单。 16.4 使用联结和联结条件在总结关于联结的这两章前，有必要汇总一下关于联结及其使用的某些要点。 注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的。 保证使用正确的联结条件，否则将返回不正确的数据。 应该总是提供联结条件，否则会得出笛卡儿积。 在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前，分别测试每个联结。这将使故障排除更为简单。 16.5 小结本章是上一章关于联结的继续。本章从讲授如何以及为什么要使用别名开始，然后讨论不同的联结类型及对每种类型的联结使用的各种语法形式。我们还介绍了如何与联结一起使用聚集函数，以及在使用联结时应该注意的某些问题。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第15章-联结表]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC15%E7%AB%A0-%E8%81%94%E7%BB%93%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[第15章-联结表本章将介绍什么是联结，为什么要使用联结，如何编写使用联结的SELECT语句。 15.1 联结SQL最强大的功能之一就是能在数据检索查询的执行中联结（join）表。联结是利用SQL的SELECT能执行的最重要的操作，很好地理解联结及其语法是学习SQL的一个极为重要的组成部分。在能够有效地使用联结前，必须了解关系表以及关系数据库设计的一些基础知识。下面的介绍并不是这个内容的全部知识，但作为入门已经足够了。 15.1.1 关系表理解关系表的最好方法是来看一个现实世界中的例子。假如有一个包含产品目录的数据库表，其中每种类别的物品占一行。对于每种物品要存储的信息包括产品描述和价格，以及生产该产品的供应商信息。现在，假如有由同一供应商生产的多种物品，那么在何处存储供应商信息（如，供应商名、地址、联系方法等）呢？将这些数据与产品信息分开存储的理由如下。 因为同一供应商生产的每个产品的供应商信息都是相同的，对每个产品重复此信息既浪费时间又浪费存储空间。 如果供应商信息改变（例如，供应商搬家或电话号码变动），只需改动一次即可。 如果有重复数据（即每种产品都存储供应商信息），很难保证每次输入该数据的方式都相同。不一致的数据在报表中很难利用。 关键是，相同数据出现多次决不是一件好事，此因素是关系数据库设计的基础。关系表的设计就是要保证把信息分解成多个表，一类数据一个表。各表通过某些常用的值（即关系设计中的关系（ relational） ）互相关联。在这个例子中，可建立两个表，一个存储供应商信息，另一个存储产品信息。 vendors表包含所有供应商信息，每个供应商占一行，每个供应商具有唯一的标识。此标识称为主键（ primary key） （在第1章中首次提到），可以是供应商ID或任何其他唯一值。products表只存储产品信息，它除了存储供应商ID（vendors表的主键）外不存储其他供应商信息。vendors表的主键又叫作products的外键，它将vendors表与products表关联，利用供应商ID能从vendors表中找出相应供应商的详细信息。外键（foreign key） 外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。这样做的好处如下： 供应商信息不重复，从而不浪费时间和空间； 如果供应商信息变动，可以只更新vendors表中的单个记录，相关表中的数据不用改动； 由于数据无重复，显然数据是一致的，这使得处理数据更简单。总之，关系数据可以有效地存储和方便地处理。因此，关系数据库的可伸缩性远比非关系数据库要好。可伸缩性（scale） 能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好（ scale well） 。 15.1.2 为什么要使用联结正如所述，分解数据为多个表能更有效地存储，更方便地处理，并且具有更大的可伸缩性。但这些好处是有代价的。如果数据存储在多个表中，怎样用单条SELECT语句检索出数据？答案是使用联结。简单地说，联结是一种机制，用来在一条SELECT语句中关联表，因此称之为联结。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。 维护引用完整性 重要的是，要理解联结不是物理实体。换句话说，它在实际的数据库表中不存在。联结由MySQL根据需要建立，它存在于查询的执行当中。在使用关系表时，仅在关系列中插入合法的数据非常重要。回到这里的例子，如果在products表中插入拥有非法供应商ID（即没有在vendors表中出现）的供应商生产的产品，则这些产品是不可访问的，因为它们没有关联到某个供应商。为防止这种情况发生，可指示MySQL只允许在products表的供应商ID列中出现合法值（即出现在vendors表中的供应商）。这就是维护引用完整性，它是通过在表的定义中指定主键和外键来实现的。（这将在第21章介绍。） 15.2 创建联结联结的创建非常简单，规定要联结的所有表以及它们如何关联即可。请看下面的例子： 我们来考察一下此代码。 SELECT语句与前面所有语句一样指定要检索的列。这里，最大的差别是所指定的两个列（prod_name和prod_price）在一个表中，而另一个列（vend_name）在另一个表中。现在来看FROM子句。与以前的SELECT语句不一样，这条语句的FROM子句列出了两个表，分别是vendors和products。它们就是这条SELECT语句联结的两个表的名字。这两个表用WHERE子句正确联结， WHERE子句指示MySQL匹配vendors表中的vend_id和products表中的vend_id。可以看到要匹配的两个列以vendors.vend_id 和 products.vend_id指定。这里需要这种完全限定列名，因为如果只给出vend_id，则MySQL不知道指的是哪一个（它们有两个，每个表中一个）。 完全限定列名 在引用的列可能出现二义性时，必须使用完全限定列名（用一个点分隔的表名和列名）。如果引用一个没有用表名限制的具有二义性的列名， MySQL将返回错误。 15.2.1 WHERE子句的重要性利用WHERE子句建立联结关系似乎有点奇怪，但实际上，有一个很充分的理由。请记住，在一条SELECT语句中联结几个表时，相应的关系是在运行中构造的。在数据库表的定义中不存在能指示MySQL如何对表进行联结的东西。你必须自己做这件事情。在联结两个表时，你实际上做的是将第一个表中的每一行与第二个表中的每一行配对。 WHERE子句作为过滤条件，它只包含那些匹配给定条件（这里是联结条件）的行。没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管它们逻辑上是否可以配在一起。 笛卡儿积（cartesian product） 由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。为理解这一点，请看下面的SELECT语句及其输出： 从上面的输出中可以看到，相应的笛卡儿积不是我们所想要的。这里返回的数据用每个供应商匹配了每个产品，它包括了供应商不正确的产品。实际上有的供应商根本就没有产品。 不要忘了WHERE子句 应该保证所有联结都有WHERE子句，否则MySQL将返回比想要的数据多得多的数据。同理，应该保证WHERE子句的正确性。不正确的过滤条件将导致MySQL返回不正确的数据。 叉联结 有时我们会听到返回称为叉联结（ cross join）的笛卡儿积的联结类型。 15.2.2 内部联结目前为止所用的联结称为等值联结（equijoin），它基于两个表之间的相等测试。这种联结也称为内部联结。其实，对于这种联结可以使用稍微不同的语法来明确指定联结的类型。下面的SELECT语句返回与前面例子完全相同的数据： 此语句中的SELECT与前面的SELECT语句相同，但FROM子句不同。这里，两个表之间的关系是FROM子句的组成部分，以INNER JOIN指定。在使用这种语法时，联结条件用特定的ON子句而不是WHERE子句给出。传递给ON的实际条件与传递给WHERE的相同。 使用哪种语法 ANSI SQL规范首选INNER JOIN语法。此外，尽管使用WHERE子句定义联结的确比较简单，但是使用明确的联结语法能够确保不会忘记联结条件，有时候这样做也能影响性能。 15.2.3 联结多个表SQL对一条SELECT语句中可以联结的表的数目没有限制。创建联结的基本规则也相同。首先列出所有表，然后定义表之间的关系。例如： 此例子显示编号为20005的订单中的物品。订单物品存储在orderitems表中。每个产品按其产品ID存储，它引用products表中的产品。这些产品通过供应商ID联结到vendors表中相应的供应商，供应商ID存储在每个产品的记录中。这里的FROM子句列出了3个表，而WHERE子句定义了这两个联结条件，而第三个联结条件用来过滤出订单20005中的物品。 性能考虑 MySQL在运行时关联指定的每个表以处理联结。这种处理可能是非常耗费资源的，因此应该仔细，不要联结不必要的表。联结的表越多，性能下降越厉害。现在可以回顾一下第14章中的例子了。该例子如下所示，其SELECT语句返回订购产品TNT2的客户列表： 正如第14章所述，子查询并不总是执行复杂SELECT操作的最有效的方法，下面是使用联结的相同查询： 正如第14章所述，这个查询中返回数据需要使用3个表。但这里我们没有在嵌套子查询中使用它们，而是使用了两个联结。这里有3个WHERE子句条件。前两个关联联结中的表，后一个过滤产品TNT2的数据。 多做实验 正如所见，为执行任一给定的SQL操作，一般存在不止一种方法。很少有绝对正确或绝对错误的方法。性能可能会受操作类型、表中数据量、是否存在索引或键以及其他一些条件的影响。因此，有必要对不同的选择机制进行实验，以找出最适合具体情况的方法。 15.3 小结联结是SQL中最重要最强大的特性，有效地使用联结需要对关系数据库设计有基本的了解。本章随着对联结的介绍讲述了关系数据库设计的一些基本知识，包括等值联结（也称为内部联结）这种最经常使用的联结形式。下一章将介绍如何创建其他类型的联结。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第14章-使用子查询]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC14%E7%AB%A0-%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[第14章-使用子查询使用子查询本章介绍什么是子查询以及如何使用它们。 14.1 子查询版本要求 MySQL 4.1引入了对子查询的支持，所以要想使用本章描述的SQL，必须使用MySQL 4.1或更高级的版本。SELECT语句是SQL的查询。迄今为止我们所看到的所有SELECT语句都是简单查询，即从单个数据库表中检索数据的单条语句。查询（query） 任何SQL语句都是查询。但此术语一般指SELECT语句。SQL还允许创建子查询（ subquery） ，即嵌套在其他查询中的查询。为什么要这样做呢？理解这个概念的最好方法是考察几个例子。 14.2 利用子查询进行过滤本书所有章中使用的数据库表都是关系表（关于每个表及关系的描述，请参阅附录B）。订单存储在两个表中。对于包含订单号、客户ID、订单日期的每个订单， orders表存储一行。各订单的物品存储在相关的orderitems表中。 orders表不存储客户信息。它只存储客户的ID。实际的客户信息存储在customers表中。现在，假如需要列出订购物品TNT2的所有客户，应该怎样检索？下面列出具体的步骤。 (1) 检索包含物品TNT2的所有订单的编号。 (2) 检索具有前一步骤列出的订单编号的所有客户的ID。 (3) 检索前一步骤返回的所有客户ID的客户信息。上述每个步骤都可以单独作为一个查询来执行。可以把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句。也可以使用子查询来把3个查询组合成一条语句。第一条SELECT语句的含义很明确，对于prod_id为TNT2的所有订单物品，它检索其order_num列。输出列出两个包含此物品的订单： 下一步，查询具有订单20005和20007的客户ID。利用第7章介绍的IN子句，编写如下的SELECT语句： 现在，把第一个查询（返回订单号的那一个）变为子查询组合两个查询。请看下面的SELECT语句： 在SELECT语句中，子查询总是从内向外处理。在处理上面的SELECT语句时， MySQL实际上执行了两个操作。首先，它执行下面的查询：SELECT order_num FROM orderitems WHERE prod_id=’TNT2’此查询返回两个订单号： 20005和20007。然后，这两个值以IN操作符要求的逗号分隔的格式传递给外部查询的WHERE子句。外部查询变成：SELECT cust_id FROM orders WHERE order_num IN (20005,20007)可以看到，输出是正确的并且与前面硬编码WHERE子句所返回的值相同。 格式化SQL 包含子查询的SELECT语句难以阅读和调试，特别是它们较为复杂时更是如此。如上所示把子查询分解为多行并且适当地进行缩进，能极大地简化子查询的使用。现在得到了订购物品TNT2的所有客户的ID。下一步是检索这些客户ID的客户信息。检索两列的SQL语句为： 可以把其中的WHERE子句转换为子查询而不是硬编码这些客户ID： 为了执行上述SELECT语句， MySQL实际上必须执行3条SELECT语句。最里边的子查询返回订单号列表，此列表用于其外面的子查询的WHERE子句。外面的子查询返回客户ID列表，此客户ID列表用于最外层查询的WHERE子句。最外层查询确实返回所需的数据。可见，在WHERE子句中使用子查询能够编写出功能很强并且很灵活的SQL语句。对于能嵌套的子查询的数目没有限制，不过在实际使用时由于性能的限制，不能嵌套太多的子查询。列必须匹配 在WHERE子句中使用子查询（如这里所示），应该保证SELECT语句具有与WHERE子句中相同数目的列。通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。虽然子查询一般与IN操作符结合使用，但也可以用于测试等于（=）、不等于（&lt;&gt;）等。子查询和性能 这里给出的代码有效并获得所需的结果。但是，使用子查询并不总是执行这种类型的数据检索的最有效的方法。更多的论述，请参阅第15章，其中将再次给出这个例子。 14.3 作为计算字段使用子查询使用子查询的另一方法是创建计算字段。假如需要显示customers表中每个客户的订单总数。订单与相应的客户ID存储在orders表中。为了执行这个操作，遵循下面的步骤。(1) 从customers表中检索客户列表。(2) 对于检索出的每个客户，统计其在orders表中的订单数目。正如前两章所述，可使用SELECT COUNT(*)对表中的行进行计数，并且通过提供一条WHERE子句来过滤某个特定的客户ID， 可仅对该客户的订单进行计数。例如，下面的代码对客户10001的订单进行计数： 为了对每个客户执行COUNT(*)计算，应该将COUNT(*)作为一个子查询。请看下面的代码： 这 条 SELECT 语 句 对 customers 表 中 每 个 客 户 返 回 3 列 ：cust_name、 cust_state和orders。 orders是一个计算字段，它是由圆括号中的子查询建立的。该子查询对检索出的每个客户执行一次。在此例子中，该子查询执行了5次，因为检索出了5个客户。子查询中的WHERE子句与前面使用的WHERE子句稍有不同，因为它使用了完全限定列名（在第4章中首次提到）。下面的语句告诉SQL比较orders表中的cust_id与当前正从customers表中检索的cust_id：WHERE orders.cust_id=customers.cust_id 相关子查询（correlated subquery） 涉及外部查询的子查询。这种类型的子查询称为相关子查询。任何时候只要列名可能有多义性，就必须使用这种语法（表名和列名由一个句点分隔）。为什么这样？我们来看看如果不使用完全限定的列名会发生什么情况： 显然，返回的结果不正确（请比较前面的结果），那么，为什么会这样呢？有两个cust_id列，一个在customers中，另一个在orders中，需要比较这两个列以正确地把订单与它们相应的顾客匹配。如果不完全限定列名， MySQL将假定你是对orders表中的cust_id进行自身比较。而SELECT COUNT(*) FROM orders WHERE cust_id = cust_id;总是返回orders表中的订单总数（因为MySQL查看每个订单的cust_id是否与本身匹配，当然，它们总是匹配的）。虽然子查询在构造这种SELECT语句时极有用，但必须注意限制有歧义性的列名。 不止一种解决方案 正如本章前面所述，虽然这里给出的样例代码运行良好，但它并不是解决这种数据检索的最有效的方法。在后面的章节中我们还要遇到这个例子。 逐渐增加子查询来建立查询 用子查询测试和调试查询很有技巧性，特别是在这些语句的复杂性不断增加的情况下更是如此。 用子查询建立（和测试）查询的最可靠的方法是逐渐进行，这与MySQL处理它们的方法非常相同。首先，建立和测试最内层的查询。然后，用硬编码数据建立和测试外层查询，并且仅在确认它正常后才嵌入子查询。这时，再次测试它。对于要增加的每个查询，重复这些步骤。这样做仅给构造查询增加了一点点时间，但节省了以后（找出查询为什么不正常）的大量时间，并且极大地提高了查询一开始就正常工作的可能性。 14.4 小结本章学习了什么是子查询以及如何使用它们。子查询最常见的使用是在WHERE子句的IN操作符中，以及用来填充计算列。我们举了这两种操作类型的例子。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第13章-分组数据]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC13%E7%AB%A0-%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[第13章 分组数据本章将介绍如何分组数据，以便能汇总表内容的子集。这涉及两个新SELECT语句子句，分别是GROUP BY子句和HAVING子句。 13.1 数据分组从上一章知道， SQL聚集函数可用来汇总数据。这使我们能够对行进行计数，计算和与平均数，获得最大和最小值而不用检索所有数据。目前为止的所有计算都是在表的所有数据或匹配特定的WHERE子句的数据上进行的。提示一下，下面的例子返回供应商1003提供的产品数目： 但如果要返回每个供应商提供的产品数目怎么办？或者返回只提供单项产品的供应商所提供的产品，或返回提供10个以上产品的供应商怎么办？这就是分组显身手的时候了。分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算。 13.2 创建分组分组是在SELECT语句的GROUP BY子句中建立的。理解分组的最好办法是看一个例子： 上面的SELECT语句指定了两个列， vend_id包含产品供应商的ID，num_prods为计算字段（用COUNT(*)函数建立）。 GROUP BY子句指示MySQL按vend_id排序并分组数据。这导致对每个vend_id而不是整个表计算num_prods一次。从输出中可以看到，供应商1001有3个产品，供应商1002有2个产品，供应商1003有7个产品，而供应商1005有2个产品。因为使用了GROUP BY，就不必指定要计算和估值的每个组了。系统会自动完成。 GROUP BY子句指示MySQL分组数据，然后对每个组而不是整个结果集进行聚集。在具体使用GROUP BY子句前，需要知道一些重要的规定。 GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。 如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。 GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。 除聚集计算语句外， SELECT语句中的每个列都必须在GROUP BY子句中给出。 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。 GROUP BY子句必须出现在WHERE子句之后， ORDER BY子句之前。使用ROLLUP 使用WITH ROLLUP关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值，如下所示： 13.3 过滤分组除了能用GROUP BY分组数据外， MySQL还允许过滤分组，规定包括哪些分组，排除哪些分组。例如，可能想要列出至少有两个订单的所有顾客。为得出这种数据，必须基于完整的分组而不是个别的行进行过滤。我们已经看到了WHERE子句的作用（第6章中引入）。但是，在这个例子中WHERE不能完成任务，因为WHERE过滤指定的是行而不是分组。事实上， WHERE没有分组的概念。那么，不使用WHERE使用什么呢？ MySQL为此目的提供了另外的子句，那就是HAVING子句。 HAVING非常类似于WHERE。事实上，目前为止所学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是WHERE过滤行，而HAVING过滤分组。HAVING支持所有WHERE操作符 在第6章和第7章中，我们学习了WHERE子句的条件（包括通配符条件和带多个操作符的子句）。所学过的有关WHERE的所有这些技术和选项都适用于HAVING。它们的句法是相同的，只是关键字有差别。那么，怎么过滤分组呢？请看以下的例子： 这条SELECT语句的前3行类似于上面的语句。最后一行增加了HAVING子句，它过滤COUNT(*) &gt;=2（两个以上的订单）的那些分组。正如所见，这里WHERE子句不起作用，因为过滤是基于分组聚集值而不是特定行值的。HAVING和WHERE的差别 这里有另一种理解方法，WHERE在数据分组前进行过滤， HAVING在数据分组后进行过滤。这是一个重要的区别， WHERE排除的行不包括在分组中。这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组。那么， 有没有在一条语句中同时使用WHERE和HAVING子句的需要呢？事实上，确实有。假如想进一步过滤上面的语句，使它返回过去12个月内具有两个以上订单的顾客。为达到这一点，可增加一条WHERE子句，过滤出过去12个月内下过的订单。然后再增加HAVING子句过滤出具有两个以上订单的分组。为更好地理解，请看下面的例子，它列出具有2个（含）以上、价格为10（含）以上的产品的供应商： 这条语句中，第一行是使用了聚集函数的基本SELECT，它与前面的例子很相像。 WHERE子句过滤所有prod_price至少为10的行。然后按vend_id分组数据， HAVING子句过滤计数为2或2以上的分组。如果没有WHERE子句，将会多检索出两行（供应商1002，销售的所有产品价格都在10以下；供应商1001，销售3个产品，但只有一个产品的价格大于等于10）: 13.4 分组和排序虽然GROUP BY和ORDER BY经常完成相同的工作，但它们是非常不同的。表13-1汇总了它们之间的差别。表13-1 ORDER BY与GROUP BY 表13-1中列出的第一项差别极为重要。我们经常发现用GROUP BY分组的数据确实是以分组顺序输出的。但情况并不总是这样，它并不是SQL规范所要求的。此外，用户也可能会要求以不同于分组的顺序排序。仅因为你以某种方式分组数据（获得特定的分组聚集值），并不表示你需要以相同的方式排序输出。应该提供明确的ORDER BY子句，即使其效果等同于GROUP BY子句也是如此。不要忘记ORDER BY 一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据。为说明GROUP BY和ORDER BY的使用方法，请看一个例子。下面的SELECT语句类似于前面那些例子。它检索总计订单价格大于等于50的订单的订单号和总计订单价格： 为按总计订单价格排序输出，需要添加ORDER BY子句，如下所示： 在这个例子中， GROUP BY子句用来按订单号（order_num列）分组数据，以便SUM(*)函数能够返回总计订单价格。 HAVING子句过滤数据，使得只返回总计订单价格大于等于50的订单。最后， 用ORDERBY子句排序输出。 13.5 SELECT子句顺序下面回顾一下SELECT语句中子句的顺序。表13-2以在SELECT语句中使用时必须遵循的次序，列出迄今为止所学过的子句。表13-2 SELECT子句及其顺序 13.6 小结在第12章中，我们学习了如何用SQL聚集函数对数据进行汇总计算。本章讲授了如何使用GROUP BY子句对数据组进行这些汇总计算，返回每个组的结果。我们看到了如何使用HAVING子句过滤特定的组，还知道了ORDER BY和GROUP BY之间以及WHERE和HAVING之间的差异。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第12章-汇总数据]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC12%E7%AB%A0-%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[第12章 汇总数据本章介绍什么是SQL的聚集函数以及如何利用它们汇总表的数据。 12.1 聚集函数我们经常需要汇总数据而不用把它们实际检索出来，为此MySQL提供了专门的函数。使用这些函数， MySQL查询可用于检索数据，以便分析和报表生成。这种类型的检索例子有以下几种。 确定表中行数（或者满足某个条件或包含某个特定值的行数）。 获得表中行组的和。 找出表列（或所有行或某些特定的行）的最大值、最小值和平均值。上述例子都需要对表中数据（而不是实际数据本身）汇总。因此，返回实际表数据是对时间和处理资源的一种浪费（更不用说带宽了）。重复一遍，实际想要的是汇总信息。为方便这种类型的检索， MySQL给出了5个聚集函数，见表12-1。这些函数能进行上述罗列的检索。聚集函数（ aggregate function） 运行在行组上，计算和返回单个值的函数。Snipaste_2018-04-13_18-54-18.png 以下说明各函数的使用。标准偏差 MySQL还支持一系列的标准偏差聚集函数，但本书并未涉及这些内容。 12.1.1 AVG()函数AVG()通过对表中行数计数并计算特定列值之和，求得该列的平均值。 AVG()可用来返回所有列的平均值，也可以用来返回特定列或行的平均值。下面的例子使用AVG()返回products表中所有产品的平均价格：Snipaste_2018-04-13_18-55-42.png 此SELECT语句返回值avg_Price，它包含products表中所有产品的平均价格。如第10章所述， avg_price是一个别名。AVG()也可以用来确定特定列或行的平均值。下面的例子返回特定供应商所提供产品的平均价格：Snipaste_2018-04-13_18-56-43.png 这条SELECT语句与前一条的不同之处在于它包含了WHERE子句。此WHERE子句仅过滤出vend_id为1003的产品，因此avg_price中返回的值只是该供应商的产品的平均值。只用于单个列 AVG()只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出。为了获得多个列的平均值，必须使用多个AVG()函数。NULL值 AVG()函数忽略列值为NULL的行。 12.1.2 COUNT()函数COUNT()函数进行计数。可利用COUNT()确定表中行的数目或符合特定条件的行的数目。COUNT()函数有两种使用方式。 使用COUNT(*)对表中行的数目进行计数， 不管表列中包含的是空值（NULL）还是非空值。 使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。下面的例子返回customers表中客户的总数：Snipaste_2018-04-13_18-58-57.png 在此例子中，利用COUNT(*)对所有行计数，不管行中各列有什么值。计数值在num_cust中返回。下面的例子只对具有电子邮件地址的客户计数：Snipaste_2018-04-13_19-00-39.png 这条SELECT语句使用COUNT(cust_email)对cust_email列中有值的行进行计数。在此例子中， cust_email的计数为3（表示5个客户中只有3个客户有电子邮件地址）。NULL值 如果指定列名，则指定列的值为空的行被COUNT()函数忽略，但如果COUNT()函数中用的是星号（ *），则不忽略。 12.1.3 MAX()函数MAX()返回指定列中的最大值。 MAX()要求指定列名，如下所示：Snipaste_2018-04-13_19-02-00.png 这里， MAX()返回products表中最贵的物品的价格。对非数值数据使用MAX() 虽然MAX()一般用来找出最大的数值或日期值，但MySQL允许将它用来返回任意列中的最大值，包括返回文本列中的最大值。在用于文本数据时，如果数据按相应的列排序，则MAX()返回最后一行。NULL值 MAX()函数忽略列值为NULL的行。 12.1.4 MIN()函数MIN()的功能正好与MAX()功能相反，它返回指定列的最小值。与MAX()一样， MIN()要求指定列名，如下所示：Snipaste_2018-04-13_19-03-15.png 其中MIN()返回products表中最便宜物品的价格。对非数值数据使用MIN() MIN()函数与MAX()函数类似，MySQL允许将它用来返回任意列中的最小值，包括返回文本列中的最小值。在用于文本数据时，如果数据按相应的列排序，则MIN()返回最前面的行。NULL值 MIN()函数忽略列值为NULL的行。 12.1.5 SUM()函数SUM()用来返回指定列值的和（总计）。下面举一个例子， orderitems表包含订单中实际的物品，每个物品有相应的数量（quantity）。可如下检索所订购物品的总数（所有quantity值之和）：Snipaste_2018-04-13_19-04-55.png 函数SUM(quantity)返回订单中所有物品数量之和， WHERE子句保证只统计某个物品订单中的物品。SUM()也可以用来合计计算值。在下面的例子中，合计每项物品的item_price*quantity，得出总的订单金额：Snipaste_2018-04-13_19-05-47.png 函数SUM(item_price*quantity)返回订单中所有物品价钱之和， WHERE子句同样保证只统计某个物品订单中的物品。在多个列上进行计算 如本例所示，利用标准的算术操作符，所有聚集函数都可用来执行多个列上的计算。NULL值 SUM()函数忽略列值为NULL的行。 12.2 聚集不同值MySQL 5 及 后 期 版 本 下 面 将 要 介 绍 的 聚 集 函 数 的DISTINCT的使用，已经被添加到MySQL 5.0.3中。下面所述内容在MySQL 4.x中不能正常运行。以上5个聚集函数都可以如下使用： 对所有的行执行计算，指定ALL参数或不给参数（因为ALL是默认行为）； 只包含不同的值，指定DISTINCT参数。ALL为默认 ALL参数不需要指定，因为它是默认行为。如果不指定DISTINCT，则假定为ALL。下面的例子使用AVG()函数返回特定供应商提供的产品的平均价格。它与上面的SELECT语句相同，但使用了DISTINCT参数，因此平均值只考虑各个不同的价格：Snipaste_2018-04-13_19-08-43.png 可以看到，在使用了DISTINCT后，此例子中的avg_price比较高，因为有多个物品具有相同的较低价格。排除它们提升了平均价格。注意 如果指定列名，则DISTINCT只能用于COUNT()。DISTINCT不能用于COUNT(*)，因此不允许使用COUNT（ DISTINCT），否则会产生错误。类似地， DISTINCT必须使用列名，不能用于计算或表达式。将DISTINCT用于MIN()和MAX() 虽然DISTINCT从技术上可用于MIN()和MAX()，但这样做实际上没有价值。一个列中的最小值和最大值不管是否包含不同值都是相同的。 12.3 组合聚集函数目前为止的所有聚集函数例子都只涉及单个函数。但实际上SELECT语句可根据需要包含多个聚集函数。请看下面的例子：Snipaste_2018-04-13_19-12-09.png 这里用单条SELECT语句执行了4个聚集计算，返回4个值（products表中物品的数目，产品价格的最高、最低以及平均值）。取别名 在指定别名以包含某个聚集函数的结果时，不应该使用表中实际的列名。虽然这样做并非不合法，但使用唯一的名字会使你的SQL更易于理解和使用（以及将来容易排除故障）。 12.4 小结聚集函数用来汇总数据。 MySQL支持一系列聚集函数，可以用多种方法使用它们以返回所需的结果。这些函数是高效设计的，它们返回结果一般比你在自己的客户机应用程序中计算要快得多。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第11章-使用数据处理函数]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC11%E7%AB%A0-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[第11章 使用数据处理函数本章介绍什么是函数， MySQL支持何种函数，以及如何使用这些函数。 11.1 函数与其他大多数计算机语言一样， SQL支持利用函数来处理数据。函数一般是在数据上执行的，它给数据的转换和处理提供了方便。在前一章中用来去掉串尾空格的RTrim()就是一个函数的例子。函数没有SQL的可移植性强 能运行在多个系统上的代码称为可移植的（ portable）。相对来说，多数SQL语句是可移植的，在SQL实现之间有差异时，这些差异通常不那么难处理。而函数的可移植性却不强。几乎每种主要的DBMS的实现都支持其他实现不支持的函数，而且有时差异还很大。为了代码的可移植，许多SQL程序员不赞成使用特殊实现的功能。虽然这样做很有好处，但不总是利于应用程序的性能。如果不使用这些函数，编写某些应用程序代码会很艰难。必须利用其他方法来实现DBMS非常有效地完成的工作。如果你决定使用函数，应该保证做好代码注释，以便以后你（或其他人）能确切地知道所编写SQL代码的含义。 11.2 使用函数大多数SQL实现支持以下类型的函数。 用于处理文本串（如删除或填充值，转换值为大写或小写）的文本函数。 用于在数值数据上进行算术操作（如返回绝对值，进行代数运算）的数值函数。 用于处理日期和时间值并从这些值中提取特定成分（例如，返回两个日期之差，检查日期有效性等）的日期和时间函数。 返回DBMS正使用的特殊信息（如返回用户登录信息，检查版本细节）的系统函数。 11.2.1 文本处理函数上一章中我们已经看过一个文本处理函数的例子，其中使用RTrim()函数来去除列值右边的空格。下面是另一个例子，这次使用Upper()函数： 正如所见， Upper()将文本转换为大写，因此本例子中每个供应商都列出两次，第一次为vendors表中存储的值，第二次作为列vend_name_upcase转换为大写。表11-1列出了某些常用的文本处理函数。 表11-1中的SOUNDEX需要做进一步的解释。 SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。 SOUNDEX考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。虽然SOUNDEX不是SQL概念，但MySQL（就像多数DBMS一样）都提供对SOUNDEX的支持。下面给出一个使用Soundex()函数的例子。 customers表中有一个顾客Coyote Inc.，其联系名为Y.Lee。但如果这是输入错误，此联系名实际应该是Y.Lie，怎么办？显然，按正确的联系名搜索不会返回数据，如下所示： 现在试一下使用Soundex()函数进行搜索，它匹配所有发音类似于Y.Lie的联系名： 在这个例子中， WHERE子句使用Soundex()函数来转换cust_contact列值和搜索串为它们的SOUNDEX值。因为Y.Lee和Y.Lie发音相似，所以它们的SOUNDEX值匹配，因此WHERE子句正确地过滤出了所需的数据。 11.2.2 日期和时间处理函数日期和时间采用相应的数据类型和特殊的格式存储，以便能快速和有效地排序或过滤，并且节省物理存储空间。一般，应用程序不使用用来存储日期和时间的格式，因此日期和时间函数总是被用来读取、统计和处理这些值。由于这个原因，日期和时间函数在MySQL语言中具有重要的作用。表11-2列出了某些常用的日期和时间处理函数。 迄今为止，我们都是用比较数值和文本的WHERE子句过滤数据，但数据经常需要用日期进行过滤。用日期进行过滤需要注意一些别的问题和使用特殊的MySQL函数。首先需要注意的是MySQL使用的日期格式。无论你什么时候指定一个日期，不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd。因此， 2005年9月1日，给出为2005-09-01。虽然其他的日期格式可能也行，但这是首选的日期格式，因为它排除了多义性（如，04/05/06是2006年5月4日或2006年4月5日或2004年5月6日或……）。应该总是使用4位数字的年份 支持2位数字的年份， MySQL处理00-69为2000-2069，处理70-99为1970-1999。虽然它们可能是打算要的年份，但使用完整的4位数字年份更可靠，因为MySQL不必做出任何假定。因此，基本的日期比较应该很简单：![pic](MySQL必知应会-第11章-使用数据处理函数/Snipaste_2018-04-13_18-40-50 此SELECT语句正常运行。它检索出一个订单记录，该订单记录的order_date为2005-09-01。但是，使用WHERE order_date = ‘2005-09-01’可靠吗？ order_date的数据类型为datetime。这种类型存储日期及时间值。样例表中的值全都具有时间值00:00:00，但实际中很可能并不总是这样。如果用当前日期和时间存储订单日期（因此你不仅知道订单日期，还知道下订单当天的时间），怎么办？比如， 存储的order_date 值 为2005-09-01 11:30:05，则WHERE order_date = ‘2005-09-01’失败。即使给出具有该日期的一行，也不会把它检索出来，因为WHERE匹配失败。解决办法是指示MySQL仅将给出的日期与列中的日期部分进行比较，而不是将给出的日期与整个列值进行比较。为此，必须使用Date()函数。 Date(order_date)指示MySQL仅提取列的日期部分，更可靠的SELECT语句为： 如果要的是日期，请使用Date() 如果你想要的仅是日期，则使用Date()是一个良好的习惯，即使你知道相应的列只包含日期也是如此。这样，如果由于某种原因表中以后有日期和时间值，你的SQL代码也不用改变。当然，也存在一个Time()函数，在你只想要时间时应该使用它。Date()和Time()都是在MySQL 4.1.1中第一次引入的。在你知道了如何用日期进行相等测试后，其他操作符（在第6章中介绍）的使用也就很清楚了。不过，还有一种日期比较需要说明。如果你想检索出2005年9月下的所有订单，怎么办？简单的相等测试不行，因为它也要匹配月份中的天数。有几种解决办法，其中之一如下所示： 其中， BETWEEN操作符用来把2005-09-01和2005-09-30定义为一个要匹配的日期范围。还有另外一种办法（一种不需要记住每个月中有多少天或不需要操心闰年2月的办法）： Year()是一个从日期（或日期时间）中返回年份的函数。类似，Month()从日期中返回月份。因此， WHERE Year(order_date) = 2005 AND Month(order_date) = 9检索出order_date为2005年9月的所有行。MySQL的版本差异 MySQL 4.1.1中增加了许多日期和时间函数。如果你使用的是更早的MySQL版本，应该查阅具体的文档以确定可以使用哪些函数。 11.2.3 数值处理函数数值处理函数仅处理数值数据。这些函数一般主要用于代数、三角或几何运算，因此没有串或日期—时间处理函数的使用那么频繁。具有讽刺意味的是，在主要DBMS的函数中，数值函数是最一致最统一的函数。表11-3列出一些常用的数值处理函数。 11.3 小结本章介绍了如何使用SQL的数据处理函数，并着重介绍了日期处理函数。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第10章-创建计算字段]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC10%E7%AB%A0-%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[第十章 创建计算字段本章介绍什么是计算字段，如何创建计算字段以及怎样从应用程序中使用别名引用它们。 10.1 计算字段存储在数据库表中的数据一般不是应用程序所需要的格式。下面举几个例子。 如果想在一个字段中既显示公司名，又显示公司的地址，但这两个信息一般包含在不同的表列中。 城市、州和邮政编码存储在不同的列中（应该这样），但邮件标签打印程序却需要把它们作为一个恰当格式的字段检索出来。 列数据是大小写混合的，但报表程序需要把所有数据按大写表示出来。 物品订单表存储物品的价格和数量，但不需要存储每个物品的总价格（用价格乘以数量即可）。为打印发票，需要物品的总价格。 需要根据表数据进行总数、平均数计算或其他计算。 在上述每个例子中，存储在表中的数据都不是应用程序所需要的。我们需要直接从数据库中检索出转换、计算或格式化过的数据；而不是检索出数据，然后再在客户机应用程序或报告程序中重新格式化。这就是计算字段发挥作用的所在了。与前面各章介绍过的列不同，计算字段并不实际存在于数据库表中。计算字段是运行时在SELECT语句内创建的。 字段（field） 基本上与列（ column） 的意思相同，经常互换使用，不过数据库列一般称为列，而术语字段通常用在计算字段的连接上。重要的是要注意到，只有数据库知道SELECT语句中哪些列是实际的表列，哪些列是计算字段。从客户机（如应用程序）的角度来看，计算字段的数据是以与其他列的数据相同的方式返回的。客户机与服务器的格式 可在SQL语句内完成的许多转换和格式化工作都可以直接在客户机应用程序内完成。但一般来说，在数据库服务器上完成这些操作比在客户机中完成要快得多，因为DBMS是设计来快速有效地完成这种处理的。 10.2 拼接字段为了说明如何使用计算字段，举一个创建由两列组成的标题的简单例子。vendors表包含供应商名和位置信息。假如要生成一个供应商报表，需要在供应商的名字中按照name(location)这样的格式列出供应商的位置。此报表需要单个值，而表中数据存储在两个列vend_name和vend_country中。此外，需要用括号将vend_country括起来，这些东西都没有明确存储在数据库表中。我们来看看怎样编写返回供应商名和位置的SELECT语句。拼接（concatenate） 将值联结到一起构成单个值。解决办法是把两个列拼接起来。在MySQL的SELECT语句中，可使用Concat()函数来拼接两个列。MySQL的不同之处 多数DBMS使用+或||来实现拼接，MySQL则使用Concat()函数来实现。当把SQL语句转换成MySQL语句时一定要把这个区别铭记在心。 Concat()拼接串，即把多个串连接起来形成一个较长的串。Concat()需要一个或多个指定的串，各个串之间用逗号分隔。上面的SELECT语句连接以下4个元素： 存储在vend_name列中的名字； 包含一个空格和一个左圆括号的串； 存储在vend_country列中的国家； 包含一个右圆括号的串。从上述输出中可以看到， SELECT语句返回包含上述4个元素的单个列（计算字段）。在第8章中曾提到通过删除数据右侧多余的空格来整理数据，这可以使用MySQL的RTrim()函数来完成，如下所示： RTrim()函数去掉值右边的所有空格。通过使用RTrim()，各个列都进行了整理。 Trim函数 MySQL除了支持RTrim()（正如刚才所见，它去掉串右边的空格），还支持LTrim()（去掉串左边的空格）以及Trim()（去掉串左右两边的空格）。 使用别名从前面的输出中可以看到， SELECT语句拼接地址字段工作得很好。但此新计算列的名字是什么呢？实际上它没有名字，它只是一个值。如果仅在SQL查询工具中查看一下结果，这样没有什么不好。但是，一个未命名的列不能用于客户机应用中，因为客户机没有办法引用它。为了解决这个问题， SQL支持列别名。 别名（ alias） 是一个字段或值的替换名。别名用AS关键字赋予。请看下面的SELECT语句： SELECT语句本身与以前使用的相同，只不过这里的语句中计算字段之后跟了文本AS vend_title。它指示SQL创建一个包含指定计算的名为vend_title的计算字段。从输出中可以看到，结果与以前的相同，但现在列名为vend_title，任何客户机应用都可以按名引用这个列，就像它是一个实际的表列一样。别名的其他用途 别名还有其他用途。常见的用途包括在实际的表列名包含不符合规定的字符（如空格）时重新命名它，在原来的名字含混或容易误解时扩充它，等等。导出列 别名有时也称为导出列（ derived column），不管称为什么，它们所代表的都是相同的东西。 10.3 执行算术计算计算字段的另一常见用途是对检索出的数据进行算术计算。举一个例子， orders表包含收到的所有订单， orderitems表包含每个订单中的各项物品。下面的SQL语句检索订单号20005中的所有物品： item_price列包含订单中每项物品的单价。如下汇总物品的价格（单价乘以订购数量）： 输出中显示的expanded_price列为一个计算字段，此计算为quantity*item_price。客户机应用现在可以使用这个新计算列，就像使用其他列一样。 MySQL支持表10-1中列出的基本算术操作符。此外，圆括号可用来区分优先顺序。关于优先顺序的介绍，请参阅第7章。 如何测试计算 SELECT提供了测试和试验函数与计算的一个很好的办法。虽然SELECT通常用来从表中检索数据，但可以省略FROM子句以便简单地访问和处理表达式。例如， SELECT 3*2;将返回6， SELECT Trim(‘abc’);将返回abc，而SELECT Now();利用Now()函数返回当前日期和时间。通过这些例子，可以明白如何根据需要使用SELECT进行试验。 10.4 小结本章介绍了计算字段以及如何创建计算字段。我们用例子说明了计算字段在串拼接和算术计算的用途。此外，还学习了如何创建和使用别名，以便应用程序能引用计算字段。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第9章-用正则表达式进行搜索]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC9%E7%AB%A0-%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[第九章 用正则表达式进行搜索本章将学习如何在MySQL WHERE子句内使用正则表达式来更好地控制数据过滤。 9.1 正则表达式介绍前两章中的过滤例子允许用匹配、比较和通配操作符寻找数据。对于基本的过滤(或者甚至是某些不那么基本的过滤)，这样就足够了。但随着过滤条件的复杂性的增加， WHERE子句本身的复杂性也有必要增加。这也就是正则表达式变得有用的地方。正则表达式是用来匹配文本的特殊的串(字符集合)。如果你想从一个文本文件中提取电话号码，可以使用正则表达式。如果你需要查找名字中间有数字的所有文件，可以使用一个正则表达式。如果你想在一个文本块中找到所有重复的单词，可以使用一个正则表达式。如果你想替换一个页面中的所有URL为这些URL的实际HTML链接， 也可以使用一个正则表达式(对于最后这个例子，或者是两个正则表达式)。所有种类的程序设计语言、文本编辑器、操作系统等都支持正则表达式。有见识的程序员和网络管理员已经关注作为他们技术工具重要内容的正则表达式很长时间了。正则表达式用正则表达式语言来建立，正则表达式语言是用来完成刚讨论的所有工作以及更多工作的一种特殊语言。与任意语言一样，正则表达式具有你必须学习的特殊的语法和指令。 学习更多内容 完全覆盖正则表达式的内容超出了本书的范围。虽然基础知识都在这里做了介绍，但对正则表达式更为透彻的介绍可能还需要参阅作者的《正则表达式必知必会》 9.2 使用MySQL正则表达式那么，正则表达式与MySQL有何关系？已经说过，正则表达式的作用是匹配文本，将一个模式(正则表达式)与一个文本串进行比较。MySQL用WHERE子句对正则表达式提供了初步的支持，允许你指定正则表达式，过滤SELECT检索出的数据。仅为正则表达式语言的一个子集 如果你熟悉正则表达式， 需要注意： MySQL仅支持多数正则表达式实现的一个很小的子集。本章介绍MySQL支持的大多数内容。我们举几个例子，更清晰地描述正则表达式的概念。 9.2.1 基本字符匹配我们从一个非常简单的例子开始。下面的语句检索列prod_name包含文本1000的所有行： 除关键字LIKE被REGEXP替代外，这条语句看上去非常像使用LIKE的语句(第8章)。它告诉MySQL： REGEXP后所跟的东西作为正则表达式(与文字正文1000匹配的一个正则表达式)处理。为什么要费力地使用正则表达式？在刚才的例子中，正则表达式确实没有带来太多好处(可能还会降低性能)，不过，请考虑下面的例子： 这里使用了正则表达式.000。 .是正则表达式语言中一个特殊的字符。它表示匹配任意一个字符，因此， 1000和2000都匹配且返回。当然，这个特殊的例子也可以用LIKE和通配符来完成(参阅第8章)。LIKE与REGEXP 在LIKE和REGEXP之间有一个重要的差别。请看以下两条语句： 如果执行上述两条语句，会发现第一条语句不返回数据，而第二条语句返回一行。为什么？正如第8章所述， LIKE匹配整个列。如果被匹配的文本在列值中出现， LIKE将不会找到它，相应的行也不被返回(除非使用通配符)。而REGEXP在列值内进行匹配，如果被匹配的文本在列值中出现， REGEXP将会找到它，相应的行将被返回。这是一个非常重要的差别。那么， REGEXP能不能用来匹配整个列值(从而起与LIKE相同的作用)？答案是肯定的，使用^和$定位符( anchor)即可，本章后面介绍。匹配不区分大小写 MySQL中的正则表达式匹配不区分大小写(即，大写和小写都匹配)。为区分大小写，可使用BINARY关键字，如WHERE prod_name REGEXP BINARY ‘JetPack .000’。 9.2.2 进行OR匹配为搜索两个串之一(或者为这个串，或者为另一个串)，使用|，如下所示： 语句中使用了正则表达式1000|2000。 |为正则表达式的OR操作符。它表示匹配其中之一，因此1000和2000都匹配并返回。使用|从功能上类似于在SELECT语句中使用OR语句， 多个OR条件可并入单个正则表达式。两个以上的OR条件 可以给出两个以上的OR条件。例如，’1000 | 2000 | 3000’将匹配1000或2000或3000。 9.2.3 匹配几个字符之一匹配任何单一字符。但是，如果你只想匹配特定的字符，怎么办？可通过指定一组用[和]括起来的字符来完成，如下所示： 这里，使用了正则表达式[123] Ton。 [123]定义一组字符，它的意思是匹配1或2或3，因此， 1 ton和2 ton都匹配且返回(没有3 ton)。正如所见， []是另一种形式的OR语句。 事实上，正则表达式[123]Ton为[1|2|3]Ton的缩写，也可以使用后者。但是，需要用[]来定义OR语句查找什么。为更好地理解这一点，请看下面的例子： 这并不是期望的输出。两个要求的行被检索出来，但还检索出了另外3行。之所以这样是由于MySQL假定你的意思是’1’或’2’或’3 ton’。除非把字符|括在一个集合中，否则它将应用于整个串。字符集合也可以被否定，即，它们将匹配除指定字符外的任何东西。为否定一个字符集，在集合的开始处放置一个^即可。因此，尽管[123]匹配字符1、 2或3，但123却匹配除这些字符外的任何东西。 9.2.4 匹配范围集合可用来定义要匹配的一个或多个字符。例如，下面的集合将匹配数字0到9：[0123456789]为简化这种类型的集合，可使用-来定义一个范围。下面的式子功能上等同于上述数字列表：[0-9]范围不限于完整的集合， [1-3]和[6-9]也是合法的范围。此外，范围不一定只是数值的， [a-z]匹配任意字母字符。举一个例子： 这里使用正则表达式[1-5] Ton。 [1-5]定义了一个范围，这个表达式意思是匹配1到5，因此返回3个匹配行。由于5 ton匹配，所以返回.5 ton。 9.2.5 匹配特殊字符正则表达式语言由具有特定含义的特殊字符构成。我们已经看到.、[]、|和-等，还有其他一些字符。请问，如果你需要匹配这些字符，应该怎么办呢？例如，如果要找出包含.字符的值，怎样搜索？请看下面的例子： 这并不是期望的输出， .匹配任意字符，因此每个行都被检索出来。为了匹配特殊字符，必须用\\为前导。\\-表示查找-， \\.表示查找.。 这才是期望的输出。 \\.匹配.，所以只检索出一行。这种处理就是所谓的转义(escaping)，正则表达式内具有特殊意义的所有字符都必须以这种方式转义。这包括.、 |、 []以及迄今为止使用过的其他特殊字符。\\也用来引用元字符(具有特殊含义的字符)，如表9-1所列。 匹配\ 为了匹配反斜杠( \\)字符本身，需要使用\\\。\或\\? 多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身。但MySQL要求两个反斜杠( MySQL自己解释一个，正则表达式库解释另一个)。 9.2.6 匹配字符类存在找出你自己经常使用的数字、所有字母字符或所有数字字母字符等的匹配。为更方便工作，可以使用预定义的字符集，称为字符类(character class)。表9-2列出字符类以及它们的含义。 9.2.7 匹配多个实例目前为止使用的所有正则表达式都试图匹配单次出现。如果存在一个匹配，该行被检索出来，如果不存在，检索不出任何行。但有时需要对匹配的数目进行更强的控制。例如，你可能需要寻找所有的数，不管数中包含多少数字，或者你可能想寻找一个单词并且还能够适应一个尾随的s(如果存在)，等等。这可以用表9-3列出的正则表达式重复元字符来完成。 下面举几个例子。 正则表达式\\([0-9] sticks?\\)需要解说一下。 \\(匹配)，[0-9]匹配任意数字(这个例子中为1和5)， sticks?匹配stick和sticks(s后的?使s可选，因为?匹配它前面的任何字符的0次或1次出现)， \\)匹配)。没有?，匹配stick和sticks会非常困难。以下是另一个例子。这次我们打算匹配连在一起的4位数字： 如前所述， [:digit:]匹配任意数字，因而它为数字的一个集合。 {4}确切地要求它前面的字符(任意数字)出现4次，所以[[:digit:]]{4}匹配连在一起的任意4位数字。需要注意的是，在使用正则表达式时，编写某个特殊的表达式几乎总是有不止一种方法。上面的例子也可以如下编写： 9.2.8 定位符目前为止的所有例子都是匹配一个串中任意位置的文本。为了匹配输入7760特定位置的文本，需要使用表9-4列出的定位符。 例如，如果你想找出以一个数(包括以小数点开始的数)开始的所有产品，怎么办？简单搜索[0-9\\.](或[[:digit:]\\.])不行，因为它将在文本内任意位置查找匹配。解决办法是使用^定位符，如下所示： ^匹配串的开始。因此， ^[0-9\\.]只在.或任意数字为串中第一个字符时才匹配它们。没有^， 则还要多检索出4个别的行(那些中间有数字的行)。 ^的双重用途 ^有两种用法。在集合中(用[和]定义)，用它来否定该集合，否则，用来指串的开始处。 使REGEXP起类似LIKE的作用 本章前面说过， LIKE和REGEXP的不同在于， LIKE匹配整个串而REGEXP匹配子串。利用定位符，通过用^开始每个表达式，用$结束每个表达式，可以使REGEXP的作用与LIKE一样。 简单的正则表达式测试 可以在不使用数据库表的情况下用SELECT来测试正则表达式。REGEXP检查总是返回0(没有匹配)或1(匹配)。可以用带文字串的REGEXP来测试表达式，并试验它们。相应的语法如下： 这个例子显然将返回0(因为文本hello中没有数字)。 9.3 小结本章介绍了正则表达式的基础知识，学习了如何在MySQL的SELECT语句中通过REGEXP关键字使用它们。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第8章-用通配符进行过滤]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC8%E7%AB%A0-%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4%2F</url>
    <content type="text"><![CDATA[第八章 用通配符进行过滤本章介绍什么是通配符、如何使用通配符以及怎样使用LIKE操作符进行通配搜索，以便对数据进行复杂过滤。 8.1 LIKE操作符前面介绍的所有操作符都是针对已知值进行过滤的。不管是匹配一个还是多个值，测试大于还是小于已知值，或者检查某个范围的值，共同点是过滤中使用的值都是已知的。但是，这种过滤方法并不是任何时候都好用。例如，怎样搜索产品名中包含文本anvil的所有产品？用简单的比较操作符肯定不行，必须使用通配符。利用通配符可创建比较特定数据的搜索模式。在这个例子中，如果你想找出名称包含anvil的所有产品，可构造一个通配符搜索模式，找出产品名中任何位置出现anvil的产品。通配符（wildcard） 用来匹配值的一部分的特殊字符。搜索模式（search pattern）由字面值、通配符或两者组合构成的搜索条件。通配符本身实际是SQL的WHERE子句中有特殊含义的字符， SQL支持几种通配符。为在搜索子句中使用通配符，必须使用LIKE操作符。 LIKE指示MySQL，后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。谓词 操作符何时不是操作符？答案是在它作为谓词（ predicate）时。从技术上说， LIKE是谓词而不是操作符。虽然最终的结果是相同的，但应该对此术语有所了解，以免在SQL文档中遇到此术语时不知道。 8.1.1 百分号（%）通配符最常使用的通配符是百分号（%）。在搜索串中， %表示任何字符出现任意次数。例如，为了找出所有以词jet起头的产品，可使用以下SELECT语句： 此例子使用了搜索模式’jet%’。在执行这条子句时，将检索任意以jet起头的词。 %告诉MySQL接受jet之后的任意字符，不管它有多少字符。区分大小写 根据MySQL的配置方式，搜索可以是区分大小写的。如果区分大小写， ‘jet%’与JetPack 1000将不匹配。通配符可在搜索模式中任意位置使用，并且可以使用多个通配符。下面的例子使用两个通配符，它们位于模式的两端： 用通配符进行过滤搜索模式’%anvil%’表示匹配任何位置包含文本anvil的值，而不论它之前或之后出现什么字符。通配符也可以出现在搜索模式的中间，虽然这样做不太有用。下面的例子找出以s起头以e结尾的所有产品： 重要的是要注意到，除了一个或多个字符外， %还能匹配0个字符。 %代表搜索模式中给定位置的0个、 1个或多个字符。注意尾空格 尾空格可能会干扰通配符匹配。例如，在保存词anvil 时 ， 如 果 它 后 面 有 一 个 或 多 个 空 格 ， 则 子 句 WHERE prod_name LIKE ‘%anvil’将不会匹配它们，因为在最后的l后有多余的字符。解决这个问题的一个简单的办法是在搜索模式最后附加一个%。一个更好的办法是使用函数（第11章将会介绍）去掉首尾空格。注意NULL 虽然似乎%通配符可以匹配任何东西，但有一个例外，即NULL。即使是WHERE prod_name LIKE ‘%’也不能匹配用值NULL作为产品名的行。 8.1.2 下划线（_）通配符另一个有用的通配符是下划线（_）。下划线的用途与%一样，但下划线只匹配单个字符而不是多个字符。举一个例子： 此WHERE子句中的搜索模式给出了后面跟有文本的两个通配符。结果只显示匹配搜索模式的行：第一行中下划线匹配1，第二行中匹配2。 .5 ton anvil产品没有匹配，因为搜索模式要求匹配两个通配符而不是一个。对照一下，下面的SELECT语句使用%通配符，返回三行产品： 与%能匹配0个字符不一样， _总是匹配一个字符，不能多也不能少。 8.2 使用通配符的技巧正如所见， MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧。 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数输出。总之，通配符是一种极重要和有用的搜索工具，以后我们经常会用到它。 8.3 小结本章介绍了什么是通配符以及如何在WHERE子句中使用SQL通配符，并且还说明了通配符应该细心使用，不要过度使用。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第7章-数据过滤]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC7%E7%AB%A0-%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%2F</url>
    <content type="text"><![CDATA[第七章 数据过滤本章讲授如何组合WHERE子句以建立功能更强的更高级的搜索条件。我们还将学习如何使用NOT和IN操作符。 7.1 组合WHERE子句第6章中介绍的所有WHERE子句在过滤数据时使用的都是单一的条件。为了进行更强的过滤控制， MySQL允许给出多个WHERE子句。这些子句可以两种方式使用：以AND子句的方式或OR子句的方式使用。操作符（operator） 用来联结或改变WHERE子句中的子句的关键字。也称为逻辑操作符（ logical operator） 。 7.1.1 AND操作符为了通过不止一个列进行过滤，可使用AND操作符给WHERE子句附加条件。下面的代码给出了一个例子： 此SQL语句检索由供应商1003制造且价格小于等于10美元的所有产品的名称和价格。这条SELECT语句中的WHERE子句包含两个条件，并且用AND关键字联结它们。 AND指示DBMS只返回满足所有给定条件的行。如果某个产品由供应商1003制造，但它的价格高于10美元，则不检索它。类似，如果产品价格小于10美元，但不是由指定供应商制造的也不被检索。AND 用在WHERE子句中的关键字，用来指示检索满足所有给定条件的行。上述例子中使用了只包含一个关键字AND的语句，把两个过滤条件组合在一起。还可以添加多个过滤条件，每添加一条就要使用一个AND。 7.1.2 OR操作符OR操作符与AND操作符不同，它指示MySQL检索匹配任一条件的行。请看如下的SELECT语句： 此SQL语句检索由任一个指定供应商制造的所有产品的产品名和价格。 OR操作符告诉DBMS匹配任一条件而不是同时匹配两个条件。如果这里使用的是AND操作符，则没有数据返回（此时创建的WHERE子句不会检索到匹配的产品）。OR WHERE子句中使用的关键字，用来表示检索匹配任一给定条件的行。 7.1.3 计算次序WHERE可包含任意数目的AND和OR操作符。允许两者结合以进行复杂和高级的过滤。但是，组合AND和OR带来了一个有趣的问题。为了说明这个问题，来看一个例子。假如需要列出价格为10美元（含）以上且由1002或1003制造的所有产品。下面的SELECT语句使用AND和OR操作符的组合建立了一个WHERE子句： 返回的行中有两行价格小于10美元，显然，返回的行未按预期的进行过滤。为什么会这样呢？原因在于计算的次序。 SQL（像多数语言一样）在处理OR操作符前，优先处理AND操作符。当SQL看到上述WHERE子句时，它理解为由供应商1003制造的任何价格为10美元（含）以上的产品，或者由供应商1002制造的任何产品，而不管其价格如何。换句话说，由于AND在计算次序中优先级更高，操作符被错误地组合了。此问题的解决方法是使用圆括号明确地分组相应的操作符。请看下面的SELECT语句及输出： 这条SELECT语句与前一条的唯一差别是，这条语句中，前两个条件用圆括号括了起来。因为圆括号具有较AND或OR操作符高的计算次序， DBMS首先过滤圆括号内的OR条件。这时， SQL语句变成了选择由供应商1002或1003制造的且价格都在10美元（含）以上的任何产品，这正是我们所希望的。在WHERE子句中使用圆括号 任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确地分组操作符。不要过分依赖默认计算次序，即使它确实是你想要的东西也是如此。使用圆括号没有什么坏处，它能消除歧义。 7.2 IN 操作符圆括号在WHERE子句中还有另外一种用法。 IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。 IN取合法值的由逗号分隔的清单，全都括在圆括号中。下面的例子说明了这个操作符： 此SELECT语句检索供应商1002和1003制造的所有产品。 IN操作符后跟由逗号分隔的合法值清单，整个清单必须括在圆括号中。如果你认为IN操作符完成与OR相同的功能，那么你的这种猜测是对的。下面的SQL语句完成与上面的例子相同的工作： 为什么要使用IN操作符？其优点具体如下。 在使用长的合法选项清单时， IN操作符的语法更清楚且更直观。 在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。 IN操作符一般比OR操作符清单执行更快。 IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。 IN WHERE子句中用来指定要匹配值的清单的关键字，功能与OR相当。 7.3 NOT操作符WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所跟的任何条件。NOT WHERE子句中用来否定后跟条件的关键字。下面的例子说明NOT的使用。为了列出除1002和1003之外的所有供应商制造的产品，可编写如下的代码： 这里的NOT否定跟在它之后的条件，因此， MySQL不是匹配1002和 1003 的 vend_id ， 而 是 匹 配 1002 和 1003 之 外 供 应 商 的vend_id。为什么使用NOT？对于简单的WHERE子句，使用NOT确实没有什么优势。但在更复杂的子句中， NOT是非常有用的。例如，在与IN操作符联合使用时， NOT使找出与条件列表不匹配的行非常简单。MySQL中的 NOT MySQL 支 持 使 用 NOT 对 IN 、 BETWEEN 和EXISTS子句取反，这与多数其他DBMS允许使用NOT对各种条件取反有很大的差别。 7.4 小结本章讲授如何用AND和OR操作符组合成WHERE子句，而且还讲授了如何明确地管理计算的次序，如何使用IN和NOT操作符。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第6章-过滤数据]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC6%E7%AB%A0-%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[第六章 过滤数据本章将讲授如何使用SELECT语句的WHERE子句指定搜索条件。 6.1 使用WHERE子句数据库表一般包含大量的数据，很少需要检索表中所有行。通常只会根据特定操作或报告的需要提取表数据的子集。只检索所需数据需要指定搜索条件（ search criteria） ，搜索条件也称为过滤条件（ filtercondition） 。在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤。WHERE子句在表名（FROM子句）之后给出，如下所示： 这条语句从products表中检索两个列，但不返回所有行，只返回prod_price值为2.50的行。这个例子采用了简单的相等测试：它检查一个列是否具有指定的值，据此进行过滤。但是SQL允许做的事情不仅仅是相等测试。 过滤与应用过滤 数据也可以在应用层过滤。为此目的， SQL的SELECT语句为客户机应用检索出超过实际所需的数据，然后客户机代码对返回数据进行循环，以提取出需要的行。通常，这种实现并不令人满意。因此，对数据库进行了优化，以便快速有效地对数据进行过滤。让客户机应用（或开发语言）处理数据库的工作将会极大地影响应用的性能，并且使所创建的应用完全不具备可伸缩性。此外，如果在客户机上过滤数据，服务器不得不通过网络发送多余的数据，这将导致网络带宽的浪费。 WHERE子句的位置 在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后， 否则将会产生错误。 6.2 WHERE子句操作符我们在关于相等的测试时看到了第一个WHERE子句，它确定一个列是否包含特定的值。 MySQL支持表6-1列出的所有条件操作符。 6.2.1 检查单个值我们已经看到了测试相等的例子。再来看一个类似的例子： 检查WHERE prod_name=‘fuses’语句，它返回prod_name的值为Fuses的一行。 MySQL在执行匹配时默认不区分大小写，所以fuses与Fuses匹配。现在来看几个使用其他操作符的例子。第一个例子是列出价格小于10美元的所有产品： 下一条语句检索价格小于等于10美元的所有产品（输出的结果比第一个例子输出的结果多两种产品）： 6.2.2 不匹配检查以下例子列出不是由供应商1003制造的所有产品： 何时使用引号 如果仔细观察上述WHERE子句中使用的条件，会看到有的值括在单引号内（如前面使用的’fuses’），而有的值未括起来。单引号用来限定字符串。如果将值与串类型的列进行比较，则需要限定引号。用来与数值列进行比较的值不用引号。 下面是相同的例子，其中使用!=而不是&lt;&gt;操作符： 6.2.3 范围值检查为了检查某个范围的值，可使用BETWEEN操作符。其语法与其他WHERE子句的操作符稍有不同，因为它需要两个值，即范围的开始值和结束值。例如， BETWEEN操作符可用来检索价格在5美元和10美元之间或日期在指定的开始日期和结束日期之间的所有产品。下面的例子说明如何使用BETWEEN操作符，它检索价格在5美元和10美元之间的所有产品： 从这个例子中可以看到，在使用BETWEEN时，必须指定两个值——所需范围的低端值和高端值。这两个值必须用AND关键字分隔。 BETWEEN匹配范围中所有的值，包括指定的开始值和结束值。 6.2.4 空值检查在创建表时，表设计人员可以指定其中的列是否可以不包含值。在一个列不包含值时，称其为包含空值NULL。NULL 无值（no value），它与字段包含0、空字符串或仅仅包含空格不同。SELECT语句有一个特殊的WHERE子句，可用来检查具有NULL值的列。这个WHERE子句就是IS NULL子句。其语法如下： 这条语句返回没有价格（空prod_price字段，不是价格为0）的所有产品，由于表中没有这样的行，所以没有返回数据。但是， customers表确实包含有具有空值的列，如果在文件中没有某位顾客的电子邮件地分析则cust_email列将包含NULL值： NULL与不匹配 在通过过滤选择出不具有特定值的行时，你可能希望返回具有NULL值的行。但是，不行。因为未知具有特殊的含义，数据库不知道它们是否匹配，所以在匹配过滤或不匹配过滤时不返回它们。因此，在过滤数据时，一定要验证返回数据中确实给出了被过滤列具有NULL的行。 6.3 小结本章介绍了如何用SELECT语句的WHERE子句过滤返回的数据。我们学习了如何对相等、不相等、大于、小于、值的范围以及NULL值等进行测试。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第5章-排序检索数据]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC5%E7%AB%A0-%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[第五章 排序检索数据本章将讲授如何使用SELECT语句的ORDER BY子句，根据需要排序检索出的数据。 5.1 排序数据正如前一章所述，下面的SQL语句返回某个数据库表的单个列。但请看其输出，并没有特定的顺序。 其实，检索出的数据并不是以纯粹的随机顺序显示的。如果不排序，数据一般将以它在底层表中出现的顺序显示。这可以是数据最初添加到表中的顺序。但是，如果数据后来进行过更新或删除，则此顺序将会受到MySQL重用回收存储空间的影响。因此，如果不明确控制的话，不能(也不应该)依赖该排序顺序。关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义。 子句(clause) SQL语句由子句构成，有些子句是必需的，而有的是可选的。一个子句通常由一个关键字和所提供的数据组成。子句的例子有SELECT语句的FROM子句，我们在前一章看到过这个子句。为了明确地排序用SELECT语句检索出的数据，可使用ORDER BY子句。ORDER BY子句取一个或多个列的名字，据此对输出进行排序。请看下面的例子： 这条语句除了指示MySQL对prod_name列以字母顺序排序数据的ORDER BY子句外，与前面的语句相同。通过非选择列进行排序 通常， ORDER BY子句中使用的列将是为显示所选择的列。但是，实际上并不一定要这样，用非检索的列排序数据是完全合法的。 5.2 按多个列排序经常需要按不止一个列进行数据排序。例如，如果要显示雇员清单，可能希望按姓和名排序（首先按姓排序，然后在每个姓中再按名排序）。如果多个雇员具有相同的姓，这样做很有用。为了按多个列排序，只要指定列名，列名之间用逗号分开即可（就像选择多个列时所做的那样）。下面的代码检索3个列，并按其中两个列对结果进行排序——首先按价格，然后再按名称排序。 重要的是理解在按多个列排序时，排序完全按所规定的顺序进行。换句话说，对于上述例子中的输出，仅在多个行具有相同的prod_price值时才对产品按prod_name进行排序。如果prod_price列中所有的值都是唯一的，则不会按prod_name排序。 5.3 指定排序方向数据排序不限于升序排序（从A到Z）。这只是默认的排序顺序，还可以使用ORDER BY子句以降序（从Z到A）顺序排序。为了进行降序排序，必须指定DESC关键字。下面的例子按价格以降序排序产品（最贵的排在最前面）： 但是，如果打算用多个列排序怎么办？下面的例子以降序排序产品（最贵的在最前面），然后再对产品名排序： DESC关键字只应用到直接位于其前面的列名。在上例中，只对prod_price列指定 DESC，对 prod_name列不指定。因此，prod_price列以降序排序，而prod_name列（在每个价格内）仍然按标准的升序排序。在多个列上降序排序 如果想在多个列上进行降序排序， 必须对每个列指定DESC关键字。与DESC相反的关键字是ASC（ASCENDING），在升序排序时可以指定它。但实际上， ASC没有多大用处，因为升序是默认的（如果既不指定ASC也不指定DESC，则假定为ASC）。区分大小写和排序顺序 在对文本性的数据进行排序时， A与a相同吗？ a位于B之前还是位于Z之后？这些问题不是理论问题，其答案取决于数据库如何设置。在字典（ dictionary）排序顺序中，A被视为与a相同，这是MySQL（和大多数数据库管理系统）的默认行为。但是，许多数据库管理员能够在需要时改变这种行为（如果你的数据库包含大量外语字符，可能必须这样做）。这里，关键的问题是，如果确实需要改变这种排序顺序，用简单的ORDER BY子句做不到。你必须请求数据库管理员的帮助。使用ORDER BY和LIMIT的组合，能够找出一个列中最高或最低的值。下面的例子演示如何找出最昂贵物品的值： prod_price DESC保证行是按照由最昂贵到最便宜检索的，而LIMIT 1告诉MySQL仅返回一行。ORDER BY子句的位置 在给出ORDER BY子句时，应该保证它位于FROM子句之后。如果使用LIMIT，它必须位于ORDER BY之后。使用子句的次序不对将产生错误消息。 5.4 小结本章学习了如何用SELECT语句的ORDER BY子句对检索出的数据进行排序。这个子句必须是SELECT语句中的最后一条子句。可根据需要，利用它在一个或多个列上对数据进行排序。分析]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第4章-检索数据]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC4%E7%AB%A0-%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[第四章 检索数据本章将介绍如何使用SELECT语句从表中检索一个或多个数据列。 4.1 SELECT语句正如第1章所述， SQL语句是由简单的英语单词构成的。这些单词称为关键字，每个SQL语句都是由一个或多个关键字构成的。大概，最经常使用的SQL语句就是SELECT语句了。它的用途是从一个或多个表中检索信息。为了使用SELECT检索表数据，必须至少给出两条信息——想选择什么，以及从什么地方选择。 4.2 检索单个列我们将从简单的SQL SELECT语句开始介绍，此语句如下所示： 上述语句利用 SELECT语句从 products表中检索一个名为prod_name的列。所需的列名在SELECT关键字之后给出， FROM关键字指出从其中检索数据的表名。 未排序数据 如果读者自己试验这个查询，可能会发现显示输出的数据顺序不同。出现这种情况很正常。如果没有明确排序查询结果，则返回的数据的顺序没有特殊意义。返回数据的顺序可能是数据被添加到表中的顺序，也可能不是。只要返回相同数目的行，就是正常的。如上的一条简单SELECT语句将返回表中所有行。数据没有过滤(过滤将得出结果集的一个子集)， 也没有排序。 结束SQL语句 多条SQL语句必须以分号(；)分隔。 MySQL如同多数DBMS一样，不需要在单条SQL语句后加分号。但特定的DBMS可能必须在单条SQL语句后加上分号。当然，如果愿意可以总是加上分号。事实上，即使不一定需要，但加上分号肯定没有坏处。如果你使用的是mysql命令行，必须加上分号来结束SQL语句。 SQL语句和大小写 请注意， SQL语句不区分大小写，因此SELECT与select是相同的。同样，写成Select也没有关系。许多SQL开发人员喜欢对所有SQL关键字使用大写，而对所有列和表名使用小写，这样做使代码更易于阅读和调试。不过，一定要认识到虽然SQL是不区分大小写的，但有些标识符(如数据库名、表名、列名)可能不同：最佳方式是按照大小写的惯例，且使用时保持一致。 使用空格 在处理SQL语句时，其中所有空格都被忽略。 SQL语句可以在一行上给出，也可以分成许多行。多数SQL开发人员认为将SQL语句分成多行更容易阅读和调试。 4.3 检索多个列要想从一个表中检索多个列，使用相同的SELECT语句。唯一的不同是必须在SELECT关键字后给出多个列名，列名之间必须以逗号分隔。当心逗号 在选择多个列时，一定要在列名之间加上逗号，但最后一个列名后不加。如果在最后一个列名后加了逗号，将出现错误。 下面的SELECT语句从products表中选择3列： 与前一个例子一样，这条语句使用SELECT语句从表products中选择数据。在这个例子中，指定了3个列名，列名之间用逗号分隔。 数据表示 从上述输出可以看到， SQL语句一般返回原始的、无格式的数据。数据的格式化是一个表示问题，而不是一个检索问题。因此，表示(对齐和显示上面的价格值，用货币符号和逗号表示其金额)一般在显示该数据的应用程序中规定。一般很少使用实际检索出的原始数据(没有应用程序提供的格式)。 4.4 检索所有列除了指定所需的列外(如上所述，一个或多个列)， SELECT语句还可以检索所有的列而不必逐个列出它们。这可以通过在实际列名的位置使用星号(*)通配符来达到，如下所示： 如果给定一个通配符(*)，则返回表中所有列。列的顺序一般是列在表定义中出现的顺序。但有时候并不是这样的，表的模式的变化(如添加或删除列)可能会导致顺序的变化。使用通配符 一般，除非你确实需要表中的每个列，否则最好别使用*通配符。虽然使用通配符可能会使你自己省事，不用明确列出所需列，但检索不需要的列通常会降低检索和应用程序的性能。 检索未知列 使用通配符有一个大优点。由于不明确指定列名(因为星号检索每个列)，所以能检索出名字未知的列。 4.5 检索不同的行正如所见， SELECT返回所有匹配的行。但是，如果你不想要每个值每次都出现，怎么办？例如，假如你想得出products表中产品的所有供应商ID： SELECT语句返回14行(即使表中只有4个供应商)，因为products表中列出了14个产品。那么，如何检索出有不同值的列表呢？解决办法是使用DISTINCT关键字，顾名思义，此关键字指示MySQL只返回不同的值。 SELECT DISTINCT vend_id告诉MySQL只返回不同(唯一)的vend_id行，因此只返回4行。如果使用DISTINCT关键字，它必须直接放在列名的前面。 不能部分使用DISTINCT, DISTINCT关键字应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT vend_id,prod_price，除非指定的两个列都不同，否则所有行都将被检索出来。 4.6 限制结果SELECT语句返回所有匹配的行，它们可能是指定表中的每个行。为了返回第一行或前几行，可使用LIMIT子句。下面举一个例子： 此语句使用SELECT语句检索单个列。 LIMIT 5指示MySQL返回不多于5行。为得出下一个5行，可指定要检索的开始行和行数，如下所示：LIMIT 5, 5指示MySQL返回从行5开始的5行。第一个数为开始位置，第二个数为要检索的行数。 所以， 带一个值的LIMIT总是从第一行开始，给出的数为返回的行数。带两个值的LIMIT可以指定从行号为第一个值的位置开始。行0 检索出来的第一行为行0而不是行1。因此， LIMIT 1, 1将检索出第二行而不是第一行。在行数不够时 LIMIT中指定要检索的行数为检索的最大行数。如果没有足够的行(例如，给出LIMIT 10, 5，但只有13行)， MySQL将只返回它能返回的那么多行。MySQL 5的LIMIT语法 LIMIT 3, 4的含义是从行4开始的3行还是从行3开始的4行？如前所述，它的意思是从行3开始的4行，这容易把人搞糊涂。由于这个原因， MySQL 5支持LIMIT的另一种替代语法。 LIMIT4 OFFSET 3意为从行3开始取4行，就像LIMIT 3, 4一样。 4.7 使用完全限定的表名迄今为止使用的SQL例子只通过列名引用列。也可能会使用完全限定的名字来引用列(同时使用表名和列字)。请看以下例子： 这条SQL语句在功能上等于本章最开始使用的那一条语句，但这里指定了一个完全限定的列名。表名也可以是完全限定的，如下所示： 这条语句在功能上也等于刚使用的那条语句(当然，假定products表确实位于crashcourse数据库中)。正如以后章节所介绍的那样，有一些情形需要完全限定名。现在，需要注意这个语法，以便在遇到时知道它的作用。 4.8 小结本章学习了如何使用SQL的SELECT语句来检索单个表列、多个表列以及所有表列。下一章将讲授如何排序检索出来的数据。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第3章-使用MySQL]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC3%E7%AB%A0-%E4%BD%BF%E7%94%A8MySQL%2F</url>
    <content type="text"><![CDATA[第三章 使用MySQL本章将学习如何连接和登录到MySQL，如何执行MySQL语句，以及如何获得数据库和表的信息。 3.1 连接在具有可供使用的MySQL DBMS和客户机软件之后，有必要简要讨论一下如何连接到数据库。MySQL与所有客户机—服务器DBMS一样，要求在能执行命令之前登录到DBMS。MySQL在内部保存自己的用户列表，并且把每个用户与各种权限关联起来。在最初安装MySQL时，很可能会要求你输入一个管理登录(通常为root)和一个口令。如果你使用的是自己的本地服务器，并且是简单地试验一下MySQL，使用上述登录就可以了。但现实中，管理登录受到密切保护(因为对它的访问授予了创建表、删除整个数据库、更改登录和口令等完全的权限)。使用MySQL Administrator MySQL Administrator Users视图提供了一个简单的界面，可用来定义新用户，包括赋予口令和访问权限。 为了连接到MySQL，需要以下信息： 主机名(计算机名)——如果连接到本地MySQL服务器， 为localhost； 端口(如果使用默认端口3306之外的端口)； 一个合法的用户名； 用户口令（如果需要）。所有这些信息都可以传递给mysql命令行实用程序，或输入到MySQL Administrator和MySQL Query Browser的服务器连接屏幕。在连接之后，你就可以访问你的登录名能够访问的任意数据库和表了。 3.2 选择数据库在你最初连接到MySQL时，没有任何数据库打开供你使用。在你能执行任意数据库操作前，需要选择一个数据库。为此，可使用USE关键字。关键字(key word) 作为MySQL语言组成部分的一个保留字。决不要用关键字命名一个表或列。例如，为了使用crashcourse数据库，应该输入以下内容： USE语句并不返回任何结果。依赖于使用的客户机，显示某种形式的通知。例如，这里显示出的Database changed消息是mysql命令行实用程序在数据库选择成功后显示的。使用MySQL Query Browser 在MySQL Query Browser中，双击Schemata列表中列出的任一数据库以使用它。你看不到USE命令的实际执行，但会看到被选择的数据库（黑体加亮），而且应用标题栏将显示所选择的数据库名。记住，必须先使用USE打开数据库，才能读取其中的数据。 3.3 了解数据库和表如果你不知道可以使用的数据库名时怎么办？这时 ， MySQLAdministrator和MySQL Query Browser怎样能显示可用的数据库列表？数据库、表、列、用户、权限等的信息被存储在数据库和表中（MySQL使用MySQL来存储这些信息）。不过，内部的表一般不直接访问。可用MySQL的SHOW命令来显示这些信息（MySQL从内部表中提取这些信息）。请看下面的例子： SHOW DATABASES;返回可用数据库的一个列表。包含在这个列表中的可能是MySQL内部使用的数据库（如例子中的mysql和information_schema）。 为了获得一个数据库内的表的列表，使用SHOW TABLES; 如下所示： SHOW TABLES;返回当前选择的数据库内可用表的列表。SHOW也可以用来显示表列：输出SHOW COLUMNS 要 求 给 出 一 个 表 名 （ 这 个 例 子 中 的 FROM customers），它对每个字段返回一行，行中包含字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息（如字段cust_id的auto_increment）。 什么是自动增量？ 某些表列需要唯一值。在每个行添加到表中时， MySQL可以自动地为每个行分配下一个可用编号，不用在添加一行时手动分配唯一值（这样做必须记住最后一次使用的值）。这个功能就是所谓的自动增量。如果需要它，则必须在用CREATE语句创建表时把它作为表定义的组成部分。 DESCRIBE语句 MySQL支持用DESCRIBE作为SHOW COLUMNSFROM的一种快捷方式。换句话说， DESCRIBE customers;是SHOW COLUMNS FROM customers;的一种快捷方式。 所支持的其他SHOW语句还有： SHOW STATUS，用于显示广泛的服务器状态信息； SHOW CREATE DATABASE和SHOW CREATE TABLE，分别用来显示创建特定数据库或表的MySQL语句； SHOW GRANTS，用来显示授予用户（所有用户或特定用户）的安全权限； SHOW ERRORS和SHOW WARNINGS， 用来显示服务器错误或警告消息。 值得注意的是，客户机应用程序使用与这里相同的MySQL命令。显示数据库和表的交互式列表、允许交互式创建和编辑表、便于数据录入和编辑或允许管理用户账号和权限等的应用全都使用你可以直接执行的相同的MySQL命令完成它们的工作。进一步了解SHOW 请在mysql命令行实用程序中，执行命令HELP SHOW;显示允许的SHOW语句。 MySQL 5 的 新 增 内 容 MySQL 5 支 持 一 个 新 的 INFORMATION_SCHEMA命令，可用它来获得和过滤模式信息。 3.4 小结本章介绍了如何连接和登录MySQL，如何用USE选择数据库，如何用SHOW查看MySQL数据库、表和内部信息。在这些知识的帮助下，我们可以进一步深入学习所有重要的SELECT语句了。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第2章-MySQL简介]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC2%E7%AB%A0-MySQL%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[第二章 MySQL简介本章将介绍什么是MySQL，以及在MySQL中可以应用什么工具。 2.1 什么是MySQL正如所述，数据的所有存储、检索、管理和处理实际上是由数据库软件——DBMS(数据库管理系统)完成的。MySQL是一种DBMS，即它是一种数据库软件。使用MySQL的原因： 成本——MySQL是开放源代码的，一般可以免费使用(甚至可以免费修改)。 性能——MySQL执行很快(非常快)。 可信赖——某些非常重要和声望很高的公司、站点使用MySQL，这些公司和站点都用MySQL来处理自己的重要数据。 简单——MySQL很容易安装和使用。 2.1.1 客户机—服务器软件DBMS可分为两类： 一类为基于共享文件系统的DBMS，(包括诸如Microsoft Access和FileMaker)用于桌面用途，通常不用于高端或更关键的应用。 另一类为基于客户机—服务器的DBMS，MySQL、 Oracle以及Microsoft SQL Server等数据库是基于客户机—服务器的数据库。 客户机—服务器应用分为两个不同的部分。 服务器部分是负责所有数据访问和处理的一个软件。这个软件运行在称为数据库服务器的计算机上。与数据文件打交道的只有服务器软件。关于数据、数据添加、删除和数据更新的所有请求都由服务器软件完成。这些请求或更改来自运行客户机软件的计算机。 客户机是与用户打交道的软件。例如，如果你请求一个按字母顺序列出的产品表，则客户机软件通过网络提交该请求给服务器软件。服务器软件处理这个请求，根据需要过滤、丢弃和排序数据；然后把结果送回到你的客户机软件。 客户机和服务器软件可能安装在两台计算机或一台计算机上。不管它们在不在相同的计算机上，为进行所有数据库交互，客户机软件都要与服务器软件进行通信。所有这些活动对用户都是透明的。数据存储在别的地方，或者数据库服务器为你完成这个处理这一事实是隐藏的。你不需要直接访问数据文件。事实上，多数网络的建立使用户不具有对数据的访问权，甚至不具有对存储数据的驱动器的访问权。这样的意义何在？因为为了使用MySQL，你需要访问运行MySQL服务器软件的计算机和发布命令到MySQL的客户机软件的计算机。 服务器软件为MySQL DBMS。你可以在本地安装的副本上运行，也可以连接到运行在你具有访问权的远程服务器上的一个副本。 客户机可以是MySQL提供的工具、脚本语言(如Perl)、 Web应用开发语言(如ASP、 ColdFusion、 JSP和PHP)、程序设计语言(如C、 C++、 Java)等。 安装mysql-linux 2.1.2 MySQL版本MySQL的当前版本为版本5版本要求说明，如果某章针对具体某个MySQL版本，则将在该章开始处明确说明。 2.2 MySQL工具MySQL是一个客户机—服务器DBMS，因此，为了使用MySQL，需要有一个客户机，即你需要用来与MySQL打交道(给MySQL提供要执行的命令)的一个应用。有许多客户机应用可供选择，但在学习MySQL(确切地说，在编写和测试MySQL脚本时)，最好是使用专门用途的实用程序。特别是有3个工具需要提及。 2.2.1 mysql命令行实用程序每个MySQL安装都有一个名为mysql的简单命令行实用程序。MySQL选项和参数 如果仅输入mysql， 可能会出现一个错误消息。因为可能需要安全证书，或者是因为MySQL没有运行在本地或默认端口上。 mysql接受你可以(和可能需要)使用的一组命令行参数。例如，为了指定用户登录名ben，应该使用mysql -u ben。为了给出用户名、主机名、端口和口令，应该使用mysql -u ben -p -h myserver -P 9999。完整的命令行选项和参数列表可用mysql —help获得。 在操作系统命令提示符下输入mysql将出现一个如下的简单提示： 当然，具体的版本和连接信息可能不同，但都可以使用这个实用程序。请注意： 命令输入在mysql&gt;之后； 命令用;或\g结束，换句话说，仅按Enter不执行命令； 输入help或\h获得帮助，也可以输入更多的文本获得特定命令的帮助(如，输入help select获得使用SELECT语句的帮助)； 输入quit或exit退出命令行实用程序。 mysql命令行实用程序是使用最多的实用程序之一，它对于快速测试和执行脚本非常有价值。 熟悉mysql命令行实用程序 即使你选择使用后面描述的某个图形工具，也应该保证熟悉mysql命令行实用程序，因为它是你可以安全地依靠的一个总是会被给出的客户机(因为它是核心MySQL安装的一部分)。 2.2.2 MySQL AdministratorMySQL Administrator(MySQL管理器)是一个图形交互客户机，用来简化MySQL服务器的管理。MySQL Administrator不作为核心MySQL 的 组 成 部 分 安 装 。必须从链接下载。在Ubuntu下安装 MySQL Administrator提示输入服务器和登录信息(并且允许你保存服务器定义供以后选择)，然后显示允许选择不同视图的图标。其中： Server Information(服务器信息)显示客户机和被连接的服务器的状态和版本信息； Service Control(服务控制)允许停止和启动MySQL以及指定服务器特性； User Administration(用户管理)用来定义MySQL用户、登录和权限； Catalogs(目录)列出可用的数据库并允许创建数据库和表。 MySQL Administrator工具菜单包含有启动mysql命令行实用程序和MySQL Query Browser( MySQL查询浏览器)的选项。MySQL Query Browser也包含启动mysql命令行实用程序和MySQL Administrator的菜单选项。 2.2.3 MySQL Query BrowserMySQL Query Browser为一个图形交互客户机，用来编写和执行MySQL命令。获得MySQL Query Browser 与MySQL Administrator一样，MySQL Query Browser不作为核心MySQL安装的成分。必须从链接下载。 MySQL Query Browser要求输入服务器和登录信息(在MySQL QueryBrowser和MySQL Administrator之间共享保存的定义)，然后显示应用界面。注意下面几点。 输入MySQL命令到屏幕顶上的窗口中。在输入语句后，单击Execute按钮把它提交给MySQL处理。 结果(如果有)显示在屏幕左边的大区域网格中。 多条语句和结果显示在它们自己的标签中，并且允许快速切换。 屏幕右边是一个标签，它列出所有可能的数据源(这里称为大纲)，展开任一数据源查看它的表，展开任一个表查看它的列。 你还可以选择表和列让MySQL Query Browser为你编写MySQL语句。 Schemata(大纲)标签的右边是一个History(历史)标签，它保持MySQL语句的执行历史。在需要测试不同版本的MySQL语句时，它非常有用。 关于MySQL语法、函数等的帮助可在屏幕右下角得到。 执行保存的脚本 可用MySQL Query Browser执行保存的脚本(如用来创建和填充本书中使用的表的脚本)。为执行保存的脚本，请选择File, Open Script，选择相应的脚本(它将显示在一个新标签中)，然后单击Execute按钮。 2.3 小结本章介绍了什么是MySQL，并引入了几个客户机实用程序(一个命20 令行实用程序，两个可选但强烈建议使用的图形实用程序)。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第1章-了解SQL]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC1%E7%AB%A0-%E4%BA%86%E8%A7%A3SQL%2F</url>
    <content type="text"><![CDATA[第一章 了解SQL本章将介绍数据库和SQL，它们是学习MySQL的先决条件。 1.1 数据库基础1.1.1 什么是数据库数据库是一个以某种有组织的方式存储的数据集合。数据库(database)保存有组织的数据的容器(通常是一个文件或一组文件)。数据库软件应称为DBMS(数据库管理系统)。数据库是通过DBMS创建和操纵的容器。数据库可以是保存在硬设备上的文件，但也可以不是。在很大程度上说，数据库究竟是文件还是别的什么东西并不重要，因为你并不直接访问数据库；你使用的是DBMS，它替你访问数据库。 1.1.2 表表是一种结构化的文件，可用来存储某种特定类型的数据。表(table) 某种特定类型数据的结构化清单。数据库中的每个表都有一个名字，用来标识自己。此名字是唯一的，这表示数据库中没有其他表具有相同的名字。表名的唯一性取决于多个因素，如数据库名和表名等的结合。表具有一些特性，这些特性定义了数据在表中如何存储，如可以存储什么样的数据，数据如何分解，各部分信息如何命名，等等。描述表的这组信息就是所谓的模式，模式可以用来描述数据库中特定的表以及整个数据库(和其中表的关系)。模式(schema) 关于数据库和表的布局及特性的信息。 1.1.3 列和数据类型表由列组成。列中存储着表中某部分的信息。列(column) 表中的一个字段。所有表都是由一个或多个列组成的。 SQL数据库中每个列都有相应的数据类型。数据类型定义列可以存储的数据种类。数据类型(datatype) 所容许的数据的类型。每个表列都有相应的数据类型，它限制(或容许)该列中存储的数据。数据类型限制可存储在列中的数据种类(例如，防止在数值字段中录入字符值)。数据类型还帮助正确地排序数据，并在优化磁盘使用方面起重要的作用。 1.1.4 行表中的数据是按行存储的，所保存的每个记录存储在自己的行内。如果将表想象为网格，网格中垂直的列为表列，水平行为表行。表中的行数为记录的总数。行(row) 表中的一个记录。 1.1.5 主键表中每一行都应该有可以唯一标识自己的一列(或一组列)。主键(primary key) 一列(或一组列)，其值能够唯一区分表中每个行。唯一标识表中每行的这个列(或这组列)称为主键。主键用来表示一个特定的行。大多数数据库设计人员都应保证他们创建的每个表具有一个主键，以便于以后的数据操纵和管理。表中的任何列都可以作为主键，只要它满足以下条件： 任意两行都不具有相同的主键值； 每个行都必须具有一个主键值(主键列不允许NULL值)。这里列出的规则是MySQL本身强制实施的。 主键通常定义在表的一列上，但这并不是必需的，也可以一起使用多个列作为主键。在使用多列作为主键时，上述条件必须应用到构成主键的所有列，所有列值的组合必须是唯一的(但单个列的值可以不唯一)。 主键的最好习惯除MySQL强制实施的规则外，应该坚持的几个普遍认可的最好习惯为： 不更新主键列中的值； 不重用主键列的值； 不在主键列中使用可能会更改的值。(例如，如果使用一个名字作为主键以标识某个供应商，当该供应商合并和更改其名字时，必须更改这个主键。) 还有一种非常重要的键，称为外键，我们将在第15章中介绍。 1.2 什么是SQLSQL(发音为字母S-Q-L或sequel)是结构化查询语言(Structured QueryLanguage)的缩写。 SQL是一种专门用来与数据库通信的语言。设计SQL的目的是很好地完成一项任务，即提供一种从数据库中读写数据的简单有效的方法。SQL有如下的优点： SQL不是某个特定数据库供应商专有的语言。几乎所有重要的DBMS都支持SQL。 SQL简单易学。它的语句全都是由描述性很强的英语单词组成，而且这些单词的数目不多。 SQL尽管看上去很简单，但它实际上是一种强有力的语言，灵活使用其语言元素，可以进行非常复杂和高级的数据库操作。 DBMS专用的SQLSQL不是一种专利语言，而且存在一个标准委员会，他们试图定义可供所有DBMS使用的SQL语法，但事实上任意两个DBMS实现的SQL都不完全相同。本书QL是专门针对MySQL的。 1.3 动手实践本书所有章节都采用可上机运行的例子来说明SQL语法，它的功能是什么，为什么起这样的作用。作者强烈建议读者试验每个例子，以便掌握MySQL的第一手资料。 1.4 小结这一章介绍了什么是SQL以及它为什么很有用。因为SQL是用来与数据库打交道的，所以，我们也复习了一些基本的数据库术语。]]></content>
      <categories>
        <category>mysql</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第11章-识别手写数字]]></title>
    <url>%2F2018%2F04%2F12%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC11%E7%AB%A0-%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[第11章 识别手写体数字 27111.1 手写体识别 27111.2 用scikit-learn识别手写体数字 27111.3 Digits数据集 27211.4 学习和预测 27411.5 小结 276 12from sklearn import svmsvc = svm.SVC(gamma=0.001, C=100.) 123from sklearn import datasetsdigits = datasets.load_digits() 1digits.images[0] array([[ 0., 0., 5., 13., 9., 1., 0., 0.], [ 0., 0., 13., 15., 10., 15., 5., 0.], [ 0., 3., 15., 2., 0., 11., 8., 0.], [ 0., 4., 12., 0., 0., 8., 8., 0.], [ 0., 5., 8., 0., 0., 9., 8., 0.], [ 0., 4., 11., 0., 1., 12., 7., 0.], [ 0., 2., 14., 5., 10., 12., 0., 0.], [ 0., 0., 6., 13., 10., 0., 0., 0.]]) 1digits.target.size 1797 1digits.target array([0, 1, 2, ..., 8, 9, 8]) 1234import matplotlib.pyplot as plt%matplotlib inlineplt.imshow(digits.images[0], cmap=plt.cm.gray_r, interpolation='nearest') &lt;matplotlib.image.AxesImage at 0x16657400&gt; 1svc.fit(digits.data[1:1790], digits.target[1:1790]) SVC(C=100.0, cache_size=200, class_weight=None, coef0=0.0, degree=3, gamma=0.001, kernel=&#39;rbf&#39;, max_iter=-1, probability=False, random_state=None, shrinking=True, tol=0.001, verbose=False) 123456789101112131415import matplotlib.pyplot as plt%matplotlib inlineplt.subplot(321)plt.imshow(digits.images[1791], cmap=plt.cm.gray_r, interpolation='nearest')plt.subplot(322)plt.imshow(digits.images[1792], cmap=plt.cm.gray_r, interpolation='nearest')plt.subplot(323)plt.imshow(digits.images[1793], cmap=plt.cm.gray_r, interpolation='nearest')plt.subplot(324)plt.imshow(digits.images[1794], cmap=plt.cm.gray_r, interpolation='nearest')plt.subplot(325)plt.imshow(digits.images[1795], cmap=plt.cm.gray_r, interpolation='nearest')plt.subplot(326)plt.imshow(digits.images[1796], cmap=plt.cm.gray_r, interpolation='nearest') &lt;matplotlib.image.AxesImage at 0x175e6b00&gt; 1svc.predict(digits.data[1791:1976]) array([4, 9, 0, 8, 9, 8]) 1digits.target[1791:1976] array([4, 9, 0, 8, 9, 8])]]></content>
      <categories>
        <category>python</category>
        <category>机器学习</category>
        <category>sklearn</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>手写字体</tag>
        <tag>SVC</tag>
        <tag>SVM</tag>
        <tag>sklearn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第10章-ipythonNotebook内嵌JavaScript库D3]]></title>
    <url>%2F2018%2F04%2F12%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC10%E7%AB%A0-ipythonNotebook%E5%86%85%E5%B5%8CJavaScript%E5%BA%93D3%2F</url>
    <content type="text"><![CDATA[第10章 IPython Notebook内嵌JavaScript库D3 25210.1 开放的人口数据源 25210.2 JavaScript库D3 25510.3 绘制簇状条状图 25910.4 地区分布图 26210.5 2014年美国人口地区分布图 26610.6 小结 270 123456789101112131415import numpy as npimport pandas as pdimport matplotlib.pyplot as plt%matplotlib inline# from urllib.request import urlopen# pop2014 = pd.read_csv(# urlopen('http://www.census.gov/popest/data/counties/totals/2014/files/CO-EST2014-alldata.csv'),# encoding='latin-1',# dtype=&#123;'STATE': 'str', 'COUNTY': 'str'&#125;# )pop2014 = pd.read_csv('CO-EST2014-alldata.csv',encoding='latin-1',dtype=&#123;'STATE': 'str', 'COUNTY': 'str'&#125;)print(pop2014.shape)print(pop2014.columns) (3193, 84) Index([&#39;SUMLEV&#39;, &#39;REGION&#39;, &#39;DIVISION&#39;, &#39;STATE&#39;, &#39;COUNTY&#39;, &#39;STNAME&#39;, &#39;CTYNAME&#39;, &#39;CENSUS2010POP&#39;, &#39;ESTIMATESBASE2010&#39;, &#39;POPESTIMATE2010&#39;, &#39;POPESTIMATE2011&#39;, &#39;POPESTIMATE2012&#39;, &#39;POPESTIMATE2013&#39;, &#39;POPESTIMATE2014&#39;, &#39;NPOPCHG_2010&#39;, &#39;NPOPCHG_2011&#39;, &#39;NPOPCHG_2012&#39;, &#39;NPOPCHG_2013&#39;, &#39;NPOPCHG_2014&#39;, &#39;BIRTHS2010&#39;, &#39;BIRTHS2011&#39;, &#39;BIRTHS2012&#39;, &#39;BIRTHS2013&#39;, &#39;BIRTHS2014&#39;, &#39;DEATHS2010&#39;, &#39;DEATHS2011&#39;, &#39;DEATHS2012&#39;, &#39;DEATHS2013&#39;, &#39;DEATHS2014&#39;, &#39;NATURALINC2010&#39;, &#39;NATURALINC2011&#39;, &#39;NATURALINC2012&#39;, &#39;NATURALINC2013&#39;, &#39;NATURALINC2014&#39;, &#39;INTERNATIONALMIG2010&#39;, &#39;INTERNATIONALMIG2011&#39;, &#39;INTERNATIONALMIG2012&#39;, &#39;INTERNATIONALMIG2013&#39;, &#39;INTERNATIONALMIG2014&#39;, &#39;DOMESTICMIG2010&#39;, &#39;DOMESTICMIG2011&#39;, &#39;DOMESTICMIG2012&#39;, &#39;DOMESTICMIG2013&#39;, &#39;DOMESTICMIG2014&#39;, &#39;NETMIG2010&#39;, &#39;NETMIG2011&#39;, &#39;NETMIG2012&#39;, &#39;NETMIG2013&#39;, &#39;NETMIG2014&#39;, &#39;RESIDUAL2010&#39;, &#39;RESIDUAL2011&#39;, &#39;RESIDUAL2012&#39;, &#39;RESIDUAL2013&#39;, &#39;RESIDUAL2014&#39;, &#39;GQESTIMATESBASE2010&#39;, &#39;GQESTIMATES2010&#39;, &#39;GQESTIMATES2011&#39;, &#39;GQESTIMATES2012&#39;, &#39;GQESTIMATES2013&#39;, &#39;GQESTIMATES2014&#39;, &#39;RBIRTH2011&#39;, &#39;RBIRTH2012&#39;, &#39;RBIRTH2013&#39;, &#39;RBIRTH2014&#39;, &#39;RDEATH2011&#39;, &#39;RDEATH2012&#39;, &#39;RDEATH2013&#39;, &#39;RDEATH2014&#39;, &#39;RNATURALINC2011&#39;, &#39;RNATURALINC2012&#39;, &#39;RNATURALINC2013&#39;, &#39;RNATURALINC2014&#39;, &#39;RINTERNATIONALMIG2011&#39;, &#39;RINTERNATIONALMIG2012&#39;, &#39;RINTERNATIONALMIG2013&#39;, &#39;RINTERNATIONALMIG2014&#39;, &#39;RDOMESTICMIG2011&#39;, &#39;RDOMESTICMIG2012&#39;, &#39;RDOMESTICMIG2013&#39;, &#39;RDOMESTICMIG2014&#39;, &#39;RNETMIG2011&#39;, &#39;RNETMIG2012&#39;, &#39;RNETMIG2013&#39;, &#39;RNETMIG2014&#39;], dtype=&#39;object&#39;) 12pop2014_by_state = pop2014[pop2014.SUMLEV == 40]pop2014_by_state.shape (51, 84) 12states = pop2014_by_state[['STNAME','POPESTIMATE2011', 'POPESTIMATE2012', 'POPESTIMATE2013','POPESTIMATE2014']] 12temp = states.sort_values(['POPESTIMATE2014'], ascending=False)[:5]print(temp) STNAME POPESTIMATE2011 POPESTIMATE2012 POPESTIMATE2013 \ 190 California 37701901 38062780 38431393 2566 Texas 25657477 26094422 26505637 329 Florida 19107900 19355257 19600311 1860 New York 19521745 19607140 19695680 608 Illinois 12858725 12873763 12890552 POPESTIMATE2014 190 38802500 2566 26956958 329 19893297 1860 19746227 608 12880580 123456%%javascriptrequire.config(&#123;paths: &#123;d3: '//cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min'&#125;&#125;); &lt;IPython.core.display.Javascript object&gt; 1234567891011121314151617181920212223from IPython.core.display import display, Javascript, HTMLdisplay(HTML("""&lt;style&gt;.bar &#123;fill: steelblue;&#125;.bar:hover&#123;fill: brown;&#125;.axis &#123;font: 10px sans-serif;&#125;.axis path,.axis line &#123;fill: none;stroke: #000;&#125;.x.axis path &#123;display: none;&#125;&lt;/style&gt;&lt;div id="chart_d3" /&gt;""")) .bar {fill: steelblue;}.bar:hover{fill: brown;}.axis {font: 10px sans-serif;}.axis path,.axis line {fill: none;stroke: #000;}.x.axis path {display: none;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import jinja2myTemplate = jinja2.Template("""require(["d3"], function(d3)&#123;var data = []&#123;% for row in data %&#125;data.push(&#123; 'state': '&#123;&#123; row[1] &#125;&#125;', 'population': &#123;&#123; row[5] &#125;&#125; &#125;);&#123;% endfor %&#125;d3.select("#chart_d3 svg").remove()var margin = &#123;top: 20, right: 20, bottom: 30, left: 40&#125;,width = 800 - margin.left - margin.right,height = 400 - margin.top - margin.bottom;var x = d3.scale.ordinal().rangeRoundBands([0, width], .25);var y = d3.scale.linear().range([height, 0]);var xAxis = d3.svg.axis().scale(x).orient("bottom");var yAxis = d3.svg.axis().scale(y).orient("left").ticks(10).tickFormat(d3.format('.1s'));var svg = d3.select("#chart_d3").append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");x.domain(data.map(function(d) &#123; return d.state; &#125;));y.domain([0, d3.max(data, function(d) &#123; return d.population; &#125;)]);svg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);svg.append("g").attr("class", "y axis").call(yAxis).append("text").attr("transform", "rotate(-90)").attr("y", 6).attr("dy", ".71em").style("text-anchor", "end").text("Population");svg.selectAll(".bar").data(data).enter().append("rect").attr("class", "bar").attr("x", function(d) &#123; return x(d.state); &#125;).attr("width", x.rangeBand()).attr("y", function(d) &#123; return y(d.population); &#125;).attr("height", function(d) &#123; return height - y(d.population); &#125;);&#125;);"""); 123display(Javascript(myTemplate.render(data=states.sort_values(['POPESTIMATE2012'], ascending=False)[:10].itertuples()))) &lt;IPython.core.display.Javascript object&gt; 12345678910111213141516171819202122232425262728display(HTML("""&lt;style&gt;.bar2011 &#123;fill: steelblue;&#125;.bar2012 &#123;fill: red;&#125;.bar2013 &#123;fill: yellow;&#125;.bar2014 &#123;fill: green;&#125;.axis &#123;font: 10px sans-serif;&#125;.axis path,.axis line &#123;fill: none;stroke: #000;&#125;.x.axis path &#123;display: none;&#125;&lt;/style&gt;&lt;div id="chart_d3" /&gt;""")) .bar2011 {fill: steelblue;}.bar2012 {fill: red;}.bar2013 {fill: yellow;}.bar2014 {fill: green;}.axis {font: 10px sans-serif;}.axis path,.axis line {fill: none;stroke: #000;}.x.axis path {display: none;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import jinja2myTemplate = jinja2.Template("""require(["d3"], function(d3)&#123;var data = []var data2 = []var data3 = []var data4 = []&#123;% for row in data %&#125;data.push(&#123; 'state': '&#123;&#123; row[1] &#125;&#125;', 'population': &#123;&#123; row[2] &#125;&#125; &#125;);data2.push(&#123; 'state': '&#123;&#123; row[1] &#125;&#125;', 'population': &#123;&#123; row[3] &#125;&#125; &#125;);data3.push(&#123; 'state': '&#123;&#123; row[1] &#125;&#125;', 'population': &#123;&#123; row[4] &#125;&#125; &#125;);data4.push(&#123; 'state': '&#123;&#123; row[1] &#125;&#125;', 'population': &#123;&#123; row[5] &#125;&#125; &#125;);&#123;% endfor %&#125;d3.select("#chart_d3 svg").remove()var margin = &#123;top: 20, right: 20, bottom: 30, left: 40&#125;,width = 800 - margin.left - margin.right,height = 400 - margin.top - margin.bottom;var x = d3.scale.ordinal().rangeRoundBands([0, width], .25);var y = d3.scale.linear().range([height, 0]);var xAxis = d3.svg.axis().scale(x).orient("bottom");var yAxis = d3.svg.axis().scale(y).orient("left").ticks(10).tickFormat(d3.format('.1s'));var svg = d3.select("#chart_d3").append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");x.domain(data.map(function(d) &#123; return d.state; &#125;));y.domain([0, d3.max(data, function(d) &#123; return d.population; &#125;)]);svg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);svg.append("g").attr("class", "y axis").call(yAxis).append("text").attr("transform", "rotate(-90)").attr("y", 6).attr("dy", ".71em").style("text-anchor", "end").text("Population");svg.selectAll(".bar2011").data(data).enter().append("rect").attr("class", "bar2011").attr("x", function(d) &#123; return x(d.state); &#125;).attr("width", x.rangeBand()/4).attr("y", function(d) &#123; return y(d.population); &#125;).attr("height", function(d) &#123; return height - y(d.population); &#125;);svg.selectAll(".bar2012").data(data2).enter().append("rect").attr("class", "bar2012").attr("x", function(d) &#123; return (x(d.state)+x.rangeBand()/4); &#125;).attr("width", x.rangeBand()/4).attr("y", function(d) &#123; return y(d.population); &#125;).attr("height", function(d) &#123; return height - y(d.population); &#125;);svg.selectAll(".bar2013").data(data3).enter().append("rect").attr("class", "bar2013").attr("x", function(d) &#123; return (x(d.state)+2*x.rangeBand()/4); &#125;).attr("width", x.rangeBand()/4).attr("y", function(d) &#123; return y(d.population); &#125;).attr("height", function(d) &#123; return height - y(d.population); &#125;);svg.selectAll(".bar2014").data(data4).enter().append("rect").attr("class", "bar2014").attr("x", function(d) &#123; return (x(d.state)+3*x.rangeBand()/4); &#125;).attr("width", x.rangeBand()/4).attr("y", function(d) &#123; return y(d.population); &#125;).attr("height", function(d) &#123; return height - y(d.population); &#125;);&#125;);"""); 123display(Javascript(myTemplate.render(data=states.sort_values(['POPESTIMATE2014'], ascending=False)[:5].itertuples()))) &lt;IPython.core.display.Javascript object&gt; 12345678%%javascriptrequire.config(&#123;paths: &#123;d3: '//cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min',queue: '//cdnjs.cloudflare.com/ajax/libs/queue-async/1.0.7/queue.min',topojson: '//cdnjs.cloudflare.com/ajax/libs/topojson/1.6.19/topojson.min'&#125;&#125;); &lt;IPython.core.display.Javascript object&gt; 1234567891011121314151617181920212223from IPython.core.display import display, Javascript, HTMLdisplay(HTML("""&lt;style&gt;.counties &#123;fill: none;&#125;.states &#123;fill: none;stroke: #fff;stroke-linejoin: round;&#125;.q0-9 &#123; fill:rgb(247,251,255); &#125;.q1-9 &#123; fill:rgb(222,235,247); &#125;.q2-9 &#123; fill:rgb(198,219,239); &#125;.q3-9 &#123; fill:rgb(158,202,225); &#125;.q4-9 &#123; fill:rgb(107,174,214); &#125;.q5-9 &#123; fill:rgb(66,146,198); &#125;.q6-9 &#123; fill:rgb(33,113,181); &#125;.q7-9 &#123; fill:rgb(8,81,156); &#125;.q8-9 &#123; fill:rgb(8,48,107); &#125;&lt;/style&gt;&lt;div id="choropleth" /&gt;""")) .counties {fill: none;}.states {fill: none;stroke: #fff;stroke-linejoin: round;}.q0-9 { fill:rgb(247,251,255); }.q1-9 { fill:rgb(222,235,247); }.q2-9 { fill:rgb(198,219,239); }.q3-9 { fill:rgb(158,202,225); }.q4-9 { fill:rgb(107,174,214); }.q5-9 { fill:rgb(66,146,198); }.q6-9 { fill:rgb(33,113,181); }.q7-9 { fill:rgb(8,81,156); }.q8-9 { fill:rgb(8,48,107); } 12345678910111213141516171819202122232425262728293031323334353637383940414243import jinja2choropleth = jinja2.Template("""require(["d3","queue","topojson"], function(d3,queue,topojson)&#123;// var data = []// &#123;% for row in data %&#125;// data.push(&#123; 'state': '&#123;&#123; row[1] &#125;&#125;', 'population': &#123;&#123; row[2] &#125;&#125; &#125;);// &#123;% endfor %&#125;d3.select("#choropleth svg").remove()var width = 960,height = 600;var rateById = d3.map();ar quantize = d3.scale.quantize().domain([0, .15]).range(d3.range(9).map(function(i) &#123; return "q" + i + "-9"; &#125;));var projection = d3.geo.albersUsa().scale(1280).translate([width / 2, height / 2]);var path = d3.geo.path().projection(projection);//row to modifyvar svg = d3.select("#choropleth").append("svg").attr("width", width).attr("height", height);queue().defer(d3.json, "us.json").defer(d3.tsv, "unemployment.tsv", function(d) &#123; rateById.set(d.id, +d.rate); &#125;).await(ready);function ready(error, us) &#123;if (error) throw error;svg.append("g").attr("class", "counties").selectAll("path").data(topojson.feature(us, us.objects.counties).features).enter().append("path").attr("class", function(d) &#123; return quantize(rateById.get(d.id)); &#125;).attr("d", path);svg.append("path").datum(topojson.mesh(us, us.objects.states, function(a, b) &#123; return a !== b; &#125;)).attr("class", "states").attr("d", path);&#125;&#125;);"""); 1display(Javascript(choropleth.render())) &lt;IPython.core.display.Javascript object&gt; 12pop2014_by_county = pop2014[pop2014.SUMLEV == 50]pop2014_by_county.shape (3142, 84) 123# USJSONnames = pd.read_table(urlopen('http://bl.ocks.org/mbostock/raw/4090846/us-countynames.tsv'))USJSONnames = pd.read_table('world-country-names.tsv')USJSONnames.shape (252, 2)]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
        <tag>javascript-D3</tag>
        <tag>jinja2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第9章-数据分析实例气象数据]]></title>
    <url>%2F2018%2F04%2F12%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC9%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E4%BE%8B%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[第9章 数据分析实例——气象数据 2309.1 待检验的假设：靠海对气候的影响 2309.2 数据源 2339.3 用IPython Notebook做数据分析 2349.4 风向频率玫瑰图 2469.5 小结 251 123import numpy as npimport pandas as pdimport datetime 1ferrara = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Ferrara,IT') 1torino = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Torino,IT') 1mantova = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Mantova,IT') 1milano = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Milano,IT') 1ravenna = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Ravenna,IT') 1asti = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Asti,IT') 1bologna = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Bologna,IT') 1piacenza = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Piacenza,IT') 1cesena = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Cesena,IT') 1faenza = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Faenza,IT') 1234567891011121314151617181920212223def prepare(city_list,city_name): temp = [ ] humidity = [ ] pressure = [ ] description = [ ] dt = [ ] wind_speed = [ ] wind_deg = [ ] for row in city_list: temp.append(row['main']['temp']-273.15) humidity.append(row['main']['humidity']) pressure.append(row['main']['pressure']) description.append(row['weather'][0]['description']) dt.append(row['dt']) wind_speed.append(row['wind']['speed']) wind_deg.append(row['wind']['deg']) headings = ['temp','humidity','pressure','description','dt','wind_speed','wind_deg'] data = [temp,humidity,pressure,description,dt,wind_speed,wind_deg] df = pd.DataFrame(data,index=headings) city = df.T city['city'] = city_name city['day'] = city['dt'].apply(datetime.datetime.fromtimestamp) return city 1234567891011df_ferrara = prepare(ferrara.list,'Ferrara')df_milano = prepare(milano.list,'Milano')df_mantova = prepare(mantova.list,'Mantova')df_ravenna = prepare(ravenna.list,'Ravenna')df_torino = prepare(torino.list,'Torino')#df_alessandria = prepare(alessandria.list,'Alessandria')df_asti = prepare(asti.list,'Asti')df_bologna = prepare(bologna.list,'Bologna')df_piacenza = prepare(piacenza.list,'Piacenza')df_cesena = prepare(cesena.list,'Cesena')df_faenza = prepare(faenza.list,'Faenza') 12345678910print df_ferrara.shapeprint df_milano.shapeprint df_mantova.shapeprint df_ravenna.shapeprint df_torino.shapeprint df_asti.shapeprint df_bologna.shapeprint df_piacenza.shapeprint df_cesena.shapeprint df_faenza.shape (24, 9) (24, 9) (24, 9) (24, 9) (24, 9) (24, 9) (24, 9) (24, 9) (24, 9) (24, 9) 123456789101112#http://it.thetimenow.com/distance-calculator.php#(Comacchio)df_ravenna['dist'] = 8df_cesena['dist'] = 14df_faenza['dist'] = 37df_ferrara['dist'] = 47df_bologna['dist'] = 71df_mantova['dist'] = 121 df_piacenza['dist'] = 200df_milano['dist'] = 250df_asti['dist'] = 315df_torino['dist'] = 357 123456789101112131415161718192021import pandas as pd#df_ferrara.to_csv('ferrara_270615.csv')#df_milano.to_csv('milano_270615.csv')#df_mantova.to_csv('mantova_270615.csv')#df_ravenna.to_csv('ravenna_270615.csv')#df_torino.to_csv('torino_270615.csv')#df_asti.to_csv('asti_270615.csv')#df_bologna.to_csv('bologna_270615.csv')#df_piacenza.to_csv('piacenza_270615.csv')#df_cesena.to_csv('cesena_270615.csv')#df_faenza.to_csv('faenza_270615.csv')df_ferrara = pd.read_csv('ferrara_270615.csv')df_milano = pd.read_csv('milano_270615.csv')df_mantova = pd.read_csv('mantova_270615.csv')df_ravenna = pd.read_csv('ravenna_270615.csv')df_torino = pd.read_csv('torino_270615.csv')df_asti = pd.read_csv('asti_270615.csv')df_bologna = pd.read_csv('bologna_270615.csv')df_piacenza = pd.read_csv('piacenza_270615.csv')df_cesena = pd.read_csv('cesena_270615.csv')df_faenza = pd.read_csv('faenza_270615.csv') 1df_cesena.columns Index([&#39;Unnamed: 0&#39;, &#39;temp&#39;, &#39;humidity&#39;, &#39;pressure&#39;, &#39;description&#39;, &#39;dt&#39;, &#39;wind_speed&#39;, &#39;wind_deg&#39;, &#39;city&#39;, &#39;day&#39;, &#39;dist&#39;], dtype=&#39;object&#39;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455dist = [df_ravenna['dist'][0], df_cesena['dist'][0], df_faenza['dist'][0], df_ferrara['dist'][0], df_bologna['dist'][0], df_mantova['dist'][0], df_piacenza['dist'][0], df_milano['dist'][0], df_asti['dist'][0], df_torino['dist'][0]]temp_max = [df_ravenna['temp'].max(), df_cesena['temp'].max(), df_faenza['temp'].max(), df_ferrara['temp'].max(), df_bologna['temp'].max(), df_mantova['temp'].max(), df_piacenza['temp'].max(), df_milano['temp'].max(), df_asti['temp'].max(), df_torino['temp'].max()]temp_min = [df_ravenna['temp'].min(), df_cesena['temp'].min(), df_faenza['temp'].min(), df_ferrara['temp'].min(), df_bologna['temp'].min(), df_mantova['temp'].min(), df_piacenza['temp'].min(), df_milano['temp'].min(), df_asti['temp'].min(), df_torino['temp'].min()]hum_min = [df_ravenna['humidity'].min(), df_cesena['humidity'].min(), df_faenza['humidity'].min(), df_ferrara['humidity'].min(), df_bologna['humidity'].min(), df_mantova['humidity'].min(), df_piacenza['humidity'].min(), df_milano['humidity'].min(), df_asti['humidity'].min(), df_torino['humidity'].min()]hum_max = [df_ravenna['humidity'].max(), df_cesena['humidity'].max(), df_faenza['humidity'].max(), df_ferrara['humidity'].max(), df_bologna['humidity'].max(), df_mantova['humidity'].max(), df_piacenza['humidity'].max(), df_milano['humidity'].max(), df_asti['humidity'].max(), df_torino['humidity'].max()] 123%matplotlib inlineimport matplotlib.pyplot as pltimport matplotlib.dates as mdates 12#temperatura massimaplt.plot(dist,temp_max,'ro') [&lt;matplotlib.lines.Line2D at 0xd697650&gt;] 12345678x = np.array(dist)y = np.array(temp_max)x1 = x[x&lt;100]x1 = x1.reshape((x1.size,1))y1 = y[x&lt;100]x2 = x[x&gt;50]x2 = x2.reshape((x2.size,1))y2 = y[x&gt;50] 123456789from sklearn.svm import SVRsvr_lin1 = SVR(kernel='linear', C=1e3)svr_lin2 = SVR(kernel='linear', C=1e3)svr_lin1.fit(x1, y1)svr_lin2.fit(x2, y2)xp1 = np.arange(10,100,10).reshape((9,1))xp2 = np.arange(50,400,50).reshape((7,1))yp1 = svr_lin1.predict(xp1)yp2 = svr_lin2.predict(xp2) 1234plt.plot(xp1, yp1, c='r', label='Strong sea effect')plt.plot(xp2, yp2, c='b', label='Light sea effect')plt.axis((0,400,20,40))plt.scatter(x, y, c='k', label='data') &lt;matplotlib.collections.PathCollection at 0x18627cf8&gt; 1234567891011121314151617from scipy.optimize import fsolvedef line1(x): a1 = svr_lin1.coef_[0][0] b1 = svr_lin1.intercept_[0] return -a1*x + b1def line2(x): a2 = svr_lin2.coef_[0][0] b2 = svr_lin2.intercept_[0] return -a2*x + b2def findIntersection(fun1,fun2,x0): return fsolve(lambda x : fun1(x) - fun2(x),x0)result = findIntersection(line1,line2,0.0)print "[x,y] = [ %d , %d ]" % (result,line1(result))x = numpy.linspace(0,300,31)plt.plot(x,line1(x),x,line2(x),result,line1(result),'ro') [x,y] = [ 101 , 34 ] --------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-25-389f5c694cae&gt; in &lt;module&gt;() 14 result = findIntersection(line1,line2,0.0) 15 print &quot;[x,y] = [ %d , %d ]&quot; % (result,line1(result)) ---&gt; 16 x = numpy.linspace(0,300,31) 17 plt.plot(x,line1(x),x,line2(x),result,line1(result),&#39;ro&#39;) NameError: name &#39;numpy&#39; is not defined 123#temperatures minplt.axis((0,400,15,25))plt.plot(dist,temp_min,'bo') [&lt;matplotlib.lines.Line2D at 0x18716320&gt;] 12#min humidityplt.plot(dist,hum_min,'bo') [&lt;matplotlib.lines.Line2D at 0x18b3de80&gt;] 12#max humidityplt.plot(dist,hum_max,'bo') [&lt;matplotlib.lines.Line2D at 0x18bc8080&gt;] 12345678#temperaturey1 = df_milano['temp']x1 = df_milano['day']fig, ax = plt.subplots()plt.xticks(rotation=70)hours = mdates.DateFormatter('%H:%M')ax.xaxis.set_major_formatter(hours)ax.plot(x1,y1,'r') [&lt;matplotlib.lines.Line2D at 0x1a109f28&gt;] 12345678#humidityy1 = df_milano['humidity']x1 = df_milano['day']fig, ax = plt.subplots()plt.xticks(rotation=70)hours = mdates.DateFormatter('%H:%M')ax.xaxis.set_major_formatter(hours)ax.plot(x1,y1,'r') [&lt;matplotlib.lines.Line2D at 0x1a2f47f0&gt;] 1234567891011y1 = df_ravenna['temp']x1 = df_ravenna['day']y2 = df_ferrara['temp']x2 = df_ferrara['day']y3 = df_milano['temp']x3 = df_milano['day']fig, ax = plt.subplots()plt.xticks(rotation=70)hours = mdates.DateFormatter('%H:%M')ax.xaxis.set_major_formatter(hours)plt.plot(x1,y1,'r',x2,y2,'b',x3,y3,'g') [&lt;matplotlib.lines.Line2D at 0x1a432e10&gt;, &lt;matplotlib.lines.Line2D at 0x1a586748&gt;, &lt;matplotlib.lines.Line2D at 0x1a586b38&gt;] 1234567891011y1 = df_ravenna['humidity']x1 = df_ravenna['day']y2 = df_ferrara['humidity']x2 = df_ferrara['day']y3 = df_milano['humidity']x3 = df_milano['day']fig, ax = plt.subplots()plt.xticks(rotation=70)hours = mdates.DateFormatter('%H:%M')ax.xaxis.set_major_formatter(hours)plt.plot(x1,y1,'r',x2,y2,'b',x3,y3,'g') [&lt;matplotlib.lines.Line2D at 0x1a5d6f60&gt;, &lt;matplotlib.lines.Line2D at 0x1a7fb9b0&gt;, &lt;matplotlib.lines.Line2D at 0x1a7fbda0&gt;] 123456789101112131415161718y1 = df_ravenna['humidity']x1 = df_ravenna['day']y2 = df_faenza['humidity']x2 = df_faenza['day']y3 = df_cesena['humidity']x3 = df_cesena['day']y4 = df_milano['humidity']x4 = df_milano['day']y5 = df_asti['humidity']x5 = df_asti['day']y6 = df_torino['humidity']x6 = df_torino['day']fig, ax = plt.subplots()plt.xticks(rotation=70)hours = mdates.DateFormatter('%H:%M')ax.xaxis.set_major_formatter(hours)plt.plot(x1,y1,'r',x2,y2,'r',x3,y3,'r')plt.plot(x4,y4,'g',x5,y5,'g',x6,y6,'g') [&lt;matplotlib.lines.Line2D at 0x18606668&gt;, &lt;matplotlib.lines.Line2D at 0x1a86ec18&gt;, &lt;matplotlib.lines.Line2D at 0x1a861470&gt;] 123456789101112131415161718y1 = df_ravenna['temp']x1 = df_ravenna['day']y2 = df_faenza['temp']x2 = df_faenza['day']y3 = df_cesena['temp']x3 = df_cesena['day']y4 = df_milano['temp']x4 = df_milano['day']y5 = df_asti['temp']x5 = df_asti['day']y6 = df_torino['temp']x6 = df_torino['day']fig, ax = plt.subplots()plt.xticks(rotation=70)hours = mdates.DateFormatter('%H:%M')ax.xaxis.set_major_formatter(hours)plt.plot(x1,y1,'r',x2,y2,'r',x3,y3,'r')plt.plot(x4,y4,'g',x5,y5,'g',x6,y6,'g') [&lt;matplotlib.lines.Line2D at 0x1aa22a90&gt;, &lt;matplotlib.lines.Line2D at 0x1ac54ba8&gt;, &lt;matplotlib.lines.Line2D at 0x1ac49518&gt;] 123456789101112hum_mean = [df_ravenna['humidity'].mean(), df_cesena['humidity'].mean(), df_faenza['humidity'].mean(), df_ferrara['humidity'].mean(), df_bologna['humidity'].mean(), df_mantova['humidity'].mean(), df_piacenza['humidity'].mean(), df_milano['humidity'].mean(), df_asti['humidity'].mean(), df_torino['humidity'].mean()]plt.plot(dist,hum_mean,'bo') [&lt;matplotlib.lines.Line2D at 0x1acbfb70&gt;] 12345678y1 = df_ravenna['wind_speed']*20y2 = df_ravenna['humidity']x = df_ravenna['day']fig, ax = plt.subplots()plt.xticks(rotation=70)hours = mdates.DateFormatter('%H:%M')ax.xaxis.set_major_formatter(hours)plt.plot(x,y1,'r',x,y2,'b') [&lt;matplotlib.lines.Line2D at 0x1ab2ee80&gt;, &lt;matplotlib.lines.Line2D at 0x1b0a0668&gt;] 1plt.plot(df_ravenna['wind_deg'],df_ravenna['wind_speed'],'ro') [&lt;matplotlib.lines.Line2D at 0x1b11c4e0&gt;] 1234plt.subplot(211)plt.plot(df_cesena['wind_deg'],df_cesena['humidity'],'bo')plt.subplot(212)plt.plot(df_cesena['wind_deg'],df_cesena['wind_speed'],'bo') [&lt;matplotlib.lines.Line2D at 0x1b4db6d8&gt;] 123hist, bins = np.histogram(df_ravenna['wind_deg'],8,[0,360])print histprint bins [3 4 9 6 1 1 0 0] [ 0. 45. 90. 135. 180. 225. 270. 315. 360.] 12345678def showRoseWind(values,city_name,max_value): N = 8 theta = np.arange(0.,2 * np.pi, 2 * np.pi / N) radii = np.array(values) plt.axes([0.025, 0.025, 0.95, 0.95], polar=True) colors = [(1-x/max_value, 1-x/max_value, 0.75) for x in radii] plt.bar(theta, radii, width=(2*np.pi/N), bottom=0.0, color=colors) plt.title(city_name,x=0.2, fontsize=20) 123hist, bin = np.histogram(df_ravenna['wind_deg'],8,[0,360])print histshowRoseWind(hist,'Ravenna', 15.0) [3 4 9 6 1 1 0 0] 123hist, bin = np.histogram(df_piacenza['wind_deg'],8,[0,360])print histshowRoseWind(hist,'Piacenza', 15.0) [8 3 4 2 4 1 1 1] 12print df_milano[df_milano['wind_deg']&lt;45]['wind_speed']print df_milano[df_milano['wind_deg']&lt;45]['wind_speed'].mean() 1 2.6 3 2.1 5 2.1 13 0.5 14 1 18 1 21 1 Name: wind_speed, dtype: object 1.47142857143 12345678910print df_milano[df_milano['wind_deg']&lt;45]['wind_speed'].mean()#print df_milano[(df_milano['wind_deg']&gt;0) &amp; (df_milano['wind_deg']&lt;45)]['wind_speed'].mean()print df_milano[(df_milano['wind_deg']&gt;44) &amp; (df_milano['wind_deg']&lt;90)]['wind_speed'].mean()print df_milano[(df_milano['wind_deg']&gt;89) &amp; (df_milano['wind_deg']&lt;135)]['wind_speed'].mean()print df_milano[(df_milano['wind_deg']&gt;134) &amp; (df_milano['wind_deg']&lt;180)]['wind_speed'].mean()print df_milano[(df_milano['wind_deg']&gt;179) &amp; (df_milano['wind_deg']&lt;225)]['wind_speed'].mean()print df_milano[(df_milano['wind_deg']&gt;224) &amp; (df_milano['wind_deg']&lt;270)]['wind_speed'].mean()print df_milano[(df_milano['wind_deg']&gt;269) &amp; (df_milano['wind_deg']&lt;315)]['wind_speed'].mean()#print df_milano[(df_milano['wind_deg']&gt;314) &amp; (df_milano['wind_deg']&lt;360)]['wind_speed'].mean()print df_milano[df_milano['wind_deg']&gt;314]['wind_speed'].mean() 1.47142857143 2.04 2.06666666667 2.05 2.68333333333 2.1 nan nan 12degs = np.arange(45,361,45)print degs [ 45 90 135 180 225 270 315 360] 123456tmp = []for deg in degs: #print df_milano[(df_milano['wind_deg']&gt;(deg-46)) &amp; (df_milano['wind_deg']&lt;deg)]['wind_speed'].mean() tmp.append(df_milano[(df_milano['wind_deg']&gt;(deg-46)) &amp; (df_milano['wind_deg']&lt;deg)]['wind_speed'].mean())speeds = np.array(tmp)print speeds [ 1.675 nan nan nan 2.93333333 3.13636364 2.58 nan] 1234567N = 8theta = np.arange(0.,2 * np.pi, 2 * np.pi / N)radii = np.array(speeds)plt.axes([0.025, 0.025, 0.95, 0.95], polar=True)colors = [(1-x/10.0, 1-x/10.0, 0.75) for x in radii]bars = plt.bar(theta, radii, width=(2*np.pi/N), bottom=0.0, color=colors)plt.title('Milano',x=0.2, fontsize=20) &lt;matplotlib.text.Text at 0x1be13ef0&gt; 123456def RoseWind_Speed(df_city): degs = np.arange(45,361,45) tmp = [] for deg in degs: tmp.append(df_city[(df_city['wind_deg']&gt;(deg-46)) &amp; (df_city['wind_deg']&lt;deg)]['wind_speed'].mean()) return np.array(tmp) 12345678def showRoseWind_Speed(speeds,city_name): N = 8 theta = np.arange(0.,2 * np.pi, 2 * np.pi / N) radii = np.array(speeds) plt.axes([0.025, 0.025, 0.95, 0.95], polar=True) colors = [(1-x/10.0, 1-x/10.0, 0.75) for x in radii] bars = plt.bar(theta, radii, width=(2*np.pi/N), bottom=0.0, color=colors) plt.title(city_name,x=0.2, fontsize=20) 1showRoseWind(RoseWind_Speed(df_milano),'Milano',10) 1showRoseWind_Speed(RoseWind_Speed(df_ravenna),'Ravenna') 1showRoseWind_Speed(RoseWind_Speed(df_faenza),'Faenza') 1showRoseWind_Speed(RoseWind_Speed(df_cesena),'Cesena') 1showRoseWind_Speed(RoseWind_Speed(df_ferrara),'Ferrara') 1showRoseWind_Speed(RoseWind_Speed(df_torino),'Torino') 1showRoseWind_Speed(RoseWind_Speed(df_mantova),'Mantova') 1ferrara = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Ferrara,IT') 12345678910df_ferrara.to_csv('ferrara.csv')df_milano.to_csv('milano.csv')df_mantova.to_csv('mantova.csv')df_ravenna.to_csv('ravenna.csv')df_torino.to_csv('torino.csv')df_asti.to_csv('asti.csv')df_bologna.to_csv('bologna.csv')df_piacenza.to_csv('piacenza.csv')df_cesena.to_csv('cesena.csv')df_faenza.to_csv('faenza.csv')]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
        <category>ipython</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第8章-用scikit-learn库实现机器学习]]></title>
    <url>%2F2018%2F04%2F12%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC8%E7%AB%A0-%E7%94%A8scikit-learn%E5%BA%93%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[第8章 用scikit-learn库实现机器学习 2058.1 scikit-learn库 2058.2 机器学习 2058.2.1 有监督和无监督学习 2058.2.2 训练集和测试集 2068.3 用scikit-learn实现有监督学习 2068.4 Iris数据集 20612345678from sklearn import datasetsiris = datasets.load_iris()print(iris.data.shape)print(iris.data[:5])print()print(iris.target[:5])print()print(iris.target_names) (150, 4) [[5.1 3.5 1.4 0.2] [4.9 3. 1.4 0.2] [4.7 3.2 1.3 0.2] [4.6 3.1 1.5 0.2] [5. 3.6 1.4 0.2]] [0 0 0 0 0] [&#39;setosa&#39; &#39;versicolor&#39; &#39;virginica&#39;] 1234567891011121314151617181920212223import matplotlib.pyplot as pltimport matplotlib.patches as mpatchesfrom sklearn import datasets% matplotlib inlineiris = datasets.load_iris()x = iris.data[:,0] #X-Axis - sepal lengthy = iris.data[:,1] #Y-Axis - sepal lengthspecies = iris.target #Speciesx_min, x_max = x.min() - .5,x.max() + .5y_min, y_max = y.min() - .5,y.max() + .5#SCATTERPLOTplt.figure()plt.title('Iris Dataset - Classification By Sepal Sizes')plt.scatter(x,y, c=species)plt.xlabel('Sepal length')plt.ylabel('Sepal width')plt.xlim(x_min, x_max)plt.ylim(y_min, y_max)plt.xticks(())plt.yticks(()) ([], &lt;a list of 0 Text yticklabel objects&gt;) 12345678910111213141516171819202122import matplotlib.pyplot as pltimport matplotlib.patches as mpatchesfrom sklearn import datasetsiris = datasets.load_iris()x = iris.data[:,2] #X-Axis - petal lengthy = iris.data[:,3] #Y-Axis - petal lengthspecies = iris.target #Speciesx_min, x_max = x.min() - .5,x.max() + .5y_min, y_max = y.min() - .5,y.max() + .5#SCATTERPLOTplt.figure()plt.title('Iris Dataset - Classification By Petal Sizes', size=14)plt.scatter(x,y, c=species)plt.xlabel('Petal length')plt.ylabel('Petal width')plt.xlim(x_min, x_max)plt.ylim(y_min, y_max)plt.xticks(())plt.yticks(()) ([], &lt;a list of 0 Text yticklabel objects&gt;) 主成分分解123456789101112131415161718192021import matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dfrom sklearn import datasetsfrom sklearn.decomposition import PCAiris = datasets.load_iris()x = iris.data[:,1] #X-Axis - petal lengthy = iris.data[:,2] #Y-Axis - petal lengthspecies = iris.target #Speciesx_reduced = PCA(n_components=3).fit_transform(iris.data)#SCATTERPLOT 3Dfig = plt.figure()ax = Axes3D(fig)ax.set_title('Iris Dataset by PCA', size=14)ax.scatter(x_reduced[:,0],x_reduced[:,1],x_reduced[:,2], c=species)ax.set_xlabel('First eigenvector')ax.set_ylabel('Second eigenvector')ax.set_zlabel('Third eigenvector')ax.w_xaxis.set_ticklabels(())ax.w_yaxis.set_ticklabels(())ax.w_zaxis.set_ticklabels(()) [] 8.5 K-近邻分类器 211123456789101112131415161718import numpy as npfrom sklearn import datasetsnp.random.seed(0)iris = datasets.load_iris()x = iris.datay = iris.targeti = np.random.permutation(len(iris.data))x_train = x[i[:-10]]y_train = y[i[:-10]]x_test = x[i[-10:]]y_test = y[i[-10:]]from sklearn.neighbors import KNeighborsClassifierknn = KNeighborsClassifier()knn.fit(x_train,y_train)y_pre = knn.predict(x_test)print(y_pre)print(y_test) [1 2 1 0 0 0 2 1 2 0] [1 1 1 0 0 0 2 1 2 0] 123456789101112131415161718192021222324import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.colors import ListedColormapfrom sklearn import datasetsfrom sklearn.neighbors import KNeighborsClassifieriris = datasets.load_iris()x = iris.data[:,:2] #X-Axis - sepal length-widthy = iris.target #Y-Axis - speciesx_min, x_max = x[:,0].min() - .5,x[:,0].max() + .5y_min, y_max = x[:,1].min() - .5,x[:,1].max() + .5#MESHcmap_light = ListedColormap(['#AAAAFF','#AAFFAA','#FFAAAA'])h = .02xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))knn = KNeighborsClassifier()knn.fit(x,y)Z = knn.predict(np.c_[xx.ravel(),yy.ravel()])Z = Z.reshape(xx.shape)plt.figure()plt.pcolormesh(xx,yy,Z,cmap=cmap_light)#Plot the training pointsplt.scatter(x[:,0],x[:,1],c=y)plt.xlim(xx.min(),xx.max())plt.ylim(yy.min(),yy.max()) (1.5, 4.900000000000003) 123456789101112131415161718192021222324import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.colors import ListedColormapfrom sklearn import datasetsfrom sklearn.neighbors import KNeighborsClassifieriris = datasets.load_iris()x = iris.data[:,2:4] #X-Axis - petals length-widthy = iris.target #Y-Axis - speciesx_min, x_max = x[:,0].min() - .5,x[:,0].max() + .5y_min, y_max = x[:,1].min() - .5,x[:,1].max() + .5#MESHcmap_light = ListedColormap(['#AAAAFF','#AAFFAA','#FFAAAA'])h = .02xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))knn = KNeighborsClassifier()knn.fit(x,y)Z = knn.predict(np.c_[xx.ravel(),yy.ravel()])Z = Z.reshape(xx.shape)plt.figure()plt.pcolormesh(xx,yy,Z,cmap=cmap_light)#Plot the training pointsplt.scatter(x[:,0],x[:,1],c=y)plt.xlim(xx.min(),xx.max())plt.ylim(yy.min(),yy.max()) (-0.4, 2.980000000000003) 8.6 Diabetes数据集 214123from sklearn import datasetsdiabetes = datasets.load_diabetes()diabetes.data[0] array([ 0.03807591, 0.05068012, 0.06169621, 0.02187235, -0.0442235 , -0.03482076, -0.04340085, -0.00259226, 0.01990842, -0.01764613]) 1np.sum(diabetes.data[:,0]**2) 1.0000000000000746 1diabetes.target[:10] array([151., 75., 141., 206., 135., 97., 138., 63., 110., 310.]) 8.7 线性回归：最小平方回归 215123456789101112from sklearn import linear_modellinreg = linear_model.LinearRegression()from sklearn import datasetsdiabetes = datasets.load_diabetes()x_train = diabetes.data[:-20]y_train = diabetes.target[:-20]x_test = diabetes.data[-20:]y_test = diabetes.target[-20:]linreg.fit(x_train,y_train)linreg.coef_ array([ 3.03499549e-01, -2.37639315e+02, 5.10530605e+02, 3.27736980e+02, -8.14131709e+02, 4.92814588e+02, 1.02848452e+02, 1.84606489e+02, 7.43519617e+02, 7.60951722e+01]) 123y_pre = linreg.predict(x_test)print(y_pre)print(y_test) [197.61846908 155.43979328 172.88665147 111.53537279 164.80054784 131.06954875 259.12237761 100.47935157 117.0601052 124.30503555 218.36632793 61.19831284 132.25046751 120.3332925 52.54458691 194.03798088 102.57139702 123.56604987 211.0346317 52.60335674] [233. 91. 111. 152. 120. 67. 310. 94. 183. 66. 173. 72. 49. 64. 48. 178. 104. 132. 220. 57.] 1linreg.score(x_test, y_test) 0.5850753022690571 123456789101112131415161718import numpy as npimport matplotlib.pyplot as pltfrom sklearn import linear_modelfrom sklearn import datasetsdiabetes = datasets.load_diabetes()x_train = diabetes.data[:-20]y_train = diabetes.target[:-20]x_test = diabetes.data[-20:]y_test = diabetes.target[-20:]x0_test = x_test[:,0]x0_train = x_train[:,0]x0_test = x0_test[:,np.newaxis]x0_train = x0_train[:,np.newaxis]linreg = linear_model.LinearRegression()linreg.fit(x0_train,y_train)y = linreg.predict(x0_test)plt.scatter(x0_test,y_test,color='k')plt.plot(x0_test,y,color='b',linewidth=3) [&lt;matplotlib.lines.Line2D at 0xeecd990&gt;] 1234567891011121314151617181920import numpy as npimport matplotlib.pyplot as pltfrom sklearn import linear_modelfrom sklearn import datasetsdiabetes = datasets.load_diabetes()x_train = diabetes.data[:-20]y_train = diabetes.target[:-20]x_test = diabetes.data[-20:]y_test = diabetes.target[-20:]plt.figure(figsize=(8,12))for f in range(0,10): xi_test = x_test[:,f] xi_train = x_train[:,f] xi_test = xi_test[:,np.newaxis] xi_train = xi_train[:,np.newaxis] linreg.fit(xi_train,y_train) y = linreg.predict(xi_test) plt.subplot(5,2,f+1) plt.scatter(xi_test,y_test,color='k') plt.plot(xi_test,y,color='b',linewidth=3) 8.8 支持向量机 2198.8.1 支持向量分类 2191234567import numpy as npimport matplotlib.pyplot as pltfrom sklearn import svmx = np.array([[1,3],[1,2],[1,1.5],[1.5,2],[2,3],[2.5,1.5],[2,1],[3,1],[3,2],[3.5,1],[3.5,3]])y = [0]*6 + [1]*5plt.scatter(x[:,0],x[:,1],c=y,s=50,alpha=0.9) &lt;matplotlib.collections.PathCollection at 0xf811110&gt; 12345678910111213import numpy as npimport matplotlib.pyplot as pltfrom sklearn import svmx = np.array([[1,3],[1,2],[1,1.5],[1.5,2],[2,3],[2.5,1.5],[2,1],[3,1],[3,2],[3.5,1],[3.5,3]])y = [0]*6 + [1]*5svc = svm.SVC(kernel='linear').fit(x,y)X,Y = np.mgrid[0:4:200j,0:4:200j]Z = svc.decision_function(np.c_[X.ravel(),Y.ravel()])Z = Z.reshape(X.shape)plt.contourf(X,Y,Z &gt; 0,alpha=0.4)plt.contour(X,Y,Z,colors=['k'], linestyles=['-'],levels=[0])plt.scatter(x[:,0],x[:,1],c=y,s=50,alpha=0.9) &lt;matplotlib.collections.PathCollection at 0xf84ce50&gt; 1svc.predict([[1.5,2.5]]) array([0]) 1svc.predict([[2.5,1]]) array([1]) 1234567891011121314import numpy as npimport matplotlib.pyplot as pltfrom sklearn import svmx = np.array([[1,3],[1,2],[1,1.5],[1.5,2],[2,3],[2.5,1.5],[2,1],[3,1],[3,2],[3.5,1],[3.5,3]])y = [0]*6 + [1]*5svc = svm.SVC(kernel='linear',C=1).fit(x,y)X,Y = np.mgrid[0:4:200j,0:4:200j]Z = svc.decision_function(np.c_[X.ravel(),Y.ravel()])Z = Z.reshape(X.shape)plt.contourf(X,Y,Z &gt; 0,alpha=0.4)plt.contour(X,Y,Z,colors=['k','k','k'], linestyles=['--','-','--'],levels=[-1,0,1])plt.scatter(svc.support_vectors_[:,0],svc.support_vectors_[:,1],s=120,facecolors='none')plt.scatter(x[:,0],x[:,1],c=y,s=50,alpha=0.9) &lt;matplotlib.collections.PathCollection at 0xfe387b0&gt; 8.8.2 非线性SVC 2231234567891011121314import numpy as npimport matplotlib.pyplot as pltfrom sklearn import svmx = np.array([[1,3],[1,2],[1,1.5],[1.5,2],[2,3],[2.5,1.5],[2,1],[3,1],[3,2],[3.5,1],[3.5,3]])y = [0]*6 + [1]*5svc = svm.SVC(kernel='linear',C=0.1).fit(x,y)X,Y = np.mgrid[0:4:200j,0:4:200j]Z = svc.decision_function(np.c_[X.ravel(),Y.ravel()])Z = Z.reshape(X.shape)plt.contourf(X,Y,Z &gt; 0,alpha=0.4)plt.contour(X,Y,Z,colors=['k','k','k'], linestyles=['--','-','--'],levels=[-1,0,1])plt.scatter(svc.support_vectors_[:,0],svc.support_vectors_[:,1],s=120,facecolors='none')plt.scatter(x[:,0],x[:,1],c=y,s=50,alpha=0.9) &lt;matplotlib.collections.PathCollection at 0xff1eb90&gt; 1234567891011121314import numpy as npimport matplotlib.pyplot as pltfrom sklearn import svmx = np.array([[1,3],[1,2],[1,1.5],[1.5,2],[2,3],[2.5,1.5],[2,1],[3,1],[3,2],[3.5,1],[3.5,3]])y = [0]*6 + [1]*5svc = svm.SVC(kernel='poly',C=1, degree=3).fit(x,y)X,Y = np.mgrid[0:4:200j,0:4:200j]Z = svc.decision_function(np.c_[X.ravel(),Y.ravel()])Z = Z.reshape(X.shape)plt.contourf(X,Y,Z &gt; 0,alpha=0.4)plt.contour(X,Y,Z,colors=['k','k','k'], linestyles=['--','-','--'],levels=[-1,0,1])plt.scatter(svc.support_vectors_[:,0],svc.support_vectors_[:,1],s=120,facecolors='none')plt.scatter(x[:,0],x[:,1],c=y,s=50,alpha=0.9) &lt;matplotlib.collections.PathCollection at 0xf99b8d0&gt; 1234567891011121314import numpy as npimport matplotlib.pyplot as pltfrom sklearn import svmx = np.array([[1,3],[1,2],[1,1.5],[1.5,2],[2,3],[2.5,1.5],[2,1],[3,1],[3,2],[3.5,1],[3.5,3]])y = [0]*6 + [1]*5svc = svm.SVC(kernel='rbf', C=1, gamma=3).fit(x,y)X,Y = np.mgrid[0:4:200j,0:4:200j]Z = svc.decision_function(np.c_[X.ravel(),Y.ravel()])Z = Z.reshape(X.shape)plt.contourf(X,Y,Z &gt; 0,alpha=0.4)plt.contour(X,Y,Z,colors=['k','k','k'], linestyles=['--','-','--'],levels=[-1,0,1])plt.scatter(svc.support_vectors_[:,0],svc.support_vectors_[:,1],s=120,facecolors='none')plt.scatter(x[:,0],x[:,1],c=y,s=50,alpha=0.9) &lt;matplotlib.collections.PathCollection at 0xe575f90&gt; 8.8.3 绘制SVM分类器对Iris数据集的分类效果图 2251234567891011121314151617import numpy as npimport matplotlib.pyplot as pltfrom sklearn import svm, datasetsiris = datasets.load_iris()x = iris.data[:,:2]y = iris.targeth = .05svc = svm.SVC(kernel='linear',C=1.0).fit(x,y)x_min,x_max = x[:,0].min() - .5, x[:,0].max() + .5y_min,y_max = x[:,1].min() - .5, x[:,1].max() + .5h = .02X, Y = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min,y_max,h))Z = svc.predict(np.c_[X.ravel(),Y.ravel()])Z = Z.reshape(X.shape)plt.contourf(X,Y,Z,alpha=0.4)plt.contour(X,Y,Z,colors='k')plt.scatter(x[:,0],x[:,1],c=y) &lt;matplotlib.collections.PathCollection at 0xd3aac90&gt; 1234567891011121314151617import numpy as npimport matplotlib.pyplot as pltfrom sklearn import svm, datasetsiris = datasets.load_iris()x = iris.data[:,:2]y = iris.targeth = .05svc = svm.SVC(kernel='poly',C=1.0,degree=3).fit(x,y)x_min,x_max = x[:,0].min() - .5, x[:,0].max() + .5y_min,y_max = x[:,1].min() - .5, x[:,1].max() + .5h = .02X, Y = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min,y_max,h))Z = svc.predict(np.c_[X.ravel(),Y.ravel()])Z = Z.reshape(X.shape)plt.contourf(X,Y,Z,alpha=0.4)plt.contour(X,Y,Z,colors='k')plt.scatter(x[:,0],x[:,1],c=y) &lt;matplotlib.collections.PathCollection at 0xf705250&gt; 1234567891011121314151617import numpy as npimport matplotlib.pyplot as pltfrom sklearn import svm, datasetsiris = datasets.load_iris()x = iris.data[:,:2]y = iris.targeth = .05svc = svm.SVC(kernel='rbf',C=1.0,degree=3).fit(x,y)x_min,x_max = x[:,0].min() - .5, x[:,0].max() + .5y_min,y_max = x[:,1].min() - .5, x[:,1].max() + .5h = .02X, Y = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min,y_max,h))Z = svc.predict(np.c_[X.ravel(),Y.ravel()])Z = Z.reshape(X.shape)plt.contourf(X,Y,Z,alpha=0.4)plt.contour(X,Y,Z,colors='k')plt.scatter(x[:,0],x[:,1],c=y) &lt;matplotlib.collections.PathCollection at 0xe419a50&gt; 8.8.4 支持向量回归 227123456789101112131415161718192021222324252627282930import numpy as npimport matplotlib.pyplot as pltfrom sklearn import svmfrom sklearn import datasetsdiabetes = datasets.load_diabetes()x_train = diabetes.data[:-20]y_train = diabetes.target[:-20]x_test = diabetes.data[-20:]y_test = diabetes.target[-20:]x0_test = x_test[:,2]x0_train = x_train[:,2]x0_test = x0_test[:,np.newaxis]x0_train = x0_train[:,np.newaxis]x0_test.sort(axis=0)x0_test = x0_test*100x0_train = x0_train*100svr = svm.SVR(kernel='linear',C=1000)svr2 = svm.SVR(kernel='poly',C=1000,degree=2)svr3 = svm.SVR(kernel='poly',C=1000,degree=3)svr.fit(x0_train,y_train)svr2.fit(x0_train,y_train)svr3.fit(x0_train,y_train)y = svr.predict(x0_test)y2 = svr2.predict(x0_test)y3 = svr3.predict(x0_test)plt.scatter(x0_test,y_test,color='k')plt.plot(x0_test,y,color='b')plt.plot(x0_test,y2,c='r')plt.plot(x0_test,y3,c='g') [&lt;matplotlib.lines.Line2D at 0xf068670&gt;] 8.9 小结 229]]></content>
      <categories>
        <category>机器学习</category>
        <category>sklearn</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>SVC</tag>
        <tag>sklearn</tag>
        <tag>scikit-learn</tag>
        <tag>KNN</tag>
        <tag>SVR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第7章-用matplotlib实现数据可视化]]></title>
    <url>%2F2018%2F04%2F12%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC7%E7%AB%A0-%E7%94%A8matplotlib%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[第7章 用matplotlib实现数据可视化 1497.1 matplotlib库 1497.2 安装 1507.3 IPython和IPython QtConsole 1507.4 matplotlib架构 151 7.4.1 Backend层 1527.4.2 Artist层 152 7.4.3 Scripting层（pyplot） 1537.4.4 pylab和pyplot 1537.5 pyplot 1547.5.1 生成一幅简单的交互式图表 154123import matplotlib.pyplot as plt%matplotlib inlineplt.plot([1,2,3,4]) [&lt;matplotlib.lines.Line2D at 0xb50aa10&gt;] 7.5.2 设置图形的属性 1561plt.plot([1,2,3,4],[1,4,9,16],'ro') [&lt;matplotlib.lines.Line2D at 0xc78c450&gt;] 123plt.axis([0,5,0,20])plt.title('My first plot')plt.plot([1,2,3,4],[1,4,9,16],'ro') [&lt;matplotlib.lines.Line2D at 0xc7ab610&gt;] 7.5.3 matplotlib和NumPy 1581234567import mathimport numpy as npt = np.arange(0,2.5,0.1)y1 = list(map(math.sin,math.pi*t))y2 = list(map(math.sin,math.pi*t+math.pi/2))y3 = list(map(math.sin,math.pi*t-math.pi/2))plt.plot(t,y1,'b*',t,y2,'g^',t,y3,'ys') [&lt;matplotlib.lines.Line2D at 0xc9e7ff0&gt;, &lt;matplotlib.lines.Line2D at 0xc9f3110&gt;, &lt;matplotlib.lines.Line2D at 0xc9f3430&gt;] 1plt.plot(t,y1,'b--',t,y2,'g',t,y3,'r-.') [&lt;matplotlib.lines.Line2D at 0xca757b0&gt;, &lt;matplotlib.lines.Line2D at 0xca758b0&gt;, &lt;matplotlib.lines.Line2D at 0xca75bd0&gt;] 7.6 使用kwargs 1601plt.plot([1,2,4,2,1,0,1,2,1,4],linewidth=2.0) [&lt;matplotlib.lines.Line2D at 0xcaba9d0&gt;] 处理多个Figure和Axes对象 12345678t = np.arange(0,5,0.1)y1 = np.sin(2*np.pi*t)y2 = np.sin(2*np.pi*t)plt.subplot(211)plt.plot(t,y1,'b-.')plt.subplot(212)plt.plot(t,y2,'r--') [&lt;matplotlib.lines.Line2D at 0xcb219b0&gt;] 12345678t = np.arange(0.,1.,0.05)y1 = np.sin(2*np.pi*t)y2 = np.cos(2*np.pi*t)plt.subplot(121)plt.plot(t,y1,'b-.')plt.subplot(122)plt.plot(t,y2,'r--') [&lt;matplotlib.lines.Line2D at 0xcb8c670&gt;] 7.7 为图表添加更多元素 1627.7.1 添加文本 16212345plt.axis([0,5,0,20])plt.title('My first plot')plt.xlabel('Counting')plt.ylabel('Square values')plt.plot([1,2,3,4],[1,4,9,16],'ro') [&lt;matplotlib.lines.Line2D at 0xcbdf930&gt;] 12345plt.axis([0,5,0,20])plt.title('My first plot',fontsize=20,fontname='Times New Roman')plt.xlabel('Counting',color='gray')plt.ylabel('Square values',color='gray')plt.plot([1,2,3,4],[1,4,9,16],'ro') [&lt;matplotlib.lines.Line2D at 0xcc19fb0&gt;] 123456789plt.axis([0,5,0,20])plt.title('My first plot',fontsize=20,fontname='Times New Roman')plt.xlabel('Counting',color='gray')plt.ylabel('Square values',color='gray')plt.text(1,1.5,'First')plt.text(2,4.5,'Second')plt.text(3,9.5,'Third')plt.text(4,16.5,'Fourth')plt.plot([1,2,3,4],[1,4,9,16],'ro') [&lt;matplotlib.lines.Line2D at 0xcc5ca50&gt;] 12345678910plt.axis([0,5,0,20])plt.title('My first plot',fontsize=20,fontname='Times New Roman')plt.xlabel('Counting',color='gray')plt.ylabel('Square values',color='gray')plt.text(1,1.5,'First')plt.text(2,4.5,'Second')plt.text(3,9.5,'Third')plt.text(4,16.5,'Fourth')plt.text(1.1,12,r'$y = x^2$',fontsize=20,bbox=&#123;'facecolor':'yellow','alpha':0.2&#125;)plt.plot([1,2,3,4],[1,4,9,16],'ro') [&lt;matplotlib.lines.Line2D at 0xcca15f0&gt;] 7.7.2 添加网格 1651234567891011plt.axis([0,5,0,20])plt.title('My first plot',fontsize=20,fontname='Times New Roman')plt.xlabel('Counting',color='gray')plt.ylabel('Square values',color='gray')plt.text(1,1.5,'First')plt.text(2,4.5,'Second')plt.text(3,9.5,'Third')plt.text(4,16.5,'Fourth')plt.text(1.1,12,r'$y = x^2$',fontsize=20,bbox=&#123;'facecolor':'yellow','alpha':0.2&#125;)plt.grid(True)plt.plot([1,2,3,4],[1,4,9,16],'ro') [&lt;matplotlib.lines.Line2D at 0xcd2e6b0&gt;] 7.7.3 添加图例 1661234567891011plt.axis([0,5,0,20])plt.title('My first plot',fontsize=20,fontname='Times New Roman')plt.xlabel('Counting',color='gray')plt.ylabel('Square values',color='gray')plt.text(2,4.5,'Second')plt.text(3,9.5,'Third')plt.text(4,16.5,'Fourth')plt.text(1.1,12,'$y = x^2$',fontsize=20,bbox=&#123;'facecolor':'yellow','alpha':0.2&#125;)plt.grid(True)plt.plot([1,2,3,4],[1,4,9,16],'ro')plt.legend(['First series']) &lt;matplotlib.legend.Legend at 0xcd71750&gt; 123456789101112131415import matplotlib.pyplot as pltplt.axis([0,5,0,20])plt.title('My first plot',fontsize=20,fontname='Times New Roman')plt.xlabel('Counting',color='gray')plt.ylabel('Square values',color='gray')plt.text(1,1.5,'First')plt.text(2,4.5,'Second')plt.text(3,9.5,'Third')plt.text(4,16.5,'Fourth')plt.text(1.1,12,'$y = x^2$',fontsize=20,bbox=&#123;'facecolor':'yellow','alpha':0.2&#125;)plt.grid(True)plt.plot([1,2,3,4],[1,4,9,16],'ro')plt.plot([1,2,3,4],[0.8,3.5,8,15],'g^')plt.plot([1,2,3,4],[0.5,2.5,4,12],'b*')plt.legend(['First series','Second series','Third series'],loc=2) &lt;matplotlib.legend.Legend at 0xcdca450&gt; Location Code Location String0 best1 upper-right2 upper-left3 lower-right4 lower-left5 right6 center-left7 center-right8 lower-center9 upper-center10 centerChapter 7.8 保存图表 1687.8.1 保存代码 1697.8.2 将会话转换为HTML文件 1707.8.3 将图表直接保存为图片 171123456789101112131415plt.axis([0,5,0,20])plt.title('My first plot',fontsize=20,fontname='Times New Roman')plt.xlabel('Counting',color='gray')plt.ylabel('Square values',color='gray')plt.text(1,1.5,'First')plt.text(2,4.5,'Second')plt.text(3,9.5,'Third')plt.text(4,16.5,'Fourth')plt.text(1.1,12,'$y = x^2$',fontsize=20,bbox=&#123;'facecolor':'yellow','alpha':0.2&#125;)plt.grid(True)plt.plot([1,2,3,4],[1,4,9,16],'ro')plt.plot([1,2,3,4],[0.8,3.5,8,15],'g^')plt.plot([1,2,3,4],[0.5,2.5,4,12],'b*')plt.legend(['First series','Second series','Third series'],loc=2)plt.savefig('my_chart.png') 7.9 处理日期值 17112345678import datetimeimport numpy as npimport matplotlib.pyplot as pltevents = [datetime.date(2015,1,23),datetime.date(2015,1,28),datetime.date(2015,2,3),datetime.date(2015,2,21),datetime.date(2015,3,15),datetime.date(2015,3,24),datetime.date(2015,4,8),datetime.date(2015,4,24)]readings = [12,22,25,20,18,15,17,14]plt.plot(events,readings) [&lt;matplotlib.lines.Line2D at 0xcdfa2d0&gt;] 12345678910111213141516import datetimeimport numpy as npimport matplotlib.pyplot as pltimport matplotlib.dates as mdatesmonths = mdates.MonthLocator()days = mdates.DayLocator()timeFmt = mdates.DateFormatter('%Y-%m')events = [datetime.date(2015,1,23),datetime.date(2015,1,28),datetime.date(2015,2,3),datetime.date(2015,2,21),datetime.date(2015,3,15),datetime.date(2015,3,24),datetime.date(2015,4,8),datetime.date(2015,4,24)]readings = [12,22,25,20,18,15,17,14]fig, ax = plt.subplots()plt.plot(events,readings)ax.xaxis.set_major_locator(months)ax.xaxis.set_major_formatter(timeFmt)ax.xaxis.set_minor_locator(days) 7.10 图表类型 1737.11 线性图 17312345import matplotlib.pyplot as pltimport numpy as npx = np.arange(-2*np.pi,2*np.pi,0.01)y = np.sin(3*x)/xplt.plot(x,y) [&lt;matplotlib.lines.Line2D at 0xcf9eab0&gt;] 123456789import matplotlib.pyplot as pltimport numpy as npx = np.arange(-2*np.pi,2*np.pi,0.01)y = np.sin(x)/xy2 = np.sin(2*x)/xy3 = np.sin(3*x)/xplt.plot(x,y)plt.plot(x,y2)plt.plot(x,y3) [&lt;matplotlib.lines.Line2D at 0xcdc4ff0&gt;] 123456789import matplotlib.pyplot as pltimport numpy as npx = np.arange(-2*np.pi,2*np.pi,0.01)y = np.sin(x)/xy2 = np.sin(2*x)/xy3 = np.sin(3*x)/xplt.plot(x,y,'k--',linewidth=3)plt.plot(x,y2,'m-.')plt.plot(x,y3,color='#87a3cc',linestyle='--') [&lt;matplotlib.lines.Line2D at 0xe00f2d0&gt;] Code Colorb blueg greenr redc cyanm magentay yellowk blackw white 12345678910111213import matplotlib.pyplot as pltimport numpy as npx = np.arange(-2*np.pi,2*np.pi,0.01)y = np.sin(3*x)/xy2 = np.sin(2*x)/xy3 = np.sin(x)/xplt.plot(x,y,color='b')plt.plot(x,y2,color='r')plt.plot(x,y3,color='g')plt.xticks([-2*np.pi, -np.pi, 0, np.pi, 2*np.pi],[r'$-2\pi$',r'$-\pi$',r'$0$',r'$+\pi$',r'$+2\pi$'])plt.yticks([-1,0,+1,+2,+3],[r'$-1$',r'$0$',r'$+1$',r'$+2$',r'$+3$']) ([&lt;matplotlib.axis.YTick at 0xe0358f0&gt;, &lt;matplotlib.axis.YTick at 0xe00f7f0&gt;, &lt;matplotlib.axis.YTick at 0xe035eb0&gt;, &lt;matplotlib.axis.YTick at 0xe05b430&gt;, &lt;matplotlib.axis.YTick at 0xe05b8b0&gt;], &lt;a list of 5 Text yticklabel objects&gt;) 1234567891011121314151617181920import matplotlib.pyplot as pltimport numpy as npx = np.arange(-2*np.pi,2*np.pi,0.01)y = np.sin(3*x)/xy2 = np.sin(2*x)/xy3 = np.sin(x)/xplt.plot(x,y,color='b')plt.plot(x,y2,color='r')plt.plot(x,y3,color='g')plt.xticks([-2*np.pi, -np.pi, 0, np.pi, 2*np.pi],[r'$-2\pi$',r'$-\pi$',r'$0$',r'$+\pi$',r'$+2\pi$'])plt.yticks([-1,0,+1,+2,+3],[r'$-1$',r'$0$',r'$+1$',r'$+2$',r'$+3$'])ax = plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position('bottom')ax.spines['bottom'].set_position(('data',0))ax.yaxis.set_ticks_position('left')ax.spines['left'].set_position(('data',0)) 1234567891011121314151617181920212223import matplotlib.pyplot as pltimport numpy as npx = np.arange(-2*np.pi,2*np.pi,0.01)y = np.sin(3*x)/xy2 = np.sin(2*x)/xy3 = np.sin(x)/xplt.plot(x,y,color='b')plt.plot(x,y2,color='r')plt.plot(x,y3,color='g')plt.xticks([-2*np.pi, -np.pi, 0, np.pi, 2*np.pi],[r'$-2\pi$',r'$-\pi$',r'$0$',r'$+\pi$',r'$+2\pi$'])plt.yticks([-1,0,+1,+2,+3],[r'$-1$',r'$0$',r'$+1$',r'$+2$',r'$+3$'])plt.annotate(r'$\lim_&#123;x\to 0&#125;\frac&#123;\sin(x)&#125;&#123;x&#125;= 1$', xy=[0,1],xycoords='data',xytext=[30,30],fontsize=16,textcoords='offset points',arrowprops=dict(arrowstyle="-&gt;",connectionstyle="arc3,rad=.2"))ax = plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position('bottom')ax.spines['bottom'].set_position(('data',0))ax.yaxis.set_ticks_position('left')ax.spines['left'].set_position(('data',0)) 1234567891011import matplotlib.pyplot as pltimport numpy as npimport pandas as pddata = &#123;'series1':[1,3,4,3,5],'series2':[2,4,5,2,4],'series3':[3,2,3,1,3]&#125;df = pd.DataFrame(data)x = np.arange(5)plt.axis([0,5,0,7])plt.plot(x,df)plt.legend(data, loc=2) &lt;matplotlib.legend.Legend at 0xf047270&gt; 7.12 直方图 1801234import matplotlib.pyplot as pltimport numpy as nppop = np.random.randint(0,100,100)pop array([32, 29, 53, 8, 43, 91, 54, 31, 81, 54, 28, 56, 43, 39, 96, 44, 6, 71, 29, 26, 34, 41, 78, 45, 1, 22, 94, 89, 19, 6, 95, 3, 86, 10, 1, 54, 51, 5, 20, 18, 87, 12, 92, 50, 82, 3, 56, 23, 57, 92, 25, 2, 86, 32, 75, 13, 85, 90, 8, 77, 91, 5, 31, 34, 44, 67, 30, 15, 42, 63, 15, 38, 56, 83, 2, 18, 94, 49, 31, 47, 25, 5, 20, 70, 47, 65, 29, 44, 23, 35, 73, 96, 34, 27, 11, 70, 96, 21, 71, 69]) 1n,bins,patches = plt.hist(pop,bins=20) 7.13 条状图 1811234import matplotlib.pyplot as pltindex = [0,1,2,3,4]values = [5,7,3,4,6]plt.bar(index,values) &lt;Container object of 5 artists&gt; 12345import numpy as npindex = np.arange(5)values1 = [5,7,3,4,6]plt.bar(index,values1)plt.xticks(index+0.4,['A','B','C','D','E']) ([&lt;matplotlib.axis.XTick at 0xf3246f0&gt;, &lt;matplotlib.axis.XTick at 0xf261bd0&gt;, &lt;matplotlib.axis.XTick at 0xf31c310&gt;, &lt;matplotlib.axis.XTick at 0xf3423f0&gt;, &lt;matplotlib.axis.XTick at 0xf342790&gt;], &lt;a list of 5 Text xticklabel objects&gt;) 123456789import numpy as npindex = np.arange(5)values1 = [5,7,3,4,6]std1 = [0.8,1,0.4,0.9,1.3]plt.title('A Bar Chart')plt.bar(index,values1,yerr=std1,error_kw=&#123;'ecolor':'0.1','capsize':6&#125;,alpha=0.7,label='First')plt.xticks(index+0.4,['A','B','C','D','E'])plt.legend(loc=2) &lt;matplotlib.legend.Legend at 0xf389970&gt; 7.13.1 水平条状图 18312345678910import matplotlib.pyplot as pltimport numpy as npindex = np.arange(5)values1 = [5,7,3,4,6]std1 = [0.8,1,0.4,0.9,1.3]plt.title('A Horizontal Bar Chart')plt.barh(index,values1,xerr=std1,error_kw=&#123;'ecolor':'0.1','capsize':6&#125;,alpha=0.7,label='First')plt.yticks(index+0.4,['A','B','C','D','E'])plt.legend(loc=5) &lt;matplotlib.legend.Legend at 0xf3c9630&gt; 7.13.2 多序列条状图 18412345678910111213import matplotlib.pyplot as pltimport numpy as npindex = np.arange(5)values1 = [5,7,3,4,6]values2 = [6,6,4,5,7]values3 = [5,6,5,4,6]bw = 0.3plt.axis([0,5,0,8])plt.title('A Multiseries Bar Chart',fontsize=20)plt.bar(index,values1,bw,color='b')plt.bar(index+bw,values2,bw,color='g')plt.bar(index+2*bw,values3,bw,color='r')plt.xticks(index+1.5*bw,['A','B','C','D','E']) ([&lt;matplotlib.axis.XTick at 0xf39dcd0&gt;, &lt;matplotlib.axis.XTick at 0xf39ded0&gt;, &lt;matplotlib.axis.XTick at 0xf3ef4b0&gt;, &lt;matplotlib.axis.XTick at 0xf42d230&gt;, &lt;matplotlib.axis.XTick at 0xf42d5d0&gt;], &lt;a list of 5 Text xticklabel objects&gt;) 12345678910111213import matplotlib.pyplot as pltimport numpy as npindex = np.arange(5)values1 = [5,7,3,4,6]values2 = [6,6,4,5,7]values3 = [5,6,5,4,6]bw = 0.3plt.axis([0,8,0,5])plt.title('A Multiseries Horizontal Bar Chart',fontsize=20)plt.barh(index,values1,bw,color='b')plt.barh(index+bw,values2,bw,color='g')plt.barh(index+2*bw,values3,bw,color='r')plt.yticks(index+0.4,['A','B','C','D','E']) ([&lt;matplotlib.axis.YTick at 0xf43e810&gt;, &lt;matplotlib.axis.YTick at 0xf43e0f0&gt;, &lt;matplotlib.axis.YTick at 0xf44f330&gt;, &lt;matplotlib.axis.YTick at 0xf473f50&gt;, &lt;matplotlib.axis.YTick at 0xf47d310&gt;], &lt;a list of 5 Text yticklabel objects&gt;) 7.13.3 为pandas DataFrame生成多序列条状图 18512345678import matplotlib.pyplot as pltimport numpy as npimport pandas as pddata = &#123;'series1':[1,3,4,3,5],'series2':[2,4,5,2,4],'series3':[3,2,3,1,3]&#125;df = pd.DataFrame(data)df.plot(kind='bar') &lt;matplotlib.axes._subplots.AxesSubplot at 0xf3a3330&gt; 12345678import matplotlib.pyplot as pltimport numpy as npimport pandas as pddata = &#123;'series1':[1,3,4,3,5],'series2':[2,4,5,2,4],'series3':[3,2,3,1,3]&#125;df = pd.DataFrame(data)df.plot(kind='barh') &lt;matplotlib.axes._subplots.AxesSubplot at 0xf3bf030&gt; 7.13.4 多序列堆积条状图 1861234567891011import matplotlib.pyplot as pltimport numpy as npseries1 = np.array([3,4,5,3])series2 = np.array([1,2,2,5])series3 = np.array([2,3,3,4])index = np.arange(4)plt.axis([0,4,0,15])plt.bar(index,series1,color='r')plt.bar(index,series2,color='b',bottom=series1)plt.bar(index,series3,color='g',bottom=(series2+series1))plt.xticks(index+0.4,['Jan15','Feb15','Mar15','Apr15']) ([&lt;matplotlib.axis.XTick at 0xf53e9f0&gt;, &lt;matplotlib.axis.XTick at 0xf549250&gt;, &lt;matplotlib.axis.XTick at 0xf53ef70&gt;, &lt;matplotlib.axis.XTick at 0xf5790b0&gt;], &lt;a list of 4 Text xticklabel objects&gt;) 123456789101112import matplotlib.pyplot as pltimport numpy as npindex = np.arange(4)series1 = np.array([3,4,5,3])series2 = np.array([1,2,2,5])series3 = np.array([2,3,3,4])plt.axis([0,15,0,4])plt.title('A Multiseries Horizontal Stacked Bar Chart')plt.barh(index,series1,color='r')plt.barh(index,series2,color='g',left=series1)plt.barh(index,series3,color='b',left=(series1+series2))plt.yticks(index+0.4,['Jan15','Feb15','Mar15','Apr15']) ([&lt;matplotlib.axis.YTick at 0xf58b1d0&gt;, &lt;matplotlib.axis.YTick at 0xf549ff0&gt;, &lt;matplotlib.axis.YTick at 0xf58bcf0&gt;, &lt;matplotlib.axis.YTick at 0xf5bf2b0&gt;], &lt;a list of 4 Text yticklabel objects&gt;) 123456789101112import matplotlib.pyplot as pltimport numpy as npindex = np.arange(4)series1 = np.array([3,4,5,3])series2 = np.array([1,2,2,5])series3 = np.array([2,3,3,4])plt.axis([0,15,0,4])plt.title('A Multiseries Horizontal Stacked Bar Chart')plt.barh(index,series1,color='w',hatch='xx')plt.barh(index,series2,color='w',hatch='///', left=series1)plt.barh(index,series3,color='w',hatch='\\\\\\',left=(series1+series2))plt.yticks(index+0.4,['Jan15','Feb15','Mar15','Apr15']) ([&lt;matplotlib.axis.YTick at 0xf5d0c10&gt;, &lt;matplotlib.axis.YTick at 0xf5b6790&gt;, &lt;matplotlib.axis.YTick at 0xf5dc170&gt;, &lt;matplotlib.axis.YTick at 0xf6066b0&gt;], &lt;a list of 4 Text yticklabel objects&gt;) 7.13.5 为pandas DataFrame绘制堆积条状图 1891234567import matplotlib.pyplot as pltimport pandas as pddata = &#123;'series1':[1,3,4,3,5],'series2':[2,4,5,2,4],'series3':[3,2,3,1,3]&#125;df = pd.DataFrame(data)df.plot(kind='bar', stacked=True) &lt;matplotlib.axes._subplots.AxesSubplot at 0xf5e74f0&gt; 7.13.6 其他条状图 19012345678910111213import matplotlib.pyplot as pltx0 = np.arange(8)y1 = np.array([1,3,4,6,4,3,2,1])y2 = np.array([1,2,5,4,3,3,2,1])plt.ylim(-7,7)plt.bar(x0,y1,0.9,facecolor='r',edgecolor='w')plt.bar(x0,-y2,0.9,facecolor='b',edgecolor='w')plt.xticks(())plt.grid(True)for x, y in zip(x0, y1): plt.text(x + 0.4, y + 0.05, '%d' % y, ha='center', va= 'bottom')for x, y in zip(x0, y2): plt.text(x + 0.4, (-y) - 0.05, '%d' % y, ha='center', va= 'top') 7.14 饼图 190123456import matplotlib.pyplot as pltlabels = ['Nokia','Samsung','Apple','Lumia']values = [10,30,45,15]colors = ['yellow','green','red','blue']plt.pie(values,labels=labels,colors=colors)plt.axis('equal') (-1.11637372803214, 1.1007797090739162, -1.1163737124158366, 1.1007797083302826) 12345678import matplotlib.pyplot as pltlabels = ['Nokia','Samsung','Apple','Lumia']values = [10,30,45,15]colors = ['yellow','green','red','blue']explode = [0.3,0,0,0]plt.title('A Pie Chart')plt.pie(values,labels=labels,colors=colors,explode=explode,startangle=180)plt.axis('equal') (-1.4003625034945653, 1.130639575385504, -1.1007797083302826, 1.1163737124158366) 123456789import matplotlib.pyplot as pltlabels = ['Nokia','Samsung','Apple','Lumia']values = [10,30,45,15]colors = ['yellow','green','red','blue']explode = [0.3,0,0,0]plt.title('A Pie Chart')plt.pie(values,labels=labels,colors=colors,explode=explode,shadow=True,autopct='%1.1f%%',startangle=180)plt.axis('equal') (-1.4003625034945653, 1.130639575385504, -1.1007797083302826, 1.1163737124158366) 1234567import matplotlib.pyplot as pltimport pandas as pddata = &#123;'series1':[1,3,4,3,5],'series2':[2,4,5,2,4],'series3':[3,2,3,1,3]&#125;df = pd.DataFrame(data)df['series1'].plot(kind='pie',figsize=(6,6)) &lt;matplotlib.axes._subplots.AxesSubplot at 0xf7d2ed0&gt; 7.15 高级图表 1937.15.1 等值线图 1931234567891011import matplotlib.pyplot as pltimport numpy as npdx = 0.01; dy = 0.01x = np.arange(-2.0,2.0,dx)y = np.arange(-2.0,2.0,dy)X,Y = np.meshgrid(x,y)def f(x,y): return (1 - y**5 + x**5)*np.exp(-x**2-y**2)C = plt.contour(X,Y,f(X,Y),8,colors='black')plt.contourf(X,Y,f(X,Y),8)plt.clabel(C, inline=1, fontsize=10) &lt;a list of 16 text.Text objects&gt; 12345678910import matplotlib.pyplot as pltimport numpy as npdx = 0.01; dy = 0.01x = np.arange(-2.0,2.0,dx)y = np.arange(-2.0,2.0,dy)X,Y = np.meshgrid(x,y)C = plt.contour(X,Y,f(X,Y),8,colors='black')plt.contourf(X,Y,f(X,Y),8,cmap=plt.cm.hot)plt.clabel(C, inline=1, fontsize=10)plt.colorbar() &lt;matplotlib.colorbar.Colorbar at 0x1100f0b0&gt; 7.15.2 极区图 195123456789import matplotlib.pyplot as pltimport numpy as npN = 8theta = np.arange(0.,2 * np.pi, 2 * np.pi / N)radii = np.array([4,7,5,3,1,5,6,7])plt.axes([0.025, 0.025, 0.95, 0.95], polar=True)colors = np.array(['#4bb2c5', '#c5b47f', '#EAA228', '#579575', '#839557', '#958c12','#953579', '#4b5de4'])bars = plt.bar(theta, radii, width=(2*np.pi/N), bottom=0.0, color=colors) 123456789import matplotlib.pyplot as pltimport numpy as npN = 8theta = np.arange(0.,2 * np.pi, 2 * np.pi / N)radii = np.array([4,7,5,3,1,5,6,7])plt.axes([0.025, 0.025, 0.95, 0.95], polar=True)colors = np.array(['lightgreen', 'darkred', 'navy', 'brown', 'violet', 'plum','yellow', 'darkgreen'])bars = plt.bar(theta, radii, width=(2*np.pi/N), bottom=0.0, color=colors) 7.16 mplot3d 1977.16.1 3D曲面 19712345678910from mpl_toolkits.mplot3d import Axes3Dimport matplotlib.pyplot as pltfig = plt.figure()ax = Axes3D(fig)X = np.arange(-2,2,0.1)Y = np.arange(-2,2,0.1)X,Y = np.meshgrid(X,Y)def f(x,y): return (1 - y**5 + x**5)*np.exp(-x**2-y**2)ax.plot_surface(X,Y,f(X,Y), rstride=1, cstride=1) &lt;mpl_toolkits.mplot3d.art3d.Poly3DCollection at 0x11eade50&gt; 1234567891011from mpl_toolkits.mplot3d import Axes3Dimport matplotlib.pyplot as pltfig = plt.figure()ax = Axes3D(fig)X = np.arange(-2,2,0.1)Y = np.arange(-2,2,0.1)X,Y = np.meshgrid(X,Y)def f(x,y): return (1 - y**5 + x**5)*np.exp(-x**2-y**2)ax.plot_surface(X,Y,f(X,Y), rstride=1, cstride=1, cmap=plt.cm.hot)ax.view_init(elev=30,azim=125) 7.16.2 3D散点图 1981234567891011121314151617181920import matplotlib.pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3Dxs = np.random.randint(30,40,100)ys = np.random.randint(20,30,100)zs = np.random.randint(10,20,100)xs2 = np.random.randint(50,60,100)ys2 = np.random.randint(30,40,100)zs2 = np.random.randint(50,70,100)xs3 = np.random.randint(10,30,100)ys3 = np.random.randint(40,50,100)zs3 = np.random.randint(40,50,100)fig = plt.figure()ax = Axes3D(fig)ax.scatter(xs,ys,zs)ax.scatter(xs2,ys2,zs2,c='r',marker='^')ax.scatter(xs3,ys3,zs3,c='g',marker='*')ax.set_xlabel('X Label')ax.set_ylabel('Y Label')ax.set_zlabel('Z Label') Text(0.5,0,&#39;Z Label&#39;) 7.16.3 3D条状图 19912345678910111213141516171819202122import matplotlib.pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3Dx = np.arange(8)y = np.random.randint(0,10,8)y2 = y + np.random.randint(0,3,8)y3 = y2 + np.random.randint(0,3,8)y4 = y3 + np.random.randint(0,3,8)y5 = y4 + np.random.randint(0,3,8)clr = ['#4bb2c5', '#c5b47f', '#EAA228', '#579575', '#839557', '#958c12', '#953579','#4b5de4']fig = plt.figure()ax = Axes3D(fig)ax.bar(x,y,0,zdir='y',color=clr)ax.bar(x,y2,10,zdir='y',color=clr)ax.bar(x,y3,20,zdir='y',color=clr)ax.bar(x,y4,30,zdir='y',color=clr)ax.bar(x,y5,40,zdir='y',color=clr)ax.set_xlabel('X Axis')ax.set_ylabel('Y Axis')ax.set_zlabel('Z Axis')ax.view_init(elev=40) 7.17 多面板图形 2007.17.1 在其他子图中显示子图 2001234import matplotlib.pyplot as pltfig = plt.figure()ax = fig.add_axes([0.1,0.1,0.8,0.8])inner_ax = fig.add_axes([0.6,0.6,0.25,0.25]) 1234567891011import matplotlib.pyplot as pltimport numpy as npfig = plt.figure()ax = fig.add_axes([0.1,0.1,0.8,0.8])inner_ax = fig.add_axes([0.6,0.6,0.25,0.25])x1 = np.arange(10)y1 = np.array([1,2,7,1,5,2,4,2,3,1])x2 = np.arange(10)y2 = np.array([1,3,4,5,4,5,2,6,4,3])ax.plot(x1,y1)inner_ax.plot(x2,y2) [&lt;matplotlib.lines.Line2D at 0x12144fd0&gt;] 7.17.2 子图网格 20212345678import matplotlib.pyplot as pltgs = plt.GridSpec(3,3)fig = plt.figure(figsize=(6,6))fig.add_subplot(gs[1,:2])fig.add_subplot(gs[0,:2])fig.add_subplot(gs[2,0])fig.add_subplot(gs[:2,2])fig.add_subplot(gs[2,1:]) &lt;matplotlib.axes._subplots.AxesSubplot at 0x12177a70&gt; 123456789101112131415161718import matplotlib.pyplot as pltimport numpy as npgs = plt.GridSpec(3,3)fig = plt.figure(figsize=(6,6))x1 = np.array([1,3,2,5])y1 = np.array([4,3,7,2])x2 = np.arange(5)y2 = np.array([3,2,4,6,4])s1 = fig.add_subplot(gs[1,:2])s1.plot(x,y,'r')s2 = fig.add_subplot(gs[0,:2])s2.bar(x2,y2)s3 = fig.add_subplot(gs[2,0])s3.barh(x2,y2,color='g')s4 = fig.add_subplot(gs[:2,2])s4.plot(x2,y2,'k')s5 = fig.add_subplot(gs[2,1:])s5.plot(x1,y1,'b^',x2,y2,'yo') [&lt;matplotlib.lines.Line2D at 0x1238a410&gt;, &lt;matplotlib.lines.Line2D at 0x1238a4d0&gt;] 7.18 小结 204]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
        <category>matplotlib</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第6章-深入pandas数据处理]]></title>
    <url>%2F2018%2F04%2F12%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC6%E7%AB%A0-%E6%B7%B1%E5%85%A5pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[第6章 深入pandas：数据处理 1176.1 数据准备 117合并 1234567891011#merge是两个dataframe共同包含的项import numpy as npimport pandas as pdframe1 = pd.DataFrame( &#123;'id':['ball','pencil','pen','mug','ashtray'], 'price': [12.33,11.44,33.21,13.23,33.62]&#125;)print(frame1)print()frame2 = pd.DataFrame( &#123;'id':['pencil','pencil','ball','pen'],'color': ['white','red','red','black']&#125;)print(frame2)print()temp = pd.merge(frame1,frame2)print(temp) id price 0 ball 12.33 1 pencil 11.44 2 pen 33.21 3 mug 13.23 4 ashtray 33.62 color id 0 white pencil 1 red pencil 2 red ball 3 black pen id price color 0 ball 12.33 red 1 pencil 11.44 white 2 pencil 11.44 red 3 pen 33.21 black 1234567891011121314151617181920frame1 = pd.DataFrame( &#123;'id':['ball','pencil','pen','mug','ashtray'], 'color': ['white','red','red','black','green'], 'brand': ['OMG','ABC','ABC','POD','POD']&#125;)print(frame1)print()frame2 = pd.DataFrame( &#123;'id':['pencil','pencil','ball','pen'], 'brand': ['OMG','POD','ABC','POD']&#125;)print(frame2)print()temp = pd.merge(frame1,frame2)print(temp)print()temp = pd.merge(frame1,frame2,on='id')print(temp)print()temp = pd.merge(frame1,frame2,on='brand')print(temp) brand color id 0 OMG white ball 1 ABC red pencil 2 ABC red pen 3 POD black mug 4 POD green ashtray brand id 0 OMG pencil 1 POD pencil 2 ABC ball 3 POD pen Empty DataFrame Columns: [brand, color, id] Index: [] brand_x color id brand_y 0 OMG white ball ABC 1 ABC red pencil OMG 2 ABC red pencil POD 3 ABC red pen POD brand color id_x id_y 0 OMG white ball pencil 1 ABC red pencil ball 2 ABC red pen ball 3 POD black mug pencil 4 POD black mug pen 5 POD green ashtray pencil 6 POD green ashtray pen 12345678print(frame1)print()frame2.columns = ['brand','sid']print(frame2)print()temp = pd.merge(frame1, frame2, left_on='id', right_on='sid')print(temp) brand color id 0 OMG white ball 1 ABC red pencil 2 ABC red pen 3 POD black mug 4 POD green ashtray brand sid 0 OMG pencil 1 POD pencil 2 ABC ball 3 POD pen brand_x color id brand_y sid 0 OMG white ball ABC ball 1 ABC red pencil OMG pencil 2 ABC red pencil POD pencil 3 ABC red pen POD pen 123frame2.columns = ['brand','id']temp = pd.merge(frame1,frame2,on='id')print(temp) brand_x color id brand_y 0 OMG white ball ABC 1 ABC red pencil OMG 2 ABC red pencil POD 3 ABC red pen POD 12temp = pd.merge(frame1,frame2,on='id',how='outer')print(temp) brand_x color id brand_y 0 OMG white ball ABC 1 ABC red pencil OMG 2 ABC red pencil POD 3 ABC red pen POD 4 POD black mug NaN 5 POD green ashtray NaN 12temp = pd.merge(frame1,frame2,on='id',how='left')print(temp) brand_x color id brand_y 0 OMG white ball ABC 1 ABC red pencil OMG 2 ABC red pencil POD 3 ABC red pen POD 4 POD black mug NaN 5 POD green ashtray NaN 12temp = pd.merge(frame1,frame2,on='id',how='right')print(temp) brand_x color id brand_y 0 OMG white ball ABC 1 ABC red pencil OMG 2 ABC red pencil POD 3 ABC red pen POD 12temp = pd.merge(frame1,frame2,on=['id','brand'],how='outer')print(temp) brand color id 0 OMG white ball 1 ABC red pencil 2 ABC red pen 3 POD black mug 4 POD green ashtray 5 OMG NaN pencil 6 POD NaN pencil 7 ABC NaN ball 8 POD NaN pen 根据索引合并 12temp = pd.merge(frame1,frame2,right_index=True, left_index=True) print(temp) brand_x color id_x brand_y id_y 0 OMG white ball OMG pencil 1 ABC red pencil POD pencil 2 ABC red pen ABC ball 3 POD black mug POD pen 123frame2.columns = ['brand2','id2']temp = frame1.join(frame2)print(temp) brand color id brand2 id2 0 OMG white ball OMG pencil 1 ABC red pencil POD pencil 2 ABC red pen ABC ball 3 POD black mug POD pen 4 POD green ashtray NaN NaN 6.2 拼接 12212array1 = np.arange(9).reshape((3,3))array1 array([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) 12array2 = np.arange(9).reshape((3,3))+6array2 array([[ 6, 7, 8], [ 9, 10, 11], [12, 13, 14]]) 1np.concatenate([array1,array2],axis=1) array([[ 0, 1, 2, 6, 7, 8], [ 3, 4, 5, 9, 10, 11], [ 6, 7, 8, 12, 13, 14]]) 1np.concatenate([array1,array2],axis=0) array([[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8], [ 6, 7, 8], [ 9, 10, 11], [12, 13, 14]]) 12ser1 = pd.Series(np.random.rand(4), index=[1,2,3,4])ser1 1 0.480270 2 0.440535 3 0.378281 4 0.799113 dtype: float64 12ser2 = pd.Series(np.random.rand(4), index=[5,6,7,8])ser2 5 0.134120 6 0.703728 7 0.657262 8 0.020803 dtype: float64 12temp = pd.concat([ser1,ser2])print(temp) 1 0.444507 2 0.690626 3 0.595412 4 0.030619 5 0.134120 6 0.703728 7 0.657262 8 0.020803 dtype: float64 12ser3 = pd.concat([ser1,ser2],axis=1)print(ser3) 0 1 1 0.444507 NaN 2 0.690626 NaN 3 0.595412 NaN 4 0.030619 NaN 5 NaN 0.134120 6 NaN 0.703728 7 NaN 0.657262 8 NaN 0.020803 12temp = pd.concat([ser1,ser3],axis=1,join='inner')print(temp) 0 0 1 1 0.444507 0.444507 NaN 2 0.690626 0.690626 NaN 3 0.595412 0.595412 NaN 4 0.030619 0.030619 NaN 12temp = pd.concat([ser1,ser2], keys=[1,2])print(temp) 1 1 0.444507 2 0.690626 3 0.595412 4 0.030619 2 5 0.134120 6 0.703728 7 0.657262 8 0.020803 dtype: float64 12temp = pd.concat([ser1,ser2], axis=1, keys=[1,2])print(temp) 1 2 1 0.444507 NaN 2 0.690626 NaN 3 0.595412 NaN 4 0.030619 NaN 5 NaN 0.134120 6 NaN 0.703728 7 NaN 0.657262 8 NaN 0.020803 12345678frame1 = pd.DataFrame(np.random.rand(9).reshape(3,3), index=[1,2,3], columns=['A','B','C'])print(frame1)print()frame2 = pd.DataFrame(np.random.rand(9).reshape(3,3), index=[4,5,6], columns=['A','B','C'])print(frame2)print()temp = pd.concat([frame1, frame2])print(temp) A B C 1 0.918894 0.884497 0.451266 2 0.990586 0.412664 0.289380 3 0.058831 0.746895 0.911668 A B C 4 0.256936 0.837374 0.677940 5 0.379119 0.453602 0.858519 6 0.832512 0.736023 0.583485 A B C 1 0.918894 0.884497 0.451266 2 0.990586 0.412664 0.289380 3 0.058831 0.746895 0.911668 4 0.256936 0.837374 0.677940 5 0.379119 0.453602 0.858519 6 0.832512 0.736023 0.583485 12temp = pd.concat([frame1, frame2], axis=1)print(temp) A B C A B C 1 0.918894 0.884497 0.451266 NaN NaN NaN 2 0.990586 0.412664 0.289380 NaN NaN NaN 3 0.058831 0.746895 0.911668 NaN NaN NaN 4 NaN NaN NaN 0.256936 0.837374 0.677940 5 NaN NaN NaN 0.379119 0.453602 0.858519 6 NaN NaN NaN 0.832512 0.736023 0.583485 6.2.1 组合 12412345678ser1 = pd.Series(np.random.rand(5),index=[1,2,3,4,5])print(ser1)print()ser2 = pd.Series(np.random.rand(4),index=[2,4,5,6])print(ser2)print()temp = ser1.combine_first(ser2)print(temp) 1 0.598971 2 0.143975 3 0.080446 4 0.437893 5 0.033583 dtype: float64 2 0.326416 4 0.732483 5 0.476231 6 0.468597 dtype: float64 1 0.598971 2 0.143975 3 0.080446 4 0.437893 5 0.033583 6 0.468597 dtype: float64 12temp = ser2.combine_first(ser1)print(temp) 1 0.598971 2 0.326416 3 0.080446 4 0.732483 5 0.476231 6 0.468597 dtype: float64 12temp = ser1[:3].combine_first(ser2[:3])print(temp) 1 0.598971 2 0.143975 3 0.080446 4 0.732483 5 0.476231 dtype: float64 6.2.2 轴向旋转 125按等级索引旋转123456frame1 = pd.DataFrame(np.arange(9).reshape(3,3),index=['white','black','red'],columns=['ball','pen','pencil'])print(frame1)ser5 = frame1.stack()ser5 ball pen pencil white 0 1 2 black 3 4 5 red 6 7 8 white ball 0 pen 1 pencil 2 black ball 3 pen 4 pencil 5 red ball 6 pen 7 pencil 8 dtype: int32 12temp = ser5.unstack()print(temp) ball pen pencil white 0 1 2 black 3 4 5 red 6 7 8 12temp = ser5.unstack(0)print(temp) white black red ball 0 3 6 pen 1 4 7 pencil 2 5 8 从长格式向宽格式旋转12345678longframe = pd.DataFrame(&#123; 'color':['white','white','white', 'red','red','red', 'black','black','black'], 'item':['ball','pen','mug', 'ball','pen','mug', 'ball','pen','mug'], 'value': np.random.rand(9)&#125;)print(longframe) color item value 0 white ball 0.905908 1 white pen 0.476735 2 white mug 0.569165 3 red ball 0.483042 4 red pen 0.663438 5 red mug 0.866178 6 black ball 0.752131 7 black pen 0.616940 8 black mug 0.713100 12wideframe = longframe.pivot('color','item')print(wideframe) value item ball mug pen color black 0.752131 0.713100 0.616940 red 0.483042 0.866178 0.663438 white 0.905908 0.569165 0.476735 6.2.3 删除 127123456789frame1 = pd.DataFrame(np.arange(9).reshape(3,3), index=['white','black','red'], columns=['ball','pen','pencil'])print(frame1)del frame1['ball']print(frame1)temp = frame1.drop('white')print(temp)print(frame1) ball pen pencil white 0 1 2 black 3 4 5 red 6 7 8 pen pencil white 1 2 black 4 5 red 7 8 pen pencil black 4 5 red 7 8 pen pencil white 1 2 black 4 5 red 7 8 6.3 数据转换 1286.3.1 删除重复元素 1281234567dframe = pd.DataFrame(&#123; 'color': ['white','white','red','red','white'], 'value': [2,1,3,3,2]&#125;)print(dframe)temp = dframe.duplicated()print(temp)temp = dframe[dframe.duplicated()]print(temp) color value 0 white 2 1 white 1 2 red 3 3 red 3 4 white 2 0 False 1 False 2 False 3 True 4 True dtype: bool color value 3 red 3 4 white 2 6.3.2 映射 129用映射替换元素12345678910frame = pd.DataFrame(&#123; 'item':['ball','mug','pen','pencil','ashtray'], 'color':['white','rosso','verde','black','yellow'],'price':[5.56,4.20,1.30,0.56,2.75]&#125;)print(frame)newcolors = &#123; 'rosso': 'red', 'verde': 'green' &#125;temp = frame.replace(newcolors)print(temp) color item price 0 white ball 5.56 1 rosso mug 4.20 2 verde pen 1.30 3 black pencil 0.56 4 yellow ashtray 2.75 color item price 0 white ball 5.56 1 red mug 4.20 2 green pen 1.30 3 black pencil 0.56 4 yellow ashtray 2.75 1234ser = pd.Series([1,3,np.nan,4,6,np.nan,3])print(ser)temp = ser.replace(np.nan,0)print(temp) 0 1.0 1 3.0 2 NaN 3 4.0 4 6.0 5 NaN 6 3.0 dtype: float64 0 1.0 1 3.0 2 0.0 3 4.0 4 6.0 5 0.0 6 3.0 dtype: float64 用映射添加元素1234567891011121314frame = pd.DataFrame(&#123; 'item':['ball','mug','pen','pencil','ashtray'], 'color':['white','red','green','black','yellow']&#125;)print(frame)price = &#123; 'ball' : 5.56, 'mug' : 4.20, 'bottle' : 1.30, 'scissors' : 3.41, 'pen' : 1.30, 'pencil' : 0.56, 'ashtray' : 2.75 &#125;frame['price'] = frame['item'].map(price)print(frame) color item 0 white ball 1 red mug 2 green pen 3 black pencil 4 yellow ashtray color item price 0 white ball 5.56 1 red mug 4.20 2 green pen 1.30 3 black pencil 0.56 4 yellow ashtray 2.75 重命名轴索引12345678reindex = &#123; 0: 'first', 1: 'second', 2: 'third', 3: 'fourth', 4: 'fifth'&#125;temp = frame.rename(reindex)print(temp) color item price first white ball 5.56 second red mug 4.20 third green pen 1.30 fourth black pencil 0.56 fifth yellow ashtray 2.75 12345recolumn = &#123; 'item':'object', 'price': 'value'&#125;temp = frame.rename(index=reindex, columns=recolumn)print(temp) color object value first white ball 5.56 second red mug 4.20 third green pen 1.30 fourth black pencil 0.56 fifth yellow ashtray 2.75 12temp = frame.rename(index=&#123;1:'first'&#125;, columns=&#123;'item':'object'&#125;)print(temp) color object price 0 white ball 5.56 first red mug 4.20 2 green pen 1.30 3 black pencil 0.56 4 yellow ashtray 2.75 6.4 离散化和面元划分 1321234results = [12,34,67,55,28,90,99,12,3,56,74,44,87,23,49,89,87]bins = [0,25,50,75,100]cat = pd.cut(results, bins)cat [(0, 25], (25, 50], (50, 75], (50, 75], (25, 50], ..., (75, 100], (0, 25], (25, 50], (75, 100], (75, 100]] Length: 17 Categories (4, interval[int64]): [(0, 25] &lt; (25, 50] &lt; (50, 75] &lt; (75, 100]] 1cat.labels D:\ProgramData\Anaconda3_32\lib\site-packages\ipykernel_launcher.py:1: FutureWarning: &#39;labels&#39; is deprecated. Use &#39;codes&#39; instead &quot;&quot;&quot;Entry point for launching an IPython kernel. array([0, 1, 2, 2, 1, 3, 3, 0, 0, 2, 2, 1, 3, 0, 1, 3, 3], dtype=int8) 1pd.value_counts(cat) (75, 100] 5 (50, 75] 4 (25, 50] 4 (0, 25] 4 dtype: int64 12bin_names = ['unlikely','less likely','likely','highly likely']pd.cut(results, bins, labels=bin_names) [unlikely, less likely, likely, likely, less likely, ..., highly likely, unlikely, less likely, highly likely, highly likely] Length: 17 Categories (4, object): [unlikely &lt; less likely &lt; likely &lt; highly likely] 1pd.cut(results, 5) [(2.904, 22.2], (22.2, 41.4], (60.6, 79.8], (41.4, 60.6], (22.2, 41.4], ..., (79.8, 99.0], (22.2, 41.4], (41.4, 60.6], (79.8, 99.0], (79.8, 99.0]] Length: 17 Categories (5, interval[float64]): [(2.904, 22.2] &lt; (22.2, 41.4] &lt; (41.4, 60.6] &lt; (60.6, 79.8] &lt; (79.8, 99.0]] 12quintiles = pd.qcut(results, 5)quintiles [(2.999, 24.0], (24.0, 46.0], (62.6, 87.0], (46.0, 62.6], (24.0, 46.0], ..., (62.6, 87.0], (2.999, 24.0], (46.0, 62.6], (87.0, 99.0], (62.6, 87.0]] Length: 17 Categories (5, interval[float64]): [(2.999, 24.0] &lt; (24.0, 46.0] &lt; (46.0, 62.6] &lt; (62.6, 87.0] &lt; (87.0, 99.0]] 1pd.value_counts(quintiles) (62.6, 87.0] 4 (2.999, 24.0] 4 (87.0, 99.0] 3 (46.0, 62.6] 3 (24.0, 46.0] 3 dtype: int64 异常值检测和过滤123randframe = pd.DataFrame(np.random.randn(1000,3))temp = randframe.describe()print(temp) 0 1 2 count 1000.000000 1000.000000 1000.000000 mean -0.017081 0.009233 -0.016035 std 0.983899 0.986440 0.961825 min -3.834283 -3.725847 -2.810249 25% -0.651448 -0.645679 -0.674606 50% -0.031185 0.004074 -0.006893 75% 0.633531 0.721898 0.669395 max 3.006011 3.018671 3.290535 1randframe.std() 0 0.983899 1 0.986440 2 0.961825 dtype: float64 12temp = randframe[(np.abs(randframe) &gt; (3*randframe.std())).any(1)]print(temp) 0 1 2 66 -1.552807 1.813374 3.141080 169 -1.154864 -3.725847 -0.647544 226 -3.411732 1.907356 -0.004208 426 3.006011 0.554358 0.687883 457 -1.282513 -1.312958 3.290535 465 -3.834283 -0.310886 1.280224 748 2.977327 -0.937580 0.361383 764 -0.000591 3.018671 -1.180475 6.5 排序 13612nframe = pd.DataFrame(np.arange(25).reshape(5,5))print(nframe) 0 1 2 3 4 0 0 1 2 3 4 1 5 6 7 8 9 2 10 11 12 13 14 3 15 16 17 18 19 4 20 21 22 23 24 12new_order = np.random.permutation(5)print(new_order) [4 2 1 3 0] 12temp = nframe.take(new_order)print(temp) 0 1 2 3 4 4 20 21 22 23 24 2 10 11 12 13 14 1 5 6 7 8 9 3 15 16 17 18 19 0 0 1 2 3 4 123new_order = [3,4,2]temp = nframe.take(new_order)print(temp) 0 1 2 3 4 3 15 16 17 18 19 4 20 21 22 23 24 2 10 11 12 13 14 随机取样12sample = np.random.randint(0, len(nframe), size=3)sample array([3, 3, 3]) 12temp = nframe.take(sample)print(temp) 0 1 2 3 4 3 15 16 17 18 19 3 15 16 17 18 19 3 15 16 17 18 19 6.6 字符串处理 1376.6.1 内置的字符串处理方法 13712text = '16 Bolton Avenue , Boston'text.split(',') [&#39;16 Bolton Avenue &#39;, &#39; Boston&#39;] 12tokens = [s.strip() for s in text.split(',')]tokens [&#39;16 Bolton Avenue&#39;, &#39;Boston&#39;] 123address, city = [s.strip() for s in text.split(',')]print(address)print(city) 16 Bolton Avenue Boston 1address + ',' + city &#39;16 Bolton Avenue,Boston&#39; 12strings = ['A+','A','A-','B','BB','BBB','C+']';'.join(strings) &#39;A+;A;A-;B;BB;BBB;C+&#39; 1'Boston' in text True 1text.index('Boston') 19 1text.find('Boston') 19 1text.index('New York') --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-113-e44f5210d36c&gt; in &lt;module&gt;() ----&gt; 1 text.index(&#39;New York&#39;) ValueError: substring not found 1text.count('e') 2 1text.count('Avenue') 1 1text.replace('Avenue','Street') &#39;16 Bolton Street , Boston&#39; 1text.replace('1','') &#39;6 Bolton Avenue , Boston&#39; 6.6.2 正则表达式 139123import retext = "This is an\t odd \n text!"re.split('\s+', text) [&#39;This&#39;, &#39;is&#39;, &#39;an&#39;, &#39;odd&#39;, &#39;text!&#39;] 12regex = re.compile('\s+')regex.split(text) [&#39;This&#39;, &#39;is&#39;, &#39;an&#39;, &#39;odd&#39;, &#39;text!&#39;] 12text = 'This is my address: 16 Bolton Avenue, Boston're.findall('A\w+',text) [&#39;Avenue&#39;] 1re.findall('[A,a]\w+',text) [&#39;address&#39;, &#39;Avenue&#39;] 1re.search('[A,a]\w+',text) &lt;_sre.SRE_Match object; span=(11, 18), match=&#39;address&#39;&gt; 12search = re.search('[A,a]\w+',text)search.start() 11 1search.end() 18 1text[search.start():search.end()] &#39;address&#39; 1re.match('[A,a]\w+',text) 1re.match('T\w+',text) &lt;_sre.SRE_Match object; span=(0, 4), match=&#39;This&#39;&gt; 12match = re.match('T\w+',text)text[match.start():match.end()] &#39;This&#39; 6.7 数据聚合 1406.7.1 GroupBy 141 6.7.2 实例 14112345frame = pd.DataFrame(&#123; 'color': ['white','red','green','red','green'], 'object': ['pen','pencil','pencil','ashtray','pen'], 'price1' : [5.56,4.20,1.30,0.56,2.75], 'price2' : [4.75,4.12,1.60,0.75,3.15]&#125;)print(frame) color object price1 price2 0 white pen 5.56 4.75 1 red pencil 4.20 4.12 2 green pencil 1.30 1.60 3 red ashtray 0.56 0.75 4 green pen 2.75 3.15 12group = frame['price1'].groupby(frame['color'])group &lt;pandas.core.groupby.SeriesGroupBy object at 0x06923E30&gt; 1group.groups {&#39;green&#39;: Int64Index([2, 4], dtype=&#39;int64&#39;), &#39;red&#39;: Int64Index([1, 3], dtype=&#39;int64&#39;), &#39;white&#39;: Int64Index([0], dtype=&#39;int64&#39;)} 1group.mean() color green 2.025 red 2.380 white 5.560 Name: price1, dtype: float64 1group.sum() color green 4.05 red 4.76 white 5.56 Name: price1, dtype: float64 12ggroup = frame['price1'].groupby([frame['color'],frame['object']])ggroup.groups {(&#39;green&#39;, &#39;pen&#39;): Int64Index([4], dtype=&#39;int64&#39;), (&#39;green&#39;, &#39;pencil&#39;): Int64Index([2], dtype=&#39;int64&#39;), (&#39;red&#39;, &#39;ashtray&#39;): Int64Index([3], dtype=&#39;int64&#39;), (&#39;red&#39;, &#39;pencil&#39;): Int64Index([1], dtype=&#39;int64&#39;), (&#39;white&#39;, &#39;pen&#39;): Int64Index([0], dtype=&#39;int64&#39;)} 1ggroup.sum() color object green pen 2.75 pencil 1.30 red ashtray 0.56 pencil 4.20 white pen 5.56 Name: price1, dtype: float64 6.7.3 等级分组 14212temp = frame[['price1','price2']].groupby(frame['color']).mean()print(temp) price1 price2 color green 2.025 2.375 red 2.380 2.435 white 5.560 4.750 12temp = frame.groupby(frame['color']).mean()print(temp) price1 price2 color green 2.025 2.375 red 2.380 2.435 white 5.560 4.750 6.8 组迭代 143123for name, group in frame.groupby('color'): print(name) print(group) green color object price1 price2 2 green pencil 1.30 1.60 4 green pen 2.75 3.15 red color object price1 price2 1 red pencil 4.20 4.12 3 red ashtray 0.56 0.75 white color object price1 price2 0 white pen 5.56 4.75 6.8.1 链式转换 14412result1 = frame['price1'].groupby(frame['color']).mean()type(result1) pandas.core.series.Series 12result2 = frame.groupby(frame['color']).mean()type(result2) pandas.core.frame.DataFrame 1frame['price1'].groupby(frame['color']).mean() color green 2.025 red 2.380 white 5.560 Name: price1, dtype: float64 1frame.groupby(frame['color'])['price1'].mean() color green 2.025 red 2.380 white 5.560 Name: price1, dtype: float64 1(frame.groupby(frame['color']).mean())['price1'] color green 2.025 red 2.380 white 5.560 Name: price1, dtype: float64 12means = frame.groupby('color').mean().add_prefix('mean_')print(means) mean_price1 mean_price2 color green 2.025 2.375 red 2.380 2.435 white 5.560 4.750 6.8.2 分组函数 14512group = frame.groupby('color')group['price1'].quantile(0.6) color green 2.170 red 2.744 white 5.560 Name: price1, dtype: float64 12def myrange(series): return series.max() - series.min() 1group['price1'].agg(myrange) color green 1.45 red 3.64 white 0.00 Name: price1, dtype: float64 12temp = group.agg(myrange)print(temp) price1 price2 color green 1.45 1.55 red 3.64 3.37 white 0.00 0.00 12temp = group['price1'].agg(['mean','std',myrange])print(temp) mean std myrange color green 2.025 1.025305 1.45 red 2.380 2.573869 3.64 white 5.560 NaN 0.00 6.9 高级数据聚合 1451234frame = pd.DataFrame(&#123; 'color':['white','red','green','red','green'], 'price1':[5.56,4.20,1.30,0.56,2.75], 'price2':[4.75,4.12,1.60,0.75,3.15]&#125;)print(frame) color price1 price2 0 white 5.56 4.75 1 red 4.20 4.12 2 green 1.30 1.60 3 red 0.56 0.75 4 green 2.75 3.15 12sums = frame.groupby('color').sum().add_prefix('tot_')print(sums) tot_price1 tot_price2 color green 4.05 4.75 red 4.76 4.87 white 5.56 4.75 12temp = pd.merge(frame,sums,left_on='color',right_index=True)print(temp) color price1 price2 tot_price1 tot_price2 0 white 5.56 4.75 5.56 4.75 1 red 4.20 4.12 4.76 4.87 3 red 0.56 0.75 4.76 4.87 2 green 1.30 1.60 4.05 4.75 4 green 2.75 3.15 4.05 4.75 12temp = frame.groupby('color').transform(np.sum).add_prefix('tot_')print(temp) tot_price1 tot_price2 0 5.56 4.75 1 4.76 4.87 2 4.05 4.75 3 4.76 4.87 4 4.05 4.75 12345frame = pd.DataFrame( &#123; 'color':['white','black','white','white','black','black'], 'status':['up','up','down','down','down','up'], 'value1':[12.33,14.55,22.34,27.84,23.40,18.33], 'value2':[11.23,31.80,29.99,31.18,18.25,22.44]&#125;)print(frame) color status value1 value2 0 white up 12.33 11.23 1 black up 14.55 31.80 2 white down 22.34 29.99 3 white down 27.84 31.18 4 black down 23.40 18.25 5 black up 18.33 22.44 12temp = frame.groupby(['color','status']).apply( lambda x: x.max())print(temp) color status value1 value2 color status black down black down 23.40 18.25 up black up 18.33 31.80 white down white down 27.84 31.18 up white up 12.33 11.23 12temp = frame.rename(index=reindex, columns=recolumn)print(temp) color status value1 value2 first white up 12.33 11.23 second black up 14.55 31.80 third white down 22.34 29.99 fourth white down 27.84 31.18 fifth black down 23.40 18.25 5 black up 18.33 22.44 12temp = pd.date_range('1/1/2015', periods=10, freq= 'H')print(temp) DatetimeIndex([&#39;2015-01-01 00:00:00&#39;, &#39;2015-01-01 01:00:00&#39;, &#39;2015-01-01 02:00:00&#39;, &#39;2015-01-01 03:00:00&#39;, &#39;2015-01-01 04:00:00&#39;, &#39;2015-01-01 05:00:00&#39;, &#39;2015-01-01 06:00:00&#39;, &#39;2015-01-01 07:00:00&#39;, &#39;2015-01-01 08:00:00&#39;, &#39;2015-01-01 09:00:00&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;H&#39;) 12timeseries = pd.Series(np.random.rand(10), index=temp)timeseries 2015-01-01 00:00:00 0.463135 2015-01-01 01:00:00 0.170738 2015-01-01 02:00:00 0.542155 2015-01-01 03:00:00 0.536056 2015-01-01 04:00:00 0.606624 2015-01-01 05:00:00 0.011034 2015-01-01 06:00:00 0.277493 2015-01-01 07:00:00 0.301076 2015-01-01 08:00:00 0.170235 2015-01-01 09:00:00 0.165120 Freq: H, dtype: float64 123timetable = pd.DataFrame( &#123;'date': temp, 'value1' : np.random.rand(10), 'value2' : np.random.rand(10)&#125;)print(timetable) date value1 value2 0 2015-01-01 00:00:00 0.783525 0.025861 1 2015-01-01 01:00:00 0.829443 0.642484 2 2015-01-01 02:00:00 0.260990 0.350753 3 2015-01-01 03:00:00 0.699793 0.118472 4 2015-01-01 04:00:00 0.349411 0.228708 5 2015-01-01 05:00:00 0.382496 0.902575 6 2015-01-01 06:00:00 0.896227 0.934669 7 2015-01-01 07:00:00 0.829987 0.941199 8 2015-01-01 08:00:00 0.479027 0.203317 9 2015-01-01 09:00:00 0.132429 0.102593 12timetable['cat'] = ['up','down','left','left','up','up','down','right','right','up']print(timetable) date value1 value2 cat 0 2015-01-01 00:00:00 0.783525 0.025861 up 1 2015-01-01 01:00:00 0.829443 0.642484 down 2 2015-01-01 02:00:00 0.260990 0.350753 left 3 2015-01-01 03:00:00 0.699793 0.118472 left 4 2015-01-01 04:00:00 0.349411 0.228708 up 5 2015-01-01 05:00:00 0.382496 0.902575 up 6 2015-01-01 06:00:00 0.896227 0.934669 down 7 2015-01-01 07:00:00 0.829987 0.941199 right 8 2015-01-01 08:00:00 0.479027 0.203317 right 9 2015-01-01 09:00:00 0.132429 0.102593 up 6.10 小结 148]]></content>
      <categories>
        <category>pandas</category>
        <category>python</category>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-zip函数使用]]></title>
    <url>%2F2018%2F04%2F12%2Fpython-zip%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[zip((1,2,3),(10,20,30),(100,200,300))[(1, 10, 100), (2, 20, 200), (3, 30, 300)] [sum(x) for x in zip((1,2,3),(10,20,30),(100,200,300))][111, 222, 333]To do this with an arbitrarily large set of tuples: myTuples = [(1,2,3), (10,20,30), (100,200,300)][sum(x) for x in zip(*myTuples)][111, 222, 333]sidenote: in python3, note that zip returns a lazy iterable, which you can always explicitly turn into a list like any other kind of iterable: list(zip(…))]]></content>
      <tags>
        <tag>python</tag>
        <tag>zip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL数据库基本操作]]></title>
    <url>%2F2018%2F04%2F12%2FPostgreSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[postgresql学习站点 创建用户 12345sudo -s -u postgrespsqlpostgres# CREATE USER xxxx1 WITH PASSWORD &apos;xxxx&apos;;postgres# CREATE DATABASE xxxx2;postgres# GRANT ALL PRIVILEGES ON DATABASE xxxx2 to xxxx1; 修改密码 1alter user postgres with password &apos;foobar&apos;; 创建数据库 12345createdb--encoding=UTF8 --owner=foo --template=template_postgis -Ufoo 参数： --encoding=UTF8 设置数据库的字符集 --owner=foo 设置数据库的所有者 --tmplate=template_postgis 设置建库的模板，该模板支持空间数据操作 --Ufoo 用foo用户身份建立数据库]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-mysql-python2和3的差异]]></title>
    <url>%2F2018%2F04%2F12%2Fpython-mysql-python2%E5%92%8C3%E7%9A%84%E5%B7%AE%E5%BC%82%2F</url>
    <content type="text"><![CDATA[运行12from sqlalchemy import create_engineengine = create_engine(&apos;mysql+mysqldb://scott:tiger@localhost/foo&apos;) 提示：No module named MySQLdb 对于python2和python3安装的软件包不一样1234pip install mysql-python (mix os/ python 2)pip install mysqlclient (mix os/ python 3)apt-get install python-mysqldb (Linux Ubuntu, ...)]]></content>
      <tags>
        <tag>python</tag>
        <tag>mysql</tag>
        <tag>sqlalchemy</tag>
        <tag>MySQLdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第5章-pandas数据读写]]></title>
    <url>%2F2018%2F04%2F12%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%AB%A0-pandas%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[第5章 pandas：数据读写 915.1 I/O API 工具 915.2 CSV和文本文件 925.3 读取CSV或文本文件中的数据 921from pandas import * myCSV_01.csvwhite,red,blue,green,animal1,5,2,3,cat2,7,8,5,dog3,3,6,7,horse2,2,8,3,duck4,4,2,1,mouse 12csvframe = read_csv('myCSV_01.csv')print(csvframe) white red blue green animal 0 1 5 2 3 cat 1 2 7 8 5 dog 2 3 3 6 7 horse 3 2 2 8 3 duck 4 4 4 2 1 mouse white,red,blue,green,animal1,5,2,3,cat2,7,8,5,dog3,3,6,7,horse2,2,8,3,duck4,4,2,1,mouse 12temp = read_table('ch05_01.csv',sep=',')print(temp) white red blue green animal 0 1 5 2 3 cat 1 2 7 8 5 dog 2 3 3 6 7 horse 3 2 2 8 3 duck 4 4 4 2 1 mouse 1,5,2,3,cat2,7,8,5,dog3,3,6,7,horse2,2,8,3,duck4,4,2,1,mouse 12temp = read_csv('ch05_02.csv')print(temp) 1 5 2 3 cat 0 2 7 8 5 dog 1 3 3 6 7 horse 2 2 2 8 3 duck 3 4 4 2 1 mouse 12temp = read_csv('ch05_02.csv', header=None)print(temp) 0 1 2 3 4 0 1 5 2 3 cat 1 2 7 8 5 dog 2 3 3 6 7 horse 3 2 2 8 3 duck 4 4 4 2 1 mouse 12temp = read_csv('ch05_02.csv', names=['white','red','blue','green','animal'])print(temp) white red blue green animal 0 1 5 2 3 cat 1 2 7 8 5 dog 2 3 3 6 7 horse 3 2 2 8 3 duck 4 4 4 2 1 mouse color,status,item1,item2,item3black,up,3,4,6black,down,2,6,7white,up,5,5,5white,down,3,3,2white,left,1,2,1red,up,2,2,2red,down,1,1,4 12temp = read_csv('ch05_03.csv', index_col=['color','status'])print(temp) item1 item2 item3 color status black up 3 4 6 down 2 6 7 white up 5 5 5 down 3 3 2 left 1 2 1 red up 2 2 2 down 1 1 4 5.3.1 用RegExp解析TXT文件 94white red blue green1 5 2 32 7 8 5 3 3 6 7 12temp = read_table('ch05_04.txt',sep='\s+')print(temp) white red blue green 0 1 5 2 3 1 2 7 8 5 2 3 3 6 7 ch05_05.txt000END123AAA122001END124BBB321002END125CCC333 12temp = read_table('ch05_05.txt',sep='\D+',header=None)print(temp) 0 1 2 0 0 123 122 1 1 124 321 2 2 125 333 D:\ProgramData\Anaconda3_32\lib\site-packages\ipykernel_launcher.py:1: ParserWarning: Falling back to the &#39;python&#39; engine because the &#39;c&#39; engine does not support regex separators (separators &gt; 1 char and different from &#39;\s+&#39; are interpreted as regex); you can avoid this warning by specifying engine=&#39;python&#39;. &quot;&quot;&quot;Entry point for launching an IPython kernel. Table 5-1. Metacharacters. single character, except newline\d digit\D non-digit character\s whitespace character\S non-whitespace character\n new line character\t tab character\uxxxx unicode character specified by the hexadecimal number xxxxch05_06.txt ##### LOG FILEThis file has been generated by automatic systemwhite,red,blue,green,animal12-Feb-2015: Counting of animals inside the house1,5,2,3,cat2,7,8,5,dog13-Feb-2015: Counting of animals outside the house3,3,6,7,horse2,2,8,3,duck4,4,2,1,mouse 12temp = read_table('ch05_06.txt',sep=',',skiprows=[0,1,3,6])print(temp) white red blue green animal 0 1 5 2 3 cat 1 2 7 8 5 dog 2 3 3 6 7 horse 3 2 2 8 3 duck 4 4 4 2 1 mouse 5.3.2 从TXT文件读取部分数据 961,5,2,3,cat2,7,8,5,dog3,3,6,7,horse2,2,8,3,duck4,4,2,1,mouse 12temp = read_csv('ch05_02.csv',skiprows=[2],nrows=3,header=None)print(temp) 0 1 2 3 4 0 1 5 2 3 cat 1 2 7 8 5 dog 2 2 2 8 3 duck white,red,blue,green,animal1,5,2,3,cat2,7,8,5,dog3,3,6,7,horse2,2,8,3,duck4,4,2,1,mouse 12345678out = Series()i = 0pieces = read_csv('ch05_01.csv',chunksize=3)for piece in pieces: print(piece) out.set_value(i,piece['white'].sum()) i = i + 1print(out) white red blue green animal 0 1 5 2 3 cat 1 2 7 8 5 dog 2 3 3 6 7 horse white red blue green animal 3 2 2 8 3 duck 4 4 4 2 1 mouse 0 6 1 6 dtype: int64 5.3.3 往CSV文件写入数据 97123import numpy as npframe2 = DataFrame(np.arange(16).reshape((4,4)), columns = ['ball','pen','pencil','paper'])print(frame2) ball pen pencil paper 0 0 1 2 3 1 4 5 6 7 2 8 9 10 11 3 12 13 14 15 1frame2.to_csv('ch05_07.csv') 1frame2.to_csv('ch05_07b.csv', index=False, header=False) 12frame3 = read_csv('ch05_08.csv')print(frame3) Unnamed: 0 ball mug paper pen pencil 0 blue 6.0 NaN NaN 6.0 NaN 1 green NaN NaN NaN NaN NaN 2 red NaN NaN NaN NaN NaN 3 white 20.0 NaN NaN 20.0 NaN 4 yellow 19.0 NaN NaN 19.0 NaN 1frame3.to_csv('ch05_08.csv') 1frame3.to_csv('ch05_09.csv', na_rep ='NaN') ch05_08.csv,ball,mug,paper,pen,pencilblue,6.0,,,6.0,green,,,,,red,,,,,white,20.0,,,20.0,yellow,19.0,,,19.0,ch05_09.csv,ball,mug,paper,pen,pencilblue,6.0,NaN,NaN,6.0,NaNgreen,NaN,NaN,NaN,NaN,NaNred,NaN,NaN,NaN,NaN,NaNwhite,20.0,NaN,NaN,20.0,NaNyellow,19.0,NaN,NaN,19.0,NaN 5.4 读写HTML文件 985.4.1 写入数据到HTML文件 9912import pandas as pdframe = pd.DataFrame(np.arange(4).reshape(2,2)) 1print(frame.to_html()) &lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt; &lt;thead&gt; &lt;tr style=&quot;text-align: right;&quot;&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;0&lt;/th&gt; &lt;th&gt;1&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;0&lt;/th&gt; &lt;td&gt;0&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;1&lt;/th&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 1234frame = pd.DataFrame( np.random.random((4,4)), index = ['white','black','red','blue'], columns = ['up','down','right','left'])print(frame) up down right left white 0.821537 0.070376 0.131624 0.718632 black 0.723164 0.409424 0.554343 0.361086 red 0.671485 0.993762 0.316291 0.999724 blue 0.834104 0.565786 0.922212 0.166467 12345678910s = ['&lt;HTML&gt;']s.append('&lt;HEAD&gt;&lt;TITLE&gt;My DataFrame&lt;/TITLE&gt;&lt;/HEAD&gt;')s.append('&lt;BODY&gt;')s.append(frame.to_html())s.append('&lt;/BODY&gt;&lt;/HTML&gt;')html = ''.join(s)html_file = open('myFrame.html','w')html_file.write(html)html_file.close() 打开html 5.4.2 从HTML文件读取数据 10012web_frames = pd.read_html('myFrame.html')print(web_frames[0]) Unnamed: 0 up down right left 0 white 0.821537 0.070376 0.131624 0.718632 1 black 0.723164 0.409424 0.554343 0.361086 2 red 0.671485 0.993762 0.316291 0.999724 3 blue 0.834104 0.565786 0.922212 0.166467 12ranking = pd.read_html('http://www.meccanismocomplesso.org/en/meccanismo-complesso-sito-2/classifica-punteggio/')print(ranking[0]) # Nome Exp Livelli 0 1 Fabio Nelli 17521 NaN 1 2 admin 9029 NaN 2 3 BrunoOrsini 2124 NaN 3 4 Berserker 700 NaN 4 5 Dnocioni 543 NaN 5 6 albertosallusti 409 NaN 6 7 Jon 231 NaN 7 8 Mr.Y 180 NaN 8 9 michele sisinni 157 NaN 9 10 Selina 136 NaN 10 11 Massimo 127 NaN 11 12 Beniamino Feula 122 NaN 12 13 stefano gustin 121 NaN 13 14 Maurizio Andreoli 111 NaN 14 15 Pietro Baima 108 NaN 15 16 Cecilia Lalatta Costerbosa 108 NaN 16 17 Leonardo Zampi 108 NaN 17 18 Davide Aloisi 106 NaN 18 19 gildalombardi 105 NaN 19 20 Telerobotlabs 104 NaN 20 21 Marco Contigiani 101 NaN 21 22 berillio 58 NaN 22 23 ron 55 NaN 23 24 Titanic4wd 43 NaN 24 25 deg 40 NaN 25 26 al45 40 NaN 26 27 il_mix 38 NaN 27 28 AndreaC 35 NaN 28 29 Sergio fly 32 NaN 29 30 bigazzi 32 NaN .. ... ... ... ... 220 221 pozi 3 NaN 221 222 mattia 3 NaN 222 223 mauro.menegazzi 3 NaN 223 224 cico89 3 NaN 224 225 eta38 3 NaN 225 226 Chinje Chang 3 NaN 226 227 fraschettin 2 NaN 227 228 Rocco 2 NaN 228 229 Dimitri 2 NaN 229 230 Arturo 2 NaN 230 231 Paolo Indennidate 2 NaN 231 232 fabioroberto 2 NaN 232 233 ycomyca 2 NaN 233 234 bdb 2 NaN 234 235 paolotirispetta 2 NaN 235 236 Roberto72 2 NaN 236 237 Christian76 2 NaN 237 238 paolos46 2 NaN 238 239 Giolat90 2 NaN 239 240 giampyypmaig 1 NaN 240 241 Marco Corbetta 1 NaN 241 242 softeng 1 NaN 242 243 strechum 1 NaN 243 244 an6991 1 NaN 244 245 plato 1 NaN 245 246 CarloAlberto98 1 NaN 246 247 cris 1 NaN 247 248 emilibassi 1 NaN 248 249 mehrbano 1 NaN 249 250 NIKITA PANCHAL 1 NaN [250 rows x 4 columns] 5.5 从XML读取数据 101books.xml&lt;?xml version=”1.0”?&gt; 272103_1_EnRoss, Mark XML Cookbook Computer 23.56 2014-22-01 272103_1_EnBracket, Barbara XML for Dummies Computer 35.95 2014-12-16 1from lxml import objectify 12xml = objectify.parse('books.xml')xml &lt;lxml.etree._ElementTree at 0xc5d74b8&gt; 123root = xml.getroot()print(root.Book.Author)print(root.Book.PublishDate) 272103_1_EnRoss, Mark 2014-22-01 1root.getchildren() [&lt;Element Book at 0xc761378&gt;, &lt;Element Book at 0xc761d78&gt;] 1[child.tag for child in root.Book.getchildren()] [&#39;Author&#39;, &#39;Title&#39;, &#39;Genre&#39;, &#39;Price&#39;, &#39;PublishDate&#39;] 1[child.text for child in root.Book.getchildren()] [&#39;272103_1_EnRoss, Mark&#39;, &#39;XML Cookbook&#39;, &#39;Computer&#39;, &#39;23.56&#39;, &#39;2014-22-01&#39;] 1234567891011121314151617def etree2df(root): column_names = [] for i in range(0,len(root.getchildren()[0].getchildren())): column_names.append(root.getchildren()[0].getchildren()[i].tag) xml_frame = pd.DataFrame(columns=column_names) for j in range(0, len(root.getchildren())): obj = root.getchildren()[j].getchildren() texts = [] for k in range(0, len(column_names)): texts.append(obj[k].text) row = dict(zip(column_names, texts)) row_s = pd.Series(row) row_s.name = j xml_frame = xml_frame.append(row_s) return xml_frame 12temp = etree2df(root)print(temp) Author Title Genre Price PublishDate 0 272103_1_EnRoss, Mark XML Cookbook Computer 23.56 2014-22-01 1 272103_1_EnBracket, Barbara XML for Dummies Computer 35.95 2014-12-16 5.6 读写Microsoft Excel文件 10312temp = pd.read_excel('data.xls')print(temp) white red green black a 12 23 17 18 b 22 16 19 18 c 14 23 22 21 12temp = pd.read_excel('data.xls','Sheet2')print(temp) yellow purple blue orange A 11 16 44 22 B 20 22 23 44 C 30 31 37 32 12temp = pd.read_excel('data.xls',1)print(temp) yellow purple blue orange A 11 16 44 22 B 20 22 23 44 C 30 31 37 32 1234frame = pd.DataFrame(np.random.random((4,4)), index = ['exp1','exp2','exp3','exp4'], columns = ['Jan2015','Fab2015','Mar2015','Apr2005'])print(frame) Jan2015 Fab2015 Mar2015 Apr2005 exp1 0.610508 0.434578 0.019900 0.099366 exp2 0.306480 0.961355 0.073820 0.742758 exp3 0.232366 0.197025 0.312307 0.697120 exp4 0.374647 0.123761 0.521675 0.641097 1frame.to_excel('data2.xlsx') 5.7 JSON数据 10512345frame = pd.DataFrame(np.arange(16).reshape(4,4), index=['white','black','red','blue'], columns=['up','down','right','left'])print(frame)frame.to_json('frame.json') up down right left white 0 1 2 3 black 4 5 6 7 red 8 9 10 11 blue 12 13 14 15 {“up”:{“white”:0,”black”:4,”red”:8,”blue”:12},”down”:{“white”:1,”black”:5,”red”:9,”blue”:13},”right”:{“white”:2,”black”:6,”red”:10,”blue”:14},”left”:{“white”:3,”black”:7,”red”:11,”blue”:15}} 12temp = pd.read_json('frame.json')print(temp) down left right up black 5 7 6 4 blue 13 15 14 12 red 9 11 10 8 white 1 3 2 0 123456789from pandas.io.json import json_normalizefile = open('books.json','r')text = file.read()text = json.loads(text)temp = json_normalize(text,'books')print(temp)print()temp = json_normalize(text,'books',['writer','nationality'])print(temp) price title 0 23.56 XML Cookbook 1 50.70 Python Fundamentals 2 12.30 The NumPy library 3 28.60 Java Enterprise 4 31.35 HTML5 5 28.00 Python for Dummies price title writer nationality 0 23.56 XML Cookbook Mark Ross USA 1 50.70 Python Fundamentals Mark Ross USA 2 12.30 The NumPy library Mark Ross USA 3 28.60 Java Enterprise Barbara Bracket UK 4 31.35 HTML5 Barbara Bracket UK 5 28.00 Python for Dummies Barbara Bracket UK D:\ProgramData\Anaconda3_32\lib\site-packages\ipykernel_launcher.py:4: FutureWarning: pandas.json is deprecated and will be removed in a future version. You can access loads as pandas.io.json.loads after removing the cwd from sys.path. 5.8 HDF5格式 1071234567from pandas.io.pytables import HDFStoreframe = pd.DataFrame(np.arange(16).reshape(4,4), index=['white','black','red','blue'], columns=['up','down','right','left'])store = HDFStore('mydata.h5')store['obj1'] = framestore &lt;class &#39;pandas.io.pytables.HDFStore&#39;&gt; File path: mydata.h5 /obj1 frame (shape-&gt;[4,4]) 12temp = store['obj1']print(temp) up down right left white 0 1 2 3 black 4 5 6 7 red 8 9 10 11 blue 12 13 14 15 5.9 pickle——Python对象序列化 1085.9.1 用pickle实现Python对象序列化 1091234import pickle as pickledata = &#123; 'color': ['white','red'], 'value': [5, 7]&#125;pickled_data = pickle.dumps(data)print(pickled_data) b&#39;\x80\x03}q\x00(X\x05\x00\x00\x00colorq\x01]q\x02(X\x05\x00\x00\x00whiteq\x03X\x03\x00\x00\x00redq\x04eX\x05\x00\x00\x00valueq\x05]q\x06(K\x05K\x07eu.&#39; 12nframe = pickle.loads(pickled_data)nframe {&#39;color&#39;: [&#39;white&#39;, &#39;red&#39;], &#39;value&#39;: [5, 7]} 5.9.2 用pandas实现对象序列化 10912345frame = pd.DataFrame(np.arange(16).reshape(4,4), index = ['up','down','left','right'])frame.to_pickle('frame.pkl')temp = pd.read_pickle('frame.pkl')print(temp) 0 1 2 3 up 0 1 2 3 down 4 5 6 7 left 8 9 10 11 right 12 13 14 15 5.10 对接数据库 1101234567891011from sqlalchemy import create_engine#For PostgreSQLengine = create_engine('postgresql://scott:tiger@localhost:5432/mydatabase')#For MySQLengine = create_engine('mysql+mysqldb://scott:tiger@localhost/foo')#For Oracleengine = create_engine('oracle://scott:tiger@127.0.0.1:1521/sidname')#For MSSQLengine = create_engine('mssql+pyodbc://mydsn')#For SQLiteengine = create_engine('sqlite:///foo.db') 上面代码运行可能会出现错误，根据运行结果，缺少什么使用pip安装什么就可以了。 5.10.1 SQLite3数据读写 111123frame = pd.DataFrame( np.arange(20).reshape(4,5), columns=['white','red','blue','black','green'])print(frame) white red blue black green 0 0 1 2 3 4 1 5 6 7 8 9 2 10 11 12 13 14 3 15 16 17 18 19 12345engine = create_engine('sqlite:///foo.db')frame.to_sql('colors',engine)temp = pd.read_sql('colors',engine)print(temp) index white red blue black green 0 0 0 1 2 3 4 1 1 5 6 7 8 9 2 2 10 11 12 13 14 3 3 15 16 17 18 19 1234567891011121314151617import sqlite3query = """CREATE TABLE test(a VARCHAR(20), b VARCHAR(20),c REAL, d INTEGER);"""con = sqlite3.connect(':memory:')con.execute(query)con.commit()data = [('white','up',1,3), ('black','down',2,8), ('green','up',4,4), ('red','down',5,5)]stmt = "INSERT INTO test VALUES(?,?,?,?)"con.executemany(stmt, data)con.commit() 1234cursor = con.execute('select * from test')print(cursor)rows = cursor.fetchall()rows &lt;sqlite3.Cursor object at 0x0D591820&gt; [(&#39;white&#39;, &#39;up&#39;, 1.0, 3), (&#39;black&#39;, &#39;down&#39;, 2.0, 8), (&#39;green&#39;, &#39;up&#39;, 4.0, 4), (&#39;red&#39;, &#39;down&#39;, 5.0, 5)] 1cursor.description ((&#39;a&#39;, None, None, None, None, None, None), (&#39;b&#39;, None, None, None, None, None, None), (&#39;c&#39;, None, None, None, None, None, None), (&#39;d&#39;, None, None, None, None, None, None)) 12temp = pd.DataFrame(rows, columns=['a','b','c','d'])print(temp) a b c d 0 white up 1.0 3 1 black down 2.0 8 2 green up 4.0 4 3 red down 5.0 5 5.10.2 PostgreSQL数据读写 1121engine = create_engine('postgresql://scott:tiger@localhost:5432/mydatabase') 123456import pandas as pdimport numpy as npframe = pd.DataFrame(np.random.random((4,4)), index=['exp1','exp2','exp3','exp4'], columns=['feb','mar','apr','may']);frame.to_sql('dataframe',engine) postgres=# SELECT * FROM DATAFRAME; 12temp = pd.read_sql_table('dataframe',engine)print(temp) index feb mar apr may 0 exp1 0.406820 0.964683 0.181662 0.660217 1 exp2 0.573869 0.940819 0.426104 0.484574 2 exp3 0.649881 0.059990 0.616504 0.681356 3 exp4 0.061554 0.733131 0.998748 0.127283 12temp = pd.read_sql_query('SELECT index,apr,may FROM DATAFRAME WHERE apr &gt; 0.5',engine)print(temp) index apr may 0 exp3 0.616504 0.681356 1 exp4 0.998748 0.127283 5.11 NoSQL数据库MongoDB数据读写 1141234import pymongoclient = pymongo.MongoClient('localhost',27017)db = client.mydatabasedb Database(MongoClient(host=[&#39;localhost:27017&#39;], document_class=dict, tz_aware=False, connect=True), &#39;mydatabase&#39;) 1client['mydatabase'] Database(MongoClient(host=[&#39;localhost:27017&#39;], document_class=dict, tz_aware=False, connect=True), &#39;mydatabase&#39;) 12collection = db.mycollectiondb['mycollection'] Collection(Database(MongoClient(host=[&#39;localhost:27017&#39;], document_class=dict, tz_aware=False, connect=True), &#39;mydatabase&#39;), &#39;mycollection&#39;) 1collection Collection(Database(MongoClient(host=[&#39;localhost:27017&#39;], document_class=dict, tz_aware=False, connect=True), &#39;mydatabase&#39;), &#39;mycollection&#39;) 123frame = pd.DataFrame( np.arange(20).reshape(4,5), columns=['white','red','blue','black','green'])print(frame) white red blue black green 0 0 1 2 3 4 1 5 6 7 8 9 2 10 11 12 13 14 3 15 16 17 18 19 123import jsonrecord = json.loads(frame.T.to_json()).values()record dict_values([{&#39;white&#39;: 0, &#39;red&#39;: 1, &#39;blue&#39;: 2, &#39;black&#39;: 3, &#39;green&#39;: 4}, {&#39;white&#39;: 5, &#39;red&#39;: 6, &#39;blue&#39;: 7, &#39;black&#39;: 8, &#39;green&#39;: 9}, {&#39;white&#39;: 10, &#39;red&#39;: 11, &#39;blue&#39;: 12, &#39;black&#39;: 13, &#39;green&#39;: 14}, {&#39;white&#39;: 15, &#39;red&#39;: 16, &#39;blue&#39;: 17, &#39;black&#39;: 18, &#39;green&#39;: 19}]) 1collection.mydocument.insert(record) 123456cursor = collection['mydocument'].find()print(type(cursor))dataframe = (list(cursor))data = pd.DataFrame(dataframe)del data['_id']print(data) &lt;class &#39;pymongo.cursor.Cursor&#39;&gt; black blue green red white 0 3 2 4 1 0 1 8 7 9 6 5 2 13 12 14 11 10 3 18 17 19 16 15 5.12 小结 116]]></content>
      <categories>
        <category>python</category>
        <category>数据分析</category>
        <category>pandas</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux防火墙设置]]></title>
    <url>%2F2018%2F04%2F11%2Flinux%E9%98%B2%E7%81%AB%E5%A2%99%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[UFW防火墙UFW防火墙是一个主机端的iptables类防火墙配置工具。这个工具的目的是提供给用户一个可以轻松驾驭的界面，就像包集成和动态检测开放的端口一样。 自2.4版本以后的Linux内核中， 提供了一个非常优秀的防火墙工具。这个工具可以对出入服务的网络数据进行分割、过滤、转发等等细微的控制，进而实现诸如防火墙、NAT等功能。一般来说， 我们会使用名气比较的大iptables等程序对这个防火墙的规则进行管理。iptables可以灵活的定义防火墙规则，功能非常强大。但是由此产生的副作用便是配置过于复杂。一向以简单易用著称Ubuntu在它的发行版中，附带了一个相对iptables简单很多的防火墙配置工具：ufw。ufw默认是没有启用的。也就是说， ubuntu中的端口默认都是开放的。使用如下命令启动ufw： UFW安装与使用 安装sudo apt-get install ufw 启用sudo ufw enablesudo ufw default deny运行以上两条命令后，开启了防火墙，并在系统启动时自动开启。关闭所有外部对本机的访问，但本机访问外部正常。 开启/禁用sudo ufw allow|deny [service]打开或关闭某个端口，例如：sudo ufw allow smtp 允许所有的外部IP访问本机的25/tcp (smtp)端口sudo ufw allow 22/tcp 允许所有的外部IP访问本机的22/tcp (ssh)端口sudo ufw allow 53 允许外部访问53端口(tcp/udp)sudo ufw allow from 192.168.1.100 允许此IP访问所有的本机端口sudo ufw allow proto udp 192.168.0.1 port 53 to 192.168.0.2 port 53sudo ufw deny smtp 禁止外部访问smtp服务sudo ufw delete allow smtp 删除上面建立的某条规则 查看防火墙状态sudo ufw status一般用户，只需如下设置：sudo apt-get install ufwsudo ufw enablesudo ufw default deny以上三条命令已经足够安全了，如果你需要开放某些服务，再使用sudo ufw allow开启。开启/关闭防火墙 (默认设置是’disable’)sudo ufw enable|disable转换日志状态sudo ufw logging on|off设置默认策略 (比如 “mostly open” vs “mostly closed”)sudo ufw default allow|deny许可或者屏蔽端口 (可以在“status” 中查看到服务列表)。可以用“协议：端口”的方式指定一个存在于/etc/services中的服务名称，也可以通过包的meta-data。 ‘allow’ 参数将把条目加入 /etc/ufw/maps ，而 ‘deny’ 则相反。基本语法如下：sudo ufw allow|deny [service]显示防火墙和端口的侦听状态，参见 /var/lib/ufw/maps。括号中的数字将不会被显示出来。sudo ufw statusUFW 使用范例：允许 53 端口$ sudo ufw allow 53禁用 53 端口$ sudo ufw delete allow 53允许 80 端口$ sudo ufw allow 80/tcp禁用 80 端口$ sudo ufw delete allow 80/tcp允许 smtp 端口$ sudo ufw allow smtp删除 smtp 端口的许可$ sudo ufw delete allow smtp允许某特定 IP$ sudo ufw allow from 192.168.254.254删除上面的规则$ sudo ufw delete allow from 192.168.254.254 加载sudo ufw reload ubuntu iptables设置删除原来 iptables 里面已经有的规则iptables -Fiptables -X 抛弃所有不符合三种链规则的数据包iptables -P INPUT DROPiptables -P OUTPUT DROPiptables -P FORWARD DROP 设置：本地进程 lo 的 INPUT 和 OUTPUT 链接 ； eth1的 INPUT链iptables -A INPUT -i lo -j ACCEPTiptables -A INPUT -i eth1 -m state —state ESTABLISHED,RELATED -j ACCEPTiptables -A INPUT -i eth1 -m state —state NEW,INVALID -j LOGiptables -A OUTPUT -o lo -j ACCEPT 对其他主要允许的端口的 OUTPUT设置： DNSiptables -A OUTPUT -o eth1 -p TCP —sport 1024:65535 —dport 53 -j ACCEPTiptables -A OUTPUT -o eth1 -p UDP —sport 1024:65535 —dport 53 -j ACCEPT HTTPiptables -A OUTPUT -o eth1 -p TCP —sport 1024:65535 —dport 80 -j ACCEPT HTTPSiptables -A OUTPUT -o eth1 -p TCP —sport 1024:65535 —dport 443 -j ACCEPT Email 接受 和发送iptables -A OUTPUT -o eth1 -p TCP —sport 1024:65535 —dport 110 -j ACCEPTiptables -A OUTPUT -o eth1 -p TCP —sport 1024:65535 —dport 25 -j ACCEPT FTP 数据和控制iptables -A OUTPUT -o eth1 -p TCP —sport 1024:65535 —dport 20 -j ACCEPTiptables -A OUTPUT -o eth1 -p TCP —sport 1024:65535 —dport 21 -j ACCEPT DHCPiptables -A OUTPUT -o eth1 -p TCP —sport 1024:65535 —dport 68 -j ACCEPTiptables -A OUTPUT -o eth1 -p UDP —sport 1024:65535 —dport 68 -j ACCEPT POP3S Email安全接收iptables -A OUTPUT -o eth1 -p TCP —sport 1024:65535 —dport 995 -j ACCEPT 时间同步服务器 NTPiptables -A OUTPUT -o eth1 -p TCP —sport 1024:65535 —dport 123 -j ACCEPT 拒绝 eth1 其他剩下的iptables -A OUTPUT -o eth1 —match state —state NEW,INVALID -j LOG 最后是有关于iptables存储的命令：代码:iptables-save &gt; /etc/iptables.up.rule - 存在你想存的地方 代码:iptables-restore &lt; /etc/iptables.up.rules - 调用 因为iptables 在每次机器重新启动以后，需要再次输入或者调用，为了方便操作，使用代码:sudo gedit /etc/network/interfaces 在代码:auto ath0iface ath0 inet dhcp后面加上代码:pre-up iptables-restore &lt; /etc/iptables.up.rules - 启动自动调用已存储的iptables 代码:post-down iptables-save &gt; /etc/iptables.up.rule #关机时，把当前iptables 储存]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第4章-pandas库]]></title>
    <url>%2F2018%2F04%2F11%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC4%E7%AB%A0-pandas%E5%BA%93%2F</url>
    <content type="text"><![CDATA[第4章 pandas库简介 564.1 pandas：Python数据分析库 564.2 安装 574.2.1 用Anaconda安装 574.2.2 用PyPI安装 584.2.3 在Linux系统的安装方法 584.2.4 用源代码安装 584.2.5 Windows模块仓库 594.3 测试pandas是否安装成功 594.4 开始pandas之旅 5912import pandas as pdimport numpy as np 4.5 pandas数据结构简介 604.5.1 Series对象 6012s = pd.Series([12,-4,7,9])s 0 12 1 -4 2 7 3 9 dtype: int64 12s = pd.Series([12,-4,7,9], index=['a','b','c','d'])s a 12 b -4 c 7 d 9 dtype: int64 1s.values array([12, -4, 7, 9]) 1s.index Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype=&#39;object&#39;) 1s[2], s['b'] (7, -4) 1s[0:2] a 12 b -4 dtype: int64 1s[['b','c']] b -4 c 7 dtype: int64 12s[1] = 0s a 12 b 0 c 7 d 9 dtype: int64 12s['b'] = 1s a 12 b 1 c 7 d 9 dtype: int64 123arr = np.array([1,2,3,4])s3 = pd.Series(arr)s3 0 1 1 2 2 3 3 4 dtype: int64 12s4 = pd.Series(s)s4 a 12 b 1 c 7 d 9 dtype: int64 12arr[2] = -2s3 0 1 1 2 2 -2 3 4 dtype: int64 1s[s &gt; 8] a 12 d 9 dtype: int64 1s / 2 a 6.0 b 0.5 c 3.5 d 4.5 dtype: float64 1np.log(s) a 2.484907 b 0.000000 c 1.945910 d 2.197225 dtype: float64 1serd = pd.Series([1,0,2,1,2,3], index=['white','white','blue','green','green','yellow']) 1serd white 1 white 0 blue 2 green 1 green 2 yellow 3 dtype: int64 1serd.unique() array([1, 0, 2, 3]) 1serd.value_counts() 2 2 1 2 3 1 0 1 dtype: int64 1serd.isin([0,3]) white False white True blue False green False green False yellow True dtype: bool 1serd[serd.isin([0,3])] white 0 yellow 3 dtype: int64 12s2 = pd.Series([5,-3,np.NaN,14])s2 0 5.0 1 -3.0 2 NaN 3 14.0 dtype: float64 1s2.isnull() 0 False 1 False 2 True 3 False dtype: bool 1s2.notnull() 0 True 1 True 2 False 3 True dtype: bool 1s2[s2.notnull()] 0 5.0 1 -3.0 3 14.0 dtype: float64 1s2[s2.isnull()] 2 NaN dtype: float64 123mydict = &#123;'red': 2000, 'blue': 1000, 'yellow': 500, 'orange': 1000&#125;myseries = pd.Series(mydict)myseries blue 1000 orange 1000 red 2000 yellow 500 dtype: int64 123colors = ['red','yellow','orange','blue','green']myseries = pd.Series(mydict, index=colors)myseries red 2000.0 yellow 500.0 orange 1000.0 blue 1000.0 green NaN dtype: float64 123mydict2 = &#123;'red':400,'yellow':1000,'black':700&#125;myseries2 = pd.Series(mydict2)myseries2 black 700 red 400 yellow 1000 dtype: int64 1myseries + myseries2 black NaN blue NaN green NaN orange NaN red 2400.0 yellow 1500.0 dtype: float64 4.5.2 DataFrame对象 6612345data = &#123;'color' : ['blue','green','yellow','red','white'],'object' : ['ball','pen','pencil','paper','mug'],'price' : [1.2,1.0,0.6,0.9,1.7]&#125;frame = pd.DataFrame(data)frame …. color object price 0 blue ball 1.2 1 green pen 1.0 2 yellow pencil 0.6 3 red paper 0.9 4 white mug 1.7 12frame2 = pd.DataFrame(data, columns=['object','price'])frame2 ….. object price 0 ball 1.2 1 pen 1.0 2 pencil 0.6 3 paper 0.9 4 mug 1.7 12frame2 = pd.DataFrame(data, index=['one','two','three','four','five'])frame2 …. color object price one blue ball 1.2 two green pen 1.0 three yellow pencil 0.6 four red paper 0.9 five white mug 1.7 1234frame3 = pd.DataFrame(np.arange(16).reshape((4,4)), index=['red','blue','yellow','white'], columns=['ball','pen','pencil','paper'])frame3 ….. ball pen pencil paper red 0 1 2 3 blue 4 5 6 7 yellow 8 9 10 11 white 12 13 14 15 1frame.columns Index([&#39;color&#39;, &#39;object&#39;, &#39;price&#39;], dtype=&#39;object&#39;) 1frame.index RangeIndex(start=0, stop=5, step=1) 1frame.values array([[&#39;blue&#39;, &#39;ball&#39;, 1.2], [&#39;green&#39;, &#39;pen&#39;, 1.0], [&#39;yellow&#39;, &#39;pencil&#39;, 0.6], [&#39;red&#39;, &#39;paper&#39;, 0.9], [&#39;white&#39;, &#39;mug&#39;, 1.7]], dtype=object) 1frame['price'] 0 1.2 1 1.0 2 0.6 3 0.9 4 1.7 Name: price, dtype: float64 1frame.price 0 1.2 1 1.0 2 0.6 3 0.9 4 1.7 Name: price, dtype: float64 1frame.ix[2] color yellow object pencil price 0.6 Name: 2, dtype: object 1frame.ix[[2,4]] 1frame[0:1] color object price 0 blue ball 1.2 1frame[1:3] color object price 1 green pen 1.02 yellow pencil 0.6 1frame['object'][3] &#39;paper&#39; 123frame.index.name = 'id'; frame.columns.name = 'item'frame item color object priceid0 blue ball 1.21 green pen 1.02 yellow pencil 0.63 red paper 0.94 white mug 1.7 12frame['new'] = 12frame item color object price newid0 blue ball 1.2 121 green pen 1.0 122 yellow pencil 0.6 123 red paper 0.9 124 white mug 1.7 12 12frame['new'] = [3.0,1.3,2.2,0.8,1.1]frame item color object price newid0 blue ball 1.2 3.01 green pen 1.0 1.32 yellow pencil 0.6 2.23 red paper 0.9 0.84 white mug 1.7 1.1 12ser = pd.Series(np.arange(5))ser 0 0 1 1 2 2 3 3 4 4 dtype: int64 12frame['new'] = serframe item color object price newid0 blue ball 1.2 01 green pen 1.0 12 yellow pencil 0.6 23 red paper 0.9 34 white mug 1.7 4 12frame['price'][2] = 3.3frame /home/vivoadmin/anaconda3/lib/python3.6/site-packages/ipykernel_launcher.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy &quot;&quot;&quot;Entry point for launching an IPython kernel. item color object price newid0 blue ball 1.2 01 green pen 1.0 12 yellow pencil 3.3 23 red paper 0.9 34 white mug 1.7 4 1frame.isin([1.0,'pen']) item color object price newid0 False False False False1 False True True True2 False False False False3 False False False False4 False False False False 1frame[frame.isin([1.0,'pen'])] item color object price newid0 NaN NaN NaN NaN1 NaN pen 1.0 1.02 NaN NaN NaN NaN3 NaN NaN NaN NaN4 NaN NaN NaN NaN 12del frame['new']frame item color object priceid0 blue ball 1.21 green pen 1.02 yellow pencil 3.33 red paper 0.94 white mug 1.7 1frame[frame &lt; 1] item color object priceid0 blue ball NaN1 green pen NaN2 yellow pencil NaN3 red paper 0.94 white mug NaN 12345nestdict = &#123;'red':&#123;2012: 22, 2013: 33&#125;, 'white':&#123;2011: 13, 2012: 22, 2013: 16&#125;, 'blue': &#123;2011: 17, 2012: 27, 2013: 18&#125;&#125;frame2 = pd.DataFrame(nestdict)frame2 blue red white 2011 17 NaN 132012 27 22.0 222013 18 33.0 16 1frame2.T 2011 2012 2013 blue 17.0 27.0 18.0red NaN 22.0 33.0white 13.0 22.0 16.0 4.5.3 Index对象 7212ser = pd.Series([5,0,3,8,4], index=['red','blue','yellow','white','green'])ser.index Index([&#39;red&#39;, &#39;blue&#39;, &#39;yellow&#39;, &#39;white&#39;, &#39;green&#39;], dtype=&#39;object&#39;) 1ser.idxmin(), ser.idxmax() (&#39;blue&#39;, &#39;white&#39;) 12serd = pd.Series(range(6), index=['white','white','blue','green','green','yellow'])serd white 0 white 1 blue 2 green 3 green 4 yellow 5 dtype: int64 1serd['white'] white 0 white 1 dtype: int64 1serd.index.is_unique False 1frame.index.is_unique True 4.6 索引对象的其他功能 744.6.1 更换索引 7412ser = pd.Series([2,5,7,4], index=['one','two','three','four'])ser one 2 two 5 three 7 four 4 dtype: int64 1ser.reindex(['three','four','five','one']) three 7.0 four 4.0 five NaN one 2.0 dtype: float64 12ser3 = pd.Series([1,5,6,3],index=[0,3,5,6])ser3 0 1 3 5 5 6 6 3 dtype: int64 1ser3.reindex(range(6),method='ffill') 0 1 1 1 2 1 3 5 4 5 5 6 dtype: int64 1ser3.reindex(range(6),method='bfill') 0 1 1 5 2 5 3 5 4 6 5 6 dtype: int64 item colors price new objectid0 blue 1.2 blue ball1 green 1.0 green pen2 yellow 3.3 yellow pencil3 red 0.9 red paper4 white 1.7 white mug 4.6.2 删除 7512ser = pd.Series(np.arange(4.), index=['red','blue','yellow','white'])ser red 0.0 blue 1.0 yellow 2.0 white 3.0 dtype: float64 1ser.drop('yellow') red 0.0 blue 1.0 white 3.0 dtype: float64 1ser.drop(['blue','white']) red 0.0 yellow 2.0 dtype: float64 1234frame = pd.DataFrame(np.arange(16).reshape((4,4)), index=['red','blue','yellow','white'], columns=['ball','pen','pencil','paper'])frame ball pen pencil paper red 0 1 2 3blue 4 5 6 7yellow 8 9 10 11white 12 13 14 15 1frame.drop(['blue','yellow']) ball pen pencil paperred 0 1 2 3white 12 13 14 15 1frame.drop(['pen','pencil'],axis=1) ball paper red 0 3blue 4 7yellow 8 11white 12 15 4.6.3 算术和数据对齐 7712s1 = pd.Series([3,2,5,1],['white','yellow','green','blue'])s2 = pd.Series([1,4,7,2,1],['white','yellow','black','blue','brown']) 1s1 + s2 black NaN blue 3.0 brown NaN green NaN white 4.0 yellow 6.0 dtype: float64 123456frame1 = pd.DataFrame(np.arange(16).reshape((4,4)), index=['red','blue','yellow','white'], columns=['ball','pen','pencil','paper'])frame2 = pd.DataFrame(np.arange(12).reshape((4,3)), index=['blue','green','white','yellow'], columns=['mug','pen','ball']) 1frame1 ball pen pencil paper red 0 1 2 3blue 4 5 6 7yellow 8 9 10 11white 12 13 14 15 1frame2 mug pen ball blue 0 1 2green 3 4 5white 6 7 8yellow 9 10 11 1frame1 + frame2 ball mug paper pen pencil blue 6.0 NaN NaN 6.0 NaNgreen NaN NaN NaN NaN NaNred NaN NaN NaN NaN NaNwhite 20.0 NaN NaN 20.0 NaNyellow 19.0 NaN NaN 19.0 NaN 4.7 数据结构之间的运算 784.7.1 灵活的算术运算方法 781frame1.add(frame2) ball mug paper pen pencil blue 6.0 NaN NaN 6.0 NaNgreen NaN NaN NaN NaN NaNred NaN NaN NaN NaN NaNwhite 20.0 NaN NaN 20.0 NaNyellow 19.0 NaN NaN 19.0 NaN 4.7.2 DataFrame和Series对象之间的运算 781234frame = pd.DataFrame(np.arange(16).reshape((4,4)), index=['red','blue','yellow','white'], columns=['ball','pen','pencil','paper'])frame ball pen pencil paper red 0 1 2 3blue 4 5 6 7yellow 8 9 10 11white 12 13 14 15 12ser = pd.Series(np.arange(4), index=['ball','pen','pencil','paper'])ser ball 0 pen 1 pencil 2 paper 3 dtype: int64 1frame - ser ball pen pencil paper red 0 0 0 0blue 4 4 4 4yellow 8 8 8 8white 12 12 12 12 12ser['mug'] = 9ser ball 0 pen 1 pencil 2 paper 3 mug 9 dtype: int64 1frame - ser ball mug paper pen pencil red 0 NaN 0 0 0blue 4 NaN 4 4 4yellow 8 NaN 8 8 8white 12 NaN 12 12 12 4.8 函数应用和映射 794.8.1 操作元素的函数 791234frame = pd.DataFrame(np.arange(16).reshape((4,4)), index=['red','blue','yellow','white'], columns=['ball','pen','pencil','paper'])frame ball pen pencil paper red 0 1 2 3blue 4 5 6 7yellow 8 9 10 11white 12 13 14 15 1np.sqrt(frame) ball pen pencil paper red 0.000000 1.000000 1.414214 1.732051blue 2.000000 2.236068 2.449490 2.645751yellow 2.828427 3.000000 3.162278 3.316625white 3.464102 3.605551 3.741657 3.872983 4.8.2 按行或列执行操作的函数 80123f = lambda x: x.max() - x.min()def f(x): return x.max() - x.min() 1frame.apply(f) ball 12 pen 12 pencil 12 paper 12 dtype: int64 1frame.apply(f, axis=1) red 3 blue 3 yellow 3 white 3 dtype: int64 12def f(x): return pd.Series([x.min(), x.max()], index=['min','max']) 1frame.apply(f) ball pen pencil paper min 0 1 2 3max 12 13 14 15 4.8.3 统计函数 811frame.sum() ball 24 pen 28 pencil 32 paper 36 dtype: int64 1frame.mean() ball 6.0 pen 7.0 pencil 8.0 paper 9.0 dtype: float64 1frame.describe() ball pen pencil paper count 4.000000 4.000000 4.000000 4.000000mean 6.000000 7.000000 8.000000 9.000000std 5.163978 5.163978 5.163978 5.163978min 0.000000 1.000000 2.000000 3.00000025% 3.000000 4.000000 5.000000 6.00000050% 6.000000 7.000000 8.000000 9.00000075% 9.000000 10.000000 11.000000 12.000000max 12.000000 13.000000 14.000000 15.000000 4.9 排序和排位次 8112ser = pd.Series([5,0,3,8,4], index=['red','blue','yellow','white','green'])ser red 5 blue 0 yellow 3 white 8 green 4 dtype: int64 1ser.sort_index() blue 0 green 4 red 5 white 8 yellow 3 dtype: int64 1ser.sort_index(ascending=False) yellow 3 white 8 red 5 green 4 blue 0 dtype: int64 1234frame = pd.DataFrame(np.arange(16).reshape((4,4)), index=['red','blue','yellow','white'], columns=['ball','pen','pencil','paper'])frame ball pen pencil paper red 0 1 2 3blue 4 5 6 7yellow 8 9 10 11white 12 13 14 15 1frame.sort_index() ball pen pencil paper blue 4 5 6 7red 0 1 2 3white 12 13 14 15yellow 8 9 10 11 1frame.sort_index(axis=1) ball paper pen pencil red 0 3 1 2blue 4 7 5 6yellow 8 11 9 10white 12 15 13 14 1ser.order() --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-131-bb828ac4164f&gt; in &lt;module&gt;() ----&gt; 1 ser.order() ~/anaconda3/lib/python3.6/site-packages/pandas/core/generic.py in __getattr__(self, name) 3612 if name in self._info_axis: 3613 return self[name] -&gt; 3614 return object.__getattribute__(self, name) 3615 3616 def __setattr__(self, name, value): AttributeError: &#39;Series&#39; object has no attribute &#39;order&#39; 1frame.sort_index(by='pen') /home/vivoadmin/anaconda3/lib/python3.6/site-packages/ipykernel_launcher.py:1: FutureWarning: by argument to sort_index is deprecated, please use .sort_values(by=...) &quot;&quot;&quot;Entry point for launching an IPython kernel. ball pen pencil paper red 0 1 2 3blue 4 5 6 7yellow 8 9 10 11white 12 13 14 15 1frame.sort_index(by=['pen','pencil']) /home/vivoadmin/anaconda3/lib/python3.6/site-packages/ipykernel_launcher.py:1: FutureWarning: by argument to sort_index is deprecated, please use .sort_values(by=...) &quot;&quot;&quot;Entry point for launching an IPython kernel. ball pen pencil paperred 0 1 2 3blue 4 5 6 7yellow 8 9 10 11white 12 13 14 15 1ser.rank() red 4.0 blue 1.0 yellow 2.0 white 5.0 green 3.0 dtype: float64 1ser.rank(method='first') red 4.0 blue 1.0 yellow 2.0 white 5.0 green 3.0 dtype: float64 1ser.rank(ascending=False) red 2.0 blue 5.0 yellow 4.0 white 1.0 green 3.0 dtype: float64 4.10 相关性和协方差 8412seq2 = pd.Series([3,4,3,4,5,4,3,2],['2006','2007','2008','2009','2010','2011','2012','2013'])seq = pd.Series([1,2,3,4,4,3,2,1],['2006','2007','2008','2009','2010','2011','2012','2013']) 1seq.corr(seq2) 0.7745966692414835 1seq.cov(seq2) 0.8571428571428571 1234frame2 = pd.DataFrame([[1,4,3,6],[4,5,6,1],[3,3,1,5],[4,1,6,4]], index=['red','blue','yellow','white'], columns=['ball','pen','pencil','paper'])frame2 ball pen pencil paper red 1 4 3 6blue 4 5 6 1yellow 3 3 1 5white 4 1 6 4 1frame2.corr() ball pen pencil paper ball 1.000000 -0.276026 0.577350 -0.763763pen -0.276026 1.000000 -0.079682 -0.361403pencil 0.577350 -0.079682 1.000000 -0.692935paper -0.763763 -0.361403 -0.692935 1.000000 1frame2.cov() ball pen pencil paper ball 2.000000 -0.666667 2.000000 -2.333333pen -0.666667 2.916667 -0.333333 -1.333333pencil 2.000000 -0.333333 6.000000 -3.666667paper -2.333333 -1.333333 -3.666667 4.666667 1ser red 5 blue 0 yellow 3 white 8 green 4 dtype: int64 1frame2.corrwith(ser) ball -0.140028 pen -0.869657 pencil 0.080845 paper 0.595854 dtype: float64 1frame2.corrwith(frame) ball 0.730297 pen -0.831522 pencil 0.210819 paper -0.119523 dtype: float64 4.11 NaN数据 854.11.1 为元素赋NaN值 8512ser = pd.Series([0,1,2,np.NaN,9], index=['red','blue','yellow','white','green'])ser red 0.0 blue 1.0 yellow 2.0 white NaN green 9.0 dtype: float64 12ser['white'] = Noneser red 0.0 blue 1.0 yellow 2.0 white NaN green 9.0 dtype: float64 4.11.2 过滤NaN 861ser.dropna() red 0.0 blue 1.0 yellow 2.0 green 9.0 dtype: float64 1ser[ser.notnull()] red 0.0 blue 1.0 yellow 2.0 green 9.0 dtype: float64 1234frame3 = pd.DataFrame([[6,np.nan,6],[np.nan,np.nan,np.nan],[2,np.nan,5]], index = ['blue','green','red'], columns = ['ball','mug','pen'])frame3 ball mug pen blue 6.0 NaN 6.0green NaN NaN NaNred 2.0 NaN 5.0 1frame3.dropna() ball mug pen 1frame3.dropna(how='all') ball mug pen blue 6.0 NaN 6.0red 2.0 NaN 5.0 4.11.3 为NaN元素填充其他值 861frame3.fillna(0) ball mug pen blue 6.0 0.0 6.0green 0.0 0.0 0.0red 2.0 0.0 5.0 1frame3.fillna(&#123;'ball':1,'mug':0,'pen':99&#125;) ball mug pen blue 6.0 0.0 6.0green 1.0 0.0 99.0red 2.0 0.0 5.0 4.12 等级索引和分级 871234mser = pd.Series(np.random.rand(8), index=[['white','white','white','blue','blue','red','red','red'], ['up','down','right','up','down','up','down','left']])mser white up 0.941438 down 0.165728 right 0.492898 blue up 0.902410 down 0.879385 red up 0.646074 down 0.210103 left 0.476333 dtype: float64 1mser.index MultiIndex(levels=[[&#39;blue&#39;, &#39;red&#39;, &#39;white&#39;], [&#39;down&#39;, &#39;left&#39;, &#39;right&#39;, &#39;up&#39;]], labels=[[2, 2, 2, 0, 0, 1, 1, 1], [3, 0, 2, 3, 0, 3, 0, 1]]) 1mser['white'] up 0.941438 down 0.165728 right 0.492898 dtype: float64 1mser[:,'up'] white 0.941438 blue 0.902410 red 0.646074 dtype: float64 1mser['white','up'] 0.9414384939430696 1mser.unstack() down left right up blue 0.879385 NaN NaN 0.902410red 0.210103 0.476333 NaN 0.646074white 0.165728 NaN 0.492898 0.941438 1frame ball pen pencil paper red 0 1 2 3blue 4 5 6 7yellow 8 9 10 11white 12 13 14 15 1frame.stack() red ball 0 pen 1 pencil 2 paper 3 blue ball 4 pen 5 pencil 6 paper 7 yellow ball 8 pen 9 pencil 10 paper 11 white ball 12 pen 13 pencil 14 paper 15 dtype: int64 1234mframe = pd.DataFrame(np.random.randn(16).reshape(4,4), index=[['white','white','red','red'], ['up','down','up','down']], columns=[['pen','pen','paper','paper'],[1,2,1,2]])mframe pen paper 1 2 1 2white up 0.992202 -1.037634 -0.083882 -0.028204down -1.758579 1.832742 -0.167739 0.174567red up 0.983876 2.306897 -1.003258 -0.591767down 1.398166 0.054964 -1.705692 -0.375007 4.12.1 重新调整顺序和为层级排序 89123mframe.columns.names = ['objects','id']mframe.index.names = ['colors','status']mframe objects pen paper id 1 2 1 2colors statuswhite up 0.992202 -1.037634 -0.083882 -0.028204down -1.758579 1.832742 -0.167739 0.174567red up 0.983876 2.306897 -1.003258 -0.591767down 1.398166 0.054964 -1.705692 -0.375007 1mframe.swaplevel('colors','status') objects pen paper id 1 2 1 2status colorsup white 0.992202 -1.037634 -0.083882 -0.028204down white -1.758579 1.832742 -0.167739 0.174567up red 0.983876 2.306897 -1.003258 -0.591767down red 1.398166 0.054964 -1.705692 -0.375007 1mframe.sortlevel('colors') /home/vivoadmin/anaconda3/lib/python3.6/site-packages/ipykernel_launcher.py:1: FutureWarning: sortlevel is deprecated, use sort_index(level= ...) &quot;&quot;&quot;Entry point for launching an IPython kernel. objects pen paper id 1 2 1 2colors statusred down 1.398166 0.054964 -1.705692 -0.375007up 0.983876 2.306897 -1.003258 -0.591767white down -1.758579 1.832742 -0.167739 0.174567up 0.992202 -1.037634 -0.083882 -0.028204 4.12.2 按层级统计数据 891mframe.sum(level='colors') objects pen paperid 1 2 1 2colorswhite -0.766377 0.795107 -0.251622 0.146363red 2.382042 2.361861 -2.708950 -0.966774 1mframe.sum(level='id', axis=1) id 1 2 colors statuswhite up 0.908320 -1.065838down -1.926319 2.007309red up -0.019382 1.715131down -0.307526 -0.320044 4.13 小结 90]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
        <category>pandas</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第3章-numpy库]]></title>
    <url>%2F2018%2F04%2F11%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC3%E7%AB%A0-numpy%E5%BA%93%2F</url>
    <content type="text"><![CDATA[第3章 NumPy库 323.1 NumPy简史 323.2 NumPy安装 323.3 ndarray：NumPy库的心脏 331import numpy as np 1a = np.array([1, 2, 3]) 1a array([1, 2, 3]) 1type(a), a.dtype, a.ndim, a.size, a.shape, a.itemsize (numpy.ndarray, dtype(&#39;int64&#39;), 1, 3, (3,), 8) 1b = np.array([[1.3, 2.4],[0.3, 4.1]]) 1b array([[1.3, 2.4], [0.3, 4.1]]) 1type(b), b.dtype, b.ndim, b.size, b.shape, b.itemsize (numpy.ndarray, dtype(&#39;float64&#39;), 2, 4, (2, 2), 8) 1b.data, type(b.data) (&lt;memory at 0x7f3df8064558&gt;, memoryview) 3.3.1 创建数组 341c = np.array([[1, 2, 3],[4, 5, 6]]) 1c array([[1, 2, 3], [4, 5, 6]]) 1d = np.array(((1, 2, 3),(4, 5, 6))) 1d array([[1, 2, 3], [4, 5, 6]]) 1e = np.array([(1, 2, 3), [4, 5, 6], (7, 8, 9)]) 1e array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 3.3.2 数据类型 341g = np.array([['a', 'b'],['c', 'd']]) 1g array([[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]], dtype=&#39;&lt;U1&#39;) 1g.dtype, g.dtype.name (dtype(&#39;&lt;U1&#39;), &#39;str32&#39;) 3.3.3 dtype选项 351f = np.array([[1, 2, 3],[4, 5, 6]], dtype=complex) 1f array([[1.+0.j, 2.+0.j, 3.+0.j], [4.+0.j, 5.+0.j, 6.+0.j]]) 3.3.4 自带的数组创建方法 361np.zeros((3, 3)) array([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]]) 1np.ones((3, 3)) array([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]) 1np.arange(0, 10) array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 1np.arange(4, 10) array([4, 5, 6, 7, 8, 9]) 1np.arange(0, 12, 3) array([0, 3, 6, 9]) 1np.arange(0, 6, 0.6) array([0. , 0.6, 1.2, 1.8, 2.4, 3. , 3.6, 4.2, 4.8, 5.4]) 1np.arange(0, 12).reshape(3, 4) array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) 1np.linspace(0,10,5) array([ 0. , 2.5, 5. , 7.5, 10. ]) 1np.random.random(3) array([0.71423775, 0.62229946, 0.97150108]) 1np.random.random((3,3)) array([[0.95155686, 0.10092046, 0.35220847], [0.96635154, 0.33764827, 0.44879963], [0.40573132, 0.97260092, 0.30105595]]) 3.4 基本操作 373.4.1 算术运算符 371a = np.arange(4) 1a array([0, 1, 2, 3]) 1a+4 array([4, 5, 6, 7]) 1a*2 array([0, 2, 4, 6]) 1b = np.arange(4,8) 1b array([4, 5, 6, 7]) 1a + b array([ 4, 6, 8, 10]) 1a - b array([-4, -4, -4, -4]) 1a * b array([ 0, 5, 12, 21]) 1a * np.sin(b) array([-0. , -0.95892427, -0.558831 , 1.9709598 ]) 1a * np.sqrt(b) array([0. , 2.23606798, 4.89897949, 7.93725393]) 1A = np.arange(0, 9).reshape(3, 3) 1A array([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) 1B = np.ones((3, 3)) 1B array([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]) 1A * B array([[0., 1., 2.], [3., 4., 5.], [6., 7., 8.]]) 3.4.2 矩阵积 381np.dot(A,B) array([[ 3., 3., 3.], [12., 12., 12.], [21., 21., 21.]]) 1A.dot(B) array([[ 3., 3., 3.], [12., 12., 12.], [21., 21., 21.]]) 1np.dot(B,A) array([[ 9., 12., 15.], [ 9., 12., 15.], [ 9., 12., 15.]]) 3.4.3 自增和自减运算符 391a = np.arange(4) 1a array([0, 1, 2, 3]) 1a += 1 1a array([1, 2, 3, 4]) 1a -= 1 1a array([0, 1, 2, 3]) 1a += 4 1a array([4, 5, 6, 7]) 1a *= 2 1a array([ 8, 10, 12, 14]) 3.4.4 通用函数 401a = np.arange(1, 5) 1a array([1, 2, 3, 4]) 1np.sqrt(a) array([1. , 1.41421356, 1.73205081, 2. ]) 1np.log(a) array([0. , 0.69314718, 1.09861229, 1.38629436]) 1np.sin(a) array([ 0.84147098, 0.90929743, 0.14112001, -0.7568025 ]) 3.4.5 聚合函数 401a = np.array([3.3, 4.5, 1.2, 5.7, 0.3]) 1a array([3.3, 4.5, 1.2, 5.7, 0.3]) 1a.sum() 15.0 1a.min() 0.3 1a.max() 5.7 1a.mean() 3.0 1a.std() 2.0079840636817816 3.5 索引机制、切片和迭代方法 413.5.1 索引机制 411a = np.arange(10, 16) 1a array([10, 11, 12, 13, 14, 15]) 1a[4], a[-1], a[-6] (14, 15, 10) 1a[[1, 3, 4]] array([11, 13, 14]) 1A = np.arange(10, 19).reshape((3, 3)) 1A array([[10, 11, 12], [13, 14, 15], [16, 17, 18]]) 1A[1, 2] 15 3.5.2 切片操作 421a = np.arange(10, 16) 1a array([10, 11, 12, 13, 14, 15]) 1a[1:5] array([11, 12, 13, 14]) 1a[1:5:2] array([11, 13]) 1a[::2] array([10, 12, 14]) 1a[:5:2] array([10, 12, 14]) 1a[:5:] array([10, 11, 12, 13, 14]) 1A = np.arange(10, 19).reshape((3, 3)) 1A array([[10, 11, 12], [13, 14, 15], [16, 17, 18]]) 1A[0,:] array([10, 11, 12]) 1A[:,0] array([10, 13, 16]) 1A[0:2, 0:2] array([[10, 11], [13, 14]]) 1A[[0,2], 0:2] array([[10, 11], [16, 17]]) 3.5.3 数组迭代 4312for i in a: print(i) 10 11 12 13 14 15 12for row in A: print(row) [10 11 12] [13 14 15] [16 17 18] 12for item in A.flat: print(item) 10 11 12 13 14 15 16 17 18 1np.apply_along_axis(np.mean, axis=0, arr=A) array([13., 14., 15.]) 1np.apply_along_axis(np.mean, axis=1, arr=A) array([11., 14., 17.]) 12def foo(x): return x/2 1np.apply_along_axis(foo, axis=1, arr=A) array([[5. , 5.5, 6. ], [6.5, 7. , 7.5], [8. , 8.5, 9. ]]) 1np.apply_along_axis(foo, axis=0, arr=A) array([[5. , 5.5, 6. ], [6.5, 7. , 7.5], [8. , 8.5, 9. ]]) 3.6 条件和布尔数组 451A = np.random.random((4, 4)) 1A array([[0.92122811, 0.55810739, 0.16604965, 0.98756188], [0.89990698, 0.45441885, 0.85233406, 0.32187075], [0.58032546, 0.01878004, 0.91573127, 0.63144651], [0.52282585, 0.57666091, 0.97865543, 0.54473589]]) 1A &lt; 0.5 array([[False, False, True, False], [False, True, False, True], [False, True, False, False], [False, False, False, False]]) 1A[A &lt; 0.5] array([0.04869294, 0.07669828, 0.26766679, 0.04023488, 0.10839496, 0.45508628, 0.48141253]) 3.7 形状变换 451a = np.random.random(12) 1a array([0.93015885, 0.01067508, 0.43200938, 0.24035759, 0.01564892, 0.09507133, 0.70143444, 0.46887118, 0.85551184, 0.61722919, 0.94688342, 0.92520351]) 1A = a.reshape(3, 4) 1A array([[0.93015885, 0.01067508, 0.43200938, 0.24035759], [0.01564892, 0.09507133, 0.70143444, 0.46887118], [0.85551184, 0.61722919, 0.94688342, 0.92520351]]) 1a.shape = (3, 4) 1a array([[0.93015885, 0.01067508, 0.43200938, 0.24035759], [0.01564892, 0.09507133, 0.70143444, 0.46887118], [0.85551184, 0.61722919, 0.94688342, 0.92520351]]) 1a.ravel() array([0.93015885, 0.01067508, 0.43200938, 0.24035759, 0.01564892, 0.09507133, 0.70143444, 0.46887118, 0.85551184, 0.61722919, 0.94688342, 0.92520351]) 1a.shape = (12) 1a array([0.93015885, 0.01067508, 0.43200938, 0.24035759, 0.01564892, 0.09507133, 0.70143444, 0.46887118, 0.85551184, 0.61722919, 0.94688342, 0.92520351]) 1A.transpose() array([[0.93015885, 0.01564892, 0.85551184], [0.01067508, 0.09507133, 0.61722919], [0.43200938, 0.70143444, 0.94688342], [0.24035759, 0.46887118, 0.92520351]]) 3.8 数组操作 463.8.1 连接数组 4612A = np.ones((3, 3))B = np.zeros((3, 3)) 1np.vstack((A, B)) array([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [0., 0., 0.], [0., 0., 0.], [0., 0., 0.]]) 1np.hstack((A,B)) array([[1., 1., 1., 0., 0., 0.], [1., 1., 1., 0., 0., 0.], [1., 1., 1., 0., 0., 0.]]) 123a = np.array([0, 1, 2])b = np.array([3, 4, 5])c = np.array([6, 7, 8]) 1np.column_stack((a, b, c)) array([[0, 3, 6], [1, 4, 7], [2, 5, 8]]) 1np.row_stack((a, b, c)) array([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) 3.8.2 数组切分 471A = np.arange(16).reshape((4, 4)) 1A array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) 1[B,C] = np.hsplit(A, 2) 1B array([[ 0, 1], [ 4, 5], [ 8, 9], [12, 13]]) 1C array([[ 2, 3], [ 6, 7], [10, 11], [14, 15]]) 1[B,C] = np.vsplit(A, 2) 1B array([[0, 1, 2, 3], [4, 5, 6, 7]]) 1C array([[ 8, 9, 10, 11], [12, 13, 14, 15]]) 1[A1,A2,A3] = np.split(A,[1,3],axis=1) 1A1 array([[ 0], [ 4], [ 8], [12]]) 1A2 array([[ 1, 2], [ 5, 6], [ 9, 10], [13, 14]]) 1A3 array([[ 3], [ 7], [11], [15]]) 1[A1,A2,A3] = np.split(A,[1,3],axis=0) 1A1 array([[0, 1, 2, 3]]) 1A2 array([[ 4, 5, 6, 7], [ 8, 9, 10, 11]]) 1A3 array([[12, 13, 14, 15]]) 3.9 常用概念 493.9.1 对象的副本或视图 4912a = np.array([1, 2, 3, 4])b = a 1b array([1, 2, 3, 4]) 1a[2] = 0 1b array([1, 2, 0, 4]) 1c = a[0:2] 1c array([1, 2]) 1a[0] = 0 1c array([0, 2]) 1a = np.array([1, 2, 3, 4]) 1c = a.copy() 1c array([1, 2, 3, 4]) 1a[0] = 0 1c array([1, 2, 3, 4]) 3.9.2 向量化 503.9.3 广播机制 501A = np.arange(16).reshape(4, 4) 1b = np.arange(4) 1A array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) 1b array([0, 1, 2, 3]) 1A + b array([[ 0, 2, 4, 6], [ 4, 6, 8, 10], [ 8, 10, 12, 14], [12, 14, 16, 18]]) 1m = np.arange(6).reshape(3, 1, 2) 1n = np.arange(6).reshape(3, 2, 1) 1m array([[[0, 1]], [[2, 3]], [[4, 5]]]) 1n array([[[0], [1]], [[2], [3]], [[4], [5]]]) 1m + n array([[[ 0, 1], [ 1, 2]], [[ 4, 5], [ 5, 6]], [[ 8, 9], [ 9, 10]]]) 3.10 结构化数组 521structured = np.array([(1, 'First', 0.5, 1+2j),(2, 'Second', 1.3, 2-2j), (3, 'Third', 0.8, 1+3j)],dtype=('i2, a6, f4, c8')) 1structured array([(1, b&#39;First&#39;, 0.5, 1.+2.j), (2, b&#39;Second&#39;, 1.3, 2.-2.j), (3, b&#39;Third&#39;, 0.8, 1.+3.j)], dtype=[(&#39;f0&#39;, &#39;&lt;i2&#39;), (&#39;f1&#39;, &#39;S6&#39;), (&#39;f2&#39;, &#39;&lt;f4&#39;), (&#39;f3&#39;, &#39;&lt;c8&#39;)]) 1structured = np.array([(1, 'First', 0.5, 1+2j),(2, 'Second', 1.3,2-2j),(3, 'Third', 0.8, 1+3j)],dtype=('int16, a6, float32, complex64')) 1structured array([(1, b&#39;First&#39;, 0.5, 1.+2.j), (2, b&#39;Second&#39;, 1.3, 2.-2.j), (3, b&#39;Third&#39;, 0.8, 1.+3.j)], dtype=[(&#39;f0&#39;, &#39;&lt;i2&#39;), (&#39;f1&#39;, &#39;S6&#39;), (&#39;f2&#39;, &#39;&lt;f4&#39;), (&#39;f3&#39;, &#39;&lt;c8&#39;)]) 1structured[1] (2, b&#39;Second&#39;, 1.3, 2.-2.j) 1structured['f1'] array([b&#39;First&#39;, b&#39;Second&#39;, b&#39;Third&#39;], dtype=&#39;|S6&#39;) 1structured = np.array([(1,'First',0.5,1+2j),(2,'Second',1.3,2-2j),(3,'Third',0.8,1+3j)],dtype=[('id','i2'),('position','a6'),('value','f4'),('complex','c8')]) 1structured array([(1, b&#39;First&#39;, 0.5, 1.+2.j), (2, b&#39;Second&#39;, 1.3, 2.-2.j), (3, b&#39;Third&#39;, 0.8, 1.+3.j)], dtype=[(&#39;id&#39;, &#39;&lt;i2&#39;), (&#39;position&#39;, &#39;S6&#39;), (&#39;value&#39;, &#39;&lt;f4&#39;), (&#39;complex&#39;, &#39;&lt;c8&#39;)]) 1structured.dtype.names = ('id','order','value','complex') 1structured['order'] array([b&#39;First&#39;, b&#39;Second&#39;, b&#39;Third&#39;], dtype=&#39;|S6&#39;) 3.11 数组数据文件的读写 533.11.1 二进制文件的读写 541data = np.random.random(16).reshape(4,4) 1data array([[0.87899377, 0.11342252, 0.6682891 , 0.90832539], [0.33643193, 0.49913359, 0.46395367, 0.38503354], [0.30343769, 0.74571053, 0.16758969, 0.11507577], [0.00213888, 0.12661618, 0.71188585, 0.95622255]]) 1np.save('saved_data',data) 1loaded_data = np.load('saved_data.npy') 1loaded_data array([[0.87899377, 0.11342252, 0.6682891 , 0.90832539], [0.33643193, 0.49913359, 0.46395367, 0.38503354], [0.30343769, 0.74571053, 0.16758969, 0.11507577], [0.00213888, 0.12661618, 0.71188585, 0.95622255]]) 3.11.2 读取文件中的列表形式数据 541data = np.genfromtxt('data.csv', delimiter=',', names=True) 1data array([(1., 123., 1.4, 23.), (2., 110., 0.5, 18.), (3., 164., 2.1, 19.)], dtype=[(&#39;id&#39;, &#39;&lt;f8&#39;), (&#39;value1&#39;, &#39;&lt;f8&#39;), (&#39;value2&#39;, &#39;&lt;f8&#39;), (&#39;value3&#39;, &#39;&lt;f8&#39;)]) 1data2 = np.genfromtxt('data2.csv', delimiter=',', names=True) 1data2 array([(1., 123., 1.4, 23.), (2., 110., nan, 18.), (3., nan, 2.1, 19.)], dtype=[(&#39;id&#39;, &#39;&lt;f8&#39;), (&#39;value1&#39;, &#39;&lt;f8&#39;), (&#39;value2&#39;, &#39;&lt;f8&#39;), (&#39;value3&#39;, &#39;&lt;f8&#39;)]) 3.12 小结 55]]></content>
      <categories>
        <category>python</category>
        <category>numpy</category>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第2章-ptyhon世界简介]]></title>
    <url>%2F2018%2F04%2F11%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC2%E7%AB%A0-ptyhon%E4%B8%96%E7%95%8C%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[这一章主要是回顾一些python的知识点。 第2章 Python世界简介 122.1 Python——编程语言 122.2 Python——解释器 132.2.1 Cython 142.2.2 Jython 142.2.3 PyPy 142.3 Python 2和Python 3 142.4 安装Python 152.5 Python发行版 152.5.1 Anaconda 152.5.2 Enthought Canopy 162.5.3 Python(x,y) 172.6 使用Python 172.6.1 Python shell 172.6.2 运行完整的Python程序 172.6.3 使用IDE编写代码 182.6.4 跟Python交互 182.7 编写Python代码 182.7.1 数学运算 1812345678910111213&gt;&gt;&gt; 1 + 23&gt;&gt;&gt; (1.045 * 3)/40.78375&gt;&gt;&gt; 4 ** 216&gt;&gt;&gt; ((4 + 5j) * (2 + 3j))(-7+22j)&gt;&gt;&gt; 4 &lt; (2*3)True&gt;&gt;&gt; a = 12 * 3.4&gt;&gt;&gt; a40.8 2.7.2 导入新的库和函数 191234567891011121314151617181920212223242526272829303132&gt;&gt;&gt; import math&gt;&gt;&gt; math.sin(a)&gt;&gt;&gt; from math import *&gt;&gt;&gt; sin(a)&gt;&gt;&gt; from math import sin&gt;&gt;&gt; dict = &#123;&apos;name&apos;:&apos;William&apos;, &apos;age&apos;:25, &apos;city&apos;:&apos;London&apos;&#125;&gt;&gt;&gt; dict[&quot;name&quot;]&apos;William&apos;&gt;&gt;&gt; for key, value in dict.items():... print(key,value)...name Williamcity Londonage 25&gt;&gt;&gt; list = [1,2,3,4]&gt;&gt;&gt; list[1, 2, 3, 4]&gt;&gt;&gt; list[2]3&gt;&gt;&gt; list[1:3][2, 3]&gt;&gt;&gt; list[-1]4&gt;&gt;&gt; items = [1,2,3,4,5]&gt;&gt;&gt; for item in items:... item + 1...23456 2.7.3 函数式编程 211234567891011121314151617181920&gt;&gt;&gt; items = [1,2,3,4,5]&gt;&gt;&gt; def inc(x): return x+1...&gt;&gt;&gt; list(map(inc,items))[2, 3, 4, 5, 6]&gt;&gt;&gt; list(map((lambda x: x+1),items))[2, 3, 4, 5, 6]filter函数只抽取函数返回结果为True的列表元素。reduce函数对列表中的而所有元素依次计算过后返回唯一结果。&gt;&gt;&gt; list(filter((lambda x: x &lt; 4), items))[1, 2, 3]&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; reduce((lambda x,y: x/y), items)0.008333333333333333&gt;&gt;&gt; S = [x**2 for x in range(5)]&gt;&gt;&gt; S[0, 1, 4, 9, 16] 2.7.4 缩进 22123456789101112131415&gt;&gt;&gt; a = 4&gt;&gt;&gt; if a &gt; 3:... if a &lt; 5:... print(&quot;I&apos;m four&quot;)... else:... print(&quot;I&apos;m a little number&quot;)...I&apos;m four&gt;&gt;&gt; if a &gt; 3:... if a &lt; 5:... print(&quot;I&apos;m four&quot;)... else:... print(&quot;I&apos;m a big number&quot;)...I&apos;m four 2.8 IPython 232.8.1 IPython shell 232.8.2 IPython Qt-Console 242.9 PyPI仓库——Python包索引 252.10 多种Python IDE 262.10.1 IDLE 262.10.2 Spyder 272.10.3 Eclipse（pyDev） 272.10.4 Sublime 282.10.5 Liclipse 292.10.6 NinjaIDE 292.10.7 Komodo IDE 292.11 SciPy 302.11.1 NumPy 302.11.2 pandas 302.11.3 matplotlib 312.12 小结 31]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开放数据源]]></title>
    <url>%2F2018%2F04%2F11%2F%E5%BC%80%E6%94%BE%E6%95%B0%E6%8D%AE%E6%BA%90%2F</url>
    <content type="text"><![CDATA[DataHub WorldHealthOrganization Data.gov EuropeanUnionOpenDataPortal AmazonWebServicepublicdatasets FacebookGraph Healthdata.gov GoogleTrends GoogleFinance GoogleBooksNgrams MachineLearningRepository 后续陆续更新中]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>数据源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第1章-数据分析简介]]></title>
    <url>%2F2018%2F04%2F11%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC1%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[1.1数据分析什么是数据，数据不同于信息。信息实际上是对数据集进行处理，从中提炼出可用于其他场合的结论，也就是说，它是对数据进行处理后得到的结果。从原始数据中抽取信息的这个过程就叫做数据分析。 数据分析的目的正是抽取不易推断的信息，而一旦理解了这些信息，就能够对产生数据的系统的运行机制进行研究，从而对系统可能的响应和演变做出预测。 数据分析最初用于数据保护，现在已经发展成为数据建模的方法论，从而完成了到一门真正科学的转变。模型实际上是指将所研究的系统转化为数学形式。一旦建立数学或逻辑模型，对系统的响应能做出不同精度的预测，我们就可以预测在给定输入的情况下，系统会给出怎样的输出。这样看来，数据分析的目的不止是建模，更重要的是其预测能力。 模型的预测能力不仅取决于建模技术的质量，还取决于选择分析使用的优质数据集的能力。因此数据搜索、数据提取、数据准备也是属于数据分析的范畴，他们对最终结果有重要影响。 在数据分析的各个阶段还是有各种各样的数据可视化方法。无论是孤立的看数据，还是将其放到整个数据集来看，理解数据的最好的方法莫过于将其做成可视化的图形，从而传达出数字中蕴含的信息。 数据分析的产出为模型和图形化展示，据此可预测所研究系统的响应。随后进入测试阶段，用已知输出结果的一个数据集对模型进行测试。这些数据不是用来生成模型的，而是用来检验系统给的能否重现实际观察到的输出，从而掌握模型的误差，了解其有效性和局限。 拿新模型的测试结果与既有模型进行对比便可知道优劣。如果新模型胜出，既可尽心该数据分析的最后一步，部署。部署阶段需要根据摩西个给出的预测结果，实现相应的决策，同时还要防范模型预测到的潜在风险。 1.2数据分析师的知识范畴 计算机科学 数据和统计学 机器学习和人工智能 数据来源领域 1.3理解数据的性质数据 -&gt; 信息 -&gt; 知识 1.4数据分析过程数据分析过程可以用下图表示 问题定义 数据抽取 数据清洗 数据转换 数据探索 预测模型 模型评估/测试 结果可视化和阐释 解决方案部署 1.5 定量和定性数据分析 1.6 开放数据源开放数据源 1.7 python和数据分析python大量的库为数据分析和处理提供了完整的工具集，也广泛应用于科学计算领域。]]></content>
      <categories>
        <category>数据分析</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-Samba服务器配置]]></title>
    <url>%2F2018%2F04%2F11%2Flinux-Samba%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1.安装samba12345samba: sudo apt-get install sambasmbclient: sudo apt-get install smbclient 2.修改配置文件sudo vi /etc/samba/smb.conf在文件末尾加上如下[share] （相当于在home目录项增加了一个新用户）123456789101112[share]comment = Share Folder require passwordbrowseable = yespath = /home/sharecreate mask = 0777directory mask = 0777valid users = shareforce user = nobodyforce group = nogrouppublic = yeswritable = yesavailable = yes 3.保存退出后重启sambasudo /etc/init.d/samba restart 4.切换到 /home/目录下创建一个用户目录：sudo mkdir share 5.设置目录的权限： （777代表最高权限，可读可写可执行）chmod 777 share 6.增加相应的系统账号sudo groupadd share -g 6000sudo useradd share -u 6000 -s /shin/nologin -d /dev/null 7.最后打开我的电脑空白位置右键添加一个网络位置输入 \IP地址（linux）\share 按提示步骤输入用户名和密码。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令-压缩分割]]></title>
    <url>%2F2018%2F04%2F10%2Flinux%E5%91%BD%E4%BB%A4-%E5%8E%8B%E7%BC%A9%E5%88%86%E5%89%B2%2F</url>
    <content type="text"><![CDATA[1、tar压缩tar -zcvf cm-11.tar.gz cm-11//将cm-11文件夹压缩成cm-11.tar.gz tar -jcvf cm-11.tar.gz cm-11//将cm-11文件夹压缩成cm-11.tar.bz2 2、分割压缩后的文件太大，需要将cm-11.tar.gz分割成N个指定大小的文件split -b 4000M -d -a 1 cm-11.tar.gz cm-11.tar.gz. //使用split命令，-b 4000M 表示设置每个分割包的大小，单位还是可以k// -d “参数指定生成的分割包后缀为数字的形式//-a x来设定序列的长度(默认值是2)，这里设定序列的长度为1 3、解压tar -zxvf cm-11.tar.gztar -jxvf cm-11.tar.bz2 4、分割后的压缩包解压命令如下cat cm-11.tar.gz.* | tar -zxv]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas使用经验-拆分dataframe中的字典]]></title>
    <url>%2F2018%2F04%2F10%2Fpandas%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C-%E6%8B%86%E5%88%86dataframe%E4%B8%AD%E7%9A%84%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[如果导入的dataframe中包含有字典的，使用data.join(data[‘A10’].apply(json.loads).apply(pd.Series))来拆分字典，组合成不同的列。 123456789101112131415161718192021222324252627282930import pandas as pdimport jsonfilename = &apos;top5.txt&apos;data = pd.read_csv(filename, sep=&quot;\t&quot;, header=None)# test model.8.10 modelname 810 8101 2018-03-28 04:21:13 2018-03-28 04:21:13 # 1 0 2018-04-02 14:50:54 &#123;&quot;cell_info&quot;:&quot;LTE PLMN:46000 EARFCN:38400(B39) Cell Identity# :197539969 PCI:141 TAC:37884 RSSI:-65 RSRP:-95 RSRQ:-11 SINR*10: 133 EMM state:REGISTERED # service state:NORMAL reg domain:CS_PS lte_tx_power tx = 9 lte_rx_chain0 rssi=-64 rsrp=-94 # sinr=133 lte_rx_chain1 rssi=-69 rsrp=-99 sinr=118 &quot;,&quot;log_from&quot;:&quot;com.android.phone&quot;,# &quot;reg_at_time&quot;:&quot;31112&quot;,&quot;rat&quot;:&quot;14&quot;,&quot;reg_during_time&quot;:&quot;3554&quot;,&quot;hplmn&quot;:&quot;46002&quot;&#125; 2018-04-02columns = []for i in range(data.shape[1]): columns.append(&apos;A&apos; + str(i))data.columns = columnsprint(data.columns)# Index([&apos;A0&apos;, &apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;, &apos;A4&apos;, &apos;A5&apos;, &apos;A6&apos;, &apos;A7&apos;, &apos;A8&apos;, &apos;A9&apos;, &apos;A10&apos;,&apos;A11&apos;],# dtype=&apos;object&apos;)print(data[&apos;A10&apos;])# 0 &#123;&quot;cell_info&quot;:&quot;LTE PLMN:46000 EARFCN:38400(B39...data = data.join(data[&apos;A10&apos;].apply(json.loads).apply(pd.Series))print(data.columns)# Index([&apos;A0&apos;, &apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;, &apos;A4&apos;, &apos;A5&apos;, &apos;A6&apos;, &apos;A7&apos;, &apos;A8&apos;, &apos;A9&apos;, &apos;A10&apos;,# &apos;A11&apos;, &apos;cell_info&apos;, &apos;hplmn&apos;, &apos;log_from&apos;, &apos;rat&apos;, &apos;reg_at_time&apos;,# &apos;reg_during_time&apos;],# dtype=&apos;object&apos;)]]></content>
      <categories>
        <category>pandas</category>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>pandas</tag>
        <tag>数据导入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas使用经验-1]]></title>
    <url>%2F2018%2F04%2F10%2Fpandas%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C-fillna%2F</url>
    <content type="text"><![CDATA[函数原型：https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.fillna.html#pandas.DataFrame.fillna pad/ffill：用前一个非缺失值去填充该缺失值backfill/bfill：用下一个非缺失值填充该缺失值None:指定一个值去替换缺失值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# coding: utf-8import pandas as pddf = pd.DataFrame([[1, None, 2], [None, 3, None], [None, 4, 5],])print('origin')print(df)# 0 1 2# 0 1.0 NaN 2.0# 1 NaN 3.0 NaN# 2 NaN 4.0 5.0print('left')data = df.bfill(axis=1).iloc[:, 0]print(data)# 0 1.0# 1 3.0# 2 4.0print('up')data = df.bfill().iloc[:, -1]print(data)# 0 2.0# 1 5.0# 2 5.0print('left')data = df.fillna(method='bfill',axis=1)print(data)# 0 1 2# 0 1.0 2.0 2.0# 1 3.0 3.0 NaN# 2 4.0 4.0 5.0print('up')data = df.fillna(method='bfill')print(data)# 0 1 2# 0 1.0 3.0 2.0# 1 NaN 3.0 5.0# 2 NaN 4.0 5.0print('right')data = df.fillna(method='ffill',axis=1)print(data)# 0 1 2# 0 1.0 1.0 2.0# 1 NaN 3.0 3.0# 2 NaN 4.0 5.0print('down')data = df.fillna(method='ffill')print(data)# 0 1 2# 0 1.0 NaN 2.0# 1 1.0 3.0 2.0# 2 1.0 4.0 5.0print('left')data = df.fillna(method='backfill',axis=1)print(data)# 0 1 2# 0 1.0 2.0 2.0# 1 3.0 3.0 NaN# 2 4.0 4.0 5.0print('up')data = df.fillna(method='backfill')print(data)# 0 1 2# 0 1.0 3.0 2.0# 1 NaN 3.0 5.0# 2 NaN 4.0 5.0print('right')data = df.fillna(method='pad',axis=1)print(data)# 0 1 2# 0 1.0 1.0 2.0# 1 NaN 3.0 3.0# 2 NaN 4.0 5.0print('down')data = df.fillna(method='pad')print(data)# 0 1 2# 0 1.0 NaN 2.0# 1 1.0 3.0 2.0# 2 1.0 4.0 5.0 12345678910111213141516171819202122232425262728293031323334353637383940414243import pandas as pdimport numpy as npdf = pd.DataFrame([[np.nan, 2, np.nan, 0], [3, 4, np.nan, 1], [np.nan, np.nan, np.nan, 5], [np.nan, 3, np.nan, 4]], columns = list(&apos;ABCD&apos;))print(df)# A B C D# 0 NaN 2.0 NaN 0# 1 3.0 4.0 NaN 1# 2 NaN NaN NaN 5# 3 NaN 3.0 NaN 4print(df.fillna(0))# A B C D# 0 0.0 2.0 0.0 0# 1 3.0 4.0 0.0 1# 2 0.0 0.0 0.0 5# 3 0.0 3.0 0.0 4print(df.fillna(method=&apos;ffill&apos;))# A B C D# 0 NaN 2.0 NaN 0# 1 3.0 4.0 NaN 1# 2 3.0 4.0 NaN 5# 3 3.0 3.0 NaN 4values = &#123;&apos;A&apos;: 0, &apos;B&apos;: 1, &apos;C&apos;: 2, &apos;D&apos;: 3&#125;print(df.fillna(value=values))# A B C D# 0 0.0 2.0 2.0 0# 1 3.0 4.0 2.0 1# 2 0.0 1.0 2.0 5# 3 0.0 3.0 2.0 4print(df.fillna(value=values, limit=1))# A B C D# 0 0.0 2.0 2.0 0# 1 3.0 4.0 NaN 1# 2 NaN 1.0 NaN 5# 3 NaN 3.0 NaN 4]]></content>
      <categories>
        <category>pandas</category>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>pandas</tag>
        <tag>数据处理</tag>
        <tag>数据清洗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转载)ubuntu下使用woeusb创建windows启动U盘]]></title>
    <url>%2F2018%2F04%2F04%2F%E8%BD%AC%E8%BD%BD-ubuntu%E4%B8%8B%E4%BD%BF%E7%94%A8woeusb%E5%88%9B%E5%BB%BAwindows%E5%90%AF%E5%8A%A8U%E7%9B%98%2F</url>
    <content type="text"><![CDATA[ubuntu(16.04)创建windows启动U盘，使用woeusb，而不是dd 使用dd创建经常不能启动，听说是必须使用isohybrid转换以后才能到u盘（另外，对于克隆linux系统，如果已经有现成的linux系统，安装一个squashfs-tools,直接把光盘里的根unsquashfs拷贝到一个分区，然后chroot进去改一下密码就行了） 那么我们必须使用另外一个工具：woeusb 安装： 123sudo add-apt-repository ppa:nilarimogard/webupd8 sudo apt update sudo apt install woeusb 图形界面的使用就不讲了，讲了命令行的：123sudo woeusb --device &lt;/path/to/windows.iso&gt; &lt;device&gt; for example sudo woeusb --device /home/windows.iso /dev/sdc Update: if you get an error like this: “Error: Partition(s) on /dev/sdb are being used” when WinUSB / WoeUSB tries to format the USB stick from the command line, or “Error 256” in the beginning of the process when using the GUI, you must unmount the partitions. Firstly, to get a list of partitions, run the following command (“mount” also works):1df -aTh This should list all the partitions mounted on your system. If you got here, you should already know the USB device drive, e.g. /dev/sdc, so you need to look for the partitions (it could also only be one) on this drive, like /dev/sdc1, /dev/sdc2, etc. Then, unmount them like this (example):12sudo umount /dev/sdc1 sudo umount /dev/sdc2]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源硬件列表]]></title>
    <url>%2F2018%2F04%2F03%2F%E5%BC%80%E6%BA%90%E7%A1%AC%E4%BB%B6%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[通信类： RTLSDRUSRPHacking RF 流行的开源硬件ArduinoRaspberry Pi 树莓派社区http://www.raspberrypi.org/community/ Arduino论坛http://forum.arduino.cc/ 几个不错的开源硬件社区http://www.openhardware.net/https://wiki.debian.org/open_hardwarehttp://p2pfoundation.net/Category:Designhttp://harkopen.com/ 还有一些不错的HACK网站 ，以下这两个都是比较有意思的硬件hack的网站http://hackaday.com/http://hackedgadgets.com/ 几个有意思的开源硬件项目Hacking RF项目http://greatscottgadgets.com/hackrf/ 开源汽车http://www.osvehicle.com/download/ http://www.oschina.net/news/47698/10-incredible-open-source-hardware-projects-in-2013?from=20140112 http://www.csdn.net/article/2014-06-30/2820457/1http://www.csdn.net/article/2014-06-30/2820457/2]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>开源硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派更新源及设置代理配置]]></title>
    <url>%2F2018%2F04%2F03%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9B%B4%E6%96%B0%E6%BA%90%E5%8F%8A%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[修改树莓派更新源及设置代理配置 更新源12345678910111213141516171819202122默认树莓派的更新源使用的是英国的源，速度奇慢；改成国内树莓派的更新源方法，看下边：备份源列表文件sudo cp /etc/apt/sources.list /etc/apt/sources.list.old在这里找到适合国内的更新源，我一般使用的是中科大的源编辑源列表sudo nano /etc/apt/sources.list删除原先的内容deb http://mirror.ox.ac.uk/sites/archive.raspbian.org/archive/raspbian wheezy main contrib non-free rpi修改成以下内容deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ wheezy main contrib non-free rpiCtrl + X确认并保存系统更新（看速度是否上来了）sudo apt-get updatesudo apt-get upgrade 代理设置123456789101112131415161718有时候上网需要设定代理，方法看这边：到下面的路径cd /etc/apt/apt.conf.d新建一个名为10proxy的文件sudo nano 10proxy编辑其中内容sudo nano /etc/apt/apt.conf.d/10proxy如果不需要认证，以下格式即可Acquire::http::Proxy &quot;http://web-proxy.corp.xx.com:8080&quot;;如果需要认证，按照以下格式Acquire::http::Proxy &quot;http://username:password@yourproxyaddress:proxyport/&quot;;Ctrl + X确认并保存，然后查看树莓派是否可以在代理下上网]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派配置中文输入法]]></title>
    <url>%2F2018%2F04%2F03%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%2F</url>
    <content type="text"><![CDATA[12345sudo apt-get install ttf-wqy-zenheisudo apt-get install scim-pinyinsudo raspi-config然后选择change_locale，在Default locale for the system environment:中选择zh_CN.UTF-8,配置完成之后，输入命令sudo reboot]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派配置静态WLAN IP]]></title>
    <url>%2F2018%2F04%2F03%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81WLAN-IP%2F</url>
    <content type="text"><![CDATA[树莓派配置静态wlan IP1路径 /etc/network/interfaces]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>WLAN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派-配置raspi-config]]></title>
    <url>%2F2018%2F04%2F03%2F%E6%A0%91%E8%8E%93%E6%B4%BE-%E9%85%8D%E7%BD%AEraspi-config%2F</url>
    <content type="text"><![CDATA[1sudo raspi-config]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派-蓝牙 基础]]></title>
    <url>%2F2018%2F04%2F03%2F%E6%A0%91%E8%8E%93%E6%B4%BE-%E8%93%9D%E7%89%99-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[树莓派-蓝牙11bluetoothctl 12pairpaired-devices 123scan offpower offexit 1help]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RF Test and Measurement-2]]></title>
    <url>%2F2018%2F04%2F03%2FRF-Test-and-Measurement-2%2F</url>
    <content type="text"><![CDATA[LTE特有的测量尽管LTE射频测量类似于其他技术有许多共同的特征，有几个测量是LTE唯一的。你能猜出这将是LTE具体测试？如果你还记得的LTE信号，我上面描述的独特性能，你会做一个很好的猜测。 IBE（In-Band Emission 带内放射) LTE的最独特的特征之一将是，在大多数情况下，UE不使用全系统带宽，这意味着它仅使用一部分射频带宽。对于射频特性而言，RF频带的这部分使用不会引起任何严重的问题，但如果所述部分被分配给中心频率的另外一边呢？你会看到频谱如下。（我无法解释这幅画的细节。只要仔细看，并试图在这张照片看，你会知道这个意思，为什么我们需要衡量这个项目）。UE发射器设计目标是尽量减少在中心频率和其他部分（image signal）的发射。 功率控制 - 绝对功率容差 当UE发送第一PUSCH发送时，功率由P0-NominalPUSCH和PUSCH功率控制算法来确定。这项测试是为了检查UE是否根据P0-NominalPUSCH和PUSCH功率控制算法设置精确的初始PUSCH功率（这和我们所说的在3G网络中开环功率控制不同的，当我们说“开环功率控制”，它通常意味着初始的PRACH功率。相反，绝对功率容差约为初始PUSCH功率）。 功率控制 - 相对功率容差 另一个方面我想提的是关于功率的控制。总体功率控制测试方法和WCDMA ILPC（内环功率控制）测试是非常相似的。网络（SS）发送TPC命令（发送功率控制命令）的连续序列，就像Up, Up, Up, Up… Down, Down, Down, Down,… 并检查UE是否正确解码命令，并设置UE TX各UP / DOWN指令（+ 1dB，1dB）指示功率。 LTE采用了类似的方法。但是，如果你看到下面的测试，你会看到在中间有一个巨大的跳跃，这是不与WCDMA相同。这是否意味着LTE具有特殊的TPC命令状10分贝或-10 dB的跳转呢？您在测试中看到的大的跳跃不是因为大的TPC命令的结果，而是RB的数量增加的结果。即使UE在每个子载波上发送相同的功率，如果UE正在使用更多的子载波，总功率就会变大。 总功率控制容差 这个测试是用来检查在无任何附加调整情况下，UL功率如何保持平稳。这个测试项是重要的，因为有在此期间，有很多种情况就像测量间隙或连接模式DRX时，UE将不能在接收任何功率控制的命令。由于该功率稳定被应用于PUCCH和PUSCH两者，此测试是有两个子试验，一个用于PUCCH和另一个用于PUSCH，如下所示。 下图是PUCCH总功率控制公差。 下图是PUSCH总功率控制公差。 射频测试设备与 UE连接图 射频一致性测试射频一致性测试的总体协议序列在36.508定义。但大多数的设备供应商有一个小的变化。我把下面有一个例子序列。 1) MIB2) SIB 1, 2, 33) RRC : PRACH Preamble4) RRC : RACH Response5) RRC : RRC Connection Request6) RRC : RRC Connection Setup7) RRC : RRC Connection Setup Complete + NAS : Attach Request8) RRC : DL Information Transfer + NAS : Authentication Request9) RRC : UL Information Transfer + NAS : Authentication Response10) RRC : DL Information Transfer + NAS : Security Mode Command11) RRC : UL Information Transfer + NAS : Security Mode Complete12) RRC: DLInformationTransfer + TC: ACTIVATE TEST MODE13) RRC: ULInformationTransfer + TC: ACTIVATE TEST MODE COMPLETE14) RRC : Security Mode Command15) RRC : Security Mode Complete16) RRC: UECapabilityEnquiry17) RRC: UECapabilityInformation15) RRC : RRC Connection Reconfiguration + NAS : Attach Accept + NAS : Activate Default EPS Bearer Context Req16) RRC : RRC Connection Reconfiguration Complete + NAS : Attach Complete17) RRC : RRC Connection Release&lt; MO or MT call &gt; : In MT call, Paging should be sent.18) RRC : PRACH Preamble19) RRC : RACH Response20) RRC : RRC Connection Request21) RRC : RRC Connection Setup22) RRC : RRC Connection Setup Complete23) RRC : Security Mode Command24) RRC : Security Mode Complete25) RRC : RRC Connection Reconfiguration26) RRC : RRC Connection Reconfiguration Complete&lt; Perform Test Case &gt;27) RRC : RRC Connection Release 和普通的呼叫处理协议序列不同的一个重要步骤，主要不同的部分是“TC：ACTIVE TEST MODE”。这一部分中详细地下列规格说明。 36.509 - 6.5 ACTIVATE TEST MODE36.509 - 5.3.2.3 Reception of ACTIVATE TEST MODE message by UE 不像在UMTS测试模式，LTE射频一致性测试的测试模式不建立环回模式。 LTE中的测试模式的主要目的，在36.509中描述 - 5.3.2.3如下。 当UE测试模式是激活的，则UE应当接受任何请求建立数据无线承载与相关联的EPS承载上下文，既包含在相同RRC消息，并在UE的无线接入功能。 射频一致性测试 - TRX一致性（36.521-1）似乎很多人都认为射频一致性仅用于测试手机的射频前端部分的性能/功能。这可能是事实，但这些测试的最终目的是为了确保UE在实网中的没有任何问题。所以每个测试项目都是和实网中的一个或多个步骤相关联。因此，具有实网中UE和网络之间交互过程的大画面是非常重要的，并发现这些一致性测试项目和步骤与实网过程/步骤之间的相关性。经常有人问我：“为什么我们需要测试这些测试项目？这些试验的目的是什么？”。如果你看到的3GPP规范（36.521），以查找对此类问题..答案被描述在“试验目的”部分，如下所示。下面的例子是6.3 动态输出功率。 当功率设置为最小值时，为了验证该UE是否有能力以一个低于测试设备上指定的输出功率传输。 这是否有任何意义吗？至少对我来说，没有太多。这说明有利于测试成功或者失败的标准，但并没有给我的测试目的有任何实际意义。 我建议是描述整个活网络程序以高层的水平如下，并尝试各一致性测试用例来映射到您的高层描述的步骤中。1）UE处于关闭状态2）UE开机3）&lt;频率搜索&gt;4）&lt;小区搜索&gt;：正常情况下，在这个过程中UE会发现多个小区5）&lt;小区选择&gt;6）MIB解码7）SIB 解码8）&lt;初始RACH过程&gt;9）&lt;注册/验证/连接&gt;10）&lt;默认EPS承载设置&gt;11）现在UE处于空闲模式12）&lt;（如果当前的电池变弱或UE移动到另一个小区注册）小区重选&gt;13）&lt;（当寻呼消息到来或用户拨打电话）RACH过程&gt;14）&lt;设置专用EPS承载&gt;15）接收数据16）发送数据17）（如果网络接收到UE功率太弱）网络发送TPC命令来增加UE Tx功率18）（如果网络接收到UE功率太强）网络发送TPC命令减少UE Tx功率19）&lt;（如果UE移动到另一小区区域）的网络和UE执行切换过程&gt;20）用户停止呼叫，UE进入空闲模式 如果你只是一味地寻找到一致性测试规范，你可能会对大量的测试用例的数量不知所措。有没有可能让我理解所有这些？我必须放弃挖掘细节，只按测试系统上的按钮，并采取盲目测试而不管机器吐出来什么东西？但是，一旦你得到了这些测试用例的大图，你会发现，所有这些测试用例可以分组称为这个框架的一部分。 首先我对你的建议是去理解每章的概念（大图），而不是直接跳跃到每个测试用例。 让我们来看看TRX一致性36.521-1的每个章节。这四个章节都与上述的3）5）19）相关联的。第6章，第7章是直截了当，他们是测试最广泛的，从开发阶段到生产线的测试。看到第8章的标题，你可能会得到一点点的混淆，当我们说“性能”，很多人会认为“IP吞吐量”。但在这种情况下，它是不正确的。在这种情况下，“性能”是指“UE如何在各种嘈杂的信道条件成功解码下行链路信号”。第9章是衡量“UE如何精确地测量各种信道条件，并报告给网络？”。总之，它是测量CQI（信道质量指示符），RI（秩指数），PMI（预编码矩阵索引）。 现在，让我们看看在每章每一个测试用例。第6章（发射机特性）有以下测试用例。正如你看到的，它只是衡量UE发射功率的不同情况和数据调制质量。大部分的测试项目，是LTE独有的。 第7章几乎是和WCDMA相同的接收机的测量。基本上这些测试用例都是测量多少数据被正确解码，在各种UE的接收机功率（网络传输功率）多少数据丢失。 第8章主要是测试关于各种嘈杂/衰落信道条件下，UE如何解调重要的下行信号（例如，PDSCH，PCFICH/ PDCCH，PHICH）。正如你可能已经猜到，这些测试用例是用像A9，A10，A11的测试系统配置（如前面的章节（TS36.508附录A））。 第9章是用于测量UE关于无线信道状态各种反馈（CQI，RI，PMI）。对于这个测量，我们要模仿各种信道条件，所以我们需要使用像A9，A10等测试配置如前面的章节（TS36.508附录A） 射频一致性测试 - RRM一致性（36.521-3） 射频/物理层性能测试概述性能测试RF/ PHY的基本理念是非常简单的。正如在下面的图中所见，一个DUT（UE）连接至SS（信令模拟器），单个小区和衰减器和AWGN，被连接到下行链路路径。目的是测试UE如何能够在恶劣的信道条件解码的各种下行链路物理信道（例如，在AWGN和/或衰落的存在）。 你可以找到来自36.521-18性能要求的性能测试的细节。有此章中相当多的测试用例如前一节的表格，但我们可以简化整套测试在一个简单的表如下。 测试信道（UE必须解码的信道）PDSCH，PCFICH/ PDCCH，PBCH，PHICH测试参数（测试条件）Rho A，Rho B，NOC，调制方式衰落条件EVA5，ETU70，ETU300，HSTSNR-1.0〜19.1 注意：如果你有兴趣更详尽的测试，是指物理层吞吐量/性能测试（我个人的测试） 《end》]]></content>
      <categories>
        <category>通信</category>
        <category>RF</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>RF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RF Test and Measurement-1]]></title>
    <url>%2F2018%2F04%2F03%2FRF-Test-and-Measurement-1%2F</url>
    <content type="text"><![CDATA[在任何无线通信设备，我们必须要经过两个大组的测试。一个用于检测发射路径，另一个用于测试接收路径。 用于无线通信装置要正常工作，它应满足下面的硬件要求1）该装置应传输是足够强大的功率，使之确保它到达通信对方的信号要求。2）设备不应发送太强的信号，而干扰其他各方之间的通信信号。3）该装置应发送足够好的信号质量，另一方可解码/校正的信号。4）该装置应当在已分配的用于通信的精确频率上发射信号。5）装置不应该产生任何噪音，除了分配给该装置的频率区域之外的其他频率区域。 如果任何这些条件和规范偏离过多，该装置不能与另一方进行通信或不能让一些其它设备进行通信。在测量设备中，1）和2）属于“功率测量”，3）是有关“调制分析”和4）属于“频率误差测量”。5）也是一种“功率测量”的，但是测量区的频域范围和1）2）不同。无论如何，如果你有一个可以执行以下三个测量你的通信技术的任何设备，你可以做传输路径的最关键的部分。 A）功率测量B）调制分析C）频率误差测量 现在，让我们想想接收路径测量。什么是用于通信设备的最重要的接收机特性？1）本接收机必须能够成功地解码从发射器来的信号，即使信号强度是很低。二）接收机必须能够成功地解码发射机传来的信号，即使当有一定水平的信号周围噪声。 在测量逻辑中，1）和2）的条件是相同的。设备发送已知信号，并让接收机解码，来比较由接收机解码信号和设备的原来信息有多大不同。差别越大，表明接收机质量越差。我们称这种方法叫“BER（误码率）测量”。1）是在输入信号非常低是测量BER，2）是在有噪声的输入信号时测量BER。 在我们前进到LTE测量之前，随便选中你已经很熟悉的技术，在你的测试计划列出来要测量的列表，并试图映射这些项目与我上面描述的测量原理。一旦你熟悉这种映射，你就会更容易明白LTE测量项目。 LTE射频测量项目现在，让我们来一点点看看LTE射频测量的细节。第一件事，我所做的是使来自3GPP36.521-1测量项目清单，并试图映射我的测量原理与每个测量项目。 在这里，首先进入的发射机测量项目。你看很多的“功率测量”和一些“调制分析”。为什么我们有这么多不同的功率测量和多种不同调制分析。他们如何各不相同？这是你必须要找到自己的答案。答案本身在3GPP36.521-1描述，但问题是，我多少可以理解所描述，那里只是通过阅读它。 第一步读每个测试的情况下的“测试目的”，“初始条件”，“测试程序”一节，并尝试至少要熟悉每个测试用例。下面是一些接收机测试项 LTE上行信号的RF测试快照正如我刚才所说，仅仅通过阅读说明书，这是不容易理解LTE射频测量的所有细节。我已阅读测试案例的目的，“初始条件”，“测试程序”一遍一遍地……但还是一切都是模糊的。当我试图让更多的进入细节，第一个障碍，阻止我的是很多描述测试条件复杂表。当然，我们看到了这种在其他技术规范像CDMA，WCDMA表，但似乎表LTE测量看起来更大，更复杂。所以，我决定去看看一些在频谱分析仪的说明书中描述的信号模式，以便我能得到的每个条件的整体RF特性的一些直观的想法。 例如，下表显示了关于MPR（最大功率衰减）的每个子测试的试验条件。如果你看到第一列上行链​​路配置 - RB分配。您将看到资源块分配的各种不同情况为同一道带宽。一些子试验使用“最大RB号”（FULL的RB）的特定信道的BW，但一些子测试的使用RB数，它比RB（部分的RB）的最大数目要少。 &lt; Full RB Signals &gt; &lt; Partial RB signals &gt;对于分配的RB的数量小于最大的RB（特别是指当RB的数量小于1/2最大的RB，可以有根据信号的位置，有许多不同的情况。例如，该信号可以位于在信道的最左侧或在中心或者最右边。从理论上讲，它可以位于频带的任何地方，但射频一致性仅指定三个地点作为测试点，低范围，中范围，高范围。最低范围意味着，从信道的最左侧的信号开始，中间装置的信号位于所述通道的中心，高范围意味着该信号是在的最右边侧渠道。 下面的示例信号是从生成一个非常好的信号质量的矢量信号发生器和功率也非常低，所以你看到的只是信号的一部分，没有任何载波泄漏或带图像。但在现实中，你会看到在大多数的情况下的载波泄漏和带图像信号。 尽管我们每隔几年都有新的技术和LTE对很多人来说是新的，RF测试和测量技术与其他无线通信技术具有很多共同点。如果你有经验，任何无线技术，如CDMA，GSM，WCDMA，蓝牙，WLAN，您可能会发现在LTE的共同逻辑。 对于LTE射频测试挑战在LTE测量中，UE开发或测试工程师面临的最大挑战将是，有太多的不同的参数设置。我进一步详细太多的子测试之前，我想通过从C2K整体射频测量简要说明。 我对C2K测量没有太多经验，但只有一点点的经验，我可以告诉你们，有在这方面相对于比较WCDMA / HSDPA，C2K测量项目要少得多，甚至相比GSM / GPRS网络相比较。至于我记得，下面是所有我做过的C2K。 1）总信道功率2）CDP（码域功率）3）Rho4）频谱辐射5）ACLR6）OBW（占用带宽） 但是，上面列出的项目超过我经历的C2K。对于一致性，我想我们可能要经过所有这些项目。但由于C2K是非常成熟的技术，现在在射频部分的开发阶段，我们不会去通过所有的这些测试项目。我听到的一个极端的情况下，“只是测量总功率，如果没有问题的。通常其它部件没有问题”。 现在让我们看看到WCDMA。对于WCDMA R99（non-HSPA），如果我简要地列入名单 1）最大功率2）最小功率3）开/关功率4）RACH 功率5）EVM6）频谱辐射7）ACLR8）OBW（占用带宽） 在名单上，它看起来并不像从C2K太大的差别。但实际上工程师将满足这看起来可能C2K完全不同的各种特性。我们能想到的第一件事是，和C2K相比，信道带宽得到了两倍，这将引入大量复杂的RF设计。另一个问题是在WCDMA的RACH过程比C2K的探测过程中添加几个重要的测试步骤，变的更为复杂。 现在，让我们再看看HSDPA。你可能会认为HSDPA在上行链路测量方面和R99不会有很大不同，因为HSDPA仅用于下行链路数据速率。这是在高层协议方面真实的，但在物理/ RF层上，在HSDPA上在上行加入了一个重要因素。它是HS-DPCCH。 HS-DPCCH是用于UE来报告CQI和ACK / NACK并发送到基站。问题是，即使有这样的附加信道的UE还必须保持总的上行链路功率和以前一样。因此，UE重新计算/重新安排每个物理信道的功率。所以，如果你看一下射频一致性测试案例列表中，你不会找到测试用例项目方面有很大的差异，但你会发现相当多的人加入到现有的测试用例子项目，就是因为引入HS-DPCCH。 （如果你想进入进一步的细节，开拓3GPP 34.121，找到测试用例关键字“HSDPCCH”的测试）。 往前一步到HSUPA，你还可能没有找到这样的测试项目方面有很大的区别。但如在HSDPA中的情况下，HSUPA也有一个新的物理信道被引入，它被称为E-DPCH。即使有这样的附加信道，UE还具有和R99一样保持总信道功率。所以，你可能已经猜到，UE必须重新计算/重新安排每个物理信道功率。其结果是，我们将得到几个附加子项添加到射频测试。 最后..让我们想想LTE。LTE在PHY / RF层方面和C2K / WCDMA / HSPA之间最大的区别是什么？这将是OFDM。是的。由于OFDM，什么样的附加测量项目将引入射频测试？因为OFDM是由大量具有非常窄的带宽子载波组成，我们必须对每个OFDM子载波测量上述列出的大部分特性。但是，如果我们对每个子载波做所有测试项目，只为一个项目也需要一整天。另一个很大的不同将是LTE规范允许许多不同类型的系统带宽，而在C2K / WCDMA，系统带宽始终是一样的。它意味着你要测量多个不同的系统带宽乘以在测量设备上测量时间和参数设置。根据LTE规范，LTE系统带宽可以是任何的1.4MHz，3MHz，5MHz，10MHz，15MHz，20MHz。而C2K只能有1.28MHz单带宽，WCDMA只能有3.84MHz单带宽。当然，特定的系统运营商在他们的网络中将只使用一个带宽，但是移动设备的制造商的应设计成它支持所有的这些带宽的UE。在此之上，还有另外一个因素，使LTE的测试更加复杂特别是对于手机设计/测试。它是被用来在特定的时间实际带宽可以动态地改变。 一个直观的例子如下面的测量屏幕。此捕获用于LTE呼叫连接和数据传输的RF信号。当您发起呼叫，移动设备会通过呼叫建立协议信令，然后数据流量将开始。如果您在测量屏幕的屏幕（频谱）的底部看，你会发现在此期间频率分配（正在使用的带宽）的变化。在这个屏幕上，数据流量的频率分配并没有改变，但是在现网中这个带宽会动态改变。 这些多系统带宽和动态带宽改变对手机设计和测试工程师意味着什么呢？对于设计师来说，最大的问题将是如何优化这些频段的各种设计参数是最适合的。对于测试工程师来说，最大的问题将是测试情况下，他们必须经历巨大数量的测试项目。所有这些在多个带宽和动态带宽改变的最终结果，可以举出如下所示的表。这仅用于一个测试用例的表。查看所有这些不同的系统带宽，你都要测试。不同的RB分配是我上面提到的动态频率分配。在LTE中，对于每一个测试用例，你会有这样的表，这对设计和测试工程师来说将是巨大的头痛。 《to be continue…》]]></content>
      <categories>
        <category>通信</category>
        <category>RF</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>RF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GSM RR信道请求/立即分配/信道释放]]></title>
    <url>%2F2018%2F04%2F03%2FGSM-RR%E4%BF%A1%E9%81%93%E8%AF%B7%E6%B1%82-%E7%AB%8B%E5%8D%B3%E5%88%86%E9%85%8D-%E4%BF%A1%E9%81%93%E9%87%8A%E6%94%BE%2F</url>
    <content type="text"><![CDATA[RR : Channel Request信道请求具有各种功能，在上电之后的信道请求相当于UMTS和LTE的RACH过程。简单地说，这个消息是告诉网络“我想驻留上你，我开始连接过程，请分配无线资源”。一个用于初始注册如下。 （在良好的信道状态，以及在开放的空间中，第一个信道请求将到达网络并获得立即分配，只有一个信道请求。以下为一种最坏的情况下的，其中初始信道请求不能由NW解码或UE对初始直接分配解码失败） 注：在“信道请求”的最后一个重传时启动T3126，并在UE得到“立即支配”时停止。如果UE没有得到“立即支配”，直到T3126到期时，UE开始小区重选。 一个信道请求的确切功能由消息的第一个8位和第一字节的描述中，由下表中44.018中指定决定。 RR : Immediate Assignment立即分配是对最初的“信道请求”的应答消息。这就是说，以MS“好吧，我会接受你的‘信道请求’，你可以使用以下步骤获得无线资源”。一个信道请求的例子将如下所示。你必须要注意的最重要的事情是，立即指派应该重放的整个信道请求消息。所有的MS（UE）的尝试连接的小区将接收相同的“立即指派”，但是，如果包含在“立即指派”的’信道请求”部分与它送出信道请求字节不匹配，UE应当丢弃“立即指派”消息，因为它不是对本身。 RR：Channel ReleaseGSM信道释放是基于44.018 3.4.13.1.1，信道释放过程是在专用模式和组传输模式下发起的。 什么时候使用？ 在呼叫释放后释放TCH 当分配给信令的专用信道被释放时用以释放DCCH 去激活SACCH UE在收到信道释放之后应该怎么做？ UE启动定时器T3110并断开主信令链路。当T3110超时，或当确认被断开时，移动台停用所有信道，认为RR连接已经释放，并返回到CCCH空闲模式，返回到PCCCH或CCCH分组空闲模式或进入数据包传送模式。 信道释放原因 有许多释放原因如下所示，但只有其中的一些在44.018 3.4.13.1.1中描述。我会继续增加更多的说明。 在信道释放消息中重要的IE 以下为信道释放进行整体结构和IE（信息元素）。BA范围：一个UE在其小区选择算法可以使用这个字段（参见3GPP TS45.008和3GPP TS23.022）。所有TCH的释放和SDCCH后的小区选择指示：移动台的所有TCH和SDCCH释放后在小区选择算法可以使用该指示（参见3GPP TS45.008）Individual priorities：移动台可以用它来传达单独优先级信息到MS（见第3.2.3.3）。当MS接收到一个单独优先级IE应启动定时器T3230的一个实例，在个人的优先级IE提供的值。《end》]]></content>
      <categories>
        <category>通信</category>
        <category>GSM</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>GSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GSM帧结构]]></title>
    <url>%2F2018%2F04%2F03%2FGSM%E5%B8%A7%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.sharetechnote.com/html/FrameStructure_GSM.html 帧结构概述当我第一次学习GSM的时候，我对帧结构感到很迷惑。主要的一个原因是整个结构的每一个周期都有需要实习和帧，很难在一张纸上形象化地画出整个帧结构。我没有找到任何形象化描述整个超帧中每一个时隙的方法，但是GSM帧层次图如下。你必须详细的理解时隙，帧，多帧，超帧。 有用的视频连接视频连接是YouTube上的，国内的小伙伴还是翻墙看吧。Teleysia - GSM TDMA Frame 1http://www.youtube.com/watch?v=HZtBIcUTop8&amp;feature=related Teleysia - GSM Logical Channels 1http://www.youtube.com/watch?v=wwEO_muXD2M 每一种Burst的结构每一种无线通信中，我们都会使用不同种类的信道类型。这些不同信道具有他们自己的物理（或者传输）结构。在GSM中，也有不同种类的物理和逻辑信道，这些信道在时隙层次上都是用他们自己的物理结构。下面是一些GSM/GPRA中使用的不同burst类型。 每一种GSM/GPRS物理信道都映射成这些burst类型。每一种物理信道也都映射为高层逻辑信道。这些信道的映射见其他文章描述。 &lt; Frequency Correction Burst &gt;频率校正突发脉冲序列 这个burst仅仅用于FCCH信道 整个数据区域有142bit，用于承载非调制的再摸（纯正弦），或者承载全零的调制载波。 频率为1625/24kHz（或者接近67kHz） 这个纯载波是beacon频率（定标频点，或者叫BCCH频率，基准频率）和FCCH时隙的标识。 &lt; Synchronization Burst &gt;同步脉冲序列 这个burst仅仅用于SCH信道 这个信道使手机和基站时钟保持时间同步。这也是相对于其他burst来说，这个burst的训练序列这个长的原因。 在这个burst中仅仅定义一个训练序列 &lt; Access Burst &gt;接入脉冲序列 这个burst用于RACH和AGCH信道 当手机发送RACH消息，并接收到AGCH回应，MS和BTS都没有时间提前信息。但是实际消息是相对较短，并且有较长的保护间隔（GP guard band），这是为了确保和下一个burst之间不会有重叠。在接入脉冲序列中保护间隔的长度（68.25bit x 3.69 = 251.16ms）是相当于37.5km传输时延。GSM允许小区半径是35km。也就说从最大距离基站35km的MS发送的RACH消息到达基站天线时是和下一个burst没有重叠的。FACCH信道是在切换操作的时候使用这个burst（当新小区的时间提前信息不知道的时候）。在这个burst中仅仅定义了一个训练序列。 &lt; Normal Burst &gt;正常脉冲序列 这个burst用于其他除FCCH/SCH/RACH/AGCH之外的所有的信道 正常burst用于TCH/SDCCH/SACCH/FACCH/BCCH/PCH 这个burst有一些重要的特征： 一个burst中最大传输57*2=114bit的语音或者数据 Flag bit是用来只是这个信道是携带的用户负载（flag=0）,或者是控制消息bit（flag=1）,也就是说，在TCH中，flag=0。在其他信道中，Flag=1。 &lt; Dummy Burst &gt;哑脉冲序列这个burst像正常脉冲学列，但是没有任何有意义的bit传输。 多帧的帧结构GSM中有两种类型的多帧。一种叫控制多帧，另外一种叫负载多帧。（slot—frame—multiframe(control or traffic)—super frame—hyperfame） 下面一个示例描述控制多帧。每一个multi-frame有51x8个时隙，值得注意的是在每一帧的第一个时隙都用于控制信道。在这个图中，每一帧的第二个时隙用于控制信道，但是不总是这样。 通信中时隙分配这个实例中的部分参考下面的文档。http://www6.conestogac.on.ca/~mkabir/TCOM1010_ConEd_Cellular/GSM%20Phy%20Part-1.pdfhttp://www.teletopix.org/gsm/how-26-and-51-multiframes-in-gsm/ 下面的图展示了时隙层面上的结构。可以看到，最小的单位是时隙，8个时隙组成一帧。 上面的图示很接近于实际物理信号流。但是很难描述出不同的调度信息，因为基本的调度室基于帧为单元的。 下面是一个traffic多帧的实例。有26个多帧用于TCH/FR和TCH/ER。 这个实例描述了两个用于在使用全速率语音信道FR。（一个用于使用每一帧的时隙2，另一个用户使用每一帧的时隙4）。在26帧traffic多帧的中间，也就是Frame-12，是SACCH，携带了ME和BTS之间的链路控制信息。最后的帧是一个空帧。所有剩余的帧都分配了负载。没有专用的FACCH帧或者时隙。FACCH会在需要的时候偷取TCH帧。 下面的这个是用于半速率语音信道HR的26多帧结构，两个用户使用HR语音。在这个实例中，两个用户交替共享每一帧中的时隙2。你可以注意到有两个SACCH。帧12用于用户1的SACCH，帧25用于用户2的SACCH。 控制信道的多帧结构更加复杂，结构会根据控制信道类型而变化。但是一个公共的地方是所有的控制信道帧结构都是基于51多帧的。 下面是Beacon信道（base信道）的控制系电脑多帧结构，它是由FCCH，SCH，BCCH，CCCH组成。图中描述的是下行多帧结构。对于上行base信道中，每一帧都是用于单一信道—RACH。下行base控制信道的主要特点有： 在51多帧结构中有5个等空间的FCCH 每一个FCCH后面跟随者SCH，意味着同样有5个SCH 四个帧（帧2-5）都用于BCCH 最后一个帧（帧50）是空的 所有剩余的帧都分配给CCCH（eg，PCH or AGCH） 上面的实例真是的独立信道。（例如，传输信道和控制信道相互独立的情况）。实际上，这些调度是融合在一起的，形成一个复杂的表格。 下面引用“GSM Phy part-1”中的描述。GSM的BTS有一个或者多个GSM频率信道（ARFCN）。这些频率信道使用base-frequency（beason频率或者BCCH频率）定义的。base-frequency的第一个时隙用于base-control信道，这个频率信道剩余的部分（slot1-7）用于传输和控制信道的混合。所有的其他频率都是用于traffic，但是也可以用于控制信道。traffic和控制信道的混合取决于每一BTS的频率信道数和traffic模式。例如： 很少电话需要很少的RACH信道 短电话需要很少的TCH 高traffic小区有大量的频率信道，可能base-frequency信道没有traffic信道。]]></content>
      <categories>
        <category>通信</category>
        <category>GSM</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>GSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GSM Basic Call Processing (Voice)]]></title>
    <url>%2F2018%2F04%2F03%2FGSM-Basic-Call-Processing-Voice%2F</url>
    <content type="text"><![CDATA[当前页是基于在MS与GSM网络模拟器之间的呼叫信令处理序列。序列和消息内容的细节将根据不同网络而有些不同，但我认为这将包含呼叫处理的所有重要组成部分。在值“时间/备注”一栏只是一个参考，让您的每一步和下一步的粗糙时间间隔。这不是很精确的绝对值。（这是在整个页面，我计划的早期阶段，所以我会持续更新很长一段时间）。]]></content>
      <categories>
        <category>通信</category>
        <category>GSM</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>GSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE-drop-part2]]></title>
    <url>%2F2018%2F04%2F03%2FLTE-drop-part2%2F</url>
    <content type="text"><![CDATA[在前面的博客，我们描述了UE执行评估无线电链路的状况的活动，以确定它是否是in-syn或不同步。根据供应商的实现，一个不同步指示的，可能会导致下降的会话。 在这篇博客中，我们将集中在由eNodeB进行的活动在检测到无线链接失败时。 失败的eNodeB可检测（再次，这些可以是供应商特定的）的类型是：A）DL失败（RLC失败）B）UL失败（物理层失败）。 在RLC层DL失败 在RLC层发生了故障时所通过空中发送数据或信令不成功并且所述RLC层停止尝试。当数据被发送的空气，但不正确地接收，接收机将发送NACK。此外，发射机可以发送请求对所有接收到的分组的确认，通过设置轮询位。接收机将发送所有接收到的分组的列表。如果没有接收到发送的分组时，它被认为是丢失的。在这两种情况下，发射器将重新传送。见下图。 这个过程可以重复，但在某些时候发射器将放弃该数据包。如果出现这种情况，发射器宣称无线链路失败，并启动程序，以传达给对方。 参数MaxRetxThreshold确定次数的分组被重发在RLC层中的下行链路的数目。如果这个数字达到中，eNodeB声明的DL RLC失败和“破坏”为示于下面的图像的背景。 在物理层UL失败 并非所有供应商的实现支持这种类型的故障检测。它本质上包括测量由UE在UL发送的探测参考信号（SRS）的功率。如果功率低于给定的SINR阈值，计时器被启动。如果SINR仍在定时器的整个持续时间的所述SINR的阈值，则e节点B宣告所述UL为不同步，并进入“杀死”的上下文。如果SRS的SINR变为上面的定时器持续时间期间的第二指定阈值，所述UL被说成是在型同步和没有动作的方式实施。 下面，由eNodeB的执行行动都显示检测到UL物理层故障时。 你是对的！！！但想想后果了！ 是的，增加maxretxthreshold的值可能会导致由于RLC DL失败降会话的数量减少。 但是，为了避免大量滴，做的最好的事情就是清理射频环境您的网络。]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE-drop-part1]]></title>
    <url>%2F2018%2F04%2F03%2FLTE-drop-part1%2F</url>
    <content type="text"><![CDATA[有多种原因可以使LTE drop。然而，会话是否被丢弃依赖于特定的供应商的实现。也就是说，下降可能会由UE消息或由eNodeB进行的测量所引起的。 两个UE和eNodeB可检查无线电链路是否in-syn。在该博客，我们将描述该UE执行，以确定是否所述无线电链路是in-syn及其后果的活动。这个博客的第2部分，将展示该eNodeB可进行以确定无线电链路是，同步或不活动。 什么时候无线链路in-syn？ UE监控下行链路中的RS。基于所述参考信号（即RSRP）的信号强度，则UE确定它是否能够基于在规范中提供的一组特定的参数来解码PDCCH。每个UE都会有不同的RSRP阈值，低于阈值它会认为它无法读取PDCCH。如果参考信号具有足够的强度，使得该UE能够始终如一解码PDCCH，则链路的in-syn。 我们如何确定无线链路不同步？ 确定是否由于不同步而链路失败的全部程序示于下图。在画面中，有示出三个参数： N310：该参数表示当UE由于检测到低的RSRP而无法成功解码PDCCH的200毫秒间隔。即该参数表示的时间内UE无法成功解码连续20帧在下行链路的数目。 T310：它是一个定时器，在几秒钟内，用于允许UE取回与所述eNodeB的同步。 N311：该参数表示的100毫秒的间隔，该UE必须成功解码所述PDCCH的数量，从而重新和eNodeB in-syn。即该参数表示的时间内在下行链路中UE必须成功解码连续10帧，为了使UE认为无线电链路是in-syn的数目。 如果UE检测N310连续失同步指示，它会启动T310定时器。如果计时器超时，链接失败。如果UE检测N311连续在同步之前的T310定时器没有超时，则定时器停止，链路没有失败。 UE检测到链路故障后，会发生什么？ 如果UE确定无线电链路失败，则UE将尝试重新连接的RRC连接重建请求消息。有一些情况下，可能发生基于供应商实现。 如果eNodeB不支持RRC连接重建呢？ 在下面的图中所示的情况是在eNB不支持RRC连接重建时最简单的情况。在这种情况下，eNB响应RRC连接重建拒绝消息。同时，则eNB将认识到，无线链路已失败，并请求连接释放到MME。它首先请求删除UE上下文或到UE的连接。原因值被设置为“与UE丢失无线连接。”该MME将UE Context Release Command作出响应。此时，所述eNodeB将响应UE Context Release Complete消息发送到MME，并通过发送RRC Connection Release消息到UE释放与UE的RRC连接。根据不同的射频情况下，则UE可以接收或不接收该消息。 如果eNodeB确实支持RRC连接重建？ 如果所述eNodeB支持RRC连接重建，并假设eNodeB发现两个UL和DL同步（当它接收到RRC连接重建请求消息时），可能会出现两种情况：RRC连接重建的成功和失败。 在一个RRC连接重建成功的情况下，下面的信令进行交换。 如果RRC连接被成功地重建，则会话不会被删除。 如果RRC连接重建过程失败的其步骤之一，则eNodeB将发送UE context release request消息发送到MME。需要注意的是在RRC连接重建过程可以在几个步骤失败。下面，在图中，仅示出一个案件。 如果RRC连接重建失败，则会话被丢弃。 如果增加了RS的功率，如果增加N310，如果增加T310，或者如果你减少N311为最小值，drop数量将减少。]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE下行吞吐量Troubleshooting]]></title>
    <url>%2F2018%2F04%2F03%2FLTE%E4%B8%8B%E8%A1%8C%E5%90%9E%E5%90%90%E9%87%8FTroubleshooting%2F</url>
    <content type="text"><![CDATA[原文链接：http://lteuniversity.com/get_trained/expert_opinion1/b/lauroortigoza/archive/2012/05/09/downlink-throughput-troubleshooting.aspx 在这篇博客中，我们将简要介绍下行吞吐量LTE网络与2×2 MIMO的一般故障排除指南。建议读者去寻找各自的OEM的文档，以解决每个低于探索领域的特定计数器。 一般故障排除策略进行说明，并覆盖的原因，坏的吞吐量见下图。 图1.低吞吐量导致的下行链路中的LTE网络。 第1步：确定低DL（下行链路）的吞吐量的小区a）第一件事就是找出那些低吞吐量的小区。此阈值由网络策略和做法定义（这也取决于你的设计参数）。报告应运行几天使得数据在统计学上是有效的。 第2步：确定下行链路干扰a）小区的下行链路干扰是那些CQI值比较低（一个例外是当大部分的流量是在小区边缘（小区位置不好））。分析由UE报告的CQI值。 发射分集 MIMO一层 MIMO两层 针对发射分集的典型值在7到8之间。 用于MIMO一层和两层典型值10到12之间。 b）若获得CQI报告之后发现低CQI值，下行干扰可能是低吞吐量的原因。 c）普通干扰的来源是，在700 MHz频段（LTE部署在美国）：互调干扰，小区干扰器和无线麦克风 步骤3：BLER值a）确定小区特定的BLER报告。BLER应小于10％或相等。如果该值较大，那么，这就是RF环境不好的指示。 B）不良BLER的典型原因是下行干扰，覆盖不好（在网络中孔等） 步骤4：MIMO参数a）确定你的网络的传输方式。有七种传输模式中所示的下表 b）调整由OEM建议的传输模式的SINR阈值。请求链路级仿真它们用于设置这些阈值，看看是否被计算在该值的条件适用于您的网络。否则，更新它们如果参数可设置并没有限制。 第5步：低需求a）使用由OEM提供的计算方法运行报告 每小区支持的RRC连接的最大数目（参数或功能） 每个小区活性的RRC连接最大数量 每个小区活跃RRC连接平均数 每个TTI每小区支持的的最大用户数（参数或功能） 在感兴趣的小区（多个）用户每个TTI调度的最大数量 每个TTI在感兴趣的小区（多个）的平均用户数量 b）若每个小区活性的无线资源控制连接最大数量是接近或等于RRC连接的支持的最大数量，则低吞吐量的原因是负载过大。 c）在每个TTI有大量的调度的用户并不一定意味着需求是导致低吞吐量。 第6步：调度类型a）找到OEM支持的调度类型 b）选择一个是更方便的您正在调查的小区的类型。调度的例子有：循环赛，比例公平，最大C / I，平等机会等OEM允许你切换调度网络中，但推荐一个特别。 c）错误的调度可能是坏的吞吐量的原因。 第7步：CQI报告参数a）检查您的网络是否使用周期性或非周期性CQI报告（或两者）。 b）核实CQI报告进行定期报告的频率以及每秒支持的用户的最大数量。 c）若与RRC活动连接的最大数目相比较，这个值过小，那么，增加的参数CQIConfigIndex与RIConfigIndex。 D）如果您的网络不使用非周期性CQI报告，然后启用它。 E）CQI慢频率报告可能会产生不好的信道估计，可能组织eNodeB的数据调度和给UE适量的调制和编码方案。 步骤7：其他a）运行的VSWR报告或要求您的OEM来运行它。 b）VSWR过高导致低吞吐量。 c）检查您的回程容量。很多时候，回程链路多种RAT中共享。请确保您的回程正确尺寸。 在这种方法的结束时，你将能够确定是否在你的小区低的原因是通过以下或者其组合，它们中的一个： BLER（坏的报道） 下行干扰（坏CQI） MIMO参数 调度算法 低需求 CQI报告频率 其他（VSWR，回程容量）]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE峰值数据率的计算方法]]></title>
    <url>%2F2018%2F04%2F03%2FLTE%E5%B3%B0%E5%80%BC%E6%95%B0%E6%8D%AE%E7%8E%87%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[原文链接：http://lteuniversity.com/get_trained/expert_opinion1/b/hongyanlei/archive/2010/02/18/how-to-calculate-peak-data-rate-in-lte.aspx 您可能会听到很多次了，LTE的峰值数据速率约为300Mbps的？如何计算出来的数字？背后什么是假设？让我们用一个简单的方法估计它。假设20 MHz信道带宽，正常的CP，4×4 MIMO。 首先，计算资源元素（RE）的数目与20MHz信道带宽的子帧：12个子载波×7个OFDMA符号×100个资源块×2个时隙=每子帧16800个RE。每个RE可携带调制符号。其次，假设64 QAM调制，并没有编码，一个调制符号将携带6位。总比特在子帧（1ms的）超过20MHz信道是16800调制符号×6比特/调制符号= 100800比特。所以数据速率为100800比特/ 1毫秒= 100.8 Mbps的。第三，具有4×4的MIMO，峰值数据速率上升至100.8 Mbps的×4 = 403 Mbps的。第四，估计约25％的开销，例如PDCCH，参考信号，同步信号，PBCH，和一些编码。我们得到403 Mbps的x 0.75 = 302 Mbps的。好吧，它是通过估算完成。有没有一种方法更准确地计算呢？如果这是你寻找什么，你需要检查3GPP规范36.213，表7.1.7.1-1和表7.1.7.2.1-1。表7.1.7.1-1显示MCS（调制和编码方案）指数和TBS（传输块大小）指数之间的映射。让我们挑选的最高MCS索引28（64 QAM用最少的编码），这是映射26. 表7.1.7.2.1-1 TBS指数表示传输块大小。这表明可以在一个子帧/ TTI（发送时间间隔）中发送的比特数。例如，具有100个RB和TBS 26指数，TBS是75376. 假定4×4的MIMO，峰值数据速率将是75376×4 = 301.5 Mbps的。 表7.1.7.1-1：调制和TBS索引表PDSCH（3GPP TX 36.213） 表7.1.7.2.1-1：传输块大小表（3GPP TS 36.213） [Q：想尝试一个小的锻炼？在这里，您是：什么是峰值数据速率，如果MCS 20时？假定信道带宽为10MHz和的2×2MIMO配置。] 我们还知道，有不同的设备能力，这在3GPP TS 36.306，表4.1-1和4.1-2表定义。例如，与cat2装置中，所支持的峰值数据速率是在DL大约50 Mbps的速度，UL约为25Mbps。所有的UE类应该支持所有的信道带宽（1.4 / 3/5/10/15/20 MHz）的所有双工模式（FDD / TDD / H-FDD）LTE中。cat1〜4的设备最多可支持在DL的2×2MIMO。只有cat5设备可以支持在UL DL和64QAM的4×4 MIMO。 现在，如果cat3装置用在与2×2的MIMO配置一个10MHz的信道，可以得到100 Mbps的在DL的峰值数据率是多少？让我们来计算。我们知道，在网络侧，峰值数据速率是300Mbps的用于与4×4的MIMO信道的20MHz，所以10MHz的2×2MIMO峰值数据速率是75 Mbps的。因此，如果cat3装置10 MHz与2×2的MIMO信道的，预期的峰值数据速率通过空中接口是：min （设备能力，网络能力）=min （cat3，10MHz的带的​​2×2MIMO）=（100， 75）= 75 Mbps的。 你声称你掌握了峰值数据速率计算之前，还有一件事，QoS 配置中还可以限制对用户期望的实际峰值数据速率的限制。 答：39.7 Mbps的。]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE Discontinuous Reception (DRX) in RRC_IDLE: Part 2]]></title>
    <url>%2F2018%2F04%2F03%2FLTE-Discontinuous-Reception-DRX-in-RRC-IDLE-Part-2%2F</url>
    <content type="text"><![CDATA[原文链接http://lteuniversity.com/get_trained/expert_opinion1/b/prakash/archive/2013/04/24/discontinuous-reception-drx-in-rrc-idle-part-2.aspx 在空闲模式下的UE监听PDCCH信道P-RNTI用于寻呼从基站接收寻呼消息。 UE需要只在某些特定的UE寻呼时机来监视PDCCH，即只在特定的无线电帧特定子帧。在其他时间，UE可以进入睡眠模式，以节省电池电量。该DRX参数和各DRX参数的意义，在这个博客的第一部分讨论。一个DRX参数“NB”是用于寻呼容量在小区中的决定因素。让我们来讨论不同的方案在这个博客考虑NB的不同的价值观和理解上的寻呼容量这个参数的影响。 方案1：NB = T / 2 观察： UE需要唤醒每32毫秒，并查找寻呼消息（共32个无线帧UE的DRX周期） 其中每2无线帧（NB = 16），可在UE的DRX周期的寻呼。即总共16个寻呼帧单元中配置的 按照寻呼帧的一个寻呼子帧（NS = 1），可用于寻呼 根据预定义的图案对于FDD，为Ns个= 1，i_s = 0，子帧9被用于寻呼在寻呼帧 总的跨哪些UE基于UE标识分布式16寻呼时机（NB = 16）每UE的DRX周期。 方案2：NB = 2T 观察： 每一个无线帧是寻呼帧 每PF（NS = 2）2子帧中的UE的DRX周期用于寻呼 根据预定义的图案对于FDD，为Ns个= 2和i_s = 0，子帧0和4被用于寻呼在寻呼帧和寻呼时机用于UE中的讨论，是子帧4 32寻呼帧和64寻呼场合（NB = 64）是内UE的DRX周期跨越哪些UE基于UE标识分布式可用。 方案3：NB = 4T 观察： 每一个无线帧是寻呼帧 每PF（NS = 4）的4个子帧中的UE的DRX周期用于寻呼 根据预定义的图案用于FDD为Ns个= 4，子帧0,4,5和9用于寻呼在用于UE中讨论的寻呼帧和寻呼时机是子帧5 32寻呼帧和128寻呼场合（NB = 128）是内UE的DRX周期可以跨哪些UE基于UE标识分布式]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
        <tag>DRX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE Discontinuous Reception (DRX) in RRC_IDLE: Part 1]]></title>
    <url>%2F2018%2F04%2F03%2FLTE-Discontinuous-Reception-DRX-in-RRC-IDLE-Part-1%2F</url>
    <content type="text"><![CDATA[原文链接：http://lteuniversity.com/get_trained/expert_opinion1/b/prakash/archive/2013/04/17/discontinuous-reception-drx-in-rrc-idle-part-1.aspx RRC空闲模式期间由UE执行的一个重要活动是监听寻呼消息。该UE应该监听寻呼消息了解来电，系统信息的变化，并ETWS（地震和海啸预警服务）通知ETWS的UE。在LTE中，UE需要连续监视PDCCH（每1ms）用于P-RNTI的收听寻呼消息和这将会导致UE电池功耗严重。相反，如果允许UE监视的P-RNTI的PDCCH中，仅在规定期间，比如说每60毫秒或100毫秒，这将减少UE的功率消耗。不连续地监视的PDCCH用于P-RNTI的过程期间RRC空闲状态被称为在RRC_IDLE非连续接收（DRX）收听寻呼消息。 什么是LTE终端的空闲模式？ UE与核心网络之间不存在的NAS信令连接 至少一个PDN连接中存在 UE被注册的MME＆EMM上下文存在于MME UE位置是已知的MME与跟踪区域的列表的精度 UE与eNB之间不存在RRC连接 该基站没有上下文信息 空闲模式的寻呼寻呼是处于RRC空闲模式或EMM注册状态用来发送寻呼消息到UE的一个过程。寻呼消息可以通过MME在核心网络或eNB触发。 不连续接收的寻呼UE的寻呼信息由在由PDCCH指示的资源块PDSCH上承载。在PDCCH上寻呼指示是单一固定指示器（FFFE）称为寻呼-RNTI（P-RNTI）。不同UE群组的监视其寻呼消息不同的子帧。 在空闲模式下的UE监听PDCCH信道P-RNTI用于从基站接收寻呼消息。 UE只在某些特定的UE寻呼时机来监视PDCCH，即只在特定的无线电帧特定子帧。在其他时间，UE可以去为睡眠模式，以节省电池电量。 让我们来讨论UE如何能够找出寻呼帧和寻呼时机的寻呼消息。 寻呼帧（PF）：一个寻呼帧（PF）是一个无线帧，其中UE正在寻找寻呼消息。一个寻呼帧可以含有一个或多个寻呼时机。 寻呼时机（PO）：这是在有可能的P-RNTI发送PDCCH上寻址用于UE的寻呼消息的子帧。对每个UE来说，在DRX周期中永远只有一个寻呼时机。 要找出PF（寻呼帧）和PO（寻呼场合），UE使用广播系统信息SIB2 DRX参数。 DRX参数的意义DRX周期：表示在寻呼周期的无线电帧的数目。这个参数的值越大，UE电池功耗越少。而DRX周期的值小，增加在UE电池功耗。 DRX周期可以是特定小区或UE特定的参数。当它被在eNB上配置并在系统信息中的SIB2作为默认寻呼周期广播到所有UE，这样的DRX周期是小区特异性的。 当DRX周期是UE特定的时，MME可以配置DRX周期，并在NAS信令中’UE特定的DRX周期“将其提供给UE和向eNB中的PAGING S1 AP消息为”寻呼DRX’（对于MME发起的寻呼消息）。UE和基站将使用默认和专用的DRX周期这两个中最小的一个。 128个无线帧的DRX周期，需要UE每隔1.28秒唤醒，并查找寻呼消息。 nB：在小区中特定的DRX周期用于指示寻呼时机的小区特定参数。 nB值的配置取决于小区中所需的寻呼容量。 nB的值配置为较大的，具有较大的寻呼容量。同样地，较小的寻呼容量时nB的值越小。 与此我们可以推断，一个最大1无线帧的可每UE以用于寻呼的DRX周期。此外，每无线电帧1的子帧的4个子帧的最小（NB≤1T）和最大（对于NB = 4T）可用于为UE寻呼消息。 寻呼帧号的计算eNB和UE计算由以下关系的寻呼帧号码： 该基站将寻呼接收UE_ID从MME S1AP消息“UE标识指数值”为MME发起的寻呼消息。 UE将找出UE_ID通过关系IMSI国防部1024（编号：TS 36.304 7.1） 该IMSI是作为类型整数（0..9）的数字序列。该IMSI应，在上述式中，被解释为一个十进制整数，其中该序列中给出的第一个数字代表的最高阶位。 例如：IMSI = 12（digit1 = 1，digit2 = 2）。在计算中，这应被解释为十进制整数“12”，而不是“1×16 + 2 = 18”。 寻呼时机的计算（在一个寻呼帧寻呼子帧号） 从基于Ns的值的预定义子帧模式（36.304第7.2节，下面所示为快速参考）中获得的寻呼场合为UE，i_s。例如，如果Ns个= 2和i_s = 1中，UE解释该子帧4和9被配置用于寻呼在小区和子帧9是用于它寻呼时机。 副车架模式（参考：TS 36.304 7.2节） FDD TDD（所有DL / UL模式） 《end》]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
        <tag>DRX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE-RACH过程]]></title>
    <url>%2F2018%2F04%2F03%2FLTE-RACH%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是设备故障的处理最棘手的部分？我的经验说：“如果做一些使用时中间的问题发生，就比较容易找到问题的根源并解决它（可能是我可能有过分简化的情况 - :)，但是如果有的话开始前发生了一件事，那将是一场噩梦。”例如，您设置的所有参数在网络仿真器要测试一个UE，然后打开了UE。在几秒之后，UE开始启动，然后再几秒之后，你看到一对的信号条在UE屏幕顶部的地方..然后在几秒钟内你看到’SOS’或’服务不可用“，而不是显示在屏幕和普通天线条网络运营商的名称。这就是我所说的“问题做一些中间”。在这种情况下，如果你收集客户端日志和设备日志，至少你可以很容易地针点出了问题发生的位置，并从那里开始的进一步细节。但如果你是在这种情况下怎么办？您将所有的参数在网络仿真器侧并打开UE .. UE启动开机..显示消息说“搜索网络…”，结果卡在那里..没有信号条吧..连“SOS”都没有..只是说“不服务”。我收集了UE侧记录和网络仿真器端日志，但没有信令消息。这是我们头痛的开始。 作为例子，1）当你在WCDMA UE打开，如果你没有看到’RRC Connection Request’？2）当你对GSM UE打开，若您没有看到 ‘Channel Request’？3）当你的LTE UE打开，如果你没有看到 ‘RACH Preamble’ ？ 首先你要做的是了解不仅在更高的信令层这一过程的每一个细节，也要涉及到关于这一步从高层到物理层一直下去的每一个细节。而你也必须使用适当的设备可以显示这些详细的过程。如果您有不提供日志记录的设备或提供日志，但只有高层信令日志，这将是很难解决。既然你有合适的工具，接下来的事情，你必须做好准备是要了解这些过程的详细知识。没有知识，即使有好的工具，这并不意味着任何东西给我。所以 ，我想在这里教我关于LTE信号的第一步，这是RACH过程。 （有人会说，即使在RACH之前，还有很多其他的步骤，如频率同步，时间同步，MIB / SIB解码..但它把这些放在一边，现在..因为它更像是基带处理）。 为什么RACH？ （RACH什么功能？） 当你第一次听到这个词RACH或RACH过程时，在你的心中第一个问题将是“为什么RACH？”，“什么是RACH过程，功能/目的是什么？”，“为什么我们需要这种复杂（看起来过分复杂的）？“。肯定的，这不是为了混淆你:)，RACH具有非常重要的功能，尤其在LTE中（在WCDMA中也一样）。 RACH的主要目的可以如下所述。1）实现高达UE与eNB之间链路同步2）为消息3获取资源（例如，RRC连接请求） 在大多数的通信（无论它是有线或无线的，特别是数字通信中），最重要的先决条件是建立接收机和发射机之间的定时同步。所以，无论你学习什么通信技术，你会看到一种是专门特定的通信同步机制。 在LTE（在WCDMA中也一样），在下行链路的同步（发送是基站，接收机是UE），这种同步是通过特别的同步​​信道（专用物理信号模式）来实现的。请参阅时间同步处理页面的详细信息。这个下行同步信号被广播给大家，它是以一定的时间间隔一直发送的。然而，在上行链路（发射机是UE，接收机是eNB），如果UE正在使用广播/始终发送同步机制，它是没有效率的（实际上浪费能源，造成了很多其他UE的干扰）。你可以很容易地理解这样的问题。在上行链路的情况下，这种同步过程应符合下列标准1）仅仅在立即需要的时候才应该发生同步过程2）同步应该只专用于特定UE 在这个页面中关于程序讨论的所有复杂的专门设计机制，都满足这些标准。 RACH过程的另一目的是为消息3获得资源（消息3）。 RRC连接请求是消息3的一个例子，根据不同的情况，有几种不同类型的消息3。你会找出这部分通过此网页阅读，这是不是很复杂，很好理解。 什么时候RACH发生？ 当你想到WCDMA中RRC连接发生时（或当PRACH发生时），这将很好帮助你理解。当你想到GSM中信道请求发生时，这将很好帮助你理解。 我的LTE RACH过程的印象是PRACH过程（WCDMA）和信道请求（GSM）的组合。它可能不是100％正确的比喻……但无论如何，我得到了这样的印象。在LTE中，RACH过程发生在下列情况下（3GPP规范中，36.300 10.1.5随机接入过程）1）RRC_IDLE首次访问2）RRC连接重建程序3）切换（基于竞争的还是非竞争为主）4）在RRC_CONNECTED状态DL数据到达，需要随机接入过程。例如，当UL同步状态为非同步5）在RRC_CONNECTED 状态UL数据到达，需要随机接入过程。例如，当UL同步状态为“非同步”或不存在可以使用SR的PUCCH资源。6）对于RRC_CONNECTED 状态下定位目的，需要随机接入过程; 例如。当UE定位需要定时超前TA 两种类型的RACH过程：基于竞争和非竞争的 当UE发送PRACH前导码，它发送特定的序列，这个序列被称为“签名”。在每个LTE小区，总共64个前导签名可用与UE随机选择这些签名中的其中一个。 UE选择“随机”这些签名中的其中一个？这是否意味着有一些可能性，即多个UE发送PRACH具有相同的签名？是。有这样的可能性。它意味着同样的PRACH前置码从多个UE同时到达NW..这种PRACH碰撞被称为“争用”。在RACH过程中，允许这种类型的“争用”被称为“基于竞争”的RACH过程。在这种基于竞争的RACH过程，网络会经历另外的过程，在稍后的步骤来解决这些争用和这个过程被称为“竞争解决”步骤。 但有一些情况下，这些种类的争用是不能接受的，由于某些原因（例如，时序限制），这些争用可被防止。通常在这种情况下，网络通知使用的每个确切时间和UE的前导签名。当然，在这种情况下，网络将分配这些前导签名，以便它不会发生碰撞。这种RACH过程被称为“无竞争”RACH程序。要启动的“无竞争”RACH过程中，UE应在连接模式的RACH过程，在切换之前。 典型的“基于竞争的”RACH程序如下：1）UE - &gt;NW ：RACH前导码（RA-RNTI，指示L2 / L3消息的大小）2）UE &lt; - NW ：随机接入响应（定时提前TA，T_C-RNTI，对L2 / L3消息的UL授权）3）UE - &gt;NW ：L2 / L3消息4）关于早竞争解决的消息 现在让我们假设一个竞争发生在步骤1）。例如，两个UE发送PRACH。在这种情况下，在步骤2）两个UE的将收到同一T_C-RNTI和资源分配。其结果是在步骤3），UE将通过相同的资源分配（具有相同的时间/频率位置）发送L2 / L3消息到NW。会发生什么，当两个UE的发射在完全相同的时间/频率位置完全相同的信息？一种可能性是，这两个信号充当彼此干扰和NW都不能解码码它们。在这种情况下，没有UE能获得从NW任何响应（HARQ ACK），并且它们都认为RACH过程失败，并返回到步骤1）。另一种可能性将是NW可以成功地从仅一个UE解码所述消息并且未能另外一个UE的解码。在这种情况下，NW成功的L2 / L3解码的UE将从网络得到HARQ ACK。此HARQ ACK过程步骤3）消息被称为“竞争解决”的过程。 典型的“无竞争”RACH程序如下：1）UE &lt; - NW：RACH前导码（PRACH）分配2）UE - &gt;NW：RACH前导码（RA-RNTI，指示L2 / L3消息的大小）3) UE &lt; - NW：随机接入响应（定时提前，C-RNTI，UL授权L2 / L3消息） 信息是如何编码成PRACH（RACH前导）？ 在LTE中，在PRACH前导码之后所有的信息（数据）都具有其自己的二进制结构，这意味着它们翻译成一定的数据结构。然而，在PRACH前导码中的信息是由纯粹的物理特性表示的。形成的信息中的PRACH物理性质如下。1）PRACH前导码传输时序（t_id）2）PRACH传输的频域位置（F​​_ID）3）PRACH信号的整个I / Q数据的序列（如下所示的一个示例） 从1）和2）中，RA-RNTI被描述下面的链接中。从3）中，可以得出前导码索引（RAPID）。在了解RA RNTI的推导时，你可能不会有太大的困难，但它不会是那么简单理解序列索引部分的推导。涉及到这个过程，大多数本页面有很多公式和复杂的表格，但我不认为我的工作做得很好以至于可以简单/清楚地描述这一部分。我将在未来添加其他短节，当我把一切都理清了。在此同时，请参阅Matlab的LTE工具箱：PRACH页面在你的大脑获得直观的形象，并了解在本页面PRACH前导信号生成部的部分。当然，你不会得到一切都一样。没有那么简单的工程:) 究竟在何时何一个UE的发射RACH？要回答这个问题，你需要参考3GPP规范TS36.211 - 表5.7.1-2。 它准确显示当UE应该根据一个所谓的“PRACH配置索引”参数来发送RACH。 例如，如果UE正在使用“PRACH配置索引0”时，它应该只在偶数SFN（系统帧号）发送所述RACH。这是足够好的答案吗？这是否意味着该UE可以以指定的SFN在任何时间发送RACH呢？这个问题回的答案在表中的“子帧号”列。它说：“1”为“PRACH配置索引0”。它意味着在UE仅被允许在每一个偶数SFN的子帧号1上发送的RACH。 检查你的表的理解，我会给你一个问题。使用哪个“PRACH配置索引”，网络能更容易的检测到来自UE的RACH？为什么？答案是14，因为UE可以在任何SFN和帧内的任何时隙发送RACH。 在一个大的图片上，你应该知道，如下图的所有维度。 （红色矩形是PRACH信号）。 该R_Slot由PRACH配置指标确定，R_length由Premable格式决定。当前导码格式0〜3时，F_offset由以下方程决定。 这个方程式中n_RA_PRBoffset是由PRACH-FreqOffset在SIB2规定。 （参考36.2115.7物理随机接入信道的细节）&lt; FDD &gt;&lt; TDD : Preamble format 0-3 &gt;&lt; TDD : Preamble format 4 &gt; 什么是前导码格式？ 如果你看到上面的表5.7.1-1展示，你看到标题为“序言格式”的列。什么是前导码格式？它被定义为下面的图。 你会看到，PRACH前导码的长度取决于前导码格式。例如，PRACH前导码格式0的长度为（3186+24567）的抽样。 （如你所知，一个抽样（TS）为1/30.72（=0.03255）us，它在36.2114帧结构定义为1 /（15000×2048）s（=0.03255us））。 你可能会问：“为什么我们需要这么多个前导码格式？”，特别是“为什么我们需要与不同时间长度的不同PRACH格式？”。其中一个主要的原因是，他们使用根据小区的半径不同使用不同的前导码格式，但是这是过于简单的回答。我想推荐一本名为“LTE：UMTS的从理论到实践”第19.4.2的PRACH结构。这是描述PRACH在最详细的级别我曾经阅读材料。 正如简短的结论为小区大小，我们可以如下重写表。 Note 1 : T_CP (in ms) = T_CP(in Ts) x 0.03255 x 1/1000,Note 2 : T_SEQ (in ms) = T_SEQ(in Ts) x 0.03255 x 1/1000,Note 3 : Guard Time (in ms) = Number of Subframe - Total LengthNote 4 : 小区半径大约是电磁波传输距离除以2。 如何网络知道什么时候UE将发送RACH？ 这很简单。网络知道当UE将发送所述RACH之前UE发送它，因为网络通知UE的当UE应该发送所述RACH。 （如果UE未能正确地解码有关的RACH的网络信息，网络将无法检测到它，即使UE发送RACH）。 以下部分将描述在RACH网络，情报。 其中RRC消息中包含RACH配置？ 正是在SIB2，你可以找到在3GPP36.331的细节。]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
        <tag>RACH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE基本过程]]></title>
    <url>%2F2018%2F04%2F03%2FLTE%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[我们中的大多数将被专门某个或某几个特定的​​区域/层的一名工程师。从技术上讲这是可以理解的，因为没有一个人可以掌握一切，但我强烈建议你尝试把整个过程的大图掌握。只要你有一些问题或东西给你的工作，尝试着问你自己“当前的问题是位于整个画面的哪部分？”。你不必去尝试死记硬背这些全过程，但如果你继续努力映射整个画面中的当前问题，这些全序列会自动在你的记忆弹出。我常常告诉我的孩子和我的晚辈“不要试图记住它，只需重复，直到你自动调用”（他们都看着我说 :“那有什么区别吗？”我只是微笑 - ： ）。 以下是我的版本的LTE全过程..但如果​​你试图去描述它，你将有一点点的不同版本..但我觉得总体逻辑是相似的。时不时地，只要回想一下这些序列，在你的心中，并问你自己“如何在细节上我可以解释有关的每个步骤？”。其实每个步骤可以在一本厚厚的书一章描述。 1）UE处于关闭状态2）UE开机3）&lt;频率搜索&gt;4）&lt;小区搜索&gt;：正常情况下，在这个过程中UE会发现多个小区5）&lt;小区选择&gt;6）MIB解码7）SIB 解码8）&lt;初始RACH过程&gt;9）&lt;注册/验证/连接&gt;10）&lt;默认EPS承载设置&gt;11）现在UE处于空闲模式12）&lt;（如果当前的电池变弱或UE移动到另一个小区注册）小区重选&gt;13）&lt;（当寻呼消息到来或用户拨打电话）RACH过程&gt;14）&lt;设置专用EPS承载&gt;15）接收数据16）发送数据17）（如果网络接收到UE功率太弱）网络发送TPC命令来增加UE Tx功率18）（如果网络接收到UE功率太强）网络发送TPC命令减少UE Tx功率19）&lt;（如果UE移动到另一小区区域）的网络和UE执行切换过程&gt;20）用户停止呼叫，UE进入空闲模式 基本信息UE能力：UE类别，频带带宽，同步信号序列，通用无线资源信息，MIMO参数，双工模式，前导序列生成算法 USIM：网络运营商的PLMN列表，签约信息 存储的信息：最近使用的频段，PLMN，跟踪区域代码，小区ID，S-TMSI，Inter-RAT频段 UE需求获取的信息：频率和时间同步信息，系统带宽，MIMO天线数量，标识（C-RNTI，物理小区ID，跟踪区域代码），网络（PLMN），信号系统和广播源，RACH_ROOT_SEQUENCE与PRACH配置。 1-LTE Basic Procedure：Initialization Sequence : From Power-On to PRACH 以下步骤列出从上电到初始PRACH的每个步骤。虽然它看起来很简单，但每一个步骤可能是UE内发生的最复杂的过程之一。更困难的是，都没有明确规定在3GPP规范了这些步骤，大部分均达到UE实现。此外，如果你的移动设备验证/验证工程师，你将有一个很大的困难，因为没有那么多详细的log，它是可将需要很长的时间和练习，直到你得到熟悉这些log。 1）UE处于关闭2）开机UE3）&lt;频率搜索&gt;4）时间和帧同步5）&lt;小区搜索&gt;：正常情况下，客户端会发现多细胞在这个过程中6）MIB解码7）SIB deconding8）&lt;小区选择&gt;：UE可以找到多个合适的细胞，但它尝试驻留到HPLM细胞具有最高优先级9）&lt;初始RACH过程&gt; 1-频率和带宽检测1）搜索中心频率注1：该算法将是最复杂的，是由每一个芯片制造商实现注2：根据UE的PHY协议栈实现中，UE可以测量RSSI并确定其是否进行到下一步骤或没有。 2）解码PSS（主同步信号） 3）解码SSS（辅同步信号）注1：UE结合PSS/SSS的结果，UE可以计算出小区ID。 （所以，如果你在UE log中看到小区ID并且它eNodeB的配置匹配，这意味着UE成功地检测到的PSS/SSS.4）结合步骤2)和3)的结果，UE可以检测小区特定参考信号 5）解码BCH占用在中心频率的72个子载波（6个RB）。 6） BCH（MIB）告诉系统的频率信息（例如，系统频率带宽） MasterInformationBlock ::= SEQUENCE {dl-Bandwidth ENUMERATED { n6, n15, n25, n50, n75, n100},phich-Config PHICH-Config,systemFrameNumber BIT STRING (SIZE (8)),spare BIT STRING (SIZE (10))} 2-时间同步过程1）UE解码主同步用三种不同主同步序列找出哪些序列被分配给该小区并获得主定时同步。2）用主同步序列解码辅同步码，并计算出被分配给该单元的序列。 此同步检测每5毫秒进行一次。 （你会明白，如果你看一下LTE下行链路帧结构的DL 帧结构部分，就可以解释了这个时间间隔） 正如我在上一节所提到的，三个不同的序列被用作主要同步信号和有各自的三个序列，小区标识组内的小区ID和这三个序列之间一对一映射。UE检测这个小区标识组后，就可以确定帧定时。从这个小区标识组中，UE也找出哪些伪随机序列被用于产生在小区的参考信号。 3）一旦这个定时同步得到确立，UE可以解码MIB并找出SFN号码，因为MIB携带SFN号码。 3-小区搜索4-小区选择5-初始RACH过程]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE帧结构-上行]]></title>
    <url>%2F2018%2F04%2F03%2FLTE%E5%B8%A7%E7%BB%93%E6%9E%84-%E4%B8%8A%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[上行时隙结构如下。当我第一次读LTE材料，几乎所有的书籍和文章中说“LTE采用SC（单载波）FDMA用于上行链路信号”，因为这个词“单载波”，并让我非常困惑，创造不出上行时隙结构的任何图像。即使是现在，我不认为我能解释清楚有关“SC FDMA”。你可能会问到FPGA或DSP工程师有关的SC FDMA机制的细节。 时隙结构但无论如何，让我感到高兴的是也是最重要的部分是，上行时隙是和下行时隙相同的。下面看一看整体上行时隙结构。 如在下行链路中，在上行链路上帧时间和时隙时间是和下行链路中相同的。在资源块结构上，上行链路和下行链路相同。如上所示，在一个时隙中有7个符号，这也是在上行链路和下行链路是相同的。 不同之处在于，你会发现，每个信道的位置不同。通常在下行链路的情况下，一个信道往往横亘整个带宽，但在上行链路时隙中的信道似乎更本地化。例如，PUCCH位于仅在频域的最低端和最高端，参考信号也局限在时域或时域和频域两者。 PUCCH RS承载参考信号用于解调PUCCH。这意味着，如果这一部分没有正确配置或eNodeB的未能检测出这一部分，eNodeB将不能解码PUCCH。 PUCCH这个信道可以携带大量的信息（UCI），但根据不同的配置中，它可以携带只有少数的以下信息。 收到的PDSCH数据的ACK / NACK CQI RI PMI 正如在时隙结构看到的，PUCCH位于上行链路频域的两个极端，以一个子帧两个时隙中交替使用的方式，也就是说，如果在PUCCH是在时隙0的频域的最低部分（第一时隙），它会被位于在时隙1频域的最高部分（第二时隙）。究竟有多少资源元素被分配给PUCCH是由网络确定，配置是由广播经SIB2到UE。 PUSCH RS承载参考信号用于解调的PUSCH。这意味着，如果这一部分没有正确配置或eNodeB的未能检测出这一部分，eNodeB的不能解码PUSCH。这总是位于上行时隙的中心。 PUSCH携带该UE试图发送的上行数据。而且还可以承载用于PDSCH的ACK / NACKUE。 SRS（探测参考信号）参见SRS的快速参考http://www.sharetechnote.com/html/Handbook_LTE_SRS.html 上行链路资源网格介绍详细信息，上行链路资源也具有一种网格格式，如下图所示。尝试熟悉在该图中参数名，因为这个参数将在本说明书的所有其它部分中使用。如果你不熟悉这些参数，当你阅读说明书的其他部分，你将无法想象的内容。 正如你看到的，最小的单位是”资源元素（RE）”，最小的资源分配单位是RB（资源块），横跨时域的7个RE和频域的12个RE。这意味着一个RB有84 RE（7×12）在里面。 实际通信中的信道下面的图表显示上行/下行数据传输的整体序列。你就可以将数据传输的序列图和在DL / UL帧结构的每个信道的特定位置相关联。 Gallery 《end》]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE帧结构-下行]]></title>
    <url>%2F2018%2F04%2F03%2FLTE%E5%B8%A7%E7%BB%93%E6%9E%84-%E4%B8%8B%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[学习这个东西并获得实践理解的好的途径是从高层开始，一步一步的逐步深入。 Overview - FDD高层如下所示，36.211 FDD LTE。下面展示了时域一帧的结构。没有展现任何频域的结构。从这个高层描述图中你可以得到： 一帧的时长是10ms（一个无线帧，一个系统帧）。也就是意味着一秒有100个无线帧。 一帧中的采样个数是307200个。也就是意味着一秒有307200*100=30.72M个采样。 一帧包含10个子帧。 一个子帧包含两个时隙。也就是意味着一帧包含20个时隙。 一个时隙是时域中最小的结构吗？不是。如果你进一步放大这个帧结构，你得到下面的图。现在你可以看到一个时隙有7个符号组成。（一个符号是信号的某个时间跨度，在I/ Q星座图携带一个点）。而你看到一个符号内甚至更小的结构。在符号的开始，你看到一个非常小的“循环前缀”，剩余部分才是真正的符号数据。有两种不同类型的循环前缀。一种是正常的循环前缀，而另一个是“扩展循环前缀’，它比正常循环前缀较长。 （由于一个时隙的长度是固定的，不能改变，如果使用“扩展循环前缀’，即可以一时隙内容纳的符号数目减少。因此，如果我们使用”扩展循环前缀’，仅具有6个符号）。如果放大的子帧，以显示的确切时间和采样，它可以如下图说明。 有关上面显示的帧结构需要注意几点： 第一OFDM CP符号比其他OFDM符号的CP要长一点 在此图中所示的采样数是基于采样率是30.072 M个samples/s和2048 bins/ IFFT（N_ifft）的假设。因为实际情况下的采样率和N_ifft取决于系统带宽，则需要根据特定的BW缩放这个数字。 每个系统带宽下的典型N_ifft如下 system BW number of RBs N IFFT (bins/IFFT) 1.4 6 128 3.0 15 256 5.0 25 512 10.0 50 1024 15.0 75 2048 20.0 100 2048 下面显示了“LTE资源网格”的总体子帧结构（http://dhagle.in/LTE） 现在，让我们进一步放大帧结构，但这次扩大在频域，而不是在时域。你会得到下面的全部细节图。 作为从事LTE一个工程师，你的第一件事情是得非常熟悉上面这张图。 我们可以在二维上表示LTE信号，如上所示。水平轴是时域，而垂直轴是频域。垂直轴的最小单位是一个子载波和横轴的最小单位是符号。对于在时域和频域，这是这些单元的多层级组合，意思是多个较小的单位成为一个更大的单元。 让我们首先来看看在频域结构。LTE（任何OFDM / OFDMA）频带由多个小间隔的信道组成，我们称每个小信道为“子载波”。无论在LTE频带的系统带宽，所述两个信道的空间总是相同的。因此，如果LTE的系统带宽发生变化，信道（子载波）数目也发生变化，但信道之间的空间不会改变。 Q&gt;一个子载波和下一个子载波之间的空间？A&gt; 15kHz Q&gt;20MHz的LTE频段的信道（子载波）数量是？A&gt; 12x100=1200个子载波。 Q&gt;10MHz的LTE频段的信道（子载波）数量是？A&gt; 12x50=600个子载波。 Q&gt;5MHz的LTE频段的信道（子载波）数量是？A&gt; 12x25=300个子载波。 是不是感受到子载波和系统的带宽有关系？ 现在，让我们来看看横轴的基本单位是时域。时域的最小单位是一个符号，这相当于66.7us。无论带宽，符号长度不会改变。在时域中的最大的单位是一帧，长度10ms。每帧包括10个子帧，每个子帧长度1ms。每个子帧的由2个时隙，其中每一个时隙是0.5ms。每个时隙由7个符号，每一个67.7us。 Q&gt;一个时隙有多少符号？ A&gt; 7个符号。Q&gt;一个子帧有多少符号？ A&gt; 14个符号。Q&gt;一个帧有多少时隙？ A&gt; 20个时隙。 现在，让我们来看看由两个时域（横轴）和频域（纵轴）的单元。让我们把这种类型的单元叫二维单元。 最小二维单元是由在时域中的一个符号和一个子载波的频域资源元素。另一个二维单位是资源块（RB），其是由在时域中的一个时隙和12个子载波组成。资源块（RB）是LTE中的最重要的单位，常用于协议侧和RF测量侧。 Q&gt;一个资源块多少个符号？ A&gt; 7个符号。Q&gt;一个资源块多少个子载波？ A&gt; 12个子载波。Q&gt;一个资源块有多少个资源单元？ A&gt; 84个资源单元。 现在是时候我们所有涉及单位结合起来。下面的问题是读取任何LTE规范的很重要的。 Q&gt;20 MHz频段有多少资源块？ A&gt; 100个资源块。Q&gt;10 MHz频段有多少资源块？ A&gt; 50个资源块。Q&gt;5 MHz频段有多少资源块？ A&gt; 25个资源块。 我已经看到了这类型映射了这么多次，从这么多不同的来源，但我真正明白了地图的所有细节？还没有。这将需要几年的时间来了解这张图的每一个方面。 也许是我做的第一个步骤就是口头形式描述地图的每个部分。 Overview-TDD PBCH（物理广播信道） 它仅携带的MIB。 它是使用QPSK。 映射到6个资源块（72个子载波），在子帧0，围绕DC子载波。 映射到未被预留用于传输参考信号/PDCCH或PCHICH的资源元素 前L（1或2或3）个符号这是因为这个区域是二位图中最混乱的地区之一，多个信道分配在这里。第一个符号是PCFICH，但PCFICH仅仅占用第一符号上的资源块的一部分不是全部。 PHICH也是在这个区域承载。而不被PCFICH和PHICH占用的剩余空间分配给PDCCH。 PCFICH（物理控制格式指示信道） 它携带了用于控制信道（PDCCH和PHICH）的符号的数目。 映射到在每个下行链路子帧的第一OFDM符号，包含从PBCH上接收的PDCCH的OFDM符号的数目和PHICH的符号持续时间的信息，UE解码此信道找出多少OFDM符号分配给PDCCH 它是由这个子帧的第一OFDM码元的16个子载波来承载。 PCFICH的数据由4个REG承载，不管带宽多大，这四个的REG是均匀分布在整个频带上。 PCFICH的确切位置是由小区ID和带宽决定的。 有关详细信息，请参阅PCFICH页面。http://www.sharetechnote.com/html/Handbook_LTE_PCFICH.html PDCCH（物理下行链路控制信道） 映射到在每个下行链路子帧的前L个OFDM符号。 符号（L）的PDCCH的数目可以是1,2，或3。 由PCFICH指定PDCCH符号数 PDCCH携带DCI。DCI携带​​传输格式，资源分配，和与DL-SCH，UL-SCH和PCH相关的H-ARQ信息。 PDCCH也携带DCI 0，这是用于UL调度分配（例如，UL授权）。 支持多个PDCCH，UE监视一组控制信道。 调制方式为QPSK。 PDCCH就像是HSDPA的HS-SCCH，R99的PDCCH，HSUPA的E-AGCH / E-RGCH。 即使PDCCH有很多的功能，并非所有的功能都在在同一时间使用，PDCCH配置应灵活进行。 如果你有兴趣有关映射此通道的详细信息，参考36.211 6.8.1。以下是这个章节的初始描述。 物理下行链路控制信道携带调度分配和其他控制信息。物理控制信道是在一个或几个连续控制信道元素（CCE）的组合上传送的，其中一个控制信道元素对应于9个资源元素组。没有分配到PCFICH或PHICH资源元素组的数量是REG N。在系统中可用的CCE的编号为从0到N_CCE-1，其中N_CCE =floor（N_REG/9）。该PDCCH支持多种格式，如表6.8.1-1中列出。占用n个连续的CCE的PDCCH可以从一个CCE满足i mod N =0的开始，其中i是CCE号。 PHICH 携带H-ARQ反馈 在UE UL 传输数据后，它在等待PHICH中的ACK。 它像HSPA中的E-HICH 有时几个PHICH构成使用相同的资源元素的PHICH组。 PDSCH（物理下行链路共享信道） 携带用户特定的数据（DL有效载荷）。 携带随机接入响应消息。 它可以使用AMC以QPSK，16QAM和64QAM PRACH 它所携带的随机接入前导码 它在频域占用72个子载波的带宽。如果随机接入前导码成功被接收，随机接入消息上将会在UL-SCH上发送。 随机接入前导是由Zadoff-Chu序列生成的。 P-SS（主同步信号） 映射到72个活动的子载波（6资源块），在0时隙（子帧0）和10时隙（子帧5​​）的DC子载波的周围。 由62的Zadoff-chu序列值 用于下行链路帧同步 其中一个关键因素是用来确定物理小区ID 如果你是一个开发人员，负责LTE芯片组的初期工作，这将是你必须实现第一信号之一。但是，当你有以下的数据和信息，你能找出到底是哪频道映射的一部分，将进行该消息？这是理解LTE协议的最棘手的部分之一，它需要很长的时间进行研究。 （如果你是一个RF工程师，这未必是对你那么重要）。 S-SS（辅同步信号）SSS是用于无线电帧同步的特定的物理层信号。它的特点如下所示。 映射到72活动子载波（6资源块），在FDD中，分布在0时隙（子帧0）和10时隙（子帧5​​）的DC子载波的周围。 SSS的在子帧0的序列和子帧5是彼此不同 由62扰码序列（基于m序列） 在奇数索引的资源元素和偶数索引的资源元素的值由不同的公式产生 用于下行链路帧同步 其中一个关键因素是用于确定物理小区ID 但是，如果你是一个开发人员的LTE芯片组的初期工作，这也将是你必须实现第一信号之一。 RS（参考信号） - 小区特有大部分的信道（例如，DPSCH，DPCCH，PBCH等）是用于携带特有信息（比特序列）和有一些较高层的信道连接到它们，但参考信号是只存在于PHY层的特殊信号。这不是用于递送任何特定信息。此参考信号的目的是为下行链路功率提供的参考点。 当UE测量DL功率（即从eNodeB信号的功率），它衡量这一参考信号的功率，并把它作为下行小区功率。 这些参考信号是通过在每一个时隙的特定资源元素，这些资源元素的位置是根据专门由天线配置确定的。 在下面的附图中，红/蓝/绿/黄是携带参考信号的部分，被标记为灰色的资源元素是保留用于参考信号的，但对那个特定天线并不携带参考信号。 有两种不同类型的参考信号：小区固有参照信号和UE特定的参考信号 小区专用参考信号：该参考信号在每个子帧上传输，并涉及所有的工作带宽中。它是由天线端口0,1,2,3发送。 UE特定参考信号：该参考信号被仅分配给特定UE的资源块中传输，并正在通过天线端口5发送。 Q&gt;对于小区特定参考信号的资源元素是否固定？A&gt;不，位置根据物理小区ID，如下所述变化。 参考信号的时域索引（I）是固定的。 （I= [0,4]） 参考信号的频域索引k是根据物理小区ID的变化而变化的，根据36.2116.10.1.2中描述映射到资源元素。 主要原则是：k=6m +（v+v_shift）mod 6，其中v_shift=物理小区ID mod 6. 有关进一步详情，请参阅36.211 6.10.1.2 Q&gt;下行参考信号携带的是什么样的值？ A&gt;该值是通过在36.211 6.10.1.1所定义的序列生成算法产生的伪随机序列（注：上行链路参考信号 - DMRS - 是的Zadoff Chu序列）。该序列的一个决定值是物理小区ID，这意味着物理小区ID影响参考信号的值。 RS（参考信号） - MBSFN以下是根据36.211图6.10.2.2-1：MBSFN参考信号映射（扩展循环前缀，ΔF= 15 kHz） RS（参考信号） - UE特定以下基于36.211图6.10.3.2-1：UE专用的映射参考信号，天线端口5（正常循环前缀） RS（参考信号） - 定位以下是根据36.211图6.10.4.2-1：定位基准信号映射（正常循环前缀） RS（参考信号） - CSI以下是基于36.211图6.10.5.2-1：CSI参考信号（CSI配置0，正常循环前缀）的映射 全帧快照以下是示出了上述全信道的快照。当然，这不是给你的详细信息。这是给你的整体框架的整体画面。你能够识别上述各信道的位置？刚刚尝试它，这将是一个很好的做法。 在这个网格中的每个组件都有自己的作用，并以各种不同的上下文中使用。如果你有兴趣在如何这些渠道在实际通信过程中使用，请参考下面的快速参考页节。 通信中的物理信道下面的图表显示上行/下行数据传输的整体序列。你就可以将数据传输的序列图和在DL / UL帧结构的每个信道的特定位置相关联。 画廊我不会把太多的评论以下捕获。这些捕获是你的做法，以关联你在前面的章节中读取到现实生活中的信号模式是什么。]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2018%2F04%2F03%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[This is my first blog.]]></content>
  </entry>
  <entry>
    <title><![CDATA[26-LTE IP Address Allocation II - A Case for Two Cities]]></title>
    <url>%2F2016%2F04%2F03%2F26-LTE-IP-Address-Allocation-II-A-Case-for-Two-Cities%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=7257 I. Introduction在之前的文档我们已经覆盖了基本IP地址分配过程，解释了在用户同一个地点不同时间接入网络时LTE网络是怎么分配IP地址的。这个文档有一点不同，学习用户在不同物理位置上接入网络时的分配IP过程。和之前的文档意一样，要讨论两种分配方式：静态和动态的。另外我们要学习UE和PDN之间的连接PGW是怎么选择的，默认承载路径是怎么设置的。 对于动态分配方式，不管UE接入到哪个城市，LTE网络都分配一个动态的IP地址给UE，并且UE可以使用这个IP地址通过PGW连接到PDN。这个IP地址不管用户的接入位置和之前文档介绍的分配方式一样。但是对于静态分配方式，网络分配一个固定的IP地址，允许UE通过一个指定的PGW接入到PDN，不管UE接入到哪里。这个过程和之前文档根据用户的签约配置文件分配固定IP地址的方式一样。但是不同点在于默认承载路径要在城市内或者两个物理城市之间设置，现在有一个指定的PGW。 这个文档组织如下：第二章，讨论不同IP地址分配类型—静态和动态的以及他们的特点。第三章和第四章将提供动态和静态分配的详细过程。 II. Types of IP Address Allocation下面，我们将使用两个城市的模型来描述分配过程。在这个场景中，我们假设在每一个城市（city1和city2）都包含MME和SGW和PGW。每一个PGW有自己的IP地址池，只有city1有HSS。UE仅仅使用一个PDN服务（Internet）。当请求PDN连接时，UE请求dns服务器地址和PDN地址。详细的场景如下： 在city1，用户打开UE，接入LTE网络，使用PDN服务 在使用Internet服务后，用户关闭UE，并移动到city2 一旦到达city2，用户打开UE，接入LTE网络，使用PDN服务。 在city1或者city2初始附着时，UE向MME请求PDN连接。一旦请求，MME通过UE接入的PDN选择一个PGW，这个PGW决定IP地址。当默认承载建立之后PGW转发IP地址给UE，UE可以使用这个IP地址来使用PDN服务。 在这个两个城市的模型中，IP地址以两种类型分配—动态和静态。动态分配在第三章讨论，静态在第四章讨论。每一种方式的IP地址是谁选择和PGW选择的方式是不同的，如下表所示： III. Dynamic IP Address Allocation对于动态分配方式，IP地址不论用户什么时候执行初始附着到网络都是动态分配的。MME通过用户接入的PDN选择一个PGW，并要求建立一个EPS会话。PGW动态选择一个IP地址供UE使用来接入PDN。图1描述了在两个城市模型中动态IP地址分配的情况。 PGW中IP地址提供在PGW1和PGW2中，IP地址池包含待分配的IP地址，dns服务器地址已经由网络运营商提供了。IP地址获取和PDN连接用户打开UE，向当地的MME请求PDN连接。从hss下载的签约配置文件中，MME知道UE不是使用静态IP地址。所以MME选择一个本地的PGW（PGW1 PGW2），接着从这个PGW IP地址池中选择一个可用的IP地址分配给UE。当默认承载建立时，UE从本地PGW中获得dns服务器地址和UE IP地址，接着，通过本地PGW连接PDN使用Internet服务。 动态IP地址分配过程在city1或者city2动态IP地址分配的过程在之前的文档已经详细叙述过了。 IV. Static IP Address Allocation对于静态IP地址分配，i）UE使用的IP地址，ii）PGW的ID，这些都已经作为签约配置文件在PDN中提供了。不管用户在哪里接入LTE网络，MME选择指定的PGW，这个PGW分配存储存在用户签约配置文件中的静态IP地址。不管初始接入的位置，UE一直会分配相同的固定IP地址，并且在UE和指定PGW之间建立默认承载。图2描述了静态IP在两个城市模型中是怎么分配的。 hss中提供IP在hss中每一个用户提供签约配置文件。没有签约配置文件包含PDN类型，PDN地址和PGW ID。 PGW提供IP在PGW中，分配给UEdns服务器地址。 IP地址获取和PDN连接在开机后，UE1向本地MME请求PDN连接。MME从HSS中下载UE的签约配置文件，并确认UE有一个静态IP地址和指定的PGW。基于这些信息，MME开始创建EPS会话和建立EPS承载。这种方式，无关UE1是在哪里接入LTE网络，i)分配相同的静态IP地址，ii）建立连接指定PGW（PGW1）的默认承载路径，iii）UE1通过PGW1连接到PDN。这个默认承载路径是每一一个城市是这样的：city1： UE1- eNB-SGW1-PGW1city2：UE1-eNB-SGW2-PGW1 静态IP地址分配过程图3描述了在两个城市模型中静态IP地址分配的过程。 在city1 1）【UE1-&gt;MME1】请求PDN连接在city1，开机后，UE1通过发送PDN connectivity request消息(PDN Type=IPv4, PCO=DNS Server IPv4 Address Request) 来请求MME1建立PDN连接。这时，除了包含UE的IPv4地址还包含请求的dns服务器地址。 2）【MME1-&gt;HSS】请求LTE网络注册MME1通过发送update location request消息通知HSS，UE1已经在控制之下，并且在网络上注册UE1。 3）【MME1&lt;-HSS】转发签约配置文件HSS识别到UE1已经在MME上注册了，通过发送update location answer(IMSI, PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1))消息来转发UE1的签约配置文件。这个签约配置文件包含静态IP地址和PGW ID。 4）~5）【MME1-&gt;SGW1-&gt;PGW1】请求会话创建在从HSS接收到UE签约配置文件后，MME1知道UE1已经有一个静态IP地址了。MME1准备create session request消息(IMSI, PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1), PCO=DNS Server IPv4 Address Request)并发送给PGW1。这时，这个消息在PDN地址域包含从hss接收到的静态IP地址，在PCO域包含从UE接收到的PCO信息。 6）~7）【MME1&lt;-SGW1&lt;-PGW1】对创建会话请求的响应作为对4-5步请求的响应，PGW1发送create session response消息(IMSI, PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1), PCO={Primary DNS IP, Secondary DNS IP})给MME1。这个消息在PDN地址域包含静态IP地址，在PCO域包含dns服务器地址。 8）【UE1&lt;-MME1】请求默认承载上下文的激活MME1通过发送active default EPS bearer context request消息(PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1), PCO={Primary DNS IP, Secondary DNS IP})请求默认承载上下文的创建。这个ESM消息包含UE的静态IP地址和dns服务器地址，嵌入到attach accept消息中。 9）【UE1】获得静态IP地址来使用PDN服务UE1获得静态IP地址和dns服务器IP地址。UE和PGW之间(UE1 – eNB – S-GW1 – P-GW1)建立了默认承载。UE现在连接了PDN，可以通过静态IP地址使用Internet服务了。 在使用Internet服务之后，UE1关机，从LTE网络detach，一旦到达city2，UE1重选开机。 在city2 1）【UE1-&gt;MME1】请求PDN连接在city1，开机后，UE1通过发送PDN connectivity request消息(PDN Type=IPv4, PCO=DNS Server IPv4 Address Request) 来请求MME2建立PDN连接。这时，除了包含UE的IPv4地址还包含请求的dns服务器地址。 2）【MME2-&gt;HSS】请求LTE网络注册MME1通过发送update location request消息通知HSS，UE1已经在控制之下，并且在网络上注册UE1。 3）【MME2&lt;-HSS】转发签约配置文件HSS识别到UE1已经在MME2上注册了，删除在MME1中的UE上下文，通过发送update location answer(IMSI, PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1))消息来转发UE1的签约配置文件。这个签约配置文件包含静态IP地址和PGW ID。 4）~5）【MME2-&gt;SGW2-&gt;PGW1】请求会话创建在从HSS接收到UE签约配置文件后，MME2知道UE1已经有一个静态IP地址了。MME1准备create session request消息(IMSI, PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1), PCO=DNS Server IPv4 Address Request)并发送给PGW1。这时，这个消息在PDN地址域包含从hss接收到的静态IP地址，在PCO域包含从UE接收到的PCO信息。 6）~7）【MME2&lt;-SGW2&lt;-PGW1】对创建会话请求的响应作为对4-5步请求的响应，PGW1发送create session response消息(IMSI, PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1), PCO={Primary DNS IP, Secondary DNS IP})给MME2。这个消息在PDN地址域包含静态IP地址，在PCO域包含dns服务器地址。 8）【UE&lt;-MME】请求默认承载上下文的激活MME2通过发送active default EPS bearer context request消息(PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1), PCO={Primary DNS IP, Secondary DNS IP})请求默认承载上下文的创建。这个ESM消息包含UE的静态IP地址和dns服务器地址，嵌入到attach accept消息中。 9）【UE】获得静态IP地址来使用PDN服务UE1获得静态IP地址和dns服务器IP地址。UE和PGW之间(UE1 – eNB – S-GW2 – P-GW1)建立了默认承载。UE现在连接了PDN，可以通过静态IP地址使用Internet服务了。 V. Closing当UE试图初始附着到LTE网络，LTE网络根据用户签约的服务提供PDN连接，一旦连接上，网络保持这个连接直到用户从网络detach。这就意味着网络分配一个IP地址来使用。PDN连接是为每一个PDN提供的。所以IP地址也是为每一个PDN提供的。 我们目前已经学习到LTE网络在两个城市模型中是怎么分配IP地址的。 References[1] Netmanias Technical Document, “LTE IP Address Allocation Schemes I: Basic”, February 2015,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=7246[2] Netmanias Technical Document, “EMM Procedure 1. Initial Attach - Part 1. Cases of Initial Attach”,December 2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6098[3] 3GPP TS 23.401, “General Packet Radio Service (GPRS) enhancements for Evolved UniversalTerrestrial Radio Access Network (E-UTRAN) access”[4] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[25-IP Address Allocation I - Basic]]></title>
    <url>%2F2016%2F04%2F03%2F25-IP-Address-Allocation-I-Basic%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=7246 I. Introductionlte是全IP网络。这就意味着交付所有用户流量时都是以IP数据包的形式，提供给用户always on IP connectivity的服务。当UE加入LTE网络，会给UE分配一个PDN地址让UE连接这个PDN，并建立默认承载。默认承载保持连接知道UE从LTE网络中detach掉。默认承载对用户拥有的没有APN建立，为每一个APN分配独立的IP地址，一个IP地址可以为ipv4，ipv6，ipv4/ipv6三种类型。 这篇文件主要解释当用户初始接入网络时LTE网络怎么给用户分配IP地址的，并通过实例来解释。 在接下来的文档中我们将会涉及到两种类型的IP地址，这篇文档涉及到基本IP地址分配机制和过程，描述熊地址是怎样分配给用户的（用户处于一个位置，对网络执行多次初始attach）。接下来文档我们将学习不同类型的IP地址分配（用户在两个物理分割区域cityA和cityB执行初始附着）。这篇文档组织如下：第二章，不同类型的IP地址分配—动态的和静态的，并讨论他们的特点。第三章和第四章将详细讨论动态和静态IP地址的分配过程。 II. Types of IP Address Allocation当UE初始附着到LTE网络，UE请求PDN连接。PGW分配一个IP地址供UE连接PDN，并在U默认承载建立时连接UE和PDN，转发给UE。使用这个IP地址，UE可以获得PDN提供的服务。PGW分配IP地址有两种方式：动态的和静态的分配。对于动态分配，当UE每次接入网络时自动分配一个IP地址。对于静态分配，一旦用户签约后指定给UE一个固定的IP地址，并在每次UE接入网络时都分配这个指定的IP地址。图1比较两种方式的不同。 对于动态分配，网络PGW自动为UE选择IP地址。在PGW中网络运营商有一个IP地址池。的那个UE初始附着到LTE网络时，PGW动态为UE分配一个IP地址。所以每次UE初始附着到网络时分配的一个新的动态IP地址。但是，对于静态分配，一旦UE签约网络之后网络运营商就分配了一个固定的IP地址。运营商在hss中和其他签约信息一起为UE分配了静态的IP地址。接着当UE初始附着到LTE网络时，PGW从hss中获得这个静态IP地址并转发给UE。所以在每次UE初始附着网络时给UE分配的都是特定的IP地址。 当在初始附着请求PDN连接时，UE通过使用协议配置选项PCO可以请求和外部协议/应用相关的协议数据（eg请求dns服务器地址，P-CSCF地址）。这篇文档将详细解释dns服务器地址和IP地址的请求。 III. Dynamic IP Address Allocation对于动态IP地址分配，PGW为UE保留IP地址池，并在UE初始附着到LTE网络时为其分配一个IP地址。 PGW中提供IP地址在PGW中，分配了一个IP地址池，并且dns服务器IP地址已经分配了。 动态IP地址分配过程用户打开UE，试图初始附着到LTE网络上。 1）【UE-&gt;MME】请求PDN connectivityUE通过发送PDN connectivity request(PDN type=IPv4, PCO=DNS Server IPv4 Address Request)消息给MME请求PDN连接。这是，除了请求ipv4地址，也请求dns服务器地址。PDN connectivity request消息是一个ESM消息，但是这个消息是嵌入在attach request(IMSI，ESM Message Container)消息中传输的。 2）~3）【MME-&gt;SGW-&gt;PGW】请求会话创建MME基于从hss接收到的签约配置文件，发送create session request(IMSI, PDN Type=IPv4, PDN Address=0.0.0.0, PCO=DNS Server IPv4 Address Request) 消息给SGW请求EPS会话创建。因为是动态IP分配，这个签约配置文件中不包含IP地址信息，在create sessionrequest消息中PDN地址域是0.0.0.0，从UE接受到的PCO信息也包含在PCO域中。 4）【PGW】分配PDN地址和dns服务器地址PGW在检查PDN类型和PDN地址（0.0.0.0）之后发现需要分配ipv4地址。PGW从ipv4地址池中选择一个IP地址(e.g. UE IP=1.1.1.5)，并分配给UE。根据PCO域的请求，也分配相应的dns服务器IP地址。 5）~6）【MME&lt;-SGW&lt;-PGW】对请求会话创建的响应作为对2-3步请求的响应，PGW发送create session response消息给MME。这个消息包含PDN地址域的UE IP地址，PCO域的dns服务器IP地址。 7）【UE&lt;-MME】请求默认承载上下文的激活MME给UE发送activate default EPS bearer context request(PDN Type=IPv4, PDN Address=UE IP(1.1.1.5), PCO={Primary DNS IP, Secondary DNS IP})消息来请求对默认承载上下文的激活。这个ESM消息包含dns服务器IP地址和UE IP地址，嵌入到attach accept消息中传输。 8）【UE】获得动态IP地址使用PDN服务UE获得动态IP地址和dns服务器地址。UE和PGW之间建立默认承载。UE现在已经连接到PDN上，可以以动态IP地址来使用Internet服务。 IV. Static IP Address Allocation对于静态IP地址分配，当用户第一次签约网络时网络运营商为用户指定了一个UE IP地址，在hss中提供用户签约配置文件，并在用户每次初始附着到网络时分配一个存储在配置文件中的静态IP地址。详细的过程如图3所示。hss中提供IP在hss中，提供了每一个签约用户的签约配置文件。这个配置文件包括PDN类型，用于PDN连接的PDN地址。PGW中IP提供在PGW中，dns服务器IP地址已经设置了。 静态IP地址分配的过程用户打开UE，试图初始化附着到LTE网络。 1）【UE-&gt;MME】请求PDN连接UE通过发送PDN connectivity request消息(PDN type=IPv4, PCO=DNS Server IPv4 Address Request)消息给MME请求PDN连接。这时，除了IPv4地址，包括dns服务器地址也请求了。 2）【MME-&gt;HSS】为了注册请求LTE网络MME通过发送update location request消息通知HSS，UE已经在MME的控制之下，请求在网络上注册UE。 3）【MME&lt;-HSS】转发签约配置文件HSS识别到UE已经在MME上注册了，通过发送update location answer(IMSI, PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1))消息来转发UE的签约配置文件。这个签约配置文件包含静态IP地址。 4）~5）【MME-&gt;SGW-&gt;PGW】请求会话创建在从HSS接收到UE签约配置文件后，MME知道UE已经有一个额静态IP地址了。MME准备create session request消息(IMSI, PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1), PCO=DNS Server IPv4 Address Request)并发送给PGW。这时，这个消息在PDN地址域包含从hss接收到的静态IP地址，在PCO域包含从UE接收到的PCO信息。 6）~7）【MME&lt;-SGW&lt;-PGW】对创建会话请求的响应作为对4-5步请求的响应，PGW和SGW发送create session response消息(IMSI, PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1), PCO={Primary DNS IP, Secondary DNS IP})给MME。这个消息在PDN地址域包含静态IP地址，在PCO域包含dns服务器地址。 8）【UE&lt;-MME】请求默认承载上下文的激活MME通过发送active default EPS bearer context request消息(PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1), PCO={Primary DNS IP, Secondary DNS IP})请求默认承载上下文的创建。这个ESM消息包含UE的静态IP地址和dns服务器地址，嵌入到attach accept消息中。 9）【UE】获得静态IP地址来使用PDN服务UE获得静态IP地址和dns服务器IP地址。UE和PGW之间建立了默认承载。UE现在连接了PDN，可以通过静态IP地址使用Internet服务了。 V. Closing到目前为止，我们讨论了两种分配IP的方式：静态和动态。当用户试图初始附着到LTE网络时，LTE网络分配一个IP地址来连接到PDN上和默认承载。只要用户网络注册有效，PDN地址和默认承载一直保持有用，即使用户没有在使用服务。这种方式叫做always-on IP connectivity。这个文档解释了IP地址分配的机制和过程。下面一个文章我们将讨论在不同的位置UE连接PDN时的情况。 References[1] Netmanias Technical Document, “LTE IP Address Allocation Schemes II: A Case for Two Cities”,February 2014 (TBD)[2] Netmanias Technical Document, “EMM Procedure 1. Initial Attach - Part 1. Cases of Initial Attach”,December 2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6098[3] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23-LTE Charging I_Offline]]></title>
    <url>%2F2016%2F04%2F03%2F23-LTE-Charging-I-Offline%2F</url>
    <content type="text"><![CDATA[原文链接： http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=7179 I. Introduction之前的PCC文档，我们的焦点在讨论关于QoS规则的PCC策略。现在我们的焦点是付费策略，特别是离线付费策略。 在LTE网络中，服务是按照承载（eg，EPC）/子系统（eg.IMS）/服务级别（eg MMS）或者是在线和离线来付费的。对于在线付费，当用户请求网络资源，网络运行账户查询并决定是否授权用户用户使用请求的网络资源。这个情况，用户的网络资源利用被实时测量，所以说付费信息对提供的服务有实时的影响。这个方法应用在预付套餐上。（预付套餐是神马？？）另一方面，对于离线付费，用户为已经使用过的网络资源付费。也就是说，网络通过转发用户的CDR（付费数据记录）到账单系统来报告特定用户的资源使用情况。用户使用的信息定期的收集，或者在没有会话结束时收集。所以付费信息对提供的服务没有实时性影响。通常上，在线付费是使用在预付费套餐上，离线付费使用在后付费套餐上。例如，多数韩国的移动用户是后付费套餐使用者，他们都属于离线付费策略。这种类型套餐的使用者首选使用服务，然后他们的运营商每月再计算他们的使用情况付费。在全球范围内，预付费用户比后付费用户要多。预付费用户首先付费，然后保证他们的配额。一旦他们的配额超出，激活的会话就会终止。这篇文档主要讨论当在承载级别后付费用户使用Internet服务时运用离线付费策略的付费过程。这篇文档组织如下：第二章提供付费相关的接口和离线付费是怎么工作的，第三章解释离线付费的过程。第四章总结CDR参数，离线付费参数。 II. Overview of Offline Charging下面我们将定义LTE参考模型中付费相关的接口。图1描述了LTE付费架构和相关的接口。 策略和付费规则功能PCRF：当决定到用户SDF的PCC策略时，PCRF选择一个付费策略适用于SDF（service data flow），并通过Gx接口转发这个策略到PGW中的PCEF（policy and charging enforcement function）。 PGW：PGW对用户的SDF执行PCRF转发的付费策略。在离线付费，PGW根据付费策略生成CDR，并通过Gz接口转发至OFCS（offline charging system）。在在线付费，PGW首先请求和获得配额，然后通过Gy接口和OCS（online charging system）执行信用控制来测量和报告用户的使用情况。 OFCS离线付费系统：一旦接收到Gz接口上PGW的CDR，OFCS后处理他们并转发至账单系统billing system、 OCS在线付费系统：通过Gy接口和PGW执行信用控制来给用户分配配额（eg，这个会话持续多长时间，用户交付多少数据等等） 遮普文档只关于离线付费的，图1展示了PCRF PGW OFCS怎么工作的。在我们进一步详细讨论之前，我们先简要介绍一下离线付费系统是怎么工作的。 图2提供了离线付费工作的概况，特别的付费规则的交付和CDR的传输。 1）PCRF，一旦EPS会话建立，PCRF选择一个付费策略，并嵌入到PCC策略中转发给PCRF（PGW）。同事，付费策略的名字被定为PCC规则的名字。像付费方法（在线或者离线），排序组（服务是怎么付费，每分钟100元，100M 1000元等等）这些信息作为付费规则包含在PCC规则中。在图2中，Internet会话建立了，在上面应用了offline的付费方法和rgInternet排序方法的付费规则。 2）PGW从PCRF接收到付费规则，PGW知道使用的是离线付费。PGW决定应该测量或者产生什么样的付费信息，通过那个接口传输这些信息。接着PGW创建默认承载，在上面应用这些付费规则，并打开CDR，准备好生成付费信息。 3）现在IP数据包通过PGW传输。PGW开始通过Internet SDF开始测量网络使用量，生成付费信息。 4）一旦EPS会话终止，PGW把这些CDR记录信息转发给OFCS。在这个实例中，每一个排序组的使用量都报告了，CDR包含以下信息： 用户信息（eg用户ID，用户位置） 网络/承载信息（eg服务网络ID，APN，PGW，SGW地址，请求的QoS，授权的QoS） 网络资源使用量（eg传输的字节数） 使用量信息（eg总的获取时间，数据包传输时间） 服务信息（eg服务id，数据包过滤） III. Offline Charging Procedure图3是LTE网络中离线付费过程。这个文档只关注在付费处理过程。 1）【PCRF&lt;-SPR】获得用户配置在用户初始附着过程中，PCRF从SPR中请求和获得用户的签约配置文件为了决定PCC规则。 2）【PGW&lt;-PCRF】请求会话建立PCRF基于用户签约配置文件决定Internet会话的付费策略。PCRF通过CCA（credit control answer消息）转发PCC规则“Internet”给PGW。 3)【PGW】CDR创建PGW根据PCC规则创建默认承载，并且对这个承载执行付费策略。接着PGW通过创建CDR准备好生成付费信息。 4）【PGW】生成付费信息一旦用户开始使用Internet，PGW记录用户网络资源使用情况和详细使用信息，生成付费信息。 5）【PGW】CDR关闭PGW一旦在用户detach之后EPS会话结束后关闭CDR。 6）【PGW-&gt;OFCS】CDR传输PGW通过data record transfer request（CDR）消息通过GTP’协议把CDR传输给OFCS。报告的信息包括每一个排序组的使用信息，数据包交付时间，字节交付时间等等。 7）【PGW&lt;-OFCS】CDR接收确认OFCS通过发送data record transfer accept消息确认CDR的接收。 OFCS收集CDR，后处理他们，并且把他们转发给运营商计费系统。这个计费系统分析接收到的CDR来获得统计值决定要付费多少钱。接着使用这些结果向用户收费或者运营商之间账户。 IV. Parameters for Charging Data Record (CDR)图2和图3总结了CDR的主要参数。除了这些参数，CDR还有其他另外的付费参数。表1列出了在承载级别上使用的CDR参数。 V. Closing我们讨论了付费过程。下一个文档将讨论在线付费系统。 References[1] Netmanias Technical Document, “LTE Policy and Charging Control (PCC)”, August 2014,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6562[2] 3GPP TS 32.240, “Telecommunication management; Charging management; Charging architectureand principles”[3] Netmanias Technical Document, “LTE Network Architecture: Basic”, July 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5904[4] 3GPP TS 32.295, “Telecommunication management; Charging management; Charging Data Record(CDR) transfer”[5] Netmanias Technical Document, “EMM Procedure 1. Initial Attach - Part 2. Call Flow of Initial Attach”,January 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6102[6] 3GPP TS 32.298, “Telecommunication management; Charging management; Charging Data Record(CDR) parameter description”[7] Netmanias Technical Document, “LTE Charging: Online”, TBD[8] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[22-LTE Policy and Charging Control (PCC)]]></title>
    <url>%2F2016%2F04%2F03%2F22-LTE-Policy-and-Charging-Control-PCC%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6562 I. introduction为了使用LTE服务，用户必须购买一个LTE设备，和运营商签署一个账户，并选择服务类型和想要的计划。为了支持和管理这些选择的服务，运营商根据用户的签约信息来配置签约文件。当用户使用LTE服务时，对每一个和不同服务相关的APN建立EPS会话。这时，网络决定一个策略：当EPS会话建立或者修改是,网络资源时怎么分配的，这些服务时怎么付费的。接着，当会话保持激活状态时，应用这个策略到EPS会话。这个过程叫做策略和付费控制PCC，主要由策略付费控制功能PCRF和策略付费增强功能PCEF实现。 当建立或者修改EPS会话，基于运营商的策略PCRF决定每一个服务数据流SDF的PCC规则。 PCEF (P-GW)检测一个SDF，并适用一个PCC规则，这个规则对用户数据包上的一个特定的SDF是特定的。它可以绑定SDF QoS和承载QoS，适用承载QoS到EPS承载。也就说，EPS承载上下文是在EPS实体(UE, eNB, S-GW, P-GW, and MME)上设置和修改的。 EPS会话的建立，修改和结束的执行时和PCC过程一致的。EPS会话修改过程可能包含EPS承载的建立修改和结束。在这个过程中，UE和MME之间的EPS承载上下文是按照NAS层的EPS会话管理功能ESM来处理的。 这篇文档讨论PCC规则和过程，是按照如下组织的：第二章定义PCC规则并描述PCC规则对于不同的服务烈性在GX接口时怎么提供的。第三章讨论伴随ESM过程的EPS会话建立和修改需要的PCC规则。第四章介绍当使用策略控制时，IP数据包是怎么处理的。第五章总结EPS实体中策略控制相关的信息。 II.PCC rulesPCRF决定每一个SDF的PCC规则，并通过Gx接口把这些规则转发给PCEF（PGW）。PGW接着对每一个SDF执行这些PCC规则。在执行PCC规则后，当IP数据包到达，检测到每一个数据包属于的SDF，并根据他们的SDF对每一个数据包适用PCC规则。3GPP29.312按照如下定义PCC规则： 目的：PCC规则的目的是检测一个数据包属于哪个SDF，并识别出SDF作用的服务，为这个SDF提供合适的付费参数，并为这个SDF提供策略控制。 适用：适用于不同的SDF。PCEF (P-GW)通过使用数据包过滤器（SDF templates）来匹配对IP数据包进行分类，并对这些数据包应用上匹配的PCC规则。 类型：动态PCC规则，或者预定义的PCC规则。动态PCC规则是在EPS会话建立或者修改时，由PCRF动态地提供给PGW的。预定义的PCC规则是在PGW中预先配置的，可以由PCRF激活或者去激活。 elements：PCC规则包含策略规则名字，service ID，SDF templates，gate status，QoS参数，付费参数等等，并根据运营商的策略而变化。 下面，我们详细介绍不同类型的PCC规则是怎样通过Gx接口传送的，并且在PGW上执行的。2,1节描述预定义的PCC规则，2.2节描述动态PCC规则。 2.1 预定义PCC规则一些运营商适用限制不是他们服务的流量的比特率这样的策略，例如P2P。所以，我们使用P2P作为示例介绍下预定义PCC策略。图1描述了在PGW中预定义PCC策略是怎么配置的。 在这个图中，预定义规则“P2P”是在PGW中预配置和去激活的。因为这个规则是预定义的，一旦PCRF决定，就需要给PGW这个策略规则的名字 ie“P2P”，来代替发送这个规则的所有元素。一旦接收到P2P这个规则名字，PGW激活之前去激活的P2P规则，并执行。 2.2 动态PCC规则动态PCC规则是在当有时间时使用的。图2描述了动态PCC规则在用户使用Internet和语音服务是在PGW中怎么配置的。图中做如下假设： 运营商策略：互联网服务的接入性在一定程度上取决于网络资源。并且可以保证语音服务的数据速率。 APN：Internet和语音服务可以通过不同的APN接入。 PCC规则名字：Internet服务“Internet”，语音服务“voice-C”（SIP信令）/“voice-U”（voice packet） “Internet”规则适用于接入Internet的所有数据包。它支持不限制的MBR（UL/DL），允许Internet接入最大可能的比特率。这个规则适用于接入Internet的默认承载。APN-AMBR(uL/DL)是设置为非限制的，如果没有其他用户在服务数据可以以最大速率传输。但是服务的用户越多，支持的速率越慢。 “voice-C”规则适用于SIP信令数据包。它适用于接入IMS网络的默认承载，支持100Kbps的APN-AMBR(uL/DL)。 “voice-U”规则适用于多媒体数据包，是用户语音数据包，支持GBR。在激活的语音会话中，分配的网络资源确保数据包随时是按照UL/DL 88 Kbps的速率交付的。专用承载建立，也是允许数据包以UL/DL 88 Kbps的速率交付。 每次建立或者修改一个EPS会话，PCRF动态决定PCC规则，包含根据选择服务类型特定规则的规则名字和规则参数。接着PCRF把这些参数提供给PGW。接着PGW在把这些参数映射到承载QoS参数上之后对IP数据包执行这些策略。 一旦用户通过初始附着过程接入Internet和IMS网络，用户默认承载保持连接直到UE从LTE网络中去附着。所以基本上，“Internet”“voice-C”规则在PGW中保持激活。另外一旦检测到语音电话，就在IMS APN上建立专用承载，并在通话结束时终止承载。 3. PCC procedures我们再第二章讨论了PCC规则。在第三章，我们将通过EPS会话建立和修改过程在探索PCC规则。在LTE中，语音服务和Internet服务使用不同的PDN，所以他们有自己的默认承载。语音信令消息是使用SIP协议通过默认承载传输的，而媒体数据包（用户语音数据包）是使用RTP协议通过专用承载传输的。 Internet服务用户的初始附着和EPS会话建立过程已经在LTE初始附着的文档中讨论过了。我们深入讨论在EPS会话建立或者修改过程对用户接入IMS拨打语音通话时PCC是如何工作的。为了在LTE网络拨打语音通话，附着LTE和IMS注册时提前必须的。一旦语音服务的EPS会话通过LTE attach过程建立了，attach到IMS网络的默认承载也在LTE网络中创建了。在这个过程中，voice-C语音服务信令的PCC规则适用于这个承载。通过这个承载，交付SIP信令消息，用户和IMS网络之间的IMS鉴权注册接着执行。接着当有一个语音通话，IMS网络监测到它，并通过PCRF。PCRF决定PCC规则（“voice-U”）并转发至PGW。PGW为语音数据包传输创建专用承载，并且通过这个专用承载传输语音数据包。 3.1 语音会话建立：默认承载建立和IMS注册图3描述了通过IMS APN初始attach的用户时如何建立EPS会话的。我们假设EPS会话建立是由用户打开UE而发起的。随着使用EMM消息完成初始附着过程，EMM之前我们已经介绍了，现在我们简要过一下ESM过程。 1）【UE-&gt;MME】PDN connectivity request UE通过PDN connectivity request消息给MME请求接入IMS网络。在ESM消息中的PCO协议配置选项域用来要求代理呼叫会话控制功能P-CSCF地址。这个消息是包含在attach request消息中，发送给MME。 2）【MME-&gt;SGW-&gt;PGW】请求语音会话的创建 MME在位置更新时从hss接收到签约配置文件中获得APN和签约QoS配置。从APN，MME意识到APN要为语音服务创建默认承载，并为这个默认承载分配ID。这个签约配置文件获得QoS参数(QCI = 5, ARP = 6, APN-AMBR = 100 Kbps)，这些配置文件应用于默认承载。MME准备create session request消息，包含默认承载ID，APN，PCO和签约QoS配置文件，并把它转发给PGW。这时候，从UE接收到PCO域被透传给PGW。 3）【PGW】UE IP和P-CSCF地址分配 PGW为IMS APN分配UE IP，并选择P-CSCF的地址。 4）【PGW-&gt;PCRF】EPS会话建立的通知 PGW通过发送Credit-Control-Request (CCR)消息把用户签约QoS配置转发给PCRF，请求鉴权。 5）~6）【PCRF，SPR】用户配置获取 PCRF可以从SPR中获得用户签约配置文件，并使用配置文件来为语音服务决定PCC策略。 7）【PCRF】策略决定 基于签约配置文件，PCRF决定EPS会话的策略。这个实例中是SIP信令，选择“voice-C”作为PCC规则。“Voice-C” rule: QCI = 5, ARP = 6, APN-AMBR (UL/DL) = 100 Kbps, Charging Rule: Offline, SIP Packet Filter 8）【PGW&lt;-PCRF】PCC规则提供 PCRF转发PCC规则(“Voice-C”) 给PGW。 9）【PGW】策略实施 一旦接收到(“Voice-C”) PCC策略，PGW执行策略参数，并把SDF QoS参数映射到默认承载QoS参数上。 P-GW (SDF): QCI = 5, ARP = 6, MBR (UL/DL) = 100 Kbps/100 Kbps, SDF Template (UL/DL) = (UE IP, ,SIP, , UDP) /( , UE IP, SIP, , UDP) P-GW (Default Bearer): QCI = 5, ARP = 6, APN=AMBR (UL/DL) = 100 Kbps/100 Kbps, TFT (UL/DL) =(UE IP, , SIP, , UDP)/( , UE IP, SIP, , UDP) 10）【MME&lt;-SGW&lt;-PGW】对语音会话创建的响应 作为对step-2请求的响应，PGW发送Create Session Response消息给MME。这个消息包含提供的QoS配置文件和上行策略参数，都需要转发给UE。 11）【UE&lt;-MME】请求默认承载上下文激活 MME通过发送Activate Default EPS Bearer Context Request消息请求UE激活默认承载上下文。这个ESM消息包含APN，UE IP，P-CSCF地址，PGW提供的策略参数，是嵌入在attach accept消息中的。 12）【UE】策略执行：默认承载上下文激活 UE执行上行策略并激活默认承载上下文UE: QCI = 5, APN-AMBR (UL) = 100 Kbps, TFT (UL) = (UE IP, , SIP, , UDP) 13）【UE-&gt;MME】默认承载上下文激活的通知 UE通过发送Activate Default EPS Bearer Context Accept消息通知MME，用于传输SIP信令消息的默认承载上下文已经激活了。一旦SIP信令的默认承载建立完成，IMS鉴权和注册过程将紧接着执行。使用SIP协议的IMS过程在本文档的讨论范围之外，我们将会在volte文档中叙述。一旦IMS注册完成，UE准备发送/接收语音通话了。3.2 语音会话修改：专用承载建立一旦LTE附着和IMS注册完成，UE准备开始语音通话。但是，因为语音数据包需要实时传送，为SIP信令建立的默认承载提供的QoS不鞥呢满足语音数据包的QoS。所以，现在需要建立一个能盲足语音数据包QoS的新承载。对每一个语音通话，建立语音数据包的专用承载，通过语音会话修改过程。图4展示了专用承载是怎么建立的，一旦检测到语音通话根据新的PCC策略语音会话时如何修改的。在途中，当发起端UE请求语音通话，PCRF从SIP信令（session progress消息）知道请求的是语音通话。接着PCRF决定一个PCC策略“Voice-U” rule (QCI = 1, ARP = 7, GBR/MBR = 88 Kbps)，并把它转发给PGW，接着PGW创建GBR类型的专用承载。当发起端UE通过默认承载接收到对端UE的200 OK的SIP消息时，UE通过专用承载转发语音数据包。 1）【UE-&gt;P-CSCF】语音通话生成 发起端UE通过发送invite消息给IMS网络请求语音通话。详细的过程将会在IMS网络的文档中叙述。 2）【PCRF&lt;-P-CSCF】传送服务信息 一旦接收到这个SIP消息，IMS网络的P-CSCF就知道了请求的是语音电话。所以他发送一个AAR（AA-request）给PCRF，转发服务消息。这个AAR消息包含媒体信息，比如最大/最小带宽，IP数据流标识，codec等等。 3）【PCRF】策略决定 基于从P-CSCF接收到的服务信息，PCRF通过选择一个PCC规则和承载来决定EPS会话的策略。对于PCC规则，它选择voice-U规则来支持语音数据包。对于这个承载的QoS级别，选择QCI=1。由于语音数据包QoS不能被已经存在的默认承载的QoS支持，需要建立一个不同QoS等级的专用承载，接着修改EPS会话。“Voice-U” rule: QCI = 1, ARP = 7, GBR (UL/DL) = 88 Kbps/88 Kbps, MBR (UL/DL) = 88 Kbps/88 Kbps,Charging Rule: Offline, RTP Packet Filter 4）【PGW&lt;-PCRF】PCC规则提供 PCRF给PGW传输PCC规则(“Voice-U”) 5）【PGW】策略执行 一旦接收到这个PCC规则(“Voice-U”) ，PGW配置QoS和付费策略参数，并且把SDFQoS参数映射到专用承载QoS参数。 P-GW (SDF): QCI = 1, ARP = 7, GBR (UL/DL) = 88 Kbps/88 Kbps, MBR (UL/DL) = 88 Kbps/88 Kbps, SDF Template (UL/DL)=(UE IP, , RTP, , UDP) /(, UE IP, RTP, , UDP) P-GW (Dedicated Bearer): QCI = 1, ARP = 7, GBR (UL/DL) = 88 Kbps/88 Kbps, MBR (UL/DL) = 88Kbps/88 Kbps, TFT (UL/DL) = (UE IP, , RTP, , UDP)/(, UE IP, RTP, , UDP) 6）~7）【MME&lt;-SGW&lt;-PGW】专用承载创建请求 PGW给MME发送create bearer request消息来请求专用承载建立。这个消息 包含连接EPS承载标识LBI，专用承载ID，专用承载QoS和上行TFT信息。专用承载相关的信息包含LBI，是作为一个每一个专用承载所属的EPS会话的默认承载ID。从上图中，它是用语音会话的默认承载ID表示的。 8）【UE&lt;-MME】请求专用承载上下文的激活 MME通过发送activate dedicated EPS bearer context request消息来请求专用承载上下文的激活。在这个消息中包含PGW发送的策略参数。 9）【UE】策略执行：专用承载上下文的激活 UE执行上行策略，并激活专用承载上下文。UE: QCI = 1, GBR (UL) = 88 Kbps, MBR (UL) = 88K bps, TFT (UL) = (UE IP, , RTP, , UDP) 10）【UE-&gt;MME】通知专用承载上下文激活 UE通过发送activate dedicated EPS bearer Context accept消息通知MME，用于语音数据包的专用承载上下文已经激活了。 11）~12）【MME-&gt;SGW-&gt;PGW】专用承载创建的通知 MME给PGW通知专用承载已经创建了。 13）【PGW-&gt;PCRF】通知PCC策略已经适用 PGW给PCRF通知PCC规则已经执行了。IV. How Policy Control Affects the Way IP Packet Flows are Handled我们将学习了PCC策略是如何影响EPS会话中IP数据流的处理的。图5描述了EPS会话中UE产生的IP数据流。在图5a中，Internet流量通过为Internet服务创建的默认承载从Internet PDN传输。对于语音服务，SIP信令流通过为语音服务创建的默认承载在IMS PDN（PCSCF）传输。语音媒体流通过为语音服务创建的专用承载和呼叫对端之间传输。图6显示了应用于图5IP数据包流的策略控制。在途中，在图2中列出的策略参数在PGW中执行。PGW检测上下行的SDF，并对每一个SDF的每一个IP数据包执行策略控制。在EPS承载上，设置EPS承载QoS参数。 下行 IP数据包流到达PGW。根据PGW中设置的门状态，来自Internet和IMS网络的流量都是允许的。 SIP流量（APN=IMS）是i)由PGW的数据包过滤PF1作为SDF1检测的，ii）限制MBR（100Kbps）速率，iii）映射到默认承载，iv）限制APN-AMBR（100Kbps）。在eNB，流量时根据UE-AMBR的速率来调度的，并传送给UE。 语音流量（APN=IMS）是i）由PGW的数据包铝PF2作为SDF2来检测的，ii）保证GBR速率，iii）映射到专用承载，iv）再次保证GBR。在eNB，流量时以GBR调度的，并传送给UE。 Internet流量（APN=Internet）是i）由PGW的数据包过滤PF3作为SDF3来检测的，ii）不限制速率，iii）映射到默认承载，iv）保证APN-AMBR速率，不受限。在eNB，流量是以UE-AMBR来调度的，并传送给UE。 上行 IP数据包从应用层到达UE。上行IP数据包通过上行数据包过滤器(UL TFT; PF1, PF2, PF3)映射到相应的的承载，并对数据包适用每一个承载的QoS。接着转发给PGW，PGW适用数据包过滤器(SDF template; PF1, PF2, PF3)检测SDF，在应用SDF QoS之后转发到目的地。 SIP流量是i）在UE的PF1映射到连接IMS APN的默认承载，ii）限制MBR（100Kbps）速率，iii）发送给eNB。在PGW中，它是i）再次限制MBR（100Kbps）速率，ii）有PF1作为SDF1检测，iii）保证SDF MBR（100Kbps），iv）接着转发给IMS网络。 语音流量是i）在UE的PF1映射到连接IMS APN的专用承载，ii）以GBR发送给eNB，作为eNB调度。一旦到达PGW，它是i）有PF2作为SDF2检测，iii）保证SDF GBR（88Kbps）转发的。 Internet流量是i）在UE的PF3映射到连接Internet APN的默认承载上的，ii）保证APN-AMBR速率，不限制，iii）发送给eNB。一旦到达PGW，它是i）再次保证上行 APN-AMBR，ii）由PF3作为SDF3检测，iii）保证SDF MBR，不限制，iv）转发到Internet。 V. EPS entity information下面我们介绍在PCC规则在Internet和语音流量上执行之后每一个APN上EPS实体信息的变化情况。 5.1 Internet服务图7展示了对Internet服务流量执行PCC规则之后EPS实体中的信息。在初始接入Internet时，PCRF选择一个PCC规则“Internet”，并转发给PGW。接着PGW使用这个规则对Internet服务的EPS默认承载执行QoS参数。这个默认承载保持激活知道UEdetach。 5.2 语音服务图8展示了对语音服务榴莲根治性PCC规则之后保存在EPS实体中的信息。在实例中，一旦UE初始接入IMS网络，默认承载就建立了，就检测到了语音通话。在初始接入IMS网络时，PCRF选择一个PCC规则“voice-C”，PGW对SIP信令的EPS默认承载执行QoS参数。因为语音通话是在很短的时间内检测的，接着，PCRF选择voice-U规则，PGW对EPS专用承载执行QoS参数。 一旦语音通话结束，P-CSCF通知PCRF。接着PCRF发起EPS会话修改过程，把专用承载终止，删除UE/eNB/SGW/PGW中的专用承载上下文。但是，SIP信令的默认承载还是保持激活直到UE从LTE网络中detach。 VI. closing目前，我们已经学习了PCRF怎么决定PCC规则的以及当用户使用Internet和语音服务时PGW怎么执行规则的，并分析PCC规程。我们还学习了基于PCC规则PGW是怎么控制EPS承载的，并举例说明了策略控制是怎么影响IP数据包流的。这篇文档覆盖了PCC规则，集中在QoS策略。下一个文档我们将介绍付费，讨论付费信息和过程。 References[1] 3GPP TS 29.212, “Policy and Charging Control over Gx Reference Point”[2] Netmanias Technical Document, “LTE EMM Procedure 1. Initial Attach – Part 2. Call Flow of InitialAttach”, January 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6102[3] Netmanias Technical Document, “LTE QoS: SDF and EPS Bearer QoS”, September 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5908[4] Netmanias Technical Document, “Initial Attach procedure for VoLTE”, TBD[5] Netmanias Technical Document, “LTE Charging: Offline”, TBD[6] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[21-EMM Procedure - 10 & 11. Move to Another City and Attach]]></title>
    <url>%2F2016%2F04%2F03%2F21-EMM-Procedure-10-11-Move-to-Another-City-and-Attach%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6354 I. introduction随着UE的移动当服务小区的信号强度变弱时UE试图进行切换或者小区重选。如果在UE移动的周边没有邻区，信号强度将会逐步减弱直到UE最终从网络detach。接着一旦达到LTE覆盖区域，UE重选通过小区选择初始注册到网络。 这篇文档讨论当UE移动到一个LTE覆盖范围之外从网络detach，并移动到另外一个LTE网络重新attach到网络。 EMM case-10 move to another cityEMM case-11 initial attach in another city这两个EMM case，本文档假设移动运营商： 在不同城市服务 只有LTE-only网络，没有2/3G 每一个城市有MME SGW PGW HSS PCRF SPR仅仅安装在一个城市 所有的MME通过S10接口 图1显示了city1和city2，车里的用户从city1移动到city2.在EMM case10中，随着UE离开city1，UE从网络detach，移动出LTE覆盖范围。不论是connected 模式下使用服务还是在idle模式下驻留在服务小区，随着UE离开city1，UE被MME网络detach掉。 在EMM case11中，随着在city2 UE移动进入LTE覆盖范围，UE再次attach到网络。不像之前文档的情况，当UEattach 新的MME时，旧MME已经包含了UE上下文。UE初始附着到新MME上时就可以使用旧MME分配的UE ID。这样，UE就可以从detach 状态转换到connected状态。 这篇文档组织如下：第二章和第三章讨论EMM case10和11的过程。第四章将描述在这个过程前后EPS实体信息的变化。 II. EMM Case 10. Move to Another City2.1 在connected模式下移动在图2中，我们看到当在city1服务的UE是怎么移出LTE覆盖范围并从网络detach的。 1）【UE-&gt;eNB】测量报告随着UE离开city1，服务小区的信号强度变弱。随着A2事件的激活，UE给eNB发送measurement report消息通知服务小区的信号强度。 2）【eNB】没有邻区来切换enB没有找到供UE切换的邻区。 3）【eNB-&gt;MME】错误指示因为糟糕的通信质量，在无线接口上传送失败。eNB通过发送error indication(Cause=Failure in the Radio Interface)给MME通知这个失败。如果eNB发现和UE之间很难保持最低的质量，eNB将给MME发送UE context release request消息。 如果UE因为糟糕的通信质量丢失了RRC连接，UE试图RRC连接重建。如果这个质量的衰减是暂时的，为了正常的无线通信允许RRC进行重建。但是服务提供会中断。如果这个质量衰减是持续的，RRC连接重建将会持续失败，最终导致连接丢失。 假设i）当eNB和UE之间的RRC连接还持续有效，eNB给MME发送error indication。ii）因为UE当前服务小区位于城市边界，并且没有邻区切换，MME决定detach掉UE。所以由MME触发detach过程。 4）MME发起detachMME通过发送detach request消息执行detach过程。这里的过程和之前文档中介绍的MME发起显式detach过程是一样的。MME存储UE的GUTI和NAS安全上下文，结束EPS会话，释放S1信令，并转移到detach状态。UE存储自己的GUTI和NAS安全上下文，删除EPS会话承载上下文，并转移到detach状态。 2.2 在idle模式下移动idle模式下的UE会周期性的通过TAU报告自己的位置给网络。当UE有电话或者数据到来，MME不知道idle模式下的UE是否可达的。为了这个原因，idle状态下的UE即使处于TAI列表中的TA也需要周期性的报告自己的位置，这样网络可以知道UE是否可达的。MME有一个TAU定时器T3412, 手机可达定时器，和隐式detach定时器。TAU定时器的值是在UE初始附着到网络时通过attach accept消息转发给UE的，或者当UE做TAU request时通过TAU accept消息发给UE的。 TAU定时器默认是54分钟，如果MME设置这个值为0，UE就不激活TAU 定时器，并不执行周期性TAU。当UE从connected状态到idle状态转换时UE的TAU定时器激活。当这个定时器超时，UE转移到connected状态给MME发送TAU request消息通知UE是可达的，接着转移到idle状态，并重启TAU定时器。UE在从idle状态到connected状态转移时停止这个定时器，或者从网络detach时停止定时器。如果MME为了UE超时设置的TAU定时器，MME立刻接收到了TAU request消息，通过这个消息MME可以跟踪UE的位置。接着，MME分配新的TAI列表，并重启TAU定时器。也就是说网络会在每一个TAU定时器周期结束时检查UE是否可达，并设置paging proceed flag为1，标示UE是可达的。 如果UE有任何问题，比如UE在T3412定时器超时时在一个阴影区域并不可达，UE在T3412超时时发起TAU request，就导致不能给MME通知自己的位置。当TAU失败时UE需要重新尝试。所以，如果UE很快从阴影区域移出，接着重选尝试TAU请求成功了。但是如果UE一直待在阴影区域，TAU 请求过程一直失败。 网络使用手机可达定时器来检查UE是否可达。和T3412 TAU定时器相比，有稍微更大的值，默认是T3412+4分钟。当在ECM连接释放时这个定时器开始，当一个新的ECM连接建立时停止定时器。 当手机可达定时器超时，MME知道UE在已经移除LTE服务区域，但是不知道移除覆盖状态需要持续多长时间。所以为了不立即删除UE上下文，MME清除PPF flag并开启隐式detach定时器。当PPF flag清除时，UE是本地detach的。也就是说当隐式detach定时器运行时，网络仍旧保持UE上下文没有删除，但是MME不会寻呼UE。即使当SGW有到达UE的电话或者数据包，SGW给MME发送downlink data notification时，MME拒绝这个消息。 当UE发送NAS消息，建立ECM连接，隐式detach定时器停止。如果MME在隐式detach定时器超时不能定位UE，MME相信UE已经长期到了LTE覆盖范围外，并从网络把UEdetach掉。现在网络中的UE上下文删除。 图3描述了UE在city1服务小区上驻留，随着移出LTE覆盖从网络detach的过程。 1）【MME】TAU定时器T3412超时UE设定的TAU定时器超时，MME没有收到从UE的TAU request消息，并必须检查UE是否可达 2）【MME】手机可达定时器超时UE的手机可达定时器也超时了。MME相信UE是在覆盖区外的状态，并清除PPF flag并开启隐式detach定时器。分配给UE的EPS承载安全上下文资源保持有效，但是MME不会寻呼UE。 3）【MME】手机隐式detach定时器超时UE的隐式detach定时器超时。MME相信UE已经长期在覆盖范围之外，并决定从网络隐式detach掉UE。 4）【eNB，MME，SGW，PGW，PCRF】UE detachedMME发起隐式detach过程。这个过程和之前文档中的MME发起的隐式detach过程意义昂。分配给UE的而资源和上下文都被删除了。 III. EMM Case 11. Initial Attach in Another City这章描述UE移动到city2，进入LTE覆盖，并选择一个新的小区，执行初始attach，从detach状态转移到connected状态。我们假设UE已经通过MME发起的隐式detach过程从city1的网络中detach掉了，所以在UE和网络MME1中的old GUTI和NAS安全上下文都保持有效。 图4显示了在city2UE初始附着过程的初始附着的类型和功能模块。这个初始附着类型和attach case-5中的类型是一样的。也就是说UE成功从网络detach，UE和old MME中都保留有效的old GUTI和NAS安全上下文，接着UE使用这些参数向new MME做初始attach。UE使用old GUTI作为ID发送attach request消息。这个消息是使用NAS完整性秘钥完保的。这个new MME转发这个消息给old MME，因为old MME可以做完整性检查。 在这篇文档中，假设在old MME上完整性检查通过了。new MME在从old MME获得包括IMSI的上下文后，执行位置更新和EPS会话建立过程。如果在old MME上完整性保护失败，old MME将给new MME发送error消息，接着UE获得IMSI并执行用户鉴权，NAS安全建立，位置更新和EPS会话建立过程。 图5描述了UE在city2的new MME上执行初始附着的过程。 1）【UE，eNB】建立RRC连接一旦进入city2，UE检测到LTE信号，选择一个新的小区，并向eNB请求RRC连接。 2）【UE，new MME】使用old GUTI向new MME请求初始附着UE向MME2发送attach request消息 (Old GUTI, Last Visited TAI, KSIASME, NAS-MAC)，使用oldMME分配的old GUTI作为UE ID。这个罅隙是使用Knasint完整性保护的，通过在无线接口上的RRC connection setup complete消息发送，并在S1接口上的initial ＵＥmessage消息发送。 3）【new MME】标识old MMEMME2通过接收到的initial UE message消息检查UE的位置，并从old GUTI中知道它是由old MME1分配的。接着MME2检查在S10接口上和MME1使用old GUTI是否有效，并获得存储在MME1中的UE上下文。 4）~6）【old MME，new MME】从old MME中获得UE上下文4）new MME（MME2）把接收到的attach request消息和old GUTI包裹在identification request消息(Old GUTI, Complete {Attach Request} message from UE)中发送给old MME（MME1）。 5）当接收到new MME的这个消息，oldMME知道这个GUTI是自己分配的，接着通过保留的UE安全上下文对UE发送的attach消息执行完整性检查，完整性检查通过。 6）完整性保护成功后，old MME给new MME通过identification response消息(IMSI, UE-AMBR, UE Security Context (KASME, KSIASME, Unused AVs, NAS Keys, etc))发送无上下文。new MME获得UE上下文。 7）~10）【old MME，new MME，HSS】在new MME更新位置信息，并在old MME中删除7）MME2现在具有了有效的UE上下文，给HSS发送update location request消息(IMSI, MME ID=MME2)来在MME2上注册UE。通过这种方式，MME2给hss通知包含IMSI的UE已经注册上MME2了。hss更新UE新的位置。 8）hss给MME1发送 cancel location request（IMSI）消息来要求MME1删除UE上下文，MME应要求删除UE上下文。 9）MME1通过发送cancel location response（IMSI）消息给hss通知UE上下文已经删除了。 10)HSS通过发送update location answer(IMSI, APN, Subscribed Profile (QCI, ARP, APNAMBR (UL/DL), UE-AMBR (UL/DL))给MME2提供UE的签约配置信息，包括签约QoS信息。所以MME2可以建立EPS会话了。 11）【new MME】建立EPS会话MME2通过使用从MME1接收到的UE上下文和从hss获得签约配置文件建立EPS会话。这个过程和之前文档中叙述的EPS会话建立过程一样。 IV. EPS Entity Information在EMM case10移动到另外一个城市过程的前后EPS实体信息的变化如下所示： before 如果UE在connected状态，保持和初始附着过程后存储的信息一样。 如果UE在idle状态，保持和S1释放过程后存储的信息一样。 after UE从网络detach。EPS实体中存储的信息和detach过程后存储的信息一样。 在EMM case11在另外一个城市初始附着前后EPS实体信息的变化如下所示： before：UE从网络detach，和detach过程后存储的信息一样。 after：UEattach到网络，存储的信息和初始附着过程后的信息一样。 V. Closing这篇文档讨论了UE移出LTE覆盖范围之外，UE怎么和新的MME建立初始附着的。这个场景的目的是介绍使用old GUTI初始附着的过程。所以实际移动到另外一个城市的过程将根据不同运营商怎么配置网络和对网络节点的实现。韩国的LTE网络时全国的，所以LTE服务是任何地方可用的。所以LTE覆盖空洞可以在低无线质量的地方找到。实际中，LTE有邻区，LTE or 2/3G。实体网络中，UE执行切换到邻区或者小区重选而不是从网络detach。 References[1] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[2] Netmanias Technical Document, “LTE EMM Procedure 2. Detach”, January 2014,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6108[3] Netmanias Technical Document, “LTE EMM Procedure 1. Initial Attach – Part 2. Call Flow of InitialAttach”, January 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6102[4] 3GPP TS 36.413, “Evolved Universal Terrestrial Radio Access Network (E-UTRAN); S1 ApplicationProtocol (S1AP)”.[5] Netmanias Technical Document, “LTE EMM Procedure 5. Periodic TAU”, February 2014,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6193[6] Netmanias Technical Document, “LTE EMM Procedure 1. Initial Attach – Part 1. Cases of InitialAttach”, December 2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6098[7] Netmanias Technical Document, “LTE Identification II: NE and Location Identifiers”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5906[8] 3GPP TS 23.401, “General Packet Radio Service (GPRS) enhancements for Evolved UniversalTerrestrial Radio Access Network (E-UTRAN) access”.[9] Netmanias Technical Document, “LTE EMM Procedure 3. S1 Release”, January 2014,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6110[10] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20-EMM Procedure 8&9. Handover & Cell Reselection with TAU]]></title>
    <url>%2F2016%2F04%2F03%2F20-EMM-Procedure-8-9-Handover-Cell-Reselection-with-TAU%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6324 I. Introduction当UE接入网络时，MME通过TAI列表分配一组TA。UE在这些TA中移动不需要给网络报告自己的位置。网络不知道UE驻留在哪个小区，但是知道在哪个TA。所以如果idle状态的UE有电话或者数据包到达，网络在UE注册的这些TA中发起寻呼。分配给UE的TAI列表是UE已经注册的区域列表。当UE移动到不在TAI列表中的TA时，UE必须执行TAU过程来请求TA更新，网络就可以更新UE的TAI列表并分配更新过的列表。 这篇文档描述的是UE移动到没有注册过的TA时的过程（EMM case-8）。在这个case-8中，在连接模式(EMM-Registered, ECM-Connected, RRC-Connected)的UE移动到另外一个TA。在这个移动过程中，从source eNB到target eNB的切换过程如EMM case-6一样。不同的地方在于，UE接着需要在target eNB的新小区上执行TAU过程。在idle模式(EMM-Registered, ECM-Idle, RRC-Idle)状态下的UE移动到另外一个TA时，服务小区重选的过程和EMM case-7一样。不同的是，在小区重选后，必须在UE新驻留的小区上进行TAU过程。 这个文档组织如下：第二章解释EMM case-8过程，第三章描述EMM case-9过程，在第四章我们学习在这些过程前后EPS实体的信息有什么不同。 II. EMM case 8. handover with TAU图1展示了连接模式下的UE移动到没有注册过程的TA时执行的过程。当UE初始附着到网络，MME为UE选择TA1和TA2，并在attach accept消息中包含TAI列表={TAI1=1,TAI=2}。UE通过eNB2 cell5获得服务。现在移动到TA3 eNB5 cell13。这里我们假设eNB2和eNB5连接到同一个MME和SGW。 handover在上图中，随着UE移动到eNB5，handover事件触发。UE测量服务小区和邻区的信号强度，并把结果发送给eNB2，包含在measurement report消息中。首先source eNB选择切换的类型 X2 or S1.在X2切换中，是source eNB选择target eNB，而在S1切换中是MME选择target eNB。接着切换在eNB2和eNB5之间执行。 TAU1）【UE-&gt;MME】TAU request当切换到target eNB时，UE知道eNB5不属于MME分配的TAs，接着只要切换一完成，UE就发送TAU request消息(Update Type=TA Updating, GUTI, Last Visited TAI, KSI ASME, NAS-MAC)给MME，请求TA更新。这时，这个消息包含如下信息：TAU Request (Update Type=TA Updating, GUTI, Last Visited TAI, KSI ASME, NAS-MAC) Update Type: indicates the TAU type. Set as TA Updating unless UE is handed over to a registered TA GUTI: UE ID previously allocated by MME. Used by MME for UE identification. Last Visited TAI: TAI reported through TAU Request last time KSIASME: index for KASME, the NAS security base key NAS-MAC: message authentication code used in protecting the integrity of TAU Request with NAS integrity Key (KNASint). TAU消息通过UL information transfer消息从 UE发送到eNB，通过uplink NAS transfer消息(NAS-PDU (TAU Request), ECGI, TAI)从eNB发送到MME。uplink NAS transfer消息包含TAU请求消息和当前小区的ECGI和TAI发送给MME。因为UE和MME之间的NAS安全上下文已经建立起来了，TAU request消息是使用NAS完成性保护秘钥完保的。如果MME对接收到的TAUrequest消息完成性保护检查失败，MME执行用户鉴权和NAS安全建立过程。在这个文档中，我们仅仅讨论MME成功完成完整性检查。 2）【MME】TA 更新：分配新TA因为UE移动到没有注册过的TA上，MME选择一组TA分配给UE，并为UE配置一个新的TAI列表。这是，也要分配一个新的GUTI。 3）【UE&lt;-MME】TAU acceptMME发送新选择的TA包含在TAU accept消息中(GUTI, TAI List)。这个消息是加密和完成性保护的，通过downlink NAS transfer消息从MME到eNB传输，接着通过DL information transfer消息从eNB传输给UE。 4）【UE-&gt;MME】TAU complete如果分配了一个新的GUTI，UE给MME发送TAU complete消息来确认收到了新的GUTI。 一旦TAU过程完成，UE现在具有了一个新的TAI列表，并通过eNB5获得服务。 III. EMM case 9. cell reselection with TAU图2显示了idle模式下的UE移动到一个没有注册的TA时需要的小区重选过程。在图中，UE驻留在eNB2的cell5,移动到eNB5的cell13。 cell reselection1）~7）【UE】小区重选UE移动eNB5触发小区重选。UE测量邻区并排序，基于结果，选择满足消息重选准则的eNB5 cell13作为最合适的小区。这里的小区重选过程和之前文档介绍的一样。 TAU当选择了eNB5 cell13，UE知道这个小区不属于之前分配TA中。所以，UE一旦完成重选过程就执行TAU过程。TAU过程和之前的描述的EMM case-5一样。不同之处在于谁发起的TAU过程。对于周期性TAU过程，UE因为TAU定时器T3412的超时执行TAU给网络报告当前位置。然而，对于上面给到的TAU，则是因为UE移动到一个没有注册的TA时UE执行TAU。所以这是TAU request消息的TA更新类型是TA updating而不是periodic updating。TAU过程简要叙述如下： 8）【UE-&gt;MME】TAU requestUE通过发送TAU request消息(Update Type=TA Updating, GUTI, Last Visited TAI, KSIASME, NAS-MAC)给MME来请求TA更新。这个TAU request消息和第二章包含相同的信息。这个消息也是使用NAS完整性秘钥完保的。UE和eNB建立RRC连接，并发送这个消息，接着从idle 状态转到connected状态。 9）【MME】TA update：分配新的TA一旦通过uplink NAS transfer消息接收到TAU request消息，MME从uplink NAS transfer消息中的TAI标记处UE当前驻留的哪个TA，并在TAU request消息包含的last visited TAI知道上次报告的TA。因为UE当期驻留的TA不是之前MME分配的TA，MME允许新分配一个TA集合最适合UE当前位置和速度。对于快速移动的UE，分配大范围的TA来减少由TAU引起的信令负载。当时，这样，由寻呼引起的心灵负载就会增加。寻呼消息将需要更长时间。所以为了每一个UE分配不同TAI，在TAU信令和寻呼性能之间的权衡应该考虑。MME更新last visited TAI包含在和UE当前TAI的UE上下文中。 10）【MME，SGW，PGW，PCRF】EPS承载/会话修改一旦UE位置改变，MME通过发送modify bearer request消息通过SGW这个变化。是否需要MME给PCRF报告TA的变化，包含UE初始附着建立EPS会话时从PCRF接收到的change report action参数中。会话修改构成执行，报告给PCRF TA的改变。 11）【UE&lt;-MME】TAU acceptMME通过tau accept消息给UE发送新的TAI列表。这是，这个消息和第二章包含相同的信息。并且也是完整性保护和加密的。 12）~14）【UE，eNB，MME】转移到idle状态在TAU过程之后，MME释放S1连接，接着释放eNB5和MME之间的S1信令连接、eNB5释放和UE之间的RRc连接。现在UE和MME之间的ECM连接都移除了。并返回到idle摸下。 15）【UE】驻留在cell13一旦返回到idle状态，UE驻留在cell13，现在，在每一个DRx周期结尾处UE醒来测量cell13的信号。 IV. EPS实体信息handover with TAU过程前后存储在EPS实体中的信息和handover without TAU的一样。只有TAI的信息由于TA更新发生了变化。cell reselection with TAU过程前后存储在EPS实体中的信息和cell reselection without TAU一样。只有TAI的信息由于TA更新发生了变化。 V. closing我们到目前为止讨论了UE移动到一个在注册TA中的切换和小区重选过程。我们学习到通过切换或者小区重选过程，UE通过TAU过程获得了新的TAI列表。下面的文档将讨论UE移动到另外一个城市，包含从城市1detach，在城市2 attach。 References[1] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[2] Netmanias Technical Document, “LTE EMM Procedure 6. Handover without TAU – Part 1. Overview ofHandover”, March 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6224[3] Netmanias Technical Document, “LTE EMM Procedure 6. Handover without TAU – Part 2. X2Handover”, March 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6257[4] Netmanias Technical Document, LTE EMM Procedure 6. Handover without TAU – Part 3. S1Handover”, April 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6286[5] Netmanias Technical Document, “LTE EMM Procedure 7. Cell Reselection without TAU”, April 2014,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6322[6] Netmanias Technical Document, “LTE EMM Procedure 1. Initial Attach – Part 2. Call Flow of InitialAttach” , January 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6102[7] Netmanias Technical Document, “LTE EMM Procedure 5. Periodic TAU”, February 2014,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6193[8] Netmanias Technical Document, “LTE EMM Procedure 3. S1 Release”, January 2014,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6110[9] Netmanias Technical Document, “LTE EMM Procedure 10 &amp;11. Move to Another City and Attach”,May 2014, TBD[10] 3GPP TS 23.401, “General Packet Radio Service (GPRS) enhancements for Evolved UniversalTerrestrial Radio Access Network (E-UTRAN) access”[11] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19-EMM Procedure 7. Cell Reselection without TAU]]></title>
    <url>%2F2016%2F04%2F03%2F19-EMM-Procedure-7-Cell-Reselection-without-TAU%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6322 I. Introduction通过前面三篇文档，我们学习了EMM case-6 handover without TAU。这篇文档我们描述在idle模式下的UE是怎么重选小区的。切换控制的是连接态的UE的移动性，小区重选是控制idle状态下UE的移动性。在切换时，是网络决定要切换到哪个小区，在小区重选中，是UE决定驻留在哪个小区。 小区重选过程可能是图1中的两种类型之一。在图1中UE驻留在cell-5，属于MME分配的{TA1，TA2}这个TA列表里，并处于idle状态。 cell reselection without TAU（7）：UE移动到TA列表中的一个TA时，例如图1的TA2，执行小区重选但是不执行TAU。 cell reselection with TAU（9）：UE移动到不属于TA列表中的一个TA时，例如图1的TA3，在小区重选后，需要执行TAU。 UE可能重选到一个小区i）和当前驻留的服务小区使用相同的LTE频率，ii）和当前小区不使用相同的频率，iii）使用另外的RAI接入（inter-RAT）。在图1中小区重选的实例中，我们只讨论intra-frequency小区重选，即使用同单一LTE频率。这篇文档只描述case-7的情况。case-9的情况在下面的文档中叙述。在第二章，我们将描述小区重选过程需要的准备信息。第三章描述不带TA过程的小区重选的详细过程。 根据之前的LTE文档，当UE在attach完成后处于idle模式下（EMM-Registered, ECM-Idle, RRCIdle）: UE IP地址保持有效，在EPC中EPC承载保持有效。 EPC（MME）知道UE的存在，但是E-UTRAN不知道。 UE是在TA级别被MME知道的 当UE移动到不在TA列表的TA时执行TAU过程，并给MME通知自己的TA位置。 UE cannot send it generates？？？？？ 如果有发往UE的数据，MME在UE所在的整个TA区域内寻呼。 UE周期性的唤醒并检查是否有寻呼消息。 当驻留在一个小区上，UE在idle状态： 接收eNB广播的系统消息 接收寻呼信号，并对paging消息响应 周期性的测量服务小区的信号强度 当小区重选触发时测量邻区的信号强度并重选到一个小区 如果重选到一个不在TA列表中的TA时发起TAU过程。 II. Cell Reselection: Required System Information and Criteria在我们详细学习第三章的小区重选过程之前，我们先简要介绍一下小区重选。接着我们学习这个过程需要的系统信息和小区重选的准则。 2.1 小区重选过程概述UE控制小区重选过程。UE从eNB广播的系统消息中获得小区重选相关的信息（决定是否测量邻区信号强度的门限值，计算服务小区和邻区的排行的参数）。在intra-frequency小区重选中，需要的信息包含在SIB3和SIB4中。 小区重选触发服务小区测量：idle状态的UE在每一个DRX周期的结尾处醒来测量服务小区的信号（Qrxlevmeas）并计算服务小区的接收信号水平（Srxlev）来决定是否待在这个当前小区还是移动到另外的小区。这里，UE的发射和接收条件都反映在计算中，例如通过应用最小接收信号水平（Qrxlevmin）允许最大发射功率水平Pemax等等。小区重选触发：如果服务小区的接收信号水平（Srxlev）比指定的门限值（s-IntraSearch）搞，UE待在当前的服务小区。如果不是，UE触发小区切换过程。这个门限值通过SIB3传输作为触发判决条，在rel-8中定义为s-IntraSearch，在rel-9中定义为s-IntraSearchP和s-IntraSearchQ。 当UE处于相同的位置，在idle状态的UE在每一个DRX周期结尾醒来去测量服务小区的接收信号水平，我们假设UE驻留在相同的服务小区，因为这个小区的接收信号水平比设定的门限s-IntraSearch持续的低。如果UE离开这个服务小区，这个小区的接收信号水平就会很快的降低，最终，当接收信号水平低于门限s-IntraSearch时，触发小区重选过程。接着UE开始测量邻区的信号强度。 小区重选准则小区排序准则：UE基于服务小区(Qmeas,s)和邻区(Qmeas,n)测量信号强度来对每一个小区排序(Rs, Rn)。小区排序需要的参数从SIB3和SIB4接收。服务小区使用SIB3中的q-Hyst这个迟滞值来排序，而邻区使用SIB4中的q-OffsetCell这个偏移值进行排序。小区重选：一旦服务小区和邻区排序，UE检查小区重选准则是否满足(Rn &gt; Rs)。如果邻区满足这个准则，UE选择最好的满意小区，接着驻留在那里。小区重选仅仅在(t-ReselectionEUTRA)时间内持续满足才会执行。 移动运营商会阻止太频繁的小区重选，通过这个迟滞值和小区特定偏移值可以通知UE在服务小区的驻留时间，根据这个小区状态来执行重选。另外，他们也会控制 q-Hyst and t-ReselectionEUTRA通过根据UE的移动速度来使用合适的(q-hystSF, t-ReselectionEUTRA-SF)。 2.2 系统信息系统信息是由eNB广播的信息，包括MIB和SIB。MIB，SIB1和SIB2是必须的，其他的是可选的。所有的系统信息像MIB SIB1或系统信息都是通过RRC消息传送给UE的。一个系统信息包括一组SIB（SIB2-16），除了MIB和SIB1。 UE基于eNB广播的系统消息来执行小区重选的。MIB SIB1 SIB2是适用于所有的UE，不论是connected模式还是idle模式下。相反的，SIB3-8仅仅只用于idle模式下的小区重选。表1描述了不同的系统信息和他们的参数。 我们假设两个移动运营商A和B，他们的网络工作如下：A：全国的LTE-only网络 LTE 频率：在1.8GHz仅仅有10MHz的一个信道(lteFA1)B：有全国的3G和LTE网络 3G频率：2.1GHz上的5MHz的六个信道 LTE频率：1.8GHz上的10MHz的一个信道，850MHz上的10MHz的另一个信道(lteFA1, lteFA2) 对于运营商A，它的eNB需要小区重选的intra-frequency相关的信息（eNB广播SIB3，SIB4，但是不广播SIB5/6/7/8）另外，对于运营商B，它需要所有的三种类型的重选信息，intra-frequency，inter-frequency，inter-RAT相关的信息（eNB广播SIB3/4/5/6） 由eNB广播的系统是通常应用于所有的UE，但是每一个根据自己的能力（release9 UE还是release11UE）来接收不同类型的系统信息。 图1描述了UE驻留在eNB2下的cell-5和它的邻区，图2只显示了eNB。 在图1中的网络时LTE-only网络，使用但是home PLMN的单一频率(lteFA1)。这篇文档只关心intra-frequency的小区重选过程。和intra-frequency重选相关的系统信息是通过SIB3和SIB4广播的。表2描述了这两个SIB的参数，但是他们和其他频率，RAT，VPLMN无关。 2.3 小区重选准则尽管不在本篇文档范围内，下面我们将简要看下在UE开机后小区重选使用的准则。下面只适用一个准则。表3提供了这个准则中参数的详细描述。 在初始小区选择是，小区接收限号水平(Srxlev)必须比Qrxlevmin和PCompensation的和要大。Srxlev要比Qrxlevmin要大，因为为了使UE正确的接收服务小区的信息，测量的信号强度必须至少大于Qrxlevmin。UE的发射功率低于UE在小区中允许的最大值Pmax将导致P-Compensation变大，使得更难选择这个小区。当选择一个小区时，UE的发射和接收条件是在考虑范围的。 在release9的情况下，增加量Squal作为小区选择准则。Qrxlevmeas是小区参考信号接收功率RSRP，而Qqualmeas是小区的参数信号接收质量RSRQ。RSRP只是接收信号的强度，而RSRQ提供关于无线链路质量更准确的信息，因为它指示信号和干扰噪声比，SINR。 小区重选触发UE一旦驻留在服务小区将一直驻留在那儿，如果服务小区的接收水平满足2-1或者2-2，UE将不需要进行测量。 在上述的不等式中，SintraSearch, SintraSearchP and SintraSearchQ是通过SIB3给出的，如果服务小区不满足前面的准则，即是它满足3-1或者3-2准则，UE开始为了小区重选进行小区测量。小区重选准则小区排序准则如果服务小区的测量Srxlev满足3-1或者3-2，UE开始测量邻区的RSRP，基于测量的结果，UE会应用4-1或者4-2进行排序。 小区重选如果有多个小区满足下面的准则，UE会选择最好的小区，并驻留在上面。 像在之前4=1或者4-2看到的，Rs和Rn是使用不同的准则进行计算的。Qhyst and Qoffset这两个值越大，UE停留在服务小区的时间越长。 III. procedure for cell reselection without TAU图3描述了EMM case-7，在图1中，UE选择cell-5满足1-1或者1-2，在通过cell-5初始附着到网络后由MME分配了一个TA列表{TA1, TA2}。接着在cell-5被服务，转移到idle状态，并一直驻留在cell-5。图3描述了驻留在cell-5上的UE怎么执行intra-frequency小区重选转移到eNB4下的cell-10的。这里UE的移动性状态为normal，所以不考虑比例因子。需要测量邻区4/6/10/13，但是图3为了描述的方便仅仅显示了cell-10和cell-13。第三章我们将详细秒后苏intra-frequency小区重选过程。必须满足一下条件。 驻留在服务小区：UE驻留在cell-5 小区重选触发：因为UE移出服务小区，小区重选触发。1、服务小区测量：服务小区的测量决定是否测量邻区，2、邻区测量：为了小区重选要测量邻区。 小区重选准则：1，小区排序：小区基于服务小区和邻区的测量结果来进行排序，2，小区重选：识别出满足准则的小区，并选择最好的。 驻留在新的小区，UE驻留在cell-10. 1）【UE】UE驻留在服务小区UE驻留在哎服务小区并保持idle状态 2）【UE】从服务小区获得系统信息UE从服务小区获得关于小区重选的系统信息。如果每一个邻区和服务小区由不同的偏移值，服务小区通过SIB4提供给UE邻区列表。接着UE通过SIB3和SIB4获得下面的信息： 决定小区重选触发需要的参数：q-RxLevMin, p-Max, sIntraSearchP, s-IntraSearchQ, t-ReselectionEUTRA, q-QualMin (SIB 3) 服务小区排序需要的参数：q-Hyst (SIB 3) 邻区排序需要的参数：q-OffsetCell (SIB 4) 3）【UE】测量服务小区的信号强度在每一个DRX周期结尾处，UE醒来并测量服务小区的信号(RSRP and RSRQ)获得Qrxlevmeas and Qqualmeas。接着，基于他们，计算出小区重选接收水平Srxlev和小区重选质量水平Squal。UE通过应用3-1或者3-2，检查UE应该重选到那个小区或者继续驻留在当前小区。例如，如果Srxlev和Squal不满足准则，UE继续驻留在当前小区，否则，执行下一步。 4）【UE】测量邻区UE测量具有和当前服务小区相同频率的邻区的RSRP。 5）【UE】小区排序准则一旦测量完RSRP，UE对服务小区和邻区进行排序，服务小区的排序R5，邻区的排序R4/6/10/12分别基于4-1和4-2。 6）【UE】小区排序比较现在UE比较R5和Rn，检测准则5是否满足。如果每一个小区满足5，UE继续驻留在cell5，在途中，cell10和cell13满足准则。 7）【UE】选择一个新小区UE比较两个满足准则的小区，R10和R13，并选择最好的一个R10作为新的服务小区。 8）【UE】驻留在新的小区上UE驻留在cell10上，在接收cell10广播的SIB1后，UE知道cell10所在的TA在TAI列表中。因为这个新的服务小区主语UE注册过的TA列表，不需要执行TAU过程。接着，UE在每一个DRX周期结尾处醒来监控cell10的系统信息和寻呼信息，并测量cell10的信号。 IV. EPS Entity Information: Before/After Cell Reselection without TAU这章描述在小区重选过程前后EPS实体信息的变化情况。在重选过程前后UE在idle状态下，MME也保持在idle状态下。UE从cell5移动到cell10，没有执行TAU过程。在小区重选后，EPS实体中的信息保持不变，和在S1释放后保持的信息相同。如图4所示。 V. Closing我们学习了UE在idle状态下移动到UE注册过的TA中，并在不执行TAU的情况下进行小区重选过程。这个文旦仅仅描述了intra-frequency过程。多数的移动运营商有多个LTE频点。他们也可以和2/3G进行互操作，所以不仅仅有intra-frequency小区重选，而且还有inter-frenqucy和inter-RAT小区重选。在接下来的文档中，我们将讨论执行TAU的小区重选过程。 References[1] Netmanias Technical Document, “LTE EMM Procedure 6. Handover without TAU – Part 1. Overview of Handover”, March 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6224[2] Netmanias Technical Document, “LTE EMM Procedure 6. Handover without TAU – Part 2. X2 Handover”, March 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6257[3] Netmanias Technical Document, “LTE EMM Procedure 6. Handover without TAU – Part 3. S1 Handover”, March 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6286[4] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[5] 3GPP TS 36.304, “Evolved Universal Terrestrial Radio Access (E-UTRA); User Equipment (UE) Procedures in Idle Mode”[6] Netmanias Technical Document, “LTE EMM Procedure 8 &amp; 9. Handover and Cell Reselection with TAU”, 2014, TBD[7] Netmanias Technical Document, “LTE EMM and ECM States”, September 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5909[8] 3GPP TS 36.331, “Evolved Universal Terrestrial Radio Access (E-UTRA); Radio Resource Control (RRC); Protocol Specification”[9] 3GPP TS 36.101, “Evolved Universal Terrestrial Radio Access (E-UTRA); User Equipment (UE) Radio Transmission and Reception”[10] Netmanias Technical Document, “LTE EMM Procedure 3. S1 Release”, January 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6110[11] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18-EMM Procedure 6. Handover without TAU - Part 3. S1 Handover]]></title>
    <url>%2F2016%2F04%2F03%2F18-EMM-Procedure-6-Handover-without-TAU-Part-3-S1-Handover%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6286 I. Introduction之前的文档，我们讨论了X2切换，这篇文档我们关注在EPC干预下的S1切换。这里，我们假设source和target eNB连接在同一个MME/SGW，并且位于UE的TAI列表中的同一个TA下。第二章我们描述S1切换的概念，第三章我们详细描述S1切换，最后第四章我们总结在S1切换前后EPS实体信息的变化。 II. Concept of S1 Handover2.1 S1协议栈S1切换是通过S1接口source和target eNB之间执行的。在控制面eNB和MME通过S1AP信令通信，在用户面eNB和SGW通过GTP隧道通信。图1显示控制面和用户的S1接口上的协议栈。 当安装一个新eNB时，就需要在eNB和MME之间执行S1 setup过程。eNB通过发送S1 setup request(eNB ID, eNB Name,TAC)给MME通知eNB配置信息。在MME中也会使用相应的 MME容量参数 用于MME间的负载均衡。这个值被标记为权值，表示每一个MME处理UE连接的相对容量。eNB连接不止一个MME，当选择一个MME建立新的UE连接时使用这个值。eNB和EPC之间的UE连接如下：在控制面，eNB和MME之间每一个用户的信令都是通过S1AP信令连接提供的，并使用{eNB UES1AP ID, MME UE S1AP ID}标识，在用户面，eNB和SGW之间的每一个用户的S1承载都是通过GTP隧道来提供，并使用{DL S1 TEID (S1 eNB TEID), UL S1 TEID (S1 SGW TEID)}标识。 2.2 和切换相关的S1AP过程和消息表1和2是在GPP TS 36.413中S1AP的基本过程，包含non-UE和UE相关的过程。这个文档是和切换相关的，所以这里只讨论UE相关的过程。表1列出了S1切换相关的S1AP过程和他们相关的S1AP消息。 列在上表中的这些S1AP消息在下面详细介绍： Handover Required message : 这个消息用于切换准备阶段，由eNB发送给MME，包含target eNB的信息和source cell的无线资源。 Handover Request message : 这个消息在切换准备阶段使用，由MME发送到target eNB，包含UE上下文信息。 Handover Request Acknowledge message : 这个消息是在切换准备阶段使用的，它是当在target eNB中成功为UE分配资源时由target eNB发送给MME。target eNB分配DL S1 TEID供S1承载在切换后使用，并分配DL S1 TEID供S1承载(indirect tunnel)用于在切换时下行数据包的传送，包含在这个消息中转发他们。 handover command message ：这个消息用于切换准备阶段，是由MME发送给source eNB。它包含了UE接入target eNB需要的信息（e.g. Target C-RNTI, Target eNB AS Security algorithm, DRB ID, etc.），并包含UL S1 TEID供SGW在切换时用于下行数据包传送。 eNB status transfer message ：这个消息是在切换执行阶段使用，由source eNB发送给MME。指示target eNB应该从哪个数据包开始接收或者发送。 MME Status Transfer message : 这个消息是在切换执行阶段使用，是由MME发送给target eNB。指示target eNB应该从哪个数据包开始接收或者发送。 Handover Notify message : 这个消息在切换完成阶段使用，是由target eNB发送给MME，指示UE已经完成到target eNB的切换。 UE Context Release Command message : 这个消息用在切换完成阶段，是由MME发送给source eNB请求UE上下文的释放。 UE Context Release Complete message : 这个消息是在切换完成阶段使用，是由source eNB发送给MME指示UE上下文已经释放了。 2.3 S1 Handover Procedure at a Glance像之前文档看到的，S1切换过程包括准备，执行，完成阶段。在我们详细介绍之前，我们简要预览一下S1切换过程。 图2描述了在切换前/中/后需要的过程。方便起见，SGW和PGW被标记为SAE-GW，source和target eNB被标记为SeNB和TeNB。 before S1 handover在上图中，UE是通过eNB A获得服务的。当UE检测到测量事件时，UE发送measurement report 给eNB A。 S1 handover preparationsource eNB基于自己保留的邻区列表信息和在measurement report 消息中包含的邻区信号强度信息选择target eNB作为切换目的地。接着，source eNB意识到通过X2连接切换到target eNB是不可能的，所以决定执行S1切换，并通过MME执行。所有的eNB都是通过S1AP信令和MME通信。这时，target eNB提前分配资源来确保source eNB提供的服务在target eNB同样可用。MME提供给source eNB所有的UE接入target cell需要的所有信息。 期间，target eNB和SGW分配创建indirect tunnel需要的资源，通过这个indirect tunnel，到达source eNB的下行数据转发给SGW，最终发送给target eNB。如下所示： source eNB发送target eNB所需要的信息给MME， 包含在handover required消息中。（1） MME发送handover request消息给target eNB，包含target eNB需要的AS安全信息来创建AS安全基础秘钥和UE上下文。 target eNB（2） 使用从MME获得的S1 S-GW TEID建立上行S1承载，通过这个承载在切换后可以转发上行数据包。并为下行S1承载分配S1 target eNB TEID。（3） 为连接SGW和target eNB的indirect tunnel分配S1 target eNB TEID。 配置handover command消息，包含UE接入target cell所需要的所有的信息。 把这些信息包含在handover request ack发送给MME。（4） MME一旦接收到这个消息，在create indirect data forwarding tunnel request消息中包含target eNB为indirect tunnel分配的S1 target eNB TEID，并把这个消息发送给SGW。（5） SGW 创建indirect tunnel连接target eNB（6） 分配S1 S-GW TEID用于source eNB和SGW之间的indirect tunnel的创建，并通过Create Indirect Data Forwarding Tunnel Response消息发送给MME。 MME包含i）SGW为indirect tunnel分配的S1 S-GW TEID，ii）包含UE接入target cell所需的信息，包含在handover command消息发送给source eNB。 接着，source eNB创建连接SGW的indirect tunnel。 通过第8和第6步，连接source eNB，SGW，target eNB三个实体的indirect tunnel创建成功了。 S1 handover execution现在两个eNB准备好切换了，是时候命令UE执行了。 source eNB 通过发送handover command消息包含UE接入target cell需要的信息命令UE执行切换到target cell（1） 发送eNB status transfer消息通知MME，eNB应该从哪个上行/下行数据包开始接收/发送。（2） 通过indirect tunnel发送从SGW接收到的下行数据包给target eNB。（4） MME通过发送MME status transfer消息通知target eNB，它应该从哪个UL/DL数据包开始发送/接收。（3） UE从source eNB断开，接入到target eNB。（5） 一旦UE成功接入target eNB，UE就立即有能力发送或接收数据包了。（6） S1 handover completion因为MME已经知道UE执行切换，不像X2切换，target eNB不需要MME进行路径修改。一旦UE连接到target eNB，target eNB给MME发送handover notify消息指示UE已经完成切换。 一旦UE连接，target eNB给MME发送handover notify通知切换完成（1） 接着MME请求SGW做S1承载修改。SGW修改下行S1承载路径连接target eNB。（2）（3） SGW改变承载路径：如下 SGW通过连接source eNB的下行S1承载发送end marker（EM）停止下行数据包传输。 接着SGW创建连接target eNB的下行S1承载，并恢复下行数据包传输给target eNB。 target eNB给UE发送下行数据包如下： target eNB在EM标记数据包到达之前通过indirect tunnel发送下行数据包 一旦EM标记数据包到达，target eNB通过新路径给UE发送数据包。 MME： MME通过发送UE context release command消息请求source eNB释放S1承载资源和UE上下文。（4） MME通过发送delete indirect data forwarding tunnel request消息通过SGW释放和indirect tunnel相关的资源。（5） after S1 handoverUE现在可以通过eNB B提供服务。 2.4 在S1切换前后UE状态和连接信息图3描述了在S1切换前后控制面用户面的连接建立情况，和UE/MME的状态。 before S1 handoverUE在EMM-REgistered和ECM/RRC-connected状态，并保持着E-UTRAN和EPC分配的所有资源。 during S1 handover即使在切换阶段，NAS层的UE状态一直保持不变。source eNB和target eNB都通过S1信令连接到MME上。他们也通过indirect tunnel连接到SGW上。在图3中，step-2展示了在切换执行阶段切换中断时的连接和状态。在这个阶段，没有激活的无线连接，但是UE仍保持连接状态。 after S1 handoverUE保持在EMM-REgistered和ECM/RRC-connected状态。在用户面，E_RAB（DRB+S1承载）转到连接新eNB的路径上，在控制面建立了新的RRC连接。 III. Procedure of S1 Handover现在我们详细介绍S1切换过程。图4描述了在S1切换之前的EPS承载和信令连接，并包括S1切换准备阶段详细过程。 before handover 1）【UE-&gt;eNB】measurement report一旦测量事件触发，UE测量邻区的信号强度，并给服务小区发送measurement report 消息。 handover preparation 2）【source eNB】handover decisionsource eNB根据measurement report消息包含的信息和source eNB自己保留的邻区列表信息中选择target eNB。并且发现在两个eNB之间没有有效X2连接可用，source eNB决定执行S1切换。 3）【source eNB-&gt;MME】 requesting handoversource eNB发送handover required消息给MME，请求切换到target eNB。这个消息包含如下：Handover Required (Handover Type, Target eNB ID, Source to Target Transparent Container) Handover Required (Handover Type, Target eNB ID, Source to Target Transparent Container) Target eNB ID: 包含Target Global eNB ID and Selected TAI information Source to Target Transparent Container: is used when forwarding the radio-related information of the source cell to the target cell transparently through EPC (MME) 4) [MME] 产生安全上下文转发给target eNBMME生成安全上下文{NCC,NH}, target eNB可用产生AS安全基础秘钥。NCC从初始NCC值开始加1，NH是从初始NH值和Kasme值产生的。 5）【target eNB &lt;-MME】请求target eNB切换MME给target eNB发送handover request消息，代表 source eNB请求切换。这个消息如下：Handover Request (UE-AMBR, E-RAB to be setup (E-RAB ID, QCI, ARP, S1 S-GW TEID), Source to Target Transparent Container, UE Security Capability, Security Context) Handover Request (UE-AMBR, E-RAB to be setup (E-RAB ID, QCI, ARP, S1 S-GW TEID), Source to TargetTransparent Container, UE Security Capability, Security Context) E-RAB to be setup: UE’s E-RAB information stored at Source eNB. Includes E-RAB ID, QoS parameters, UL S1 bearer information Source to Target Transparent Container: is used when forwarding the radio-related information of the source cell (e.g. UE radio access capability, RRC configuration Info, etc.) to the target cell transparently through EPC (MME). UE Security Capability: security algorithms supported by UE (encryption and integrity algorithm) Security Context: includes {NCC, NH} to be used when Target eNB derives the AS Security base key, KeNB* 6) [Target eNB] 准备S1 handover一旦接收到handover request消息，target eNB开始准备切换为UE提供无缝服务 i)新的S1承载资源分配 ：target eNB基于要建立的E-RAB信息，检查source eNB提供的QoS是否在target eNB中可用。如果可用，target eNB使用存储在source eNB中的上行S1承载信息（S1 SGW TEID）建立上行S1承载连接SGW。接着分配S1 target eNB TEID准备下行S1承载。 ii）indirect tunnel资源分配 ：在UE执行S1切换时，应该有一个从source eNB到target eNB的indirect tunnel。所以，target eNB分配S1 target eNB TEID，SGW可以建立indirect tunnel连接target eNB。 iii）为UE在无线链路上分配资源 ：基于E-RAB的QoS信息，target eNB为UE在无线链路上保留RRC资源，并分配C-RNTI。 iv）Kenb*产生 ：使用从MME中接收到的安全上下文信息（NCC1，NH1）来产生Kenb，接着获得AS安全秘钥(KRRCint, KRRCenc, KUpenc)。接着，当UE连接到target eNB是，UE和target eNB可以使用这些秘钥来安全的通信。图5显示了Kenb 是怎么产生的。我们可以看到Kenb 从NH1，PCI，频点生成。* 7）【target eNB-&gt;MME】通知MME准备完毕target eNB给MME发送handover request ack消息，消息中包含了step-6中的所有资源。这些消息如下所示：Handover Request Ack (E-RAB Admitted(E-RAB ID, S1 Target eNB TEID, DL S1 Target eNB TEID), Handover Command (Target C-RNTI, Target DRB ID, AS Security Algorithm of Target eNB)) E-RAB Admitted E-RAB ID : E-RAB ID allocated by the target eNB S1 Target eNB TEID : DL S1 TEID that the target eNB allocated to S-GW for establishment of S1 bearer connecting to itself. DL S1 Target eNB TEID : DL S1 TEID that the target eNB allocated for establishment of an indirect tunnel for handover through which to deliver DL packets. Handover Command: Transparent Container, delivered by the target eNB to the source eNB, that contains the radio information of the target cell that UE needs to access the target eNB. Target C-RNTI: C-RNTI allocated by the target cell to identify UE. Target DRB ID: ID of DRB that the target eNB set to deliver user packets over the radio link. Target DRB ID: ID of DRB that the target eNB set to deliver user packets over the radio link. 8）【MME-&gt;SGW】请求S1承载创建用于下行数据包传输MME给SGW发送Create Indirect Data Forwarding Tunnel Request消息，请求创建indirect tunnel用于交付下行数据包。这个消息包括GTP TEID（S1 Target eNB TEID，target eNB分配的） 9）【MME&lt;-SGW】通知MME S1承载创建完成SGW一旦接收到Create Indirect Data Forwarding Tunnel Request消息，创建一个连接target eNB的indirect tunnel。接着分配S1 SGW TEID，通过Create Indirect Data Forwarding Tunnel Response消息转发给MME，source eNB可以使用这个TEID穿件indirect tunnel连接SGW。 10）【source eNB&lt;-MME】通知完成切换MME发送给source eNB handover command消息包含i)S1 SGW TEID（在step-9从SGW接收到）ii）包含包含handover command消息（在step-7从target eNB接收到的）source eNB从handover command消息中知道target eNB和EPC已经准备UE切换了。 handover execution图6描述了S1切换的执行阶段。 11）【UE&lt;-source eNB】命令UE执行切换一旦source eNB准备好切换，source eNB发送handover command消息命令UE执行切换。这个消息是包含在RRC connection reconfiguration消息中的。 12）【UE】执行切换一旦UE从handover command消息中获得C-RNTI和DRB ID，并从source eNB detach。现在UE和source eNB之间的所有的数据包交换都停止了，切换中断时间开始了。 13）【UE】AS安全建立UE产生AS安全秘钥用于target eNB的无线链路。首先产生Kenb，接着使用target eNB选择的AS安全算法产生AS安全秘钥 (KRRCint, KRRCenc, KUPenc)。 14）~15）【source eNB-&gt;MME.MME-&gt;target eNB】通知从哪个数据包开始发送/接收source eNB发送eNB status transfer 消息，包含DL count和UL count给MME。接着MME通过MME status transfer消息包含相同的信息给target eNB。这是为了让target eNB知道从哪个数据包开始发送/接收数据包。这里这个count值是PDCP PDU计数，每一个count是32bit值，包含HFN超帧号和PDCP序列号SN。这个消息如下：eNB Status Transfer (DL Count, UL Count) DL Count: Count of the first packet to send to the UE UL Count: Count of the first packet to receive from the UE在发送eNB status transfer消息之后，source eNB开始通过indirect tunnel转发从SGW到达的下行数据包给target eNB。target eNB缓存这些数据包，知道UE成功接入到target eNB。 16）-18）【UE，target eNB】UE接入到target eNB16）UE检测到target eNB的同步信号并执行同步到target eNB。一旦同步完成，UE发起非竞争的随即接入。17）target eNB给UE发送时间偏移信息和上行授权。18）UE给target eNB发送handover confirm消息包含在RRC connection reconfiguration complete消息中。现在UE可以从target eNb接收或发送数据包了。切换中断时间结束。 19）【UE~target eNB】无线链路上的安全通信UE和target eNB之间的所有的RRC信令消息和用户数据包都是使用AS安全秘钥安全传输的。rrc信令消息是完整性保护和加密的，用户数据是加密的。 20）【target eNB】恢复下行数据包交付给UE随着UE成功连接到target eNB，target eNB通过下面的路径恢复发送缓冲的下行数据包给UE。S5承载( PGW到SGW)——S1承载（SGW到source eNB）——-S1承载（source eNB到SGW）——S1承载（SGW到target eNB）—-DRB（target eNB到UE）对于UE发送的数据包，target eNB检查是否以正确的顺序接收到上行数据包，接着通过下面的路径转发给SGW。DRB（UE到target eNB）—-S1承载（target eNB到SGW）—-S5承载（SGW到PGW） handover completion图7描述了S1切换结束阶段的过程。 21）【target eNB-&gt;MME】请求EPS承载路径转换一旦UE成功接入，target eNB通过发送handover notify消息给MME通知UE已经成功完成了S1切换，这个消息中包含ECGI和TAI。 22）~27）修改EPS承载MME转发由target eNB分配的S1 target eNB TEID给SGW（通过发送modify bearer request消息）。通过这种方式请求SGW修改承载路径。接着SGW建立下行S1承载连接target eNB。一些SGW，根据UE初始附着时的选项设置，需要报告UE的服务小区是否发生变化。就需要SGW发送modify bearer request消息给PGW（PGW报告给PCRF），根据EPS会话修改过程，表示UE服务小区发生变化了。 28）~29）【SGW】修改S1承载路径SGW转换下行数据包转发路径为连接target eNB的下行S1承载。首先SGW发送end marker（EM）来指示发送给source eNB的最后一个数据包。接着它通过连接target eNB的S1承载来发送下行数据包。 30）【target eNB】数据包重新排序现在，target eNB接收到从source eNB转发过来的下行数据包，和通过新修改的路径的下行数据包。所以应该以正确的顺序交付给UE。首先target eNB转发从indirect tunnel接收到的数据包，接着当EM到达时，就是知道从indirect tunnel的最后一个数据包，接着发送从新修改的路径上接收到的下行数据包给UE。 31）~32）【source eNB&lt;-&gt;MME】释放存储在source eNB中的UE上下文和S1资源MME通知source eNB，source eNB可以释放indirect tunnel和S1资源，以及UE上下文了（通过发送UE context release command消息）。* 33）~34）【MME&lt;-&gt;SGW】MME给SGW发送delete indirect data forwarding tunnelrequest消息请求释放indirect tunnel。一旦接收到这个请求，SGW释放indirect tunnel，并发送delete indirect data forwarding tunnel response消息通知MME释放完成。 IV. EPS entity information：before/after S1 handover在intra-LTE环境中，在S1切换前后存储在EPS实体中的信息和X2相同、 切换相关的As安全上下文会根据切换的类型不同俄日变化（S1 or X2）。切换安全在本篇文档范围之外。 在切换过程中，EPS实体中存储的信息十分相同，但是也会根据切换类型而不同。 V. closing目前为止，我们讨论了在SGW和MME都不发生变化时的S1切换过程。不想X2切换，在S1切换中，EPS知道UE的切换。EPC从切换准备阶段参与到切换过程。它和source eNB，target eNb协作共同完成切换。在EMM case-6我们讨论了LTE 切换。接下来对我们将讨论小区重选。 References[1] Netmanias Technical Document, “LTE EMM Procedure 6 – Part 2. X2 Handover”, March 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6257[2] 3GPP TS 36.413, “Evolved Universal Terrestrial Radio Access Network (E-UTRAN); S1 Application Protocol (S1AP)”[3] Netmanias Technical Document, “LTE EMM Procedure 6 – Part 1. Overview of LTE Handover”, March 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6224[4] 3GPP TS 36.331, “Evolved Universal Terrestrial Radio Access (E-UTRA); Radio Resource Control (RRC); Protocol specification”[5] Netmanias Technical Document, “LTE Security II: NAS and AS Security”, August 2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5903[6] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[7] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[17-EMM Procedure 6. Handover without TAU - Part 2. X2 Handover]]></title>
    <url>%2F2016%2F04%2F03%2F17-EMM-Procedure-6-Handover-without-TAU-Part-2-X2-Handover%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6257 I. Introduction在前一篇文档中我们讨论了LTE切换相关的过程，并学习了LTE切换是一个 UEassisted / network - controlled 的过程，即UE报告，eNB决定。这篇文档将讨论X2切换。所以我们假设源和目的eNB都连接到同一个MME/SGW，并且位于同一个TA，也就是在UE的TAI列表中。第二章将讨论X2切换的概念，第三章详细介绍X2切换的过程，最后第四章将总结在X2切换前后EPS实体的信息是怎么变化的。 II. Concept of X2 Handover2.1 X2 Protocol StacksX2切换是通过X2接口在源eNB和目的eNB之间执行的。在一个LTE网络中，两个eNB可以通过X2接口直接通信，这不同于在2/3G网络的情况。在2/3G网络中，eNB获得邻eNB状态的唯一的方法就是通过数据核心节点的控制。但是在LTE网络，允许eNB直接通过X2接口来交换状态信息，并在没有EPC节点的介入下来独立的执行切换。图1展示了控制面和用户面X2接口上的协议栈。 在控制面，两个eNB通过SCTP数据流控制传输协议提供给多个用户X2AP X2应用层协议信令。在X2AP层，使用eNB UE X2AP ID (Old eNB UE X2AP ID, New eNB UE X2AP ID)来标识用户。在数据面，两个eNB通过GPRS隧道协议GTP协议连接。为每一个用户产生一个独一无二的GTP隧道，并且每一个隧道被分配的TEID标识。 2.2 X2AP功能表1列出了通过X2AP信令执行的功能，并且和每一个功能相关的基本过程。如下所示，X2AP信令信息可以粗略地分为两种，一种是和负载/接口相关（例如，负载管理），另一种是和切换相关（例如，移动性管理，移动参数管理，移动鲁棒性优化）。 对比2/3G网络，像LTE宽带网络具有少的小区覆盖，但是有很多基站来覆盖。所以，像2/3G那样传统的配置和管理网络方式将不再有效。为了处理这个问题，在LTE网络中，定义了X2AP协议来提供自组网SON功能。这就允许eNB可以连接到邻eNB，获取他们的状态信息，并使用获取的信息自动的配置和优化参数。在表1列出的X2AP功能，这些和SON相关的如下： Load Management: 通过在两个eNB之间交换负载和接口信息来增强性能干涉。eNB Configuration Update: 执行自动eNB配置Mobility Parameters Management: 在eNB之间协商切换触发设置信息，并使用这些信息来切换优化Mobility Robustness Optimization: 对切换失败事件提供信息Energy Saving: 通过交换交换小区的激活或者去激活来帮助eNB减少能量消耗 2.3 和移动向管理相关的X2消息表2显示了用于移动性管理功能的消息，和切换相关的将会在第三章讨论。我可以看出在切换准备阶段需要来自目标eNB的响应消息。 Handover Request message: 这个小区在切换准备阶段使用。它由源eNB发送给目的eNB，包含用户的UE上下文。Handover Request Acknowledge message: 这个消息在切换准备阶段使用，在目的eNB成功完成资源分配之后由目的eNB发送给源eNB。Handover Preparation Failure message: 这个消息在切换准备阶段使用，在目的eNB分配资源失败时由目的eNB发送给源eNB。SN Status Transfer message: 这个消息在切换执行阶段使用，它由源eNB发送给目的eNB来指示从哪一个数据包开始应该接收或者发送。UE Context Release message: 这个消息在切换完成阶段使用，由目的eNB发送给源eNB，来请求UE上下文的释放。Handover Cancel message: 这个消息在切换准备阶段使用，当需要删除一个正在准备的切换时由源eNB发送给目的eNB。 2.4 简要X2切换过程如前一个文档所述，X2切换过程包括准备，执行，完成阶段。在我们深入讨论之前，我们将简要预览一下X2切花过程。如2描述了在X2切换前，中，后需要的过程。为了方面SGW和PGW被标记为SAE-GW，源和目的eNB被标记为SeNB和TeNB。 Before X2 Handover在上图中，UE是由eNB A服务，当UE检测到一个测量事件，UE给eNB A发送测量报告消息。 X2 Handover Preparation源eNB基于自己保存的邻区列表信息和包含在测量报告消息中的邻区信号强度信息来选择目的eNB切换。接着，通过X2信令和目的eNB准备X2切换。这时，目的eNB提前分配资源，使得在源eNB用户可用的服务现在在目的eNB也可用了。为了切换更快的切换，目的eNB发送给源eNB 目的eNB需要的所有UE信息，同样也把这些信息发送给UE，来发起切换执行阶段。目的eNB分配的资源如下： 当源eNB给目的eNB发送handover request消息包含用户UE上下文（1）。 目的eNB： 获取S1承载信息(S1 S-GW TEID)来建立上行S1承载传输上行数据包（2）. 为X2传输协议（GTP-U）分配TEID，用于在UE试图接入目的eNB时接收下行数据。 分配DRB资源和C-RNTI供UE在目的小区中使用。 发送handover request ack消息给源eNB（3）。 一旦接受到这个消息，源eNB建立X2传输承载用于发送下行数据包（4）。 X2 Handover Execution一旦在两个eNB之间切换准备完成，可以开始执行切换了。 源eNB 通过发送handover command消息（包含接入目的小区需要的所有信息）指示UE来执行切换到目的小区。（1） 通过发送给目的eNB一个SN status transfer消息通知目的eNB当和UE通信时哪一个UL/DL数据包需要接收或者发送（2） 通过X2传输承载转发从SGW接收到的下行数据包给目的eNB（3） UE从源eNB去附着，并接入到目的eNB（4）. 一旦UE成功接入，目的eNB有能力发送和接收数据包了（5）。 X2 Handover Completion到目前为止，从源eNB决定执行切换开始，在切换执行阶段到UE最终连接到目的eNB，之间执行的所有过程都没有切换相关的信息报告给EPC（MME）。现在切换完成了，目的eNB通知EPC： 一旦UE接入完成，目的eNB通知EPC，并发送path switch request消息给MME，通知EPC承载路径可以修改了。（1） 当接收到这个消息，MME觉察到UE新的服务小区，接着需求请求SGW修改S1承载（2）。 一旦请求，SGW建立下行S1承载(S1 Target eNB TEID)连接到目的eNB。接着SGW停止发送下行数据包到源eNB，并通过新建立的下行承载开始向目的eNB发送下行数据包。（3） MME通知目的eNB，下行S1承载路径已经修改完成（4）。 目的eNB发送给源eNB一个UE Context Release消息，允许源eNB释放UE上下文。（5） After X2 HandoverUE开始通过eNB B获得服务。 2.5 X2切换前后UE状态和连接信息图3描述了在用户面控制面建立的连接，和UE、MME状态Before X2 HandoverUE处于EMM-Registered and ECM/RRC-Connected状态并保持E-UTRAN和EPC分配的资源。During X2 Handover即使在切换状态，NAS层UE状态保持不变，X2承载和X2信令连接通过X2接口建立。在图3中，第2步展示了在切换执行阶段当切换中断时的连接和状态。这时候，没有无线连接处于激活状态，但是UE一直保持connected。After X2 HandoverUE保持在EMM-Registered and ECM/RRC-Connected状态。用户面的E-RAB(DRB+S1承载)路径转移到新的eNB上，控制面的新RRc连接和S1信令连接(eNB(B) S1AP UE ID)也建立起来了。 III. Procedure of X2 Handover现在我们来详细讨论X2切换过程。图4描述了在X2切换之前的EPS承载和信令连接，和详细的X2切换准备过程。 Before Handover1) [UE -&gt; eNB] Measurement Report随着测量事件触发，UE测量邻区的信号强度，并发送measurement report消息给响应的eNB。 Handover Preparation2) [Source eNB] Handover Decision源eNB基于measurement report消息包含的信息和自己保存的邻区列表信息选择目标eNB。在实际切换中，有不止一个目标eNB选择或者不是UE报告的邻区被选择为目标小区。但是，我假设只有一个eNB包含在measurement report消息里面，这个eNB被选择为目标eNB。 3) [Source eNB] Deriving the AS Security Base Key (KeNB) to be Used by the Target eNB当切换发生时，UE的服务eNB发生转换。在转换期间，RRC信令消息和用户数据包不得不无缝的和安全的传送。在无线连接上，是AS安全秘钥确保这些数据的安全传输。AS安全秘钥是从KeNB（AS安全基础秘钥）衍生的。KeNB是在用户鉴权后从KASME派生的，由MME发送给eNB。但是，因为X2切换是在没有EPC干预下在两个eNB之间执行的，目的eNB不能从MME中获得KeNB（KeNB被目的eNB使用）。所以，源eNB生成这个秘钥然后发送给目的eNB。这样，一旦源eNB决定执行切换，它会首先产生KeNB ，如图5所示。KeNB 从KeNB/目标小区PCI和频率（EARFCN-DL）中派生。4) [Source eNB -&gt; Target eNB] 请求X2切换源eNB给目的eNB发送handover request消息请求切换。通过这个消息，传输存储的UE上下文信息和UE历史信息（UE连接目的小区优先于最后切换到的目标小区）。这个信息包括如下：Handover Request (Target Cell ID, UE Context Info(UE-AMBR, UE Security Capability, KeNB*, E-RAB to be setup (E-RAB ID, QCI, ARP, S1 S-GW TEID), RRC Context), UE History Info) Target Cell ID: the target cell’s ECGI UE Context Info: UE context stored at the source eNB UE-AMBR: provided by HSS, but can be modified by MME. This value can be set for eNB, and used to control the aggregated MBR value of non-GBR bearers. UE Security Capability: security algorithms supported by UE (encryption and integrity algorithm) KeNB*: AS security base key generated by the source eNB for the target eNB’s use, i.e. KeNB to be used by the target eNB E-RAB to be setup: UE’s E-RAB information stored at the source eNB UE History Info: information about the cells that UE has accessed while staying Active, including each cell’s ECGI, type and the duration of UE’s stay in the cell. 5) [Target eNB] 准备X2切换一旦接收到handover request消息，target eNB开始切换准备为UE提供无缝的服务。(i) 首先，target eNB从source eNB接收的KeNB生成AS安全秘钥(KRRCint, KRRCenc, KUPenc)。使用这些秘钥，target eNB可以和UE安全的通信。(ii) 接着，target eNB基于要建立的E-RAB信息检查source eNB提供的相同的QoS是否在target eNB中可用。如果可用，target eNB通过存储在source eNB的上行S1承载信息(S1 S-GW TEID)建立上行S1承载连接SGW。(iii) 接着，基于E-RAB QoS信息，target eNB在无线链路上为UE保留RRc资源，并分配C-RNTI。(iv) 当UE执行切换时，到达source eNB的下行数据包需要转发给target eNB。为了实现这个，target eNB分配X2 Target eNB TEID (DL TEID of X2 GTP tunnel) ，source eNB可以建立X2传输承载（GTP隧道）。6) [Source eNB &lt;- Target eNB] 给source eNB通知切换准备完成target eNB发送handover request ack消息包含在step-5准备的所有资源。这些信息如下：*Handover Request Ack (E-RAB Admitted (E-RAB ID, Target eNB TEID), Handover Command (Target CRNTI, Target DRB ID, AS Security Algorithm of Target eNB)) E-RAB Admitted 12: includes i) E-RAB ID allocated by the target eNB, and ii) TEID information of X2 transport bearer through which E-RAB packets are to be forwarded to the target eNB. Handover Command: Transparent Container, delivered by the target eNB to the source eNB, that contains information that UE needs to access the target eNB Target C-RNTI: C-RNTI allocated by the target cell to identify UE Target DRB ID: ID of DRB that the target eNB set to deliver user packets over the radio link AS Security Algorithm of Target eNB: AS Security algorithm supported by the target eNB 7) [Source eNB] 为下行数据包交付建立X2传输承载一旦接收到handover request ack消息，source eNB知道target eNB可以服务UE了。接着使用X2 target eNB TEID，source eNB开始建立X2传输承载，在切换执行阶段可以使用这个承载把下行数据包转发给target eNB。 Handover Execution图6显示了X2执行阶段的详细过程。 8) [UE &lt;- Source eNB] 命令切换一旦source eNB和target eNB完成切换准备，source eNB发送handover command消息命令UE执行切换。 9) [UE] 执行切换UE从handover command消息中获得C-RNTI和DRB ID用于target cell，并从source eNB上detach。现在UE和source eNB之间的所有数据包都中断了，切换中断时间周期开始。 10) [UE] AS安全建立UE产生AS安全秘钥用于target eNB的无线链路。首先从source eNB的KeNB/target cell的PCI和频点信息中生成KeNB，接着通过target eNB选择的AS安全算法来生成target eNB的AS安全秘钥(KRRCint, KRRCenc, KUPenc) 。11) [Source eNB -&gt; Target eNB] 通知发送或者接收的数据包序号source eNB给target eNB发送SN Status Transfer 消息通知从哪个数据包开始发送或者接收，在这个消息中包含下行计数和上行计数，这个计数值是PDCP PDU的计数，每一个计数32bit，是由Hyper Frame Number (HFN) and PDCP Sequence Number (SN)组成。这个信息如下所示：*SN Status Transfer (DL Count, UL Count) DL Count: Count of the first packet to send to the UE UL Count: Count of the first packet to receive from the UE 在发送给target eNB SN status transfer消息后，source eNB开始转发从SGW的下行数据包到target eNB。target eNB缓存这些数据包等待UE接入完成。 12) ~ 14) [UE, Target eNB] UE接入到target eNB 12) UE检测到target eNB的同步信号并执行同步到target eNB。一旦同步完成，UE发起非竞争的随机接入。 13) target eNB给UE发送定时偏移信息（时间提前量）和UL grant。 14) UE给target eNB发送handover confirm消息包含在RRC connection reconfiguration complete 消息。现在，UE可以发送或接收来自target eNB的数据包，切换中断时间周期结束。 15) [UE - Target eNB] 在无线链路上安全通信UE和target eNB之间无线链路上的所有rrc信令消息和用户数据包都使用AS安全秘钥安全的传输。RRC信令消息是完整性保护和加密的，用户数据包是加密的。 16) [Target eNB] 恢复发送至UE的下行数据包一旦UE成功连接到target eNB，target eNB开始通过图6的路径发送缓存的下行数据包给UE。至于UE发送的数据包，target eNB检查上行数据包是否以正确的顺序接收，并通过图6的路径转发给SGW。 Handover Completion图7描述了X2切换完成阶段的详细过程。 17) [Target eNB -&gt; MME] 请求EPS承载（S1承载）路径转换target eNB通过发送path switch request消息通知EPC（MME）UE的服务消息转换了，并请求转换EPS承载路径。 18) ~ 23) 修改EPS承载MME转发target eNB分配的S1 Target eNB TEID给SGW。通知SGW下行S1承载已经改变了，并要求改变这个承载路径。SGW建立下行S1承载连接到target eNB。一些SGW根据UE初始attach的设置的选项在EPS会话创建时需要报告UE的服务小区是否改变。在此场景下，S-GW向P-GW发一个modify bearer request消息，让P-GW向PCRF发送报告，根据EPS session modification procedure，指示说UE的服务小区已经发生了改变。 24) [S-GW] 修改EPS承载路径并发送EM数据包现在下行S1承载已经修改，SGW转换下行数据包交付路径到连接target eNB的下行S1承载。首先SGW发送结束标记EM来标识到达source eNB的下行S1承载的最后一个数据包。接着SGW通过修改过的下行S1承载发送下行数据包。 25) [Target eNB] 数据包重新排序现在target eNB从source eNB和从修改过的下行S1承载接收下行数据包。所以，应该以一定的顺序交付给UE这些数据包。首先，target eNB交付给UE source eNB转发的下行数据包，当收到EM，target eNB知道这是从X2承载的最后一个数据包，接着target eNB发送从S1承载接收到的数据包给UE。 26) [Target eNB &lt;- MME] 通告修改过的承载路径MME通过发送path switch request ack消息通知给target eNB，SGW已经完成了EPS承载路径的转换。接着，MME转发用于切换的安全上下文{NH Chaining Count (NCC), Next Hop (NH)}，target eNB可以在UE下次切换到另外一个小区时使用。 27) [Source eNB &lt;- Target eNB] 通知释放UE上下文target eNB保留{NCC, NH}并给source eNB发送UE context release消息，通知UE上下文可以释放，UE承载路径转换完成。 IV. EPS Entity Information: Before/After X2 Handover这章描述在X2切换前后EPS实体信息的变化。所有的信息被分类为UE ID，UE Location，安全，EPS会话/承载信息。 4.1 Before X2 Handover在X2切换前，UE处于EMM-Registered and ECM/RRC-Connected状态。直到执行X2切换构成，所有的信息和初始附着/service request之后的信息相同。也就是，E-UTRAN和EPC分配的资源和存储在EPS实体中的UE上下文信息。图8列出来这些信息。 4.2 After X2 Handover在X2切换后，UE处于EMM-Registered and ECM/RRC-Connected状态。存储在每一个EPS实体中的信息没有改变，但是UE的Location信息发生变化。在source eNB中所有的E-UTRAN资源和UE上下文都释放了，但是在target eNB中设置了。图9列出来这些信息。在图中，改变的信息被标记为蓝色。 V. Closing到目前为止我们讨论了MME和SGW都不发生改变的X2切换过程。X2切换是在没有EPC参与下由source 和target eNB来执行的。我们学习了下行数据包通过X2传输承载转发来避免数据包丢失。在第三篇文档，我们将讨论S1切换，以及S1切换和X2切换的不同之处。 References[1] Netmanias Technical Document, “LTE EMM Procedure 6. Handover without TAU – Part 1. Overview of Handover”, March 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6224[2] 3GPP TS 36.423, “Evolved Universal Terrestrial Radio Access Network (E-UTRAN); X2 application protocol (X2AP)”.[3] 3GPP TS 36.331, “Evolved Universal Terrestrial Radio Access (E-UTRA); Radio Resource Control (RRC); Protocol specification”[4] Netmanias Technical Document, “LTE Security II: NAS and AS Security”, August 2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5903[5] Netmanias Technical Document, “LTE Security I: LTE Security Concept and LTE Authentication”, July 2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5902[6] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16-EMM Procedure 6. Handover without TAU - Part 1. Overview of LTE Handover]]></title>
    <url>%2F2016%2F04%2F03%2F16-EMM-Procedure-6-Handover-without-TAU-Part-1-Overview-of-LTE-Handover%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6224 I. Introduction这篇文档描述EMM case-6。这个过程是当UE移动到在TAI列表中的TA的一个小区时执行的。在handover过程中，并不发起TAU过程。我们定义这种过称为“Handover without TAU”。这个过程通过接下来的三篇文档讲述。第一个文档描述LTE handover，提供基本的信息。第二篇文档描述X2 handover，第三篇文档描述intra-LTE环境下的S1 handover。 II. Overview of LTE Handover无线设备比有线的一个最大的好处就是它可以移动中使用服务。这种移动性可以使用户在任何位置使用该服务，不论是家里还是在路上，任何想要的时间都可以。正因为这种便利，无线用户大大超过有线用户。签约服务的用户可以在路上使用服务就是因为移动网络支持handover切换。UE可以从一个基站在不丢失数据的情况下切换到另外一个基站。这确保用户可以被无缝地服务到，不论连接到那个小区。这个文档描述UE和LTE实体需要采取什么行动来支持切换，并且简要的讲述这些行为的不同。和切换的过程如表1所示。 UE有一个天线可以在多个band上搜索多个频率信道。所以在检查完多个邻区之后，UE通常接入有最强信号强度的那个小区（除非因为接入限制或者拥塞控制而不允许接入）。接着随着UE的移动和遮蔽，UE当前服务小区的接收信号强度变弱了，而邻区的信号变强，发起handover。允许UE接入邻区并建立新的RRC连接。 为了达到这种目的，当UE和eNB建立RRC连接时，eNB通过一个配置消息（RRC Connection Reconfiguration）给UE指示哪些事件的接收信号强度需要报告。UE监视服务小区和邻区的接收信号强度。当其中一个事件发生，UE通过Measurement Report消息把接收信号强度报告给eNB。eNB一旦接收到这个消息，通过查看报告强度信息和邻区的负载状态决定是否发起handover。一旦决定，将执行handover到选择的目的小区。 2.1 Measurement图1描述了当UE测量和报告信号轻度的测量配置和测量报告过程。 (1) Measurement Configuration测量配置是由eNB提供给UE的，eNB指示什么类型的测量信息需要报告。eNB通过RRC connection reconfiguration消息提供给UE这些测量配置。这些信息包含如下： 测量对象：提供UE需要测量的E-UTRAN小区，包括，频道号，物理小区ID-PCI，小区ID的黑名单，每一个小区的偏移值等等。 报告配置：指示需要UE发送测量报告信息的触发事件 测量ID：描述测量对象的ID Quantity配置：指示UE测量的值 测量间隔：指示UE测量邻区的间隔 在同频邻区测量情况下，UE可以不使用测量间隔(gap)来测量邻区。但是在异频邻区测量时，UE应该首先同步到邻区的频点，然后在上下行idle周期内使用测量间隔gap来测量信号强度。 (2) Measurement Report TriggeringUE测量服务小区和邻区的信号强度。接着UE把测量结果报告给eNB（周期性的，或者在满足测量配置中设定的报告门限时触发测量事件）。E-UTRAN的报告门限包括事件A1, A2, A3, A4 and A5，在inter-RAT测量报告中包括事件 B1 and B2。Event A3通常用来触发切换。图2显示了由事件A3触发切换的实例。表2提供了事件A3使用的符号。 Event A3当邻区的信号强度（信号强度和偏移，MNbr = Mn + Ofn + Ocn）比UE服务小区的信号强度（信号强度和偏移，MSer = Ms + Ofs + Ocs）高时，并且这个差额比A3偏移 (Off)还要大时，事件A3触发，UE给eNB报告测量结果。迟滞(Hys)是服务小区和目标小区越区切换界限的值。在A3触发的时候并且A3触发判决持续指定的TTT周期，eNB决定触发切换。 Table 2. Definition of the Symbols Represented in E-UTRA Measurement Symbol Definition Mn Measurement result of the neighbor cell Ms Measurement result of the serving cell Hys Hysteresis parameter for Event A3 Off Offset parameter of Event A3 Ofn Frequency specific offset of the frequency of the neighbor cell Ocn Cell specific offset of the neighbor cell Ofs Frequency specific offset of the serving frequency Ocs Cell specific offset of the serving cell 2.2 Handover Decision当事件A3报告时，eNB决定执行什么类型的切换到哪一个目标小区，接着发起切换过程。切换可以分类为不同的类型，但是他们的分类遵循以下的目的： (1) Handover分类1: EPC实体是否发生变化切换可以分类为不同的类型—同频LTE，异频LTE，inter-RAT切换，这些根据UE连接的EPC实体在切换前后是否发生变化。 同频LTE切换▪ Intra-MME/S-GW Handover: 在切换前后UE服务的MME和SGW是否发生变化 异频LTE切换: 在切换前后UE服务的MME和/或SGW发生了变化▪ Inter-MME Handover: 在切换后，UE服务MME发生变化，而服务的SGW保持不变▪ Inter-S-GW Handover: 在切换后，UE服务SGW发生变化，而服务的MME保持不变▪ Inter-MME/S-GW Handover: 在切换后，UE服务MME和SGW都发生了变化 Inter-RAT Handover: 在不同无线接入技术之间的切换▪ UTRAN to E-UTRAN▪ E-UTRAN to UTRAN, etc. (2) Handover 分类2: 是否有EPC实体涉及到根据是否有EPC实体涉及到在源eNB和目标eNB之间准备和执行切换，LTE切换可以分为使用X2接口的X2切换和使用S1接口的S1切换。图3描绘了随着UE的移动而触发的两种不同类型的切换。图4显示了源eNB是如何决定是哪种类型的切换，X2或者S1。 X2 HandoverX2接口连接两个eNB。如果在两个服务小区的eNB和目标小区的eNB之间存在X2连接，并且X2连接可用于切换，则发起X2切换。一旦切换完成，两个eNB相互通信来控制切换，并没有MME的介入。 S1 HandoverS1接口连接eNB和EPC。如果i）在源eNB和目标eNB之间没有X2连接，ii）有X2连接，但是这个连接不允许用于切换，iii）在源小区和目标小区之间切换准备失败，则发起S1切换。一旦切换完成，源eNB通过MME和目标eNB通信控制切换。 2.3 Handover Procedure根据接收到的测量配置，UE把测量结果报告给eNB。一旦eNB决定，切换则发起。切换过程包含三个阶段—准备，执行，完成阶段。 (1) Handover Preparation Phase在这个阶段，源eNB和目标eNB准备切换。对X2切换，通过X2信令两个eNB直接进行通信，并且不需要MME介入情况下执行。对S1切换，通过S1信令，需要MME介入。源eNB发送用户UE上下文给目标eNB来检查目标eNB是否有能力提供满意的服务质量。如果可以，目标eNB建立传输承载（下行数据包转发承载）用于数据转发。接着分配C-RNTI（用于UE接入这个eNB），并把这个值转发给源eNB。这就完成了准备阶段。这时候对X2切换，下行数据包转发承载是一个连接两个eNB的直传隧道，对S1切换，则是连接三个实体的非直传隧道。图5标书了这个阶段的数据包转发路径，UL/DL承载数据交付路径，控制信息交付路径，和下行数据包转发路径。 (2) Handover Execution Phase在这个阶段，执行切换。UE从源eNB上释放无线连接，并连接到目标eNB，接入到新小区。一旦用于两个eNB之间数据包转发的资源(i.e. a DL packet forwarding bearer)分配完成，并且在准备阶段目标eNB为UE分配了新资源(i.e. a DRB, DL S1 bearer, C-RNTI, etc.)，则这两个eNB准备好切换了。接着源eNB通过发送handover command消息命令UE执行切换。在切换执行阶段，UE使用在切换准备阶段目标eNB分配的C-RNTI。这样可以使UE更快的接入目标eNB。一旦到达目标eNB，下行数据包通过转发承载转发给目标eNB，并缓存直到UE完成到目标eNB的接入。这确保了没有数据包丢失。从UE的上行数据包不转发直到UE成功的接入目标eNB。一旦UE完成对目标eNB的无线接入，上行数据立即通过目标eNB转发至SGW。图6描述了在切换执行阶段下行数据交付路径，和通过目标eNB上行数据交付路径。 (3) Handover Completion Phase一旦UE完成对目标eNB的无线接入，UE承载路径 (DL S1 bearer)连接到目标eNB上而不是源eNB上。一旦这个路径转换完成，在切换执行阶段使用的转发承载被释放。在图7中，一旦完成切换完成阶段，上下行数据都使用新承载来交付的。 2.4 切换中断时间在切换准备阶段，网络实体在执行切换时提前分配资源来确保没有下行数据包丢失。但是实际切换中，切换中断时间是不可避免的。在这个时间内（UE从源eNB释放无线资源到重新连接上新小区），数据包时不能在UE和小区之间交付的。图8显示了X2切换时切换中断时间的实例。如果中断时间持续过长，无缝服务将不支持，用户要承受差的服务质量。切换中断时间包括：❶ 下行同步到目标eNB的时间❷ RACH等待时间❸ 发送专用RACH preamble请求上行资源的时间❹ 目标eNB检测到preamble 并处理的时间❺ 准备RACH Response 的时间❻ 解码RACH Response 的时间❼ 通知UE已经完成到目标eNB切换的时间❽ 在完成切换阶段获得目标eNB确认的时间 2.5 Mobility Robustness Optimization移动性鲁棒优化有时候，在切换执行阶段在UE完成接入到目标小区之前UE从服务小区或者目标小区接收到的信号不足够强将会导致无线链路失败RLF。RLF引起的因素有很多，可能和切换有关，也可能没关。如果是由切换执行时间相关的原因，切换发起的太早或者太晚都会引起RLF。如果在执行切换时RLF发生，UE可能会执行RRC重建过程，并连接到服务小区/目标小区或者另外一个小区（错误的小区）。RLF也和小区覆盖有关。所以，3GPP标准定义了移动鲁棒性优化（Mobility Robustness Optimization (MRO)）来帮助检测哪种类型的接入失败，并增强切换的鲁棒性。MRO超出本片文档的范围，将可能在LTE SON自组网文档中介绍。在下一个文档，我们将讨论没有RLF的成功切换。 III. Closing这篇文档，讨论了LTE切换的概述，讨论了小区测量，不同类型的切换和切换阶段。接下来的两篇文档将继续深入讨论X2和S1切换。 References[1] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[2] 3GPP TS 36.300, “Evolved Universal Terrestrial Radio Access (E-UTRA) and Evolved Universal Terrestrial Radio Access Network (E-UTRAN); Overall description”[3] 3GPP TS 36.331, “Evolved Universal Terrestrial Radio Access (E-UTRA); Radio Resource Control (RRC); Protocol specification”[4] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15-EMM Procedure 5. Periodic TAU]]></title>
    <url>%2F2016%2F04%2F03%2F15-EMM-Procedure-5-Periodic-TAU%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6193 I. Introduction这篇文档描述EMM case-5 周期性TAU过程。这个过程是在ecm-idle rrc-idle状态下的UE因为没有数据传输而需要周期性的更新MME的位置信息。当UE进入一个不在TAI列表中的TA时发起TAU，或者当TAU定时器超时。这篇文档介绍的是周期性TAU。当TAU定时器超时时，idle状态的UE发送TAU request消息报告自己的位置信息。在转移到ecm-connected rrc-connected状态后，执行周期性TAU过程，然后UE返回到idle状态。这篇文档介绍idle状态的UE执行周期性TAU过程，第二章介绍周期性TAU的概念，第三章描述具体的过程，最后第四章总结在这个过程前后EPS实体信息的变化。 II. Concept of Periodic TAU在connected状态的UE已经建立UE到PGW的端到端的EPS承载。MME保持UE位置的跟踪。所以如果有到达UE的数据，网络可以立即传送。但是如果UE在idle状态，UE和MME之间的信令连接和承载已经被释放，MME丢失了UE位置的跟踪。网络应该时刻知道UE的位置信息，无论是idle还是active，这是为了能够传送给UE数据。所以在idle状态的UE即使没有数据传输时，应该给MME周期性的报告自己的位置信息（比如UE所在的TA）。TA是一些小区的组合，由MME管理。idle状态的UE位置信息的识别是在TA级别。当UE初始附着网络时，MME会在attach accept消息中包含TAI列表和TAU定时器（T3412）给UE。使用这些信息，UE可以在TAU定时器超时时执行TAU过程。当MME接收到UE的位置信息，MME会更新UE的最新位置信息。如果UE在idle状态下有数据到达UE，MME可以通过发送给这个TA下的所有小区寻呼信息来通知UE有数据到达，这个TA是idle状态的UE报告给MME的TA。图1描述了TAU执行的实例。UE1在初始附着时attach上了eNB1的cell2，并且通过attach accept由MME分配了TAI列表(e.g. TAI={TAI1, TAI2})和TAU timer (e.g.T3412=60 mins)，接着在转移到idle状态，❶ -&gt; ❷ -&gt; ❸ -&gt; ❹。我们假设i)UE只在TAI列表中的TAs中移动，ii）UE报告TA信息的MME是存储着UE的上下文信息，iii）MME和UE都包含有效的NAS安全上下文。 在cell2 attach和转移到idle状态后，在t1时刻当TAU超时时UE1醒来并建立ECM信令连接。接着UE1发送给MME TAUrequest消息 (TAI=TAI1, Last Visited TAI=TAI1) 包含当前小区的TAI和上次访问的TAI(❶)。接着UE1接收到TAU accept消息后返回到idle状态。在接收到TAU request消息后，MME检查UE的上次TAI是否改变，如果变化了更新最新的TAI信息。如果有到达UE1的数据，SGW通知MME有下行数据，MME根据上次TAU报告的最新的TAI查找UE在哪个TA，并在这个TA下的所有小区发送寻呼消息。接下来，如果UE1移动到cell4，并且TAU定时器超时，UE给MME发送TAU request消息(TAI=TAI1, Last Visited TAI=TAI1)，因为UE一直在TA1中。如果UE1移动到cell11中，并且定时器超时，UE给MME发送TAU Request 消息(TAI=TAI2, Last Visited TAI=TAI1)，用TAI2代替TAI1，因为这个小区属于TAI2。接着MME更新UE1的上次TAI为TAI2。图2描述了连接建立，TAU前后用户面和控制面UE、MME的状态。 UE状态如下：（i）在TAU之前，UE在EMM-Registered, ECM-Idle and RRC-Idle状态，E-UTRAN分配的资源，ECM信令连接都释放了。 （ii）在TAU过程中，UE处于EMM-Registered, ECM-Connected and RRC-Connected状态。周期性TAU过程不同于初始附着和service request过程，周期性TAU过程没有e-rab建立，只有ecm信令连接用于传输周期性TAU相关的NAS消息。 （iii）在TAU过程之后，ECM连接释放，释放E-UTRAN资源。接着UE返回到EMM-Registered, ECM-Idle and RRC-Idle状态。 图3描述了在TAU前后状态转换的过程。一旦T3412超时，idle状态的UE给MME发送TAU request报告当前TA和上次TA。MME在更新完最新UE位置信息后发送TAU accept消息。最后释放信令连接返回到idle状态。 III. Procedure of Periodic TAU图4和图5描述了周期性TAU的详细过程。图4中，UE的NAS通过发送TAU request消息给MME报告新的TA，更新类型标记为“Periodic Updating”。“Periodic Updating”类型的TAU不需要承载的建立，只需要建立ECM信令连接后就可以发送TAU request消息。当UE接收到TAU accept消息，释放ECM信令连接。TAU request消息是完整性保护。所以MME通过对这个消息完整性检查来决定是否执行鉴权过程。 ❶ Periodic TAU Triggering 1) [UE] TAU Timer Expiryidle状态UE在T3412TAU定时器超时后出发TAU过程给MME报告自己的位置信息。 ❷ ECM Connection Establishment and TA Report UE的NAS层 i）配置TAU消息，ii）发送RRC参数给RRC层。 2), 3) [UE – eNB] RRC Connection Establishment一旦接收到TAU request消息，UE的RRC层给eNB发送RRC connection request消息，请求专用信令资源。eNB通过分配SRB信道和给UE发送RRC connection setup消息来建立RRC连接。 4), 5), 6) [UE -&gt; MME] ECM Connection Establishment Request and TA ReportTAU request消息在UE到eNB之间包含在RRC Connection Setup Complete消息中，在eNB和MME之间包含在Initial UE Message消息中，TAU request消息是完整性保护和加密的。 The TAU Request消息如下信息:TAU Request (Update Type=Periodic Updating, Active Flag=0, GUTI, Last Visited TAI, KSI ASME, NASMAC) Update Type: 标识TAU类型，当TAU定时器超时设置为Periodic Updating Active Flag: 标识是否有上行用户数据或者信令要传送，如果有这个参数设置为1，会在TAU之后建立承载和维持ECM连接。 GUTI: UE ID, 之前由MME分配，用来标识UE的。 Last Visited TAI: UE上次注册的TAI KSIASME: index for KASME, the NAS security base key NAS-MAC: TAU request的消息完整性保护时使用MAC 为了从NAS层接收TAU request消息，UE的RRC层在RRC Connection Setup Complete消息中包裹这个消息发送给eNB。这时，RRC Connection Setup Complete消息包含GUMMEI。这个ID是从NAS层接收的，标识UE注册在哪一个MME上。通常eNB可以连接不止一个运营商网络和MME，所以一旦接收到RRC Connection Setup Complete消息，eNB检查自己是否连接着这个标记的MME。接着，eNB把TAU request消息包裹在Initial UE Message消息中发送给MME。这时，eNB分配给initial UE message消息一个eNB S1AP UE ID标识。MME一旦接收到Initial UE Message消息，分配MME S1AP UE ID，并建立S1信令承载。这时候就完成了UE和MME之间的ECM信令连接，允许UE转移到connected状态。 ❸ UE Authentication and NAS Security Setup (Optional) 7) [UE – MME – HSS] UE AuthenticationMME一旦接收到TAU request消息，对这个消息进行完整性保护检查，如果检查通过，MME跳过UE鉴权过程，并继续使用自己保存的NAS安全上下文来传递NAS消息。如果检查失败了，需要执行UE鉴权。 8) [UE – MME] NAS Security Setup一旦UE鉴权完成，NAS安全秘钥用于NAS消息传输。 ❹ TA Update 9) [MME -&gt; S-GW] TA Update当MME接收到了TAU request消息后，重置TAU定时器，并给SGW发送Modify Bearer Request消息，转发UE的位置信息(ECGI, TAI)。 10) EPS Session Modification (Optional)SGW接收到UE位置信息后，检查UE的小区是否发生变化。如果变化，SGW发送Modify Bearer Request消息给PGW通知这个变化。接着PGW通过EPS session modification过程发送同样的信息给PCRF。 11) [MME &lt;- S-GW] Responding to TA Update RequestSGW给MME发送Modify Bearer Response消息作为对Modify Bearer Request 消息的响应。 12) [MME] Preparing TAU Accept MessageMME配置新的TAI列表来反映UE当前位置，或者分配一个新的GUTI（根据实现来决定）。 13) [UE &lt;- MME] Sending TAU Accept MessageMME给UE发送TAU Accept 消息，完整性保护而且加密的。这个消息使用Downlink NAS Transport消息（从MME到eNB）和DL Information Transfer message消息（从eNB到UE）发送给UE。 14) [UE] Updating TIN and TAI List当UE从MME接收到TAU Accept消息，检查GUTI和TAI列表值。如果这些值发生变化，UE会用新值来更新TIN (Temporary Identifier used in Next update)和TAI列表。这里的TIN是在下次UE发送TAU request消息时使用的用户ID，并且更新包含在TAU accept消息中的GUTI。 15) [UE] Acknowledging New GUTI如果MME分配了一个新的GUTI，UE发送TAU complete消息给MME作为对新GUTI的响应。 ❺ ECM Connection Release 16) [eNB &lt;- MME] Requiring E-UTRAN to Release UE Context在更新UE的位置信息后，MME给eNB发送UE Context Release Command消息来释放用于周期TAU的ECM连接，并释放存储在E-UTRAN中的UE上下文。 17) [UE &lt;- eNB] Releasing RRC Connection一旦接收到UE Context Release Command 消息，eNB释放UE上下文，并释放分配给UE的E-UTRAN资源。接着给UE发送RRC Connection Release消息来释放RRC连接，然后释放分配给UE的SRB。 18) [eNB -&gt; MME] Announcing Release of UE Context from E-UTRANeNB给MME发送UE Context Release Complete消息指示S1信令连接已经释放了。现在，为TAU request建立的ECM连接释放了，UE重新回到idle状态。(ECM/RRC-Idle) IV. EPS Entity Information: Before/After Periodic TAU这章描述周期性TAU过程前后EPS实体的信息。所有的信息被分类为UE ID，UE Location，安全，EPS会话/承载信息。 4.1 Before Periodic TAU在TAU过程触发之前，UE在EMM-Registered, ECM-Idle and RRC-Idle状态，和service request发起之前存储的信息相同。即，E-utran分配的无线资源和相关的EPS承载和信令都被释放了。在图6中描述了在周期性TAU之前EPS实体中存储的信息。 4.2 After Periodic TAU在周期性TAU止呕，ECM连接释放，UE重新返回到idle状态。存储的EPS实体中的信息和TAU request之前的信息相同，如图6所示。 V. Closing我们学习了周期性TAU过程。不像service request过程，这个过程不建立e-rab承载，但是需要建立ECM连接。在TAU完成后，ECM连接释放，UE重新返回到idle状态。如果有上行数据要发送，首先建立e-rab承载，然后在TAU之后发送数据，像service request过程一样。接下来将介绍connected UE移动到另外的TA引起handover，但是没有TAU的情况。 References[1] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[2] Netmanias Technical Document, “LTE EMM Procedure 4. Service Request”, February 2014,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6134[3] Netmanias Technical Document, “LTE Identification II: NE and Location Identifiers”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5906[4] Netmanias Technical Document, “LTE EMM Procedure 1. Initial Attach – Part 2. Call Flow of InitialAttach”, January 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6102[5] Netmanias Technical Document, “LTE Security I: LTE Security Concept and LTE Authentication”, July2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5902[6] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14-EMM Procedure 4. Service Request]]></title>
    <url>%2F2016%2F04%2F03%2F14-EMM-Procedure-4-Service-Request%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6134 I. Introduction这篇文档描述EMM case-4：service request过程。这个过程是当有新流量时，在idle状态不活动的UE想激活来处理流量时执行的。新用户流量可以是从UE开始的上行流量，也可以是从网络到UE的下行流量。UE的E-UTRAN资源已经被释放了，UE处于ecm-idle rrc-idle状态。所以UE为了能够接受或者发送数据，UE需要通过service request过程来转换到ecm-connected rrc-connected状态，E-UTRAN资源被重新分配。这个文档解释了LTE网络下的service request过程。第二章根据新流量产生在哪，对service request分为不同的类型。第三章和第四章描述了每一种service request详细过程的不同。最后第五章总结在service request前后EPS实体中信息的变化。 II. Cases of Service Request当UE仍注册在网络，但是由于用户不活动删除了S1连接，UE没有可用的无线资源。这时候UE处于emm-registered和ecm-idle状态。如果这时候有新数据从UE产生或者从网络到UE，UE请求网络服务，转换到ecm-connected状态。ECM连接(RRC + S1 signaling connections)和e-RAB连接(DRB + S1 bearer)在控制面和用户面建立，允许UE接收或发送数据。如果网络发送数据给UE，网络会通知给UE自己的意图，让用户可以请求服务。当UE有数据发送，或者从网络的意图中知道网络要发送数据，UE发送给MME service request消息，并转移到ecm-connected、rrc-connected状态。接着UE通过使用分配的无线和网络资源，可以接受和发送数据。service request可以由UE或者网络来触发，根据不同的触发情况，可以分类为以下几种： service request case-1：UE触发的新数据。当UE有新上行数据要发送给网络。 service request case-2：网络触发的新数据。当网络有下行数据要放给UE。 图1展示了在service request执行前后用户面和控制面连接建立、UE和MME状态。在service request之前，用户时emm-registered ecm-idle rrc-idle状态。只有EPS分配的资源保持连接没有释放，而由E-UTRAN分配的所有资源都被释放了。在控制面S5 GTP-C and S11 GTP-C保持在连接状态。 在service request之前，用户处于EMM-Registered and ECM/RRC-Idle状态。只有EPC分配的资源没有被释放，e-utran分配的资源都释放了。在ECM连接丢失的情况下，在控制面S5 GTP-C和S11 GTP-C隧道仍然保持激活。在用户面，在下行S1承载和DRB被释放的情况下，S5承载和上行S1承载保持激活。 在service request之后，UE被e-utran分配了资源，处于emm-registered和ecm-connected rrc-connected状态。我们可以看到EPS承载的所有承载和连接以及信令连接都被建立起来用于传输数据。 III. UE-triggered Service Request图2和3描述了由UE触发的service request过程。UE的NAS通过service request消息给MME指示说UE有数据要发送。接着网络为数据传输分配资源。因为UE注册在网络，所以UE的NAS安全上下文在UE和MME中保持有效。所以UE可以发送加密和完整性保护的service request消息。当MME接收到这个消息，MME决定是否执行对用户的鉴权，尽管这个消息是加密和完整性保护的，接着eNB建立e-rab。 ❶ ECM连接建立 当有数据要发送，UE给MME发送service request消息建立ECM连接。service request消息通过无线链路上建立的RRC连接和S1信令连接传送给MME。这篇文档假设在UE和MME中有有效的GUTI和NAS安全上下文。 1), 2) [UE – eNB] RRC Connection SetupUE的NAS层提供给RRC层S-TMSI。RRC层使用S-TMSI作为UEID发送RRC connection request消息到eNB来建立RRC连接。eNB返回给UE RRC connection setup消息。 3), 4), 5) [UE -&gt; MME] ECM Connection Setup RequestUE的NAS层发送service request消息给MME来建立ECM连接。NAS安全上下文已经存储在UE和MME中。这个消息中包含KSI-ASME，并且是加密和完整性保护的。service request消息包含在RRC connection setup complete 消息中传送给eNB的。这个消息是包含在S1AP消息（initial UE消息）中从eNB传送到MME的。这是，eNB分配eNB UE S1AP ID，并包含在initial UE消息消息中发送给MME。一旦接收到initial UE消息，MME分配MME S1AP UE ID，并和eNB之间建立S1信令连接。 ❷ UE鉴权和NAS安全建立(可选) 6) [UE – MME – HSS] UE Authentication在接收到service request消息后，MME执行完整性检查，如果通过，MME使用当前的NAS安全上下文传输NAS消息，并不对UE再执行鉴权流程。如果失败，MME会对UE执行鉴权流程。 7) [UE – MME] NAS Security Setup当鉴权过程完毕后，UE和MME都生成了用于传输NAS消息的NAS安全秘钥。 ❸ E-RAB 建立 在收到service request消息之后，MME通过e-rab建立过程建立DRB和下行承载。 8) [eNB &lt;- MME] 请求E-RAB建立一旦接收到UE发送的service request消息，MME意识到要建立e-rab。接着MME给eNB发送Initial Context Setup Request 消息，让eNB可以建立和SGW建立S1承载，和UE建立DRB。这个消息包含以下信息： Initial Context Setup Request (E-RAB ID, KeNB, S1 S-GW TEID, MME UE S1AP ID) E-RAB ID KeNB: AS安全基础秘钥，用来eNB和UE建立AS安全 S1 S-GW TEID: 标识连接到SGW的上行S1承载 MME UE S1AP ID: 标识连接到MME的S1信令承载 9) [UE &lt;– eNB] AS Security Setup在接收到initial context setup消息后，eNB意识到要建立DRB和S1承载用于用户数据传输。在建立DRB之前，eNB执行AS安全建立过程。UE和eNB通过AS安全建立过程生成KRRCint/KRRCenc用于加密和完整性保护，生成KUPenc 用于用户数据加密。在成功完成AS安全建立，RRC消息在无线链路上是加密和完整性保护传输的，用户数据也是加密传输的。接着eNB开始DRB建立。 10) [UE &lt;- eNB] DRB EstablishmenteNB分配一个DRB ID来创建DRB，并根据从MME接收到的e-rab QoS配置DRB QoS参数后，发送RRC connection reconfigutaion消息给UE。UE一旦接收到RRC Connection Reconfiguration消息，生成DRB和SRB2。 11) 上行传输通道可用一旦完成步骤10生成DRB之后，就建立从UE到PGW的上行EPS承载，允许UE传输上行数据。 12) 13) &amp; 16) [eNB -&gt; S-GW] 建立下行S1承载在步骤12，eNB为S1承载分配下行S1 TEID (S1 eNB TEID)，并把这个ID包含在initial context setup response消息中发送给MME，作为对Initial Context Setup Request消息的响应。MME把S1 eNB TEID包含在Modify Bearer Request消息中发送给SGW，SGW使用这个信息建立下行S1承载。接着，在步骤16，SGW通过Modify Bearer Response 消息通知MME下行S1承载建立完成。 14) 下行传输通道可用一旦完成步骤13，从SGW到eNB的下行S1 GTP-U隧道就建立了，完成了从PGW到UE的下行EPS承载。用来传输下行数据给UE。 15) Modifying EPS Session (UE Location Registration)在service request时如果UE的当前小区或者TA发送变化，SGW通知PGW这个变化。接着PGW通过EPS session medication过程报告给PCRF。 IV. Network-triggered Service Request图4和 5描述了网络触发的service request过程。这种类型的service request是当网络有下行数据要发送给UE时触发。MME不知道idle状态的UE处于什么位置，所以MME不得不通过寻呼过程来通知UE它有数据要发送，接着已经释放的承载资源可以重新建立。 ❶ Service Request触发如果SGW从PGW通过S5承载收到下行数据包，但是不能通过下行S1承载发送给eNB，因为下行S1承载已经释放了。首先SGW缓存这些数据包，并找到UE注册在哪一个MME。接着SGW给MME发送Downlink Data Notification消息通知需要为UE建立信令连接和承载。 ❷ PagingMME知道UE驻留在哪一个TA，但是不知道UE驻留的小区。所以MME给这个TA下的所有eNB发送寻呼消息。eNB广播接收到的寻呼消息（通过PCH信道），UE在常规监控PCH时可以接收到这个消息。 ❸ ECM连接建立意识到有数据要到来，UE发送service request消息来建立ECM连接。ECM建立从UE通过无线接入信道接入小区开始，接着发送RRC Connection Request消息建立RRC消息。执行过程如图2所示。 ❹ UE鉴权和NAS安全（可选）MME一旦接收到UE发送的service request消息，如果NAS-MAC完整性检查失败，将实行UE鉴权和生成NAS安全秘钥。 ❺ E-RAB 建立在从UE接收到service request消息后，MME通过e-rab建立过程建立DRB和下行S1承载。接着准备接收从SGW的数据包。详细过程如图3所示。 V. EPS Entity Information: Before/After Service Request这章将描述在service request前后EPS实体中信息的变化。所有的这些信息将分类为UE ID，UE Location，安全和EPS会话/承载信息。 5.1 Before Service Request在service request触发之前，UE以为S1承载的释放而转移到emm-registered和ecm-idle rrc-idle状态。在S1承载释放后，所有EPS实体中的信息都保持相同直到service request过程执行。也就是说，E-UTRAN分配的无线资源和相关的EPS承载信令都从EPS实体中删除了。在图6中，在service request之前EPS实体中信息被标记为黑色。 5.2 After Service Request一旦完成service request过程，UE转移到ECM/RRC-Connected状态，RRC连接、S1信令和e-rab承载都建立起来了。用于UE和PGW之间传输的所有需要的信息都存储在EPS实体中。图7描述了在service request之后，EPS实体中存储的信息。 VI. Closing这篇文档，学习了service request过程。总结了存储在EPS实体中的信息。接下来的文档将讨论TAU过程。 References[1] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[2] Netmanias Technical Document, “LTE EMM Procedure 1. Initial Attach – Part 2. Call Flow of InitialAttach”, January 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6102[3] Netmanias Technical Document, “LTE Security II: NAS and AS Security”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5903[4] Netmanias Technical Document, “LTE EMM Procedure 3. S1 Release”, January 2014,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6110[5] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13-EMM Procedure 3. S1 Release]]></title>
    <url>%2F2016%2F04%2F03%2F13-EMM-Procedure-3-S1-Release%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6110 I. Introduction这个文档 描述了EMM case-3，当UE不活动状态时释放S1连接。当注册到网络的UE处于不活动状态，没有使用任何服务（并不意味着不适用eNB分配的无线资源）。所以网络需要释放这些相关的无线接入相关的资源，并删除相关的信息（ID，QoS参数等等）。从网络的角度看，S1释放意味着和UE有关的控制面S1信令和RRC连接，以及用户面下行S1承载和DRB。但是，从UE的角度来看，它意味着在控制面和用户面丢失RRC连接和DRB。一旦S1连接释放，MME和UE之间的ECM连接也丢失了，在eNB中和UE相关的所有上下文都被删除了。接着用户从ecm-connected状态转移到ecm-idle状态，但是一直保持emm-registered状态。这个文档解释了LTE网络中因为用户的不活动引起的S1释放。第二章描述了S1释放是怎么执行的，第三章描述了在S1释放过程之后信息单元是怎么变化的。 II. S1 Release due to User InactivityS1释放可以被eNB或者MME触发。eNB触发的释放原因有： 用户不活动 RRC信令完整性校验失败（再三） 因为UE产生信令连接释放而释放 未知错误 O&amp;M干预 MME触发的释放原因有： 鉴权失败 detach 不允许CSG小区 另外，S1释放可以被其他另外两个因素，例如处理超负荷，没有足够可用的用户面处理资源等等。图1展示了在S1释放前后，控制面和用户面UE和MME的状态。在释放前，EPS承载和信令连接建立来支持用户网络之间的流量传输。EPS承载包括DRB，S1承载，S5承载。信令连接包含ECM（RRC+S1信令连接），S11和S5连接。UE和MME都在emm-registered状态和ecm-connected状态，UE和eNB在rrc-connected状态。在S1释放后，用户面的DRB和下行S1承载被释放，在控制面ECM（RRC+S1信令连接）连接丢失，释放E-UTRAN资源。应该注意的是，这时候只有下行S1承载释放了，上行的S1承载还在保持着。S1释放不同于在detach过程中释放一样。在detach过程中，所有分配给UE的资源都被释放，UE转移到emm-deregistered状态。而在S1释放过程中，只有由无线接入网络分配的这些资源释放，而被EPC分配的资源则没有释放。所以UE保持在emm-registered状态，转移到ecm-idle状态。在接下来，当有上下行用户流量时，ECM连接和DRB/S1承载（下行）建立起来，UE状态转到ecm-connected并传输用户流量。 图2描述了由eNB触发的一旦用户不活动时S1释放过程。在由MME触发的S1释放情景中步骤1和2保留。 1）【eNB-&gt;MME】请求UE上下文释放一旦检测到用户不活动，eNB发送给MME UE Context Release Request消息，伴随着释放的原因，来释放UE上下文。 2）【MME-&gt;SGW】请求S1承载释放MME通过发送给SGW Release Access Bearers Request消息来请求SGW释放和eNB关联的资源，S1的下行端口。通过这个消息，通知SGW没有下行流量传输给UE了。 3）【SGW】下行S1承载释放SGW释放和UE关联的所有下行S1承载（eNB相关的资源，包含eNB分配的下行S1 TEID等等）但是保留着上行S1承载资源（SGW相关的资源，包括上行S1 TEID和自己分配的上行S1 TEID等等）。所以当上行数据包到达时，eNB可以保持上行S1 TEID，通过S1承载无延迟的传输这些数据包。 4）【MME&lt;-SGW】响应S1 Bearer Release RequestSGW通过发送Release Access Bearers Response消息来确认下行S1承载资源已经被释放了。之后，如果有到达UE的下行数据包到达，SGW缓存他们，然后在下行S1承载重建之后再传输。详细的步骤将在下面文档中解释EMM case-4、 5）【eNB&lt;-MME】UE Context Release CommandMME给eNB发送UE Context Release Command消息来释放存储在eNB中的UE上下文。 6) [UE &lt;- eNB] RRC Connection ReleaseeNB一旦从MME接收到命令，将删除eNB具有所有UE上下文。如果RRC连接还没有释放，eNB发送给UE RRC Connection Release消息来释放。通过这个消息，eNB释放和UE相关的所有无线资源和承载，并伤处UE上下文。 7) [eNB -&gt; MME] UE Context Release CompleteeNB给MME发送UE Context Release Complete message作为步骤5的响应。MME确认UE所有的上下文已经删除了。 8) 【MME】 S1 ReleaseMME释放在UE上下文中所有eNB相关的信息，除了上行S1承载信息。但是保留和eNB不关联的信息。 III. EPS Entity Information: Before/After S1 Release这章将学习在S1释放前后EPS实体中信息的变化。所有的信息分类为UE ID，UE Location，安全和EPS会话/承载信息。 3.1 Before S1 Release在S1释放之前，UE连接到网络，在EMM-Registered, ECMConnected and RRC-Connected 状态下使用服务。所有的EPS实体保持着和初始附着后相同的信息。图3列出来在S1释放之前所有EPS实体的信息。 3.2 After S1 Release在S1释放之后，UE仍然注册在网络上，但是是在EMM-Registered, ECM-Idle and RRC-Idle状态，不使用任何服务。因为UE和任何eNB没有连接，所有UE请求连接eNB和传输数据需要的信息被释放。在控制面，ECM连接（RRC和S1信令连接）被释放，在用户面DRB和下行S1承载被释放。图4列出了在S1释放之后每一个实体中的信息。在S1释放的信息被标记为灰色。 在UE中删除的信息： C-RNTI：在UE要连接小区中标识UE的ID。 ECGI：在UE要连接的小区上的信息 DRB ID：在无线链路上的EPS承载的ID。由eNB分配给UE。 AS Security Info: 在UE和eNB之间的AS安全上下文。 在eNB中删除的信息： 所有的信息 在MME删除的信息： S1AP UE ID：用在S1信令连接的UE ID信息(eNB S1AP UE ID and MME S1AP UE ID) ECGI: 在UE要连接的小区上的信息 S1 TEID (DL): 在下行S1承载上使用的TEID信息 在SGW删除的信息 S1 TEID (DL): 在下行S1承载上使用的TEID信息 ECGI: 在UE要连接的小区上的信息 IV. Closing我们已经讨论完了当用户不活动时S1释放过程。接下来我们学习service request过程。 References[1] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[2] Netmanias Technical Document, “LTE EMM Procedure 1. Initial Attach – Part 2. Call Flow of InitialAttach”, January 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6102[3] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12-EMM Procedure 2. Detach]]></title>
    <url>%2F2016%2F04%2F03%2F12-EMM-Procedure-2-Detach%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6108 I. Introduction这篇文档讨论EMM case-2。在这个过程中，用户从附着的网络上去附着。用户在EMM case-1通过初始附着附着到网络上在emm-registered状态使用LTE服务，在使用服务后，当在ECM/RRC-connected状态或者ECM/RRC-idle状态下用户可能被网络或者UE去附着。无论任何一种情况，一旦去附着过程完毕，用户的EPS承载释放并且状态信息清除。 这篇文档介绍LTE网络的detach过程，组织如下：第二章根据detach是谁发起的来定义不同的类型，第三章描述每一个detach类型的具体过程，第四章深入了解在detach后每一个EPS实体的信息有如何变化。 II. Cases of Detach通过初始附着生成EPS会话和默认EPS承载之后用户可以使用LTE服务。在一些情况下，用户一旦使用完了服务可以may从网络detach。在另外一些情况下，用户一直在使用网络服务时被网络detach，然后不能和网络保持连接了。 一旦用户从网络detach，所有分配给这个用户的EPS会话和承载都将被释放。释放过程将删除用户的MM上下文和给EPS实体设置的EPS承载。这时，EMM状态从registered转到de-registered。如果用户正确的detach了，GUTI，NAS层的用户ID和安全上下文，用户接入网络所需要的这些信息都将在UE和MME中保持有效，所以用户可以在下一次接入网络时使用这些信息。 detach可以由UE和网络来触发。网络触发的detach是由MME或者HSS引起的。detach根据在哪里触发可以分为以下几类：1) Detach Case 1: UE发起的DetachUE可以发起detach: 如果UE关机 USIM从UE中移除 UE试图使用non-EPS服务（比如，CSFB，SMS等等） 2) Detach Case 2: MME发起的DetachMME发起detach可以更信息分为显式detach和隐式detach。对于显式detach，MME通过发送detach request消息提前通知UE它要detach，并通知UE在detach之后是否要重新attach。对于隐式detach，MME不通知UE就发起detach过程，因为UE没有能力和MME通信。MME可以发起 i)显式detach 运营商O&amp;M（操作或者维护）的目的 重新鉴权失败 如果MME不能为用户提供分配资源 ii）隐式detach 由于无线链路质量比较差导致不能和用户通信（比如RLF） 3) Detach Case 3: HSS发起的DetachHSS可以发起detach: 如果HSS提供的用户配置文件发生变化，保存在MME中的配置文件也不得不改变时 如果运营商试图限制一个非法的UE接入网络 在下面几章中，我们将描述下面三种类型的详细过程。在这个三个类型中，假设用户在detach之前处于emm-registered ecm-connected rrc-connected状态，并且仅仅通过默认EPS承载提供服务。图1描述了建立了哪些连接，在detach前后用户和控制面的UE和MME都处于什么状态。在detach之前，已经建立默认EPS承载和相关的控制连接，用户处于emm-registered ecm-connected rrc-connected状态。在detach之后，默认EPS承载和所有的信令连接都被释放，用户进入EMM-Deregistered, ECM-Idle and RRC-Idle状态。 III. UE-initiated Detach图2展示了用户发起的detach是怎么执行的。用户发起的detach是由UE触发的，由UE发送detach request消息。当UE接收到MME的detach accept消息（除非用户关机情况下）这个过程结束。 ❶ UE触发detach当检测到UE触发detach，UE和MME都能感知到，这两个实体开始以下的过程：1）【UE-&gt;MME】detach requestUE通过发送detach request消息给MME，请求MME detach。detach request消息参数根据这个消息传送的方向有不同的解释。如果是从UE到MME，这个消息参数如下所示：Detach Request (GUTI, KSIASME, Detach Type(Switch Off)) GUTI：MME在网络attach时分配的用户ID KSI-ASME：UE使用的KSI值 detach type：只是detach的类型 switch off：只是detach是normal detach（0）还是switch off（1） type of detach：EPS detach 2）【UE】处理安全和承载上下文在发送完detach request消息后，UE存储它当前NAS安全上下文，GUTI和TA信息，并删除EPS承载上下文。 3）【MME】通知detach意图和处理安全上下文在接收到detach request消息后，MME可以知道UE detach的意图。并存储用户当前NAS安全上下文，检查detach的类型，例如，是否是normal detach或者关机。通过上述步骤，MME可以知道是否需要发送detach accept消息。 ❷ EPS会话终止一旦MME感知到UE发起的detach并存储用户当前NAS安全上下文，请求对已经激活EPS会话的终止。这个请求触发PCEF（PGW）发起EPS终止，释放所有分配给用户的网络/无线资源。 1）EPS承载释放和PCC策略移除4）【MME-&gt;SGW】请求EPS会话释放MME和SGW在S11接口上通过GTP-C协议通信。MME通过发送给SGW一个delete session request消息来请求删除用户的会话和默认EPS承载。这时，在消息中传递 默认EPS承载ID和UE位置信息 (ECGI, TAI)。 5）【MME】删除EPS承载上下文MME在发送delete session request消息后删除用户EPS承载上下文。 6）【SGW-&gt;PGW】请求EPS会话释放SGW和PGW在S5接口上通过GTP协议相互通信。SGW转发从MME接收到的delete session request消息给PGW。 7）【SGW】删除EPS承载上下文SGW在发送delete session request消息后删除用户EPS承载上下文。 8）【PGW-&gt;PCRF】通知EPS会话终止PGW和PCRF在Gx接口上通过Diameter协议通信。PGW发送给PCRF一个CCR（CC-request）消息来通知PCRF用户已经结束了使用服务。这样，它就可以发起EPS会话终止过程。 9）【PCRF】删除PCC策略一旦PCRF从PGW收到CCR消息，PCRF删除用户的PCC策略。 10）【PGW&lt;-PCEF】确认EPS会话终止PCRF通过发送给PGW CCA（CC-answer）消息来确认用户的PCC策略已经删除了。 11）【SGW&lt;-PGW】响应EPS delete session request当PGW从PCRF接收到CCA消息，PGW发送给SGW一个Delete Session Response消息作为对delete session request消息的响应。 12）【PGW】删除EPS承载上下文在发送delete session response消息后，PGW删除用户的EPS承载上下文。 13）【MME&lt;-SGW】响应EPS Session Release Request当SGW从PGW接收到delete session response消息后，SGW发送给MME delete session response消息作为对delete session request消息的响应。 14）【MME&lt;-UE】确认detach一旦接受到delete session response消息，MME确认用户资源释放已经由PCRF同意了。接着MME发送给UE detach accept接收到作为detach request消息的响应。detach accept消息仅仅当UE的detach请求原因除关机之外的情况下才发送。如果detach 请求原因是因为设备关机，么么不会发送detach accept消息。 (2) S1信令连接释放一旦发送完detach accept 消息给UE之后，么么和eNB释放分配给用户的所有资源（S1信令连接，RRC连接和eNB中的UE上下文），以为UE不要他们的服务了。 15）【eNB&lt;-MME】确认S1信令连接释放MME发送UE Context Release Command给eNB来释放S1信令连接。 16）【UE&lt;-】RRC连接释放eNB发送RRC Connection Release消息给UE来释放任何没有释放的RRC连接。 17）【eNB】删除UE上下文eNB删除所有和UE相关的信息。 18）【eNB-&gt;MME】RRC Connection Release Complete最后eNB发送给MME UE Context Release Complete消息作为对15）请求消息的响应。 IV. MME-initiated Detach图3显示了MME发起的detach是怎么执行的。MME发起的detach是由MME触发，接着MME发送detach request消息给UE，当分配UE的EPS会话资源都被释放后这个过程结束。 ❶ MME触发的detach下面描述了MME检测到detach触发之后，在EPS会话终止过程执行之前的步骤。如果用户这时处于idle状态，MME执行寻呼来建立S1信令连接。1）【UE-&gt;MME】detach request因为这是一个显式detach，MME发送detach request消息来请求UE detach。消息参数包含如下：Detach Request (Detach Type(Re-attach required or not), Cause) detach type：指示UE在detach之后是否需要重新attach（001-需要重新attach，010-不需要重新attach） cause：指示detach的原因 对于隐式detach，MME不发送detach request消息给UE。 2）【MME】处理安全上下文在发送detach request消息给UE之后，MME在删除EPS会话之前存储当前NAS安全上下文。下次重新attach时，MME可以使用这些存储的上下文，并跳过鉴权和ＮＡＳ安全建立过程。 3）【UE】通知detach意图和处理安全承载上下文在接收到MME发送的detach request后，UE获知MME detach的意图。UE检查detach的类型是否需要在detach之后重新attach。然后存储当前NAS安全上下文，并删除EPS承载上下文。 ❷ EPS会话终止一旦MME存储NAS安全上下文，MME请求PGW终止用户的EPS会话。这个请求触发PCEF（PGW）发起EPS终止过程，释放分配给用户的所有网络无线资源。（1）EPS承载释放和PCC规则移除通过4）~13），MME请求终止用户EPS会话，PCEF一旦接收到请求删除PCC规则，删除S5承载资源。在MME发起的detach中需要重新attach时，MME可以保存当前的UE-AMBR，在下次重新attach时UE可以更快的建立EPS承载。 14）【UE-&gt;MME】确认detach一旦接收到detach request消息，在存储NAS安全上下文和删除EPS承载上下文之后，UE发送detach accept消息作为detach request像爱惜的响应。对于隐式detach的情况，1）14）16）步骤是跳过的。 （2）S1信令连接释放在这节中，MME在接收到UE发送的detach accept消息和从SGW发送的delete session response消息后，释放所有未释放的资源。这节的过程和第三章的15-18步相同，除了detach 类型是允许重新attach，UE是在RRC连接释放完成后重新attach到网络的。 V. HSS-initiated Detach图4描述了HSS发起detach的过程 ❶ HSS触发的detach当因为签约信息退回由HSS触发detach，HSS试图立即删除用户的MM上下文和EPS承载。1) 【MME&lt;-HSS】 Detach RequestHSS和MME在S6a接口上通过Diameter协议相互通信。HSS通过发送请求给MME Cancel Location Request (CLR)消息来detach用户。使用以下参数：Cancel Location Request (IMSI, Cancellation Type) IMSI：要detach的用户ID cancellation type = Subscription Withdrawn：指示detach的原因 ❷ EPS会话终止一旦从HSS接收到Cancel Location Request (CLR) 消息，MME释放之前分配给UE的所有资源。这个步骤和MME发起detach的过程是一样的，除了在2）中描述的额外的步骤。MME需要发送给HSS Cancel Location Answer消息作为Cancel Location Request消息的响应。 2) [MME -&gt; HSS] 响应Detach Request一旦从UE接收到detach accept消息，和从SGW接收到delete session response消息，MME会发送给HSS Cancel Location Answer消息作为Cancel Location Request消息的响应。 VI. EPS Entity Information: Before/After Detach这章描述了在执行“EMM Case 2: Detach”步骤之后EPS实体中的信息是如何变化的。每一个实体中的所有信息被分类为UE ID，UE Location，安全和EPS会话/承载信息。 6.1 Before Detach在detach之前用户处于ECM/RRC-Connected状态。所以在detach之前，所有的EPS实体都有和初始附着完成后他们具有的信息相同。图5列出了在detach之前每一个实体中所有的信息。 6.2 After Detach在detach之后，用于用户下次更快和安全attach的信息存储在UE和MME中。所有和用户相关的其他上下文信息，例如NAS安全上下文，GUTI，MME分配的TAI信息都将会释放。图6列出了在detach之后每一个EPS实体中的信息。在detach之后需要删除的信息标示为灰色，不要保留的信息标示为黑色，在下次attach时需要使用的信息被表示为蓝色。 VII. Closing我们已经学习了连接到LTE网络的用户从网络detach的过程。我们根据触发的位置分类detach类型，并对每一种类型进行详细的讲解。我们对比了detach前后每一个实体存储信息的变化。接下来的文档将讨论在用户不活动时删除S1资源的情况。 References[1] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[2] Netmanias Technical Document, “LTE EMM Procedure 1. Initial Attach – Part 2. Call Flow of InitialAttach” , January 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6102[3] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11-EMM Procedure 1. Initial Attach Part2]]></title>
    <url>%2F2016%2F04%2F03%2F11-EMM-Procedure-1-Initial-Attach-Part2%2F</url>
    <content type="text"><![CDATA[EMM Procedure 1. Initial AttachPart 2. Call Flow of Initial Attach 原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6102 I. Introduction我们首先详细探讨EMM case-1：unknown UE的初始附着。这是当用户在签约LTE网络之后，首次打开UE并尝试附着到网络上。之前被分类为attach case-1。 这个文档组织如下：第二章讨论EMM case-1的详细过程，关注在在这个case中的功能需求。第三章描述在初始附着之后每一个实体中哪些信息发生了变化。 II. Initial Attach Procedure图1描述了EMM case1的初始附着过程，还有在每一个流程中的功能模块需求。 2.1 IMSI获取图2展示了这个流程中的第一步。在这一步结束后，MME从UE获得IMSI。UE用attach request包含IMSI试图初始附着到网络上，MME从这个消息中获得IMSI。这一步可以细分为两小步：1）UE在无线连接同步之后待在初始状态2）UE建立ECM连接来传送attach request消息给MME。ECM建立连接过程又可以分为两个子过程，1）RRC连接建立过程2）S1信令连接建立过程。 1）在无线连接同步之后初始状态 为了UE请求附着到网络上，和eNB通信是必须的。所以UE通过PLMN选择和小区搜索过程选择一个eNB，并无线连接同步。接着用户可以和eNB通信了。在这个时候，UE是EMM-deregistered ECM-idle/rrc-idle状态。 2）ECM连接建立 在NAS层上，UE发送attach request消息（包含IMSI和UE网络能力信息）给MME的NAS层来请求初始附着。为了能使attach request消息传输，在UE和MME之间的ECM连接时需要的。对于ECM连接，包含UE和eNB之间的RRC连接，eNB和MME之间的S1信令连接。NAS消息发送首先作为RRC消息通过RRC连接传输，然后通过S1信令连接作为S1AP消息传送（initial UE message初始UE消息）。 （1）RRC连接建立RRC连接时建立在UE和eNB的RRC层之间的。一旦建立完成，在控制面传输消息到RRC层或者上层（NAS层）时使用RRC连接。建立RRC连接的过程如下所示： 1) [UE -&gt; eNB] RRC Connection RequestUE通过发送RRC connection request消息给eNB来请求RRC连接。当UE请求attach，detach，TAU时都是用“Mobile Originating Signaling”，它是一个值，包含在Establishment Cause域。这个消息通过SRB0，CCCH，逻辑信道由UE发送给eNB。SRB0可以被这个小区的所有UE使用。 2) [UE &lt;- eNB] RRC Connection SetupeNB通过发送给UE RRC connection setup消息来为UE分配专有SRB1，这个消息是通过SRB0 CCCH传输的。UE的上行和下行无线资源是由eNB控制的。所以当完成这一步之后，UE通过使用RRC connection setup消息分配的SRB配置信息来使用无线资源。然后UE转到到EMM-deregistered ECM-idle RRC-connected状态。 3) [UE -&gt; eNB] RRC Connection Setup CompleteUE通过使用SRB1 DCCH发送RRC connection setup complete消息通知eNB RRC连接建立完成了。为了有效的传输，当RRC Connection Setup Complete消息传输时，传输到NAS层的attach request消息也被发送到eNB（嵌入到RRC Connection Setup Complete消息的专用NAS信息域DedicatedInfoNAS）。 （2）S1信令连接建立 在eNB和MME之间的控制信息时通过S1-MME接口嵌入到S1AP消息中发送的。S1AP消息是通过为他们专有建立的S1信令连接来传送的。S1信令连接使用eNB和MME分配的ID对（eNB UE S1AP ID, MME UE S1AP ID）来定义标示UE。 在图2中，第一个NAS消息attach request消息在S1信令连接建立之前到达eNB。 eNB接着分配eNB UE S1AP ID用于S1信令连接的建立，并发送给MME attach request消息，嵌入到initial UE message中。attach request消息嵌入到initial UE message消息的NAS-PDU域。这个initial UE message消息包含以下信息字段： Initial UE Message (eNB UE S1AP ID, NAS-PDU, TAI, ECGI, RRC Establishment Cause) eNB UE S1AP ID: 在S1-MME接口上(Uplink)在eNB中标识UE NAS-PDU: a NAS message (Attach Request) TAI: 标识UE待在的TA ECGI: 标识UE待在的小区 RRC Establishment Cause = mo-Signaling: 标识这个信令是UE产生的 当MME在S1-MME接口从eNB接收到这个initial UE message消息，MME为UE分配一个 MME S1AP UE ID。现在有了新分配的这个ID和之前分配的eNB UE S1AP ID，在这两个实体间的S1信令连接建立起来了。接下来MME S1AP UE ID会用于在S1-MME接口（下行）上MME标识UE。 （3）ECM S1连接建立 通过步骤（1）（2），在UE和MME的NAS层之前的ECM连接建立起来了。接着UE转移到EMM-registered ECM-connected RRC-connected状态。 （4）IMSI获取 MME的NAS层从UE的NAS发送的attach request消息中获取的UE的IMSI，通过UE的网络能力信息可以知道UE使用的安全算法和安全能力。 在从attach request消息中获取UE的IMSI和安全能力信息之后，MME执行鉴权和NAS安全建立过程用于NAS消息的安全传输（根据EPS AKA过程使用收集到的信息）。这两个过程—鉴权和NAS安全建立—是在2.2和2.3节描述。我们已经在LTE安全文档中详细介绍了，在这里我们将简单介绍一下。 2.2 鉴权图3描述了UE和MME之间的鉴权过程。这个过程包含两部分，1）鉴权向量获取，MME从HSS获取鉴权向量，2）相互鉴权。在第一步中是在MME和HSS之间S6a接口使用Diameter协议来执行。第二步在UE和MME之间使用NAS协议执行。 （1）鉴权向量的获取1）【MME-&gt;HSS】authentication information RequestMME向HSS发送authentication information Request消息，请求鉴权向量AV。这时候，在这个消息中包含UE的SN ID（服务网络ID）和IMSI，确保HSS返回的是UE当前服务网络信息。authentication information Request消息的主要参数包括： Authentication Information Request (IMSI, SN ID) IMSI: Subscriber identifier (a fixed value provisioned at HSS for a UE) SN ID: indicates the serving network of a subscriber, and consists of an PLMN ID (MCC+MNC) 2）【HSS】产生鉴权向量HSS使用在IMSI中的LTE K和SN ID来生成鉴权向量。鉴权向量生成包含下面两步：第一，HSS生成SQN和RAND，接着在加密函数中输入{LTE K,SQN, RAND} 生成了{XRES, AUTN, CK, IK}. 接着在秘钥生成函数中输入 {SQN, SN ID, CK, IK} 生成KASME。 鉴权向量的最终格式是{RAND, AUTN, XRES, KASME}, 每一个鉴权向量单元的角色如下： Authentication Vectors (RAND, AUTN, XRES, KASME) RAND: HSS生成的随机数，并发送至UE。UE使用它来生成自己的鉴权向量 AUTN: HSS生成的鉴权令牌，并发送至UE，UE在生成自己的鉴权向量之后，和自己对比的鉴权令牌来鉴权网络 XRES: HSS生成的值。MME保留这个值而不发送给UE，接着MME和UE发过来的RES对比来鉴权用户。 KASME: 接入网络的顶层秘钥，由UE和HSS生成，并由HSS发送至MME。它作为MME和UE的基本秘钥用来生成NAS安全秘钥。 3）【MME&lt;-HSS】传输鉴权向量HSS在authentication information Response消息中包含鉴权向量发送给MME。MME接着使用这些信息和UE相互鉴权。 （2）相互鉴权LTE需要相互鉴权。用户必须鉴权网络，网络必须鉴权用户。一旦MME从HSS接收到鉴权向量{RAND, AUTN, XRES, KASME}，它把RAND和AUTN发送给UE，UE使用它们来生成鉴权向量，并鉴权网络。MME保留着XRES, KASME用来用户鉴权和NAS安全秘钥生成。KASME是不会传输UE的。但是KASME的索引KSI-ASME是传输给UE的。相互鉴权过程如下： 4）【UE&lt;-MME】MME请求用户鉴权MME传输authentication Request消息（RAND, AUTN, KSIASME）给UE。 5）【UE】用户鉴权网络：生成鉴权向量并鉴权网络一旦接收到authentication Request消息（RAND, AUTN, KSI-ASME），UE首先从AUTN中生成SQN，接着像图4HSS那样生成鉴权向量。接着UE对比自己生成的AUTN-UE和接收到的AUTN来鉴权网络。并存储 KSI-ASME作为K-ASME的索引。 6）【UE-&gt;MME】用户的RES传输给MME通过对比AUTN，用户完成网络鉴权之后，UE发送自己生成的RES到MME，包含在authentication Response消息中。这样MME就可以鉴权用户了。 7）【MME】网络鉴权UE一旦接收到authentication Response消息，MME对比UE发过来的RES和从HSS接收到的XRES来鉴权用户。 一旦上述步骤完成后，UE和网络就完成了相互鉴权。现在将开始建立NAS安全。 2.3 NAS安全建立一旦用户鉴权完成，MME发起NAS安全建立过程为了NAS消息可以安全的传输。图5展示NAS安全建立过程的流程。 1）【MME】生成NAS安全秘钥MME从attach Request消息中选择应用于NAS消息的加密和完整性算法。接着，从K-ASME中生成NAS完整性秘钥和NAS加密秘钥K-NASint/K-NASenc，应用于NAS消息。 2）【UE&lt;-MME】帮助UE生成NAS安全秘钥MME通过Security mode command消息(KSIASME, Security Algorithm, NAS-MAC)通知给UE选择的加密算法，帮助UE生成NAS安全秘钥。这个消息时包含NAS-MAC完整性保护的。 3）【UE】产生NAS安全秘钥 当UE收到Security mode command消息，UE通过使用MME选择的NAS安全算法来生成NAS安全秘钥(KNASint and KNASenc)。并通过NAS完整性秘钥(KNASint)来对Security mode command消息进行完整性检查。如果完整性检查通过，表示NAS安全秘钥成功设置并工作正常。 4）【UE-&gt;MME】NAS安全秘钥生成完毕UE通过发送Security mode complete消息通知给MME NAS安全秘钥成功生成，接着可以使用生成的秘钥来加密和完整性保护。 在完整上述步骤之后，NAS安全建立过程结束。接着来UE和MME之间的消息都是安全传输的（使用加密和完整性保护）。 2.4 位置更新一旦完成鉴权和NAS安全建立过程，MME需要注册签约用户，并找出来签约用户使用的服务。MME通知HSS签约用户已经注册了并驻留在它的TA，接着从HSS下载签约用户信息。所有这些过程都是通过MME和HSS之间S6a接口的Diameter协议来执行位置更新过程来完成的。具体过程如图6所示。 1）【MME-&gt;HSS】通告UE位置MME向HSS发送update location Request（IMSI，MME ID）消息为了通告UE的注册和获取UE的签约信息。 2）【HSS】UE位置更新HSS注册MME ID来指示UE驻留的哪个MME。 3）【MME&lt;-HSS】用户签约信息的传输HSS把用户的签约信息包含在update location answer消息中发送给MME，MME创建这个签约用户的EPS会话和默认EPS承载。包含在update location answer消息中的签约信息如下： Update Location Answer (IMSI, Subscribed APN, Subscribed P-GW ID, Subscribed QoS Profile) Subscribed APN: 用户签约的APN (e.g. Internet service) Subscribed P-GW ID: 用户接入签约APN通过的那个PGW的ID Subscribed QoS Profile(UE-AMBR(UL/DL), QCI, ARP, APN-AMBR(UL/DL)) UE-AMBR (UL/DL): MME决定和eNB控制的UE具有所有的nonGBR承载的聚合带宽 QCI, ARP, APN-AMBR (UL/DL): 应用于签约APN的QoS 4）【MME】存储签约信息MME从HSS接收到update location answer消息后，存储这个消息中的签约信息。 从下载的签约信息，MME可以检查用户签约的服务，使用什么QoS级别的资源来连接到哪个APN。 2.5 EPS会话建立MME基于签约信息建立EPS会话和默认EPS承载。MME为每一个用户提供满足用户签约QoS的网络/无线资源。图7/8描述了EPS会话和默认EPS承载建立过程。 1）【MME】分配EPS承载IDMME从5-15选择一个值，分配作为EPS承载ID（EBI）来为新附着的用户连接默认EPS承载。 2）【MME】选择PGWMME检查从HSS接收到的APN，并决定使用哪个PGW来接入这个APN。这个决定是基于从HSS接收到的签约信息（PGW ID）。或者如果没有这些信息，MME请求DNS服务器获得APN FQDN(e.g. internet.apn.epc.mnc05.mcc450.3gppnetwork.org), 并从按照PGW选择策略返回的PGW IP地址列表中选择一个。这时候，也需要选择一个SGW来到达PGW。 3）~4）请求EPS会话创建MME通过给PGW发送create session Request消息来请求EPS会话和默认EPS承载的创建。在这个消息中，MME包含从HSS接收到的用户签约信息，当请求PCRF创建EPS会话时，PGW可以使用这些信息。这时候，UE-AMBR还没有包含，因为它是由MME决定的。 3）【MME-&gt;SGW】请求EPS会话创建MME和SGW在控制面使用GTP协议在S11接口上通信。MME发送给第二步选择的SGW create session Request消息，包含以下参数： Create Session Request (IMSI, EPS Bearer ID, P-GW IP, APN, Subscribed Profile (QCI, ARP, APNAMBR (UL/DL)), ECGI, TAI) IMSI: 固定的用户ID EPS Bearer ID: 由MME分配的默认EPS承载ID P-GW IP: MME选择用于EPS会话/承载创建的PGW IP地址 APN: 用户签约的APN Subscribed Profile (QCI, ARP, APN-AMBR (UL/DL)): 建立默认EPS承载时使用的QoS信息 ECGI: 用户驻留的小区 TAI: 用户驻留的TA 4）【SGW-&gt;PGW】请求EPS会话的创建SGW和PGW在S5接口上用户面和控制面使用GTP（UP：GTP-U，CP：GTP-C）协议通信。SGW在create session Request消息中分配S5 TEID来建立到PGW的S5 GTP。接着在create session request消息中发送这个ID和其他参数给PGW。 Create Session Request (IMSI, EPS Bearer ID, S5 S-GW TEID, APN, Subscribed Profile (QCI, ARP, APN- AMBR (UL/DL)), ECGI, TAI) 5）【S5 承载：下行】一旦4）完成之后，下行S5 GTP-U隧道就建立起来了，允许PGW发送下行流量给SGW。在图7和8中，分配和发送GTP隧道TEID的实体被标记为实点，接收的一个被标记为虚点。 6）【PGW】分配用户IP地址PGW一旦接收到create session request消息，意识到用户试图通过IMSI接入网络。所以PGW给UE分配IP地址，让UE可以使用IP。 7）【PGW-&gt;PCRF】通知EPS会话建立PGW和PCRF通过Gx接口使用Diameter协议通信。当创建了用户的EPS会话，用户的资源配置和QoS控制都必须基于用户订阅的服务来决定。PCRF负责所有接入网络UE的接入策略。所以，PGW提供给PCRF用户的签约信息，并获取资源分配和网络运营商策略的PCRF授权。从UE的签约信息（从MME接收到的），PGW获取用于PCRF运营商策略决策制定的信息，并通过CCR消息（CC-request）发送这些信息给PCRF。这个消息实例如下：CCR (IMSI, UE IP, PDN ID (APN), Subscribed QoS Profile (QCI, ARP, APN-AMBR (UL/DL)), ECGI,TAI)： IMSI: 固定的用户ID UE IP: 正在服务中的用户使用的IP地址 PDN ID: 用户使用的APN Subscribed Profile (QCI, ARP, APN-AMBR (UL/DL)): 建立默认EPS承载时应用的QoS信息 ECGI: UE驻留的小区 TAI: UE驻留的TA 8）【PCRF-&gt;SPR】请求接入配置PCRF向SPR请求用户接入配置文件来决定用户的PCC策略 9）【PCRF&lt;-SPR】返回接入配置SPR返回用户的接入配置文件。这个配置文件包含的信息例如，SDF Filter, QCI, ARP, APN-AMBR (UL/DL), Charging Method (e.g. Offline), Changing Reporting Action (e.g. Start Reporting ECGI, TAI),等等 10）【PCRF】决定策略PCRF决定EPS会话建立（基于用户接入配置文件）的PCC策略。 11）【PGW&lt;-PCRF】确认EPS会话建立PCRF传输决定好的PCC策略给PGW，包含在CCA（CC-answer）消息中。这个消息的实例如下：CCA (IMSI, PCC Rule (SDF Filter, QCI, ARP, APN-AMBR (UL/DL), Charging=Offline, Change Reporting Action (Start Reporting ECGI, TAI)) 12）策略实施PGW应用从PCRF接收到的PCC策略。PCC策略应用到每一个SDF上，所以PGW需要建立SDF和EPS承载之间的映射，并准备应用QoS配置文件到默认EPS承载上。 13）~15）EPS session create responsePGW通过发送create session response消息通知MME，应用于建立EPS会话和默认EPS承载的QoS信息。PCRF可能会保存这个从HSS接收到的值或者选择一个新的值。 13）【SGW&lt;-PGW】EPS session responsePGW为建立到SGW的S5 GTP分配S5 TEID。接着在create session response消息中包含S5 PGW TEID和QoS配置文件应用于默认EPS承载，并发送给SGW作为对create session request消息的响应。Create Session Response (UE IP, EPS Bearer ID, S5 P-GW TEID, Authorized QoS Profile (QCI, ARP,APN-AMBR (UL/DL)), TFT (UL), Change Reporting Action (Start Reporting ECGI, TAI)) 14）【S5承载：上行】S5承载建立在完成13）之后建立了上行S5 GTP-U隧道，允许SGW和PGW剑豪上下行流量。 15）【MME&lt;-SGW】EPS session create response当从PGW接收到create session response消息后，SGW保留上行S5 TEID用于上行流量，并允许S1GTP 隧道的S1 TEID用于S1承载。在处理完这个消息后，SGW在处理完的消息上加入新分配的S1 SGW TEID，然后发送到MME，作为对3）的create session request的响应。 16）【MME】为什么MME保留S5 PGW TEID一旦附着到网络，如果UE执行TAU或者切换，SGW可能发生改变。所以MME通知UE新SGW的上行S5 TEID，这样新SGW可以传输上行流量给PGW。 17）【S1承载：上行】完成15）之后建立了上行S1 GTP隧道。但是因为eNB还没有S1 SGW TEID，所以这是还不能给SGW传输上行流量。 18）【MME】计算ue-ambr这时候，MME返回给attach accept消息给UE作为对attach request消息的响应，并通过控制eNB来转呗e-rab建立（eg，为无线链路和S1承载分配资源）。MME计算ue-ambr值发送给eNB。MME已经接收到ue-ambr值，包含在签约信息中。但是MME可以调整这个值，使之不超过每一个APN的全部apn-ambr，并分配它。 19）决定E-rab和NAS信令需要的信息在从PGW接收到create session response消息之后，MME知道已经指定和分配给用户的资源。接着，MME负责E-RAB的建立，并控制eNB和SGW。最后，MME决定E-RAB建立所需要的资源和NAS信令需要的信息： 分配给UE GUTI代替IMSI 决定和控制TAU相关的参数（TAI列表分配，tau定时器值） 决定eNB使用的ue-ambr值 分配e-rab ID 20）【UE&lt;-MME】attach acceptMME在attach accept消息中包含下面信息：PGW分配的UE IP地址，GUTI，TAI list，EPS bearer ID，MME自己分配的UE-AMBR，从SGW接收到的QoS参数，并发送给UE作为对attach request的响应。这个消息是包含在initial context setup request消息中通过S1信令连接传送的，接着通过RRC连接包含在RRC connection reconfiguration消息中。 21）【MME】生成K-eNBMME从K-asme中生成K-enb，（AS安全基础秘钥）。这是为了确保eNB可以生成AS安全秘钥用于eNB和UE之间无线链路的安全传输。 22）【eNB&lt;-MME】请求e-rab建立MME发送initial context setup request消息，接着eNB和SGW建立起S1承载，和UE建立起DRB承载。这个消息包含以下信息：Initial Context Setup Request (UE-AMBR (UL/DL), E-RAB ID, E-RAB QoS (QCI, ARP), S1 S-GW TEID,KeNB, , UE Security Algorithm, NAS-PDU)： UE-AMBR(UL/DL):只能被eNB控制的QoS参数 E-RAB ID: 由MME分配，并由eNB作为EPS bearer ID使用 E-RAB QoS: 由MME以及与从PGW接收到的EPS bearer QoS来决定 S1 S-GW TEID: 从SGW接收到的上行S1 TEID KeNB: 由MME从Kasme生成的，用于eNB中AS安全秘钥的生成 UE Security Algorithm: 包含在Attach Request消息中，和KeNB一起用来eNB建立AS安全 NAS-PDU: NAS消息 (Attach Accept) 23) [S1 承载: 上行]一旦22）完成，获得了S1 SGW TEID，eNB可以传输上行流量到SGW。当eNB接收到MME的Initial Context Setup Request消息来请求E-RAB建立，eNB通过发送attach accept消息给UE来建立DRB。接着eNB在Initial Context Setup Response消息中包含下行S1 TEID来建立S1承载，并发送Initial Context Setup Response消息到MME来作为Initial Context Setup request消息的响应，所以MME可以转发这个消息给SGW。 24) ~ 27) AS安全建立一旦接收到MME的initial context setup request消息，eNB试图和UE通信建立DRB。为了在无线链路上安全的通信，eNB在发送信息给UE之间需要执行AS安全建立过程。 24) [eNB] 产生AS安全秘钥eNB从KeNB中生成AS安全秘钥用于RRC消息和用户流量的安全传输。eNB从MME传输过来的安全算法中为RRC消息选择加密和完整性算法，并未用户流量选择加密算法。接着，从K-eNB中生成KRRCint/KRRCenc（RRC完整性和加密秘钥）和KUPenc（用于用户数据的加密）。 25) [UE &lt;- eNB] 帮助UE生成AS安全秘钥eNB通过通知给UE选择的AS安全算法来帮助UE生成AS安全秘钥 (KRRCint, KRRCenc and KUPenc)，（使用Security Mode Command(AS Security Algorithm, MAC-I)消息来传输）。eNB发送完整性保护的RRC消息，（包含mac-I）. 26) [UE] 生成AS加密秘钥一旦接受到Security Mode Command 消息，UE通过使用eNB选择的AS安全算法来生成AS安全秘钥，并执行Security Mode Command 消息的完整性检查。 27) [UE -&gt; eNB] AS秘钥生成完成一旦完成对Security Mode Command 消息的完整性检查，AS安全秘钥被成功的建立起来，并准备在UE和eNB之间使用。UE通过使用Security Mode complete (MAC-I) 消息指示eNB AS安全秘钥已经产生。UE使用RRC完整性秘钥来对发送的消息进行完整性保护。随着在无线链路接上AS安全建立过程结束，在随后的无线连接上的RRC消息交换都是加密和完整性保护的，并用户消息是加密传送的。现在eNB开始建立DRB 28) ~ 29) DRB建立28) [UE &lt;- eNB] 重配RRC连接eNB分配上下行 DRB ID，并从E-RAB QoS中配置DRB QoS参数来建立无线连接的DRB。接着通过安全的RRC连接发送RRC connection reconfiguration消息给UE。RRC连接上在UE发送attach request消息时建立。现在RRC连接必须重配，因为UE被允许接入网络后需要根据网络分配的资源来配置参数。UE的RRC层根据RRC connection reconfiguration消息中的配置参数来分配无线资源。接着从RRC connection reconfiguration中提取attach accept消息，并发送到NAS层。当UE的NAS层接收到这个消息，从这个消息中蝴蝶UE IP地址和GUTI，用于接下来的通信需要。 29) [DRB 建立: 上行和下行] DRB建立完成一旦28）完成后，UE可以和eNB之间传输上下行数据。 30) [eNB -&gt; S-GW] E-RAB Setup ResponseeNB为S1承载分配下行S1 TEID (S1 eNB TEID) 。接着在 Initial Context Setup Response消息中包含分配的ID发送给MME，作为 Initial Context Setup request消息的响应，接着MME把这个消息转发给SGW。 31) [eNB] 为S1承载分配下行TEID一旦29）完成后，eNB为S1承载分配了下行TEID，建立下行S1 GTP-U隧道。因为SGW并不知道是否建立，现在它还不能传输下行数据到eNB。 32) [UE -&gt; MME] 发送Attach Complete 消息UE发送Attach Complete消息给MME作为20）的消息的响应。Attach Complete消息是在RRC连接上通过UL Information Transfer消息，在S1信令连接上通过Uplink NAS Transport 消息传输的。 33) [UE][MME] EMM State现在UE和MME处于EMM-Registered状态。如果在20）从MME接收到的是Attach Reject消息，UE必须释放ECM/RRC连接，并且转移到EMM-deregistered状态。 34) [MME -&gt; S-GW] 请求S1承载修改MME通过Modify Bearer Request消息转发从eNB接收到的下行S1 TEID(S1 eNB TEID)给SGW。 35) [MME &lt;- S-GW] 响应S1 Bearer Modification RequestSGW发送给MME Modify Bearer Response消息作为对Modify Bearer Request消息的响应。现在SGW准备传输下行S1数据。 36) [S1 Bearer: Downlink] S1 Bearer Setup Complete在35）完成S1承载建立过程。随着S1承载建立的完成，eNB和SGW可以相互交换数据了。现在从UE一直到PGW的默认承载终于建立起来了，允许在UE和PGW之间传输上下行EPS承载通信。 III. EPS Entity Information: Before/After Initial Attach在这一章，我们将讨论在“EMM Case 1: Initial Attach by Unknown UE”过程前后EPS实体的EMM状态的变化。存储在EPS实体中的信息将会被分组给UE ID信息，UE 位置信息，安全上下文信息，安全上下文信息，EPS会话/承载信息，如图9所示。 3.1 Initial Attach之前图10描述了在“EMM Case 1: Initial Attach by Unknown UE”过程之前每一个实体中的信息。因为EMM case-1是未知用户的初始附着，所以仅包含网络提供的信息。 UE ID information: 在UE, HSS and SPR.中提供的用户的IMSI。 UE Location information: 在UE和网络都没有任何关于UE位置的信息。 Security Context information: 在UE and HSS提供了用于用户鉴权的LTE 主秘钥 EPS Session/Bearer information: 用户签约信息 (Default APN, Subscribed QCI, ARP,UE-AMBR, APN-AMBR, etc.) 和用户接入配置 (Subscribed QCI, ARP, APN-AMBR, etc.)在HSS and SPR中提供。 3.2 Initial Attach之后图11描述了在“EMM Case 1: Initial Attach by Unknown UE”过程之后EPS实体中存储的信息。因为用户已经注册到网络上，所有必要的信息都分配了，信息（用于UE安全接收用户数据和用于在任何设定的位置以想要的服务质量使用服务的信息）都分配了。我们将学习在initial attach之后什么信息发生了变化。 UE ID Information的变化 IMSI: 在EPS承载/会话建立之后，由UE通过attach request消息传输的IMSI被加入到MME, SGW, P-GW and PCRF。 GUTI: 在NAS消息中使用由MME分配的用来代替IMSI的GUTI加入到MME和UE. UE IP address: PGW分配的UE IP地址被加入到P-GW, PCRF, MME and UE. C-RNTI: eNB分配的C-RNTI 用来空中接口物理层识别UE被加入到到eNB和UE. UE S1AP ID: eNB UE S1AP ID和MME UE S1AP ID接入到eNB和MME用来S1-MME接口S1AP消息中标识用户。 UE Location Information的变化 ECGI: 用户驻留小区信息加入到UE, eNB, MME, S-GW, P-GW and PCRF. 每次用户移动到一个新小区，MME通知PGW，接着通知PCRF，用PCRF设定的Change Reporting Action策略通知小区。 TAI: 用户驻留的TA加入到UE, eNB, MME, S-GW, P-GW and PCRF. 每次用户移动到一个新的TA，MME通知PGW，接着通知PCRF，用PCRF设定的Change Reporting Action策略通知TA。 TAI list: UE不需要tau就可以进入的TA列表加入到MME和UE MME ID: 用户附着打MME信息加入到HSS中 Security Context Information的改变 NAS Security Info: NAS安全上下文信息加入到UE和MME中 AS Security Info: AS安全上下文加入到UE和eNB中 EPS Session/Bearer Information的改变 APN in Use: 在EPS会话创建时加入到MME, S-GW, P-GW, PCRF and UE EPS Bearer ID: 加入到MME和默认承载创建的实体，像UE, eNB, S-GW and P-GW. DRB ID: 加入到UE 和eNB使之能在无线连接上通信 E-RAB ID: 在E-RAB创建时加入到eNB和MME中 S1 TEID (UL/DL): 在S1承载建立时加入到eNB, S-GW and MME S5 TEID (UL/DL): 在S5承载建立时加入到S-GW, P-GW and MME QCI: 分配用于所有类型的SDF和EPS承载，加入到UE, eNB, MME, S-GW, P-GW and PCRF. 这个值是由PCRF提供的。 ARP: 分配用于所有类型的SDF和EPS承载，加入到eNB, MME, S-GW, P-GW and PCRF,但是不分配给UE(unlike QCI). 这个值是由PCRF提供的。 UE-AMBR (UL/DL): 在EPS会话和承载创建时加入到MME和eNB中。是由MME计算得到的。 APN-AMBR (UL/DL): 在EPS会话和承载创建时加入到MME和eNB中。这个值是由PCRF提供的。UE只有APN-AMBR（UL）。 TFT (UL/DL): 在EPS承载创建时加入到PGW和UE中。PGW上下行都有这个值，但是UE只有上行有。 SDF Filter: 在EPS会话创建时加入到PCRF。 Subscribed Profile: 在用户位置更新过程时在从HSS中下载签约信息时加入到MME中。 IV. Closing我们讨论了在签约服务之后第一次附着网络initial attach过程。另外，在上面的文档讨论了四种case。在接下来我们将讨论detach过程。 References[1] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[2] Netmanias Technical Document, “EMM Procedure 1. Initial Attach – Part 1. Cases of Initial Attach”,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6098[3] Netmanias Technical Document, “LTE Security II: NAS and AS Security”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5903[4] Netmanias Technical Document, “LTE Security I: LTE Security Concept and LTE Authentication”, Julyhttp://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5902[5] Netmanias Technical Document, “LTE QoS: SDF and EPS Bearer QoS”, September 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5908[6] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10-EMM Procedure 1. Initial Attach Part-1]]></title>
    <url>%2F2016%2F04%2F03%2F10-EMM-Procedure-1-Initial-Attach-Part-1%2F</url>
    <content type="text"><![CDATA[EMM Procedure 1. Initial AttachPart 1. Cases of Initial Attach 原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6098 I. Introduction这个文档讨论初始附着，也就是第九篇文档所讨论的case1。在这个阶段，用户在签约到一个LTE网络服务之后，用户开机，试图附着到网络上，发送IMSI给网络。初始附着过程随着环境发生变化。可以是下面将要讨论的case1也可以是EMM case11（在另外一个城市初始附着，将在后面的文档中讨论）。或者可以使其他类型，取决于用户是否保存着上次附着到网络时使用的信息，（这里是指最后附着信息，或者MME是否有用户的信息，包括UE ID，接下来都是指最后一次UE上下文）。所以这个文档描述了不同初始附着类型，发现他们的特征和不同。接下来的文档part2将描述EMM case1，详细介绍相关的过程。 这个文档组织如下：第二章描述不同的初始附着类型，第三章通过列出MME执行的功能来简要讨论每一种情况的不同初始附着过程。 II. Cases of Initial Attach当UE初始附着到网络，MME根据附着的类型来发起不同的过程。这个过程以attach request消息开始，以attach accept消息结束。当UE发送给MME attach request消息，在这个消息包含UE ID（IMSI or old GUTI）来识别UE。当MME发送attach accept（GUTI和TAI列表）消息，在消息中包含用来代替IMSI的ID —GUTI，和包含TAI列表（在这个区域，UE不需要TAU过程可以进入的区域）。 在接收到attach request消息之后，发送attach accept消息之前，MME可能执行以下过程的全部或部分： UE ID 获取 鉴权 NAS安全建立 位置更新 EPS会话建立 基于UE发起的初始附着的类型，决定要执行哪些过程。但是，UE ID过去和EPS会话建立过程是所有初始附着过程都必须的。其他过程，像鉴权，NAS安全建立和位置更新更具初始附着的类型选择的执行。这些过程的选择受到下面因素的影响：i)UE有的UE ID是什么（IMSI or old GUTI），ii）上次附着信息是否依旧保存在MME中有效等等。在这个文档中，我们将使用下面的判决来分辨初始附着的不同类型，如图1所示。 UE使用什么UE ID累发起初始附着请求（IMSI or old GUTI）？ UE尝试附着的MME是哪个（是上次附着的那个，还是从来没有附着过的一个新的）？ 在网络中是否有有效的UE上下文存在？ 在这个文档中，如果上次UE上下文（包含UE ID）在网络中不存在，UE被定义为未知UE，其他的称为已知UE。2.1节描述未知UE的初始附着，2.2节描述已知UE的初始附着。下面，如果UE有上次附着信息，我们假设attach request消息已经完整性保护的。 2.1 未知UE图2描述了当UE给网络发送了attach request消息初始附着的实例，MME没有关于用户的有效的UE上下文。我们将分辨初始附着的类型，并解释每一种类型的特征比较。现在UE想附着的MME称为新MME，上次UE已经附着过的MME称为旧MME。 attach case-1：当UE使用IMSI来附着 这个是在UE和MME中都没有上次UE上下文，这种情况下需要的场景如下： 1）UE使用IMSI作为UE ID发送给MME attach request消息。MME从这个消息中获得IMSI。2）假设MME不知道UE（以为发送的而是IMSI），MME发起鉴权和NAS安全建立过程。3）MME向HSS发送位置更新消息通知HSS UE已经注册上了，并从HSS中下载这个用户的签约信息。 attach case-2：当UE附着的MME是上次已经附着的MME（new MME=old MME），但是MME没有包含有效的上次UE上下文 这个是当UE在上次附着后仍保留着上次附着信息（old GUTI和NAS安全上下文）时UE尝试附着到相同的MME上，但是MME没有任何UE的上下文。基本的过程如下：1）UE使用old GUTI给新的MME发送attach request消息。这时候，这个attach request消息是使用NAS安全秘钥（K-NASinc）完整性保护的。2）因为GUTI包含GUMMEI，新的MME就可以从old GUTI中知道这个旧的GUTI是从哪里分配的。新的MME查找上次UE上下文，但是没有找到任何信息（例如，完整性验证失败或者没有old GUTI）。3）MME给UE发送identity request消息来请求IMSI。4）UE给MME发送identity response消息提供请求的IMSI。5）现在，MME通过使用获取的IMSI按照attach case-1的流程执行鉴权和NAS安全建立过程，接着发送UE位置更新消息给HSS。 attach case-3：当UE附着到一个之前从来没有附着过的MME上（new MME ！= old MME），且MME没有有效的上次UE上下文信息 这是当UE在上次去附着之后仍然还保留着上次附着信息，附着到一个新的MME，不是旧的MME，但是就的MME没有和UE关联的有效的UE上下文信息。基本过程如下所示：1）UE使用old GUTI作为UE ID给新的MME发送attach request消息，这时候这个消息是完整性保护的2）当新的MME接收到这个消息，他从这个old GUTI知道来自哪里。3）接着，新的MME向旧的MME发送identification request（old GUTI，完整的attach request消息）把旧的GUTI和attach request消息转发给旧的MME。通过这个消息，新的MME请求和旧的GUTI相关的上次UE上下文。4）一旦接收到这个消息，旧MME查找UE上下文，但是没有找到任何信息。5）旧MME给新MME发送identification response消息，通知没有找到UE上下文。 从这儿开始开始和attach case-2相同，执行attach case-2的3/4/5。新MME发送给UE identify request消息来请求IMSI。接着UE携带自己的IMSI使用identify response消息发送给MME。MME接收到IMSI后，MME开始执行鉴权和NAS安全建立和UE位置更新。 2.2 已知UE图3展示了UE发送attach request初始附着到网络，并且MME有用户有效的UE上下文信息的情况。在初始附着时，不像未知UE，所有的已知UE都是使用GUTI，不是IMSI。在图3中，UE和MME中都包含和用户相关的UE上下文信息，并且UE发送的attach request消息是完整性保护的。 attach case-4：当UE附着到上次附着过的MME上，并且这个MME中包含用户有效的上次UE上下文 这是当UE仍旧有上次附着信息（old GUTI，NAS安全上下文），附着到它上次附着的MME，MME具有这个UE的有效UE上下文。具体的场景如下：1）UE使用old GUTI作为自己的UE ID给new MME发送attach request消息。这个attach request消息是使用NAS完整性秘钥K-NASint完整性保护的。2）这个new MME从old GUTI中知道谁分配的这个ID。然后它查找old GUTI，找到有效的UE上下文（IMSI，MM上下文（NAS安全上下文，UE-AMBR））。3）MME对attach request消息执行完整性检查 i)如果完整性检查失败，MME必须使用IMSI来鉴权用户，并执行用户的NAS安全建立过程。 ii）如果完整性检查通过，MME会略过鉴权和NAS安全建立过程。 attach case-5：当UE附着到之前没有附着过的MME上（new MME！=old MME），并且old MME具有有效的上次UE上下文 这是当仍包含上次附着信息，附着到一个新的MME，在旧的MME上具有有效的UE上下文。一个简单过程如下：1）UE使用old GUTI作为自己的UE ID给new MME发送attach request消息。这个attach request消息是完整性保护的。2）new MME从接收到的old GUTI上知道是谁分配的（old MME）。3）new MME向old MME发送identification request（old GUTI，完整的attach request消息），转发old GUTI和attach request消息。通过这样，new MME请求和old GUTI相关联的上次UE上下文信息。4）一旦接收到这个消息，old MME查找UE上下文，找到和这个UE相关联的IMSI和MM上下文（NAS安全上下文，UE-AMBR）。5）old MME对attach request消息执行完整性检查6）old MME把完整性检查的结果通过identification response消息发给new MME i)如果完整性检查失败，old MME在这个消息转发错误原因消息。 ii）如果完整性检查通过，则转发UE上下文（IMSI，old GUTI，MM上下文）。 如果完整性检查失败，情况和attach case-3相同，因此需要执行和attach case-3上相同的IMSI获取，鉴权和NAS安全建立过程。如果检查通过，new MME从old MME接收到IMSI和MM上下文，并略去鉴权和NAS安全建立的过程（类似case-4）。和case-4不同的一点就是因为UE是附着到一个new MME，这个new MME需要和HSS通信更新UE的位置信息。 III. Simplified Call Flow in Each Case第二章介绍了不同类型的初始附着。第三章将描述在每种类型的流程，主要关注在功能模块上。图4描述了基于使用不同的UE ID，每一个初始附着过程具有不同的流程。对于known UE的初始附着情况，我们讨论NAS-MAC完整性检查在什么地方完整。在初始附着过程中执行的功能模块包括： 1）UE ID获取MME获取去UE ID用于用户身份认证和鉴权。UE ID可以是IMSI和old GUTI。IMSI可以通过attach request或者iDentify response消息从UE中获取，而old GUTI可以通过attach request消息从UE中获取。 2）鉴权如果MME通过attach request消息获取IMSI或者old GUTI作为UE ID，但是这个消息的完整性检查失败了，网络检查是否需要通过执行EPS AKA过程来允许UE附着。通过产生鉴权向量并发送到MME，HSS产生K-ASME（MME基本秘钥），接着和UE之间执行相互鉴权。 3） NAS安全建立一旦用户鉴权完成，产生了在UE和MME之间用于NAS消息安全传输的NAS安全秘钥。 4）位置更新MME从HSS下载用户信息，并且HSS更新UE当前位置的信息。MME只有当i)UE使用IMSI作为UE ID时ii）MME没有有效的上次UE上下文信息iii）MME没有关于用户的任何签约信息iv）UE上次从其他MME上去附着，这些情况下MME才会执行位置更新。 5）EPS会话建立EPS会话和默认承载建立。 3.1 使用IMSI初始附着attach case-1：unknown UE UE使用IMSI请求初始附着，MME从attach request消息中获取用户的IMSI。 【UE-&gt;MME】attach request（IMSI） 在初始附着时UE如果使用IMSI，MME会执行鉴权，NAS安全建立和位置更新，建立EPS会话/默认EPS承载。 3.2 使用GUTI初始附着attach case-2：unknown UE，MME unchanged UE使用old GUTI请求初始附着，但是MME中没有old GUTI。所以MME向UE请求UE ID，并获取IMSI。 【UE-&gt;MME】 attach request（old GUTI）【MME】 no IMSI【UE&lt;-MME】 identity request（UE ID=IMSI）【UE-&gt;MME】identity response（IMSI） 剩下来的过程和case-1相同。也就是，MME执行鉴权，NAS安全建立，位置更新和建立EPS会话/默认EPS承载。 attach case-3：unknown UE，MME changed UE使用old GUTI请求初始附着。所以，new MME向old MME请求上次UE上下文，但是没有接收到任何有效的。所以MME向UE请求UE ID，获取IMSI。 【UE-&gt;new MME】 attach request（old GUTI）【new MME-&gt;old MME】identification request(old GUTI)【old MME】no IMSI【new MME&lt;-old MME】identification response（error cause）【UE&lt;-new MME】identity request （UE ID=IMSI）【UE-&gt;new MME】identify response（IMSI） 剩下的过程和case-1相同。也就是，MME执行鉴权，NAS安全建立，位置更新和建立EPS会话/默认EPS承载。 attach case-4： known UE， MME unchanged UE使用old GUTI请求初始附着，MME有和old GUTI相关的上次UE上下文。所以不需要获取IMSI的步骤。 【UE-&gt;MME】 attach request（old GUTI）【MME】 IMSI，old GUTI，MM上下文 如果在NAS-MAC完整性检查通过，MME可能不执行鉴权，NAS安全建立和位置更新立即建立EPS会话/默认EPS承载。 attach case-5：known UE，MME changed UE使用old GUTI来请求初始附着。所以new MME向old MME请求上次UE上下文信息，并获取UE的IMSI和MM上下文。 【UE-&gt;new MME】 attach request（old GUTI）【new MME-&gt;old MME】identification request(old GUTI)【old MME】IMSI，old GUTI，MM上下文【new MME&lt;-old MME】identification response（IMSI，old GUTI，MM上下文） 如果old MME的NAS-MAC完整性检查通过，new MME介绍接收到IMSI和MM上下文，就不执行鉴权和NAS安全建立。但是因为MME发生了改变，new MME需要和HSS通信来更新UE位置信息，并建立EPS会话/默认EPS承载。HSS从old MME到new MME更新UE的位置信息，并发送cancel Location消息给old MME来通知UE的MM上下文信息可以从old MME中删除了。 IV. Closing到目前为止，我们讨论了初始附着的不同类型，并且不同类型所需要的步骤。在接下来的文档中，我们将关注详细的初始附着过程，并探讨在这些附着过程中在EPS实体中有哪些信息需要设置。 References[1] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[2] Netmanias Technical Document, “LTE Security II: NAS and AS Security”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5903[3] Netmanias Technical Document, “LTE Security I: LTE Security Concept and LTE Authentication”, July2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5902[4] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9-EMM Scenario and Eleven EMM Cases]]></title>
    <url>%2F2016%2F04%2F03%2F9-EMM-Scenario-and-Eleven-EMM-Cases%2F</url>
    <content type="text"><![CDATA[原文地址：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002 NOTE：初始状态，UE A是关机的，并且在网络中没有UE A的UE上下文存在。 EMM case 1，Initial Attach（初始附着）UE状态：“EMM-Deregistered，ECM/RRC-Idle”—&gt;“EMM-Registered，ECM/RRC-Connected” UE A开机，UE A进入“EMM-Deregistered，ECM/RRC-Idle”并试图接入网络。 在UE A和MME中没有UE A的UE上下文 在同步到一个小区之后，UE A用IMSI作为UE ID发送Attach Request给MMT来发起initial attach过程 在成功完成initial attach之后，UE A进入“EMM-Registered，ECM/RRC-Connected”状态并使用注册的服务。 EMM case 2，Detach（去附着）UE状态：“EMM-Registered，ECM/RRC-Connected”—&gt;“EMM-Deregistered，ECM/RRC-Idle” UE A在“EMM-Registered，ECM/RRC-Connected”状态下从网络去附着。 根据detach触发的原因，有三种类型的detach过程（UE发起的，MME发起的和HSS发起的）。 一旦成功完成了Detach过程之后，UE A进入”EMM-Deregistered，ECM/RRC-Idle”状态 EMM case 3，由于用户不活动释放S1UE状态：“EMM-Registered，ECM/RRC-Connected”—&gt;“EMM-Registered，ECM/RRC-Idle” 在“EMM-Registered，ECM/RRC-Connected”状态下在一段时间内UE A没有使用服务。 eNB检测到用户的不活动，释放S1承载和S1信令连接。 在成功完成S1释放过程后，UE A进入“EMM-Registered，ECM/RRC-Idle”状态。 EMM case 4，由于新的业务发起服务请求UE状态：“EMM-Registered，ECM/RRC-Idle”—-&gt;“EMM-Registered，ECM/RRC-Connected” UE A在“EMM-Registered，ECM/RRC-Idle”状态下产生了新的业务。 新的业务可以由UE A产生也可以由网络产生，并发起服务请求过程。 在成功完成服务请求过程之后，UE A进入“EMM-Registered，ECM/RRC-Connected”状态。 EMM case 5，TAUUE状态：“EMM-Registered，ECM/RRC-Idle”—-&gt;“EMM-Registered，ECM/RRC-Connected”—-&gt;“EMM-Registered，ECM/RRC-Idle” UE A在“EMM-Registered，ECM/RRC-Idle”状态，且周期性TAU定时器（T3412）超时。 UE A执行周期性TAU过程，UE A建立到MME的ECM连接，发送TAU Request消息并转移到“EMM-Registered，ECM/RRC-Connected”状态。 在成功完成周期性TAU过程之后，释放ECM连接并且UE A进入“EMM-Registered，ECM/RRC-Idle”状态。 EMM case 6，没有TAU的切换UE状态：“EMM-Registered，ECM/RRC-Connected”—&gt;“EMM-Registered，ECM/RRC-Connected” UE A在“EMM-Registered，ECM/RRC-Connected”状态，移动到一个新的小区，并且检测到这个新进入的TA包含在TAI列表中。 执行切换到新的小区，但是不需要执行TAU过程。 在成功完成切换之后，UE A保持在“EMM-Registered，ECM/RRC-Connected”状态。 EMM case 7，没有TAU的小区重选UE状态：“EMM-Registered，ECM/RRC-Idle”—&gt;“EMM-Registered，ECM/RRC-Idle” UE A在“EMM-Registered，ECM/RRC-Idle”状态，移动到一个新的小区，并且检测到这个新进入的TA包含在TAI列表中。 执行重选到新的小区，但是不需要执行TAU过程。 在成功完成重选过程之后，UE A保持在“EMM-Registered，ECM/RRC-Idle”状态。 EMM case 8，包含TAU的切换UE状态：“EMM-Registered，ECM/RRC-Connected”—&gt;“EMM-Registered，ECM/RRC-Connected” UE A在“EMM-Registered，ECM/RRC-Connected”状态，移动到一个新的小区，并且检测到这个新进入的TA不包含在TAI列表中。 执行切换到新的小区，并且需要执行TAU过程。 在成功完成切换之后，UE A保持在“EMM-Registered，ECM/RRC-Connected”状态。 EMM case 9，包含TAU的小区重选UE状态：“EMM-Registered，ECM/RRC-Idle”—&gt;“EMM-Registered，ECM/RRC-Connected”—&gt;“EMM-Registered，ECM/RRC-Idle” UE A在“EMM-Registered，ECM/RRC-Idle”状态，移动到一个新的小区，并且检测到这个新进入的TA不包含在TAI列表中。 执行重选到新的小区，并且需要执行TAU过程。UE A建立到MME的ECM连接并发送TAU Request消息，转移到“EMM-Registered，ECM/RRC-Connected”状态。 在成功完成TAU更新过程之后，UE A进入“EMM-Registered，ECM/RRC-Idle”状态。 EMM case 10，移动到另一个城市UE状态：“EMM-Registered，ECM/RRC-Connected”—&gt;“EMM-Registered，ECM/RRC-Idle”—&gt;“EMM-Deregistered，ECM/RRC-Idle” UE A从城市1（正在服务或者在idle状态）移动到城市2。UE A移出了LTE的覆盖区外，并且从网络detach。 在detach过程之后，UE A进入“EMM-Deregistered，ECM/RRC-Idle”状态。 EMM case 11，在另一个城市初始附着UE状态：“EMM-Deregistered，ECM/RRC-Idle”—&gt;“EMM-Registered，ECM/RRC-Connected” UE A在“EMM-Deregistered，ECM/RRC-Idle”状态，进入到城市2，并且检测到一个新的LTE小区。 UE A用GUTI作为UE ID发送Attach Request小区给新的MME发起初始附着过程。 在成功完成初始附着过程之后，UE A进入“EMM-Registered，ECM/RRC-Connected”状态。 References[1] Netmanias Technical Document, “LTE EMM and ECM State”, February 2013,http://www.netmanias.com/bbs/zboard.php?id=1x_TechdocsForum_4G[2] 3GPP TS 24.301, “Non-Access-Stratum (NAS) Protocol for Evolved Packet System (EPS); Stage 3”.[3] 3GPP TS 23.401, “General Packet Radio Service (GPRS) Enhancements for Evolved Universal Terrestrial Radio Access Network(E-UTRAN) Access“.[4] NMC Consulting Group Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8-LTE EMM and ECM States]]></title>
    <url>%2F2016%2F04%2F03%2F8-LTE-EMM-and-ECM-States%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5909 I. Introduction通过之前的技术文档，我们已经学习了LTE网络架构和LTE identification和LTE安全操作（当用户附着到LTE网络时需要的，并保证通信的安全）。现在我们开始更深入学习LTE的详细过程。 一旦用户附着到LTE网络，i）在网络端鉴权用户和注册用户，ii）EPS会话和承载建立用于提供服务，iii）触发支持用户移动的移动性管理的功能。在这个时候，MME通过和用户建立信令连接并交换控制信息来负责这三个任务。在用户和网络之间的移动性和会话管理是由UE和MME的控制面的NAS层的NAS协议来控制的。这两个实体使用NAS消息相互通信。NAS协议定义在3GPP 24.301中。NAS可以大致分为EPS移动性管理EMM和EPS会话管理ESM。通过一系列的技术文档，我们描述EMM和ESM这两个过程。当前这个文档是这个系列文档的第一个，将描述i）EMM状态，ii）一旦EMM过程发起，在EPS实体中会保存什么用户信息。 本篇文档组织如下：第二章介绍EMM过程的类型和EMM相关的状态。第三章描述这些状态之间的转换。第四章总结在EPS实体中EMM的特征。第五章讨论在EMM/ECM/RRC状态的不同组合下EPS实体中保存着什么样的用户信息。 II. EMM, ECM and RRC States2.1 EMM过程的类型表1列出了NAS协议支持的EMM过程的类型和属于这些类型的特定的EMM过程。详细的EMM过程将通过这个文档在下面解释。我先简要看看每一个EMM类型都包含哪些特定的过程。 有三张类型的EMM过程：i）EMM 一般过程：是指在UE和MME之间NAS信令连接存在时总是可以发起的过程。这类过程分为五种过程：GUTI allocation（GUTI分配）Authentication（鉴权）identification（身份认证）Security mode control（安全模式控制SMC）EMM information（EMM消息）ii）EMM特殊过程：是指和用户移动性相关的过程（注册，位置更新）。可以分为三种过程，attach（附着）detach（去附着）TAU（TA更新）。在和3gpp网络共存的LTE网络中，额外的过程也包含在这类中（比如，combined attach联合附着，combined detach联合去附着，combined TAU联合TA更新）。但是因为这个文档仅仅讨论LTE网络，所以这几种没有列出在表1中。iii）EMM连接管理过程：是指和NAS信令连接建立有关的过程。可以分为三种过程，service Request（服务请求）paging（寻呼）NAS消息的传输。 2.2 EMM/ECM/RRC状态EMM是NAS层的一个子层。随着EMM过程的进行，UE处于七种EMM状态之一，MME处于四种EMM状态之一。在这些状态中，一些状态例如“EMM-registered”和“EMM-Dergistered”是这两个实体都具有的共同状态，在下文中，EMM状态就是指这两种状态。 为了UE和MME之间相互交换NAS消息，在他们之间必须建立信令连接。这个连接叫EPS连接管理（ECM）连接。它包含UE与eNB之间的RRC连接和eNB与MME之间的S1信令连接的逻辑连接，如图1所示。也就是意味着，当ECM建立和终止时，RRC和S1信令连接全部建立和终止。对于UE，一个建立的ECM连接意味着与eNB之间具有RRC连接，对MME，意味着与eNB之间具有S1信令连接。 图1描述了和UE与MME有关的EMM，ECM，RRC状态。EMM可以是“EMM-Registered” or “EMM-Deregistered”状态取决于附着到网络还是去附着到网络。ECM是可以是“ECM-Connected” or “ECM-Idle”取决于NAS信令连接是否建立。同样的，RRC可以是“RRCConnected” or “RRC-Idle”状态取决于是否有RRC连接建立。表2显示了什么条件下UE待在什么状态。 III. EMM State TransitionEMM，ECM和RRC状态随着EMM过程的处理发生改变。因为RRC连接是ECM连接的一部分，所以在UE的角度看ECM和RRC总是保持相同的状态。在图2中描述了状态转换的过程以及触发状态转换的事件。在图2中用户EMM，ECM/RRC连接的组合用A B C D表示。用户的过程将会是这样组合之一，见表3。 3.1 EMM-Deregistered状态在A和B中，状态都是EMM-Deregistered，ECM-idle，RRC-idle，UE从网络去附着了。但是，在这两种情况下在网络端存储的手机信息是不一样的。在A情况中，在网络端处理提供的信息，没有包含任何UE信息。而在B情况下，网络保存着UE上次附着时网络获得的GUTI和NAS安全上下文。根据在状态A和B中，UE是否附着到网络，初始附着过程可能会有变化。 在状态B，在UE再次附着到网络时，网络保持着鉴权和安全建立所需求的信息，过了一段时间之后，网络会删除这些信息，并转换到状态A。 在EMM-Deregistered状态（A或者B），当选择PLMN和小区的时候，UE能分辨出来UE能通信的哪个网络和哪个小区。当UE请求接入网络获取服务的允许时，开始初始附着过程，然后UE状态转换到C（EMM-registered，ECM-connected，RRC-connected）。 3.2 EMM-Registered状态在C和D状态，状态是EMM-registered，UE接入或注册到网络。但是ECM和RRC的状态是ECM-connected/RRC-connected或者是ECM-idle/RRC-idle状态取决于UE的激活特性。一旦UE成功地附着到网络，状态从EMM-Deregistered（A or B）转换到状态C，UE在使用服务的时候将会一直呆在状态C，当不用服务时转换到状态D。 在状态C，在控制面无线和网路资源分配给信令连接，在用户面分配给EPS承载。当有一个比当前正在通信服务的小区更好无线信号质量的小区时UE可能执行切换到邻小区。但是，当在状态D，UE是去激活的，ECM/RRC连接被释放了。资源在控制面没有分配给ECM连接，也没有分配给EPS承载（DRB和S1承载），除了S5承载一直存在。在这个状态，没有发送到UE或者网络的上下行流量。为了在状态D能传输用户流量，就需要建立ECM连接，转换到状态C，需要建立新的DRB和S1承载来激活EPS承载。在状态D，UE通过测量服务小区和邻小区的无线信号强度根据小区重选准则来选择一个小区驻留（见文档LTE EMM Procedure: 7. Cell Reselection without TAU）。 当i）上下行有新流量，ii）UE在idle状态由于TA改变或者TAU定时器超时，需要进行TAU请求时UE从状态D转换到状态C。另一方面，当i）UE去激活（也就说在一段时间内没有上下行UE流量）ii）UE在状态D完成TAU之后释放资源时UE状态从C转换到D。 当在EMM-Registered（C或D），如果UE从网络去附着，如果UE是关机或者无线链路失败RLF（如果在无线链路上数据包错误率超过门限值），这种情况下，UE转换到B转台（EMM-deregistered）。另外，当UE在状态C执行切换到非LTE网络，或者UE请求附着到网络被拒绝，或者TAU更新请求被拒绝，这时候，UE状态从EMM-registered转换到EMM-deregistered。 IV. EMM Features在这章，我们将讨论在图2的各个状态由EPS实体支持的EMM过程相关的特性。下面，我们将讨论以下议题：i）在每一个状态，被EPS实体知道的UE位置信息的粒度，ii）在什么状态EPS承载和NAS信令连接建立，iii）在每一个状态和UE移动性相关的特性，iv）在每一个状态在EPS实体中都设置了什么类型的ID。 4.1 UE位置信息在表4中展示了被每一个EPS实体识别的UE位置信息的粒度。EMM-registered状态标示UE是附着到网络且网络知道UE的当前位置。在状态C，网络在小区的粒度上知道UE的位置，在状态D，网络在TA粒度上知道UE的位置。对于HSS，不像其他EPS实体，除了UE在状态A，是在MME粒度上知道UE的位置信息。 4.2 EPS承载和NAS信令连接表5展示了在什么状态传输用户流量的EPS承载和传输NAS信令消息的NAS信令连接建立的。一旦UE成功附着到网络，变成EMM-registered状态，UE将通过EPS承载使用服务。一个EPS承载包含三个承载：DRB承载，S1承载和S5承载。如图3所示，当传输用户流量在ECM-connected/RRC-connected状态下，所有的这三种承载是建立和保持激活的，另一方面，当用户没有数据流量在ECM-idle/RRC-idle状态时，只有S5承载是建立，其他两种承载是去激活的。 NAS信令连接包含RRC连接和S1信令连接，是在当传输用户流量时建立的。当用户从网络去附着，或者附着在网络上但是在idle状态下，这时候ECM连接时释放的。 4.3 移动性表6列出了在每一个状态UE移动性相关的特性。移动性：在EMM-deregistered开机的UE通过选择PLMN和小区来知道需要驻留在哪个小区和哪个网络。当有一个无线信号质量比当前小区好的小区时，在EMM-registered状态使用服务的UE从当前小区切换到另外邻区。对一个当前不使用服务的UE，当有一个无线信号质量比当前小区好的小区时，在EMM-registered状态的UE从当前小区重选到另外邻区。 TAU：在EMM-registered状态下的UE，不论是否使用服务，当TA改变时就需要更新TA。但是当在ECM-idle/RRC-idle状态下，即使TA没有改变，当TAU定时器超时时也会更新TA。TA更新时由UE发送TAU request消息来发起的。当UE在ECM-idle/RRC-idle状态，ECM/RRC应该首先建立，然后UE需要转移到ECM-connected/RRC-connected状态来更新TA。一旦UE在状态C发送TAU request消息并从MME接收到TAU accept消息，TAU过程就结束了。这时候，释放ECM/RRC连接，然后UE返回到ECM-idle/rrc-idle状态。 寻呼：当UE附着到网络，但是在idle状态，如果有用户流量传输，网络需要发起寻呼来唤醒UE，接下来UE状态转换到C。寻呼是根据在最后一次TA更新中由UE提供的TAI信息来进行的。 4.4 UE ID表7列出了每一个实体在四种状态中所具有的UE ID。UE IP地址当UE初始附着到网络由PGW分配的，会建立默认承载，并且当默认承载去激活时释放。GUTI是当UE初始成功附着到网络由MME分配的，用来代替IMSI来使用。如果UE从网络成功的去附着，UE和MME会波爱吃UE最后一次的GUTI，并且在下次UE附着到网络时使用它，即使在附着之后。C-RNTI是由eNB分配，用来在一个小区中RRC-connected状态下区别UE的，只有当和小区中已经分配的C-RNTI关联才是有效的。eNB UE S1AP ID and MME UE S1AP ID是由eNB和MME来使用分辨在S1-MME接口上的UE的。Old eNB UE X2AP ID and New eNB UE X2AP ID是服务eNB和目标eNB用来在X2接口上分辨UE的（当UE在服务eNB和目标eNB之间执行切换时）。 V. EMM User Information这一章将描述在图2状态下EPS实体和用户关联的数据。 5.1 EMM-deregistered+ECM-idle/rrc-idle表8描述了在状态A下EPS实体包含的用户信息。在状态A，除了运营商提供的信息外，网络没有用户信息。也就是说，在状态A，在UE和NE中所有的信息都是运营商提供的。IMSI，LTE K，主秘钥在用户鉴权是需要，默认APN，EPS QoS签约信息和接入配置在建立EPS会话和默认EPS承载时都需要。在EPSQoS签约配置文件和接入配置包含如下信息： EPS QoS签约配置文件（在HSS中）：QCI，APR，APN-AMBR和UE-AMBR 接入配置文件（在SPR中）：SDF过滤器，QCI，APR，APN-AMBR、UE-AMBR和计费方法。 5.2 EMM-deregistered+ECM-idle/rrc-idle表9描述了在状态B下EPS实体包含的用户信息。在状态B，最后一次UE附着网络使用的信息在UE和MME中保持有效，所以，在下次附着时UE可以使用相同的信息。这些信息包括由MME最后一次分配的GUTI，在UE最后一次更新TA时的TA信息，在UE和MME之间最后一次使用的NAS安全上下文，由MME分配给UE的UE-AMBR等等。在状态A中UE和NE中没有的用户信息，在状态B中包含的被标记为绿色，已经在状态A分配的是黑色的。如表9所示。 5.3 EMM-registered+ECM-connected+RRC-connected表10列出了在状态C下EPS实体所拥有的用户信息。在状态C，建立了EPS承载和NAS信令连接，执行切换和TA更新。所以，在这个状态设置了这些过程需要的所有用户信息。为了容易和状态B进行区分，在状态C中新加入的标记被蓝色，B状态的标记为绿色。 5.4 EMM-registered+ECM-idle/rrc-idle表11列出了在状态D中EPS实体拥有的用户信息。这个状态首先可以从A/B转移到C。在状态D，在状态C分配给EPS承载和NAS信令连接的所有资源，除了S5承载，都被释放了。这些释放的信息被标记成灰色。在S1承载上，下行资源被释放，但由PGW分配的上行资源被保持。所以，在下次转换到状态C时，在建立S1承载时，相同的上行承载将会使用。我们可以看到一旦UE从状态C变成idle状态，在UE和eNB之间的所有的资源都被释放。 VI. Closing我们学习了EMM，ECM，RRC状态。在ESM过程中讨论EPS会话和承载建立相关的更有意义。作为EMM过程的一部分，UE初始附着流程包含默认EPS承载的建立，ESM相关的相关的EMM过程也包含在这个文档中。基于我们对EMM，ECM，RRC状态的讨论，我们为更深入的学习EMM过程。 References[1] 3GPP TS 24.301, “Non-Access-Stratum (NAS) protocol for Evolved Packet System (EPS); Stage 3”.[2] Netmanias Technical Document, “LTE Network Architecture: Basic”, July 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5904[3] Netmanias Technical Document, “LTE Security II: NAS and AS Security”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5903[4] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-LTE QoS: SDF and EPS Bearer QoS]]></title>
    <url>%2F2016%2F04%2F03%2F7-LTE-QoS-SDF-and-EPS-Bearer-QoS%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5908 I. IntroductionSDF：Service Data Flow LTE服务提供商应该能够根据用户的不同订阅等级来定制不同的QoS的服务需求。所以，为了能够根据不同用户流量分配无线和网络资源，并为了合适的管理这些资源，服务提供商需要能感知每一个用户的订阅级别和能感知请求的服务类型。 为了这种原因，LTE网络首先根据通过SDF提供服务的类型来把用户数据流分为不同的SDFs（具有不同QoS），然后对每一个SDF应用不同的QoS规则。因为SDF在LTE网络中是通过EPS承载来传送的，所以EPS承载QoS以保持SDF QoS的方式来控制。 在这个文档中，适用于SDF的QoS机制和EPS承载将解释为LTE中的QoS机制，并且举例说明他们是怎么工作的。这个文档组织如下：第二章定义SDF和EPS承载。第三章描述适用于SDF和EPS承载的QoS参数。第四章介绍QoS提供和QoS实施，通过实体的QoS参数是怎么提供和在哪里实施的。在第五章，将举例说明LTE QoS是怎么工作的。 II. SDF and EPS Bearer图1描述了SDF和EPS承载，和他们之间的关系。在LTE网络中，用户数据（IP数据包）被分为SDF数据流和EPS承载数据流。一个SDF是和用户正在使用的服务相关联的一组IP数据流，而EPS承载是具有相同QoS级别的聚合的SDFs数据流。 SDF和EPS承载是通过使用不同的数据包过滤器匹配IP数据流来检测的（SDF template用于SDF，traffic flow template TFT用于EPS承载）。数据包过滤器是由网络运营商根据他们的策略预先配置的。他们每一个都有由五元组组成（源IP地址，目的IP地址，源端口，目的端口，协议ID）。 换种说话，在ＬＴＥ网络中，具有相同服务特征（匹配SDF template数据包过滤器）的IP数据流被指定为一个SDF。匹配TFT数据包过滤器的SDFs被映射为EPS承载，最后交付给UE。具有相同QoS级别的SDFs被聚合在一起通过一个EPS承载传送，不同的QoS级别的SDF通过不同的EPS承载传送。 SDF 使用不同服务或应用的用户数据流具有不同的QoS。一个SDF是一个IP数据流或者是根据服务类型分类的用户IP数据流的聚合。不同的SDF由不同的QoS级别，因此一个SDF作为一个单元服务的，这个单元的QoS规则是按照LTE中PCC过程得到的。在图1中，到UE的IP数据流使用SDF template按照他们的服务类型被分类成不同的SDF。接着相应的QoS规则（例如，优先级，带宽控制等）在数据传输到ＵＥ之前应用到SDF上。QoS是当SDF在ＬＴＥ网络传输的时候由EPS承载提供的，每一个SDF被PGW映射到一个EPS承载来满足它的QoS需求，并交付给ＵＥ． EPS承载 有两种类型的EPS承载：默认和专用的。当UE附着到LTE网络时，分配一个IP地址用于连接PDN，同时建立一个默认EPS承载。当用户通过默认承载试图接入需要高QoS（当前的默认承载满足不了这个QoS）时，就按需建立一个专用承载。专用承载建立的QoS是不同于当前已经存在的承载上的QoS。UE可以连接不止一个PDN，包含一个必须的默认EPS承载和零到多个可选的专用EPS承载。UE拥有的EPS承载的数目不超过11个。 一旦在UE初始附着到网络时建立默认承载，这个承载会一直持续，即使没有服务在使用，直到UE从网络去附着。每一个PDN上都有一个默认承载。当UE初始附着到网络，网络MME需要关于怎样建立默认承载的信息，比如使用哪个QoS，需要连接哪个PDN。这些信息已经作为签约信息提供了HSS。所以，MME只需要下载这些签约信息即可（默认APN，EPS签约QoS信息等等），并基于这个APN选择一个PGW连接到PDN，并且基于签约QoS配置信息激活和这个PDN相关的默认承载。 在图1中的SDF和EPS承载图1展示了当通过EPS下行IP数据流交付给UE时的SDF和EPS承载。通过PDN IP数据流到达PGW并使用SDF templates过滤成不同的SDF。在这个图中，IP数据流1/2/3被过滤成SDF1/2/3，相应的IP数据流4/5倍过滤成SDF4。对每一个SDF适用不同的QoS策略，接着映射到通过使用TFT分类的EPS承载上。SDF1/2映射到默认承载，而SDF3/4映射到专用承载，接着都传输都ＵＥ。一旦到达UE，IP数据被发送到相应的目的应用。 在图1中显示的EPS承载和SDF列出来表1中。在IP连接接入网（IP Connectivity Access NetworksI P-CAN）范围外的在3gpp标准中。这个文档只讨论EPS。所以这里讨论的所有的IP_CAN都是指EPS承载。 III. QoS Parameters of SDF and EPS Bearer在第二章学习了使用数据包过滤器把用户承载分为SDF或EPS承载。SDF QoS和EPS承载QoS对应的应用于SDF和EPS承载。在第三章我们学习SDF和EPS承载的QoS，以及他们之间的关系。 在LTE网络中，QoS在服务层面和承载层面上定义。SDF QoS参数一个服务层面的QoS参数，而EPS承载QoS参数是承载层面的QoS参数。服务层面和承载层面也被称为SDF层面和SDF聚合层面。一个SDF聚合就是一组具有相同QCI（QoS级别标识QoS Class Identifier）和ARP（分配和保留优先级Allocation and Retention Priority）的SDF，这些SDF属于同一个EPS承载。QCI和ARP都是基本的QoS参数，适用于所有的SDF和EPS承载。QCI特别重要，因为它作为一个参考标识SDF和EPS承载的性能特征。除了这两个基本的参数，还有其他的QoS参数，例如GBR、MBR、AMBR，这些参数指定SDF和EPS承载的 带宽/比特速率特征。SDF和EPS承载的参数如下所示： SDF QoS参数：QCI、ARP、GBR、MBR EPS承载QoS参数：QCI、ARP、GBR、MBR、APN-AMBR、UE-AMBR SDF QoS参数 QCI和ARP使用于所有的SDF。QCI是1-9的整数，标识IP数据包9种不同的QoS性能特征，例如资源类型（GBR或NON-GBR）优先级（1-9）数据包延迟预算（50-300ms）数据包错误速率（10-2 ~ 10-6）。MBR和GBR（最大比特速率和保证比特速率Maximum Bit Rate 和Guaranteed Bit Rate ）都是SDFQoS参数，他们用来标识SDF带宽/比特速率。MBR指定SDF的最大比特速率。如果网络流量不拥挤，则以SDF传输的用户流量可以以最大MBR传输。而，GBR是SDF保证的比特速率。这意味着无论什么情况，SDF能保证一个特定的GBR。所以即使网络流量是拥挤的，通过SDF传输的用户流量也至少能按照保证的GBR传输。 有两种类型的SDF，GBR SDF和non-GBR SDF。对于GBR SDF，根据QCI指定的资源类型分配专用的网络资源。但是，对于non-GBR SDF，不分配专用的网络资源。GBR SDF分配一个GBR和MBR，而non-GBR SDF只分配一个MBR。这两种SDF的QoS参数如下所示： GBR SDF QoS参数：QCI、ARP、GBR（UL/DL）、MBR（UL/DL） non-GBR SDF QoS参数：QCI、ARP、MBR（UL/DL） 匹配TFT过滤器的SDF在PGW中映射为一个EPS承载，并通过这个映射的EPS承载交付给ＵＥ．具有相同QCI和ARP的SDF聚合被映射到一个EPS承载上。 EPS承载QoS参数 QCI和ARP使用所有的EPS承载。EPS承载根据不同QCI的资源类型被分为GBR承载和non-GBR承载。默认承载必须是non-GBR，而专用承载可以是GBR，也可以是non-GBR。除了QCI和ARP，EPS承载还有其他的QoS参数，MBR和GBR用来指示EPS承载的带宽/比特速率，AMBR（聚合最大比特速率Aggregated Maximum Bit Rate）指示多个EPS承载的总共带宽。MBR和GBR是EPS承载的最大和保证带宽，AMBR是多个EPS承载的最大总共带宽。 GBR EPS承载分配GBR和MBR，意味着为这个承载分配专用的网络资源。而，non-GBR EPS承载分配一个AMBR，意味着对这个承载没有分配专用的网络资源，但是分配了一个和其他non-GBR承载共享的最大带宽。由两种类型的AMBR，APN-AMBR（是在PDN中由所有的non-GBR承载共享的最大带宽）和UE-AMBR（在ＵＥ中共同分享的最大带宽）。一个UE可以连接到不止一个PDN，也就是说，所有PDN的总APN-AMBR不能超过UE-AMBR。这两种类型的QoS参数如下： GBR承载QoS参数：QCI、ARP、GBR（UL/DL）、MBR（UL/DL） non-GBR承载QoS参数：QCI、ARP、APN-AMBR（UL/DL）、UE-AMBR（UL/DL） SDF和EPS承载QoS参数图2显示了应用于SDF和EPS承载的QoS参数。 在图2中，UE连接两个PDN。UE有两个IP地址：IP地址1由PGW1分配用于PDN1，IP地址2由PGW2分配用于PDN2。每一个PDN有一个默认承载和两个专用承载。在PGW使用SDF templates把用户IP数据流分成了不同的SDF。从PDN1和PDN2由两组SDF（1-5）。对于这些SDF，根据在PGW设置的QoS规则来分配网络资源和数据包转发策略。并基于他们特定的QCI和ARP映射到EPS承载上。图中，对于PDN1，SDF1/2映射到默认承载，SDF3/4映射到non-GBR专用承载，SDF5映射到GBR专用承载，所有的都传送到UE。这样的从SDF到EPS承载的映射是由TFT决定的。所有用户流量在通过EPS承载传输时都准守EPS承载QoS。 所有和PDN关联的non-GBR承载都是由他们共享的最大APN-AMBR控制，而和UE关联的non-GBR承载都是由他们共享的最大UE-AMBR控制。 表2 SDF和EPS承载的QoS参数 项 描述 QCI 指示不同的QoS性能特征；标准QoS特征值用QCI=1-9定义；QCI代表了QoS的下列特征：资源类型（GBR or non-GBR），优先级（1-9），数据包延迟预算（50-300ms），数据包错误丢失率（10-2~10-6）；在网络节点（eNB，SGW，PGW）上控制数据包转发（调度权重，准入阈值，队列管理阈值，链路层协议配置等等）；在运营商网络节点（例如eNB）预先配置。 ARP ARP参数：优先等级，抢占能力，被抢占能力；优先级（1-15）：定义资源请求的相对重要性，1是最高。抢占能力（yes or no）：定义SDF是否占用已经分配给一个优先级较低的SDF/承载的资源。被抢占能力（yes or no）：定义SDF是否能失去已经分配给它了，但是为了建立更高优先级的SDF/承载的资源。用于控制呼叫准入：指示一个优先级值用于决定在网络资源有限的条件下一个新的SDF/EPS承载需要激活或者修改的情况下是否拒绝激活一个新的SDF/EPS承载或移除存在的SDF/EPS承载。仅当在决定是否激活一个新SDF/EPS承载时需要考虑。一旦成功的建立，ARP对数据包转发处理没有影响。 GBR (UL/DL) 应用于GBR SDF/承载。指示对GBR SDF/承载能保证的最小的带宽 MBR（UL/DL） 应用于GBR/non-GBR SDF和承载。指示对SDF/承载允许的最大带宽；任何超过指定MBR的数据流量都通过数据策略丢弃。 APN-AMBR(UL/DL) 每一个PDN定义一个。指示对所有和PDN相关的non-GBR承载所允许的最大带宽；只适用于non-GBR聚合带宽 UE-AMBR(UL/DL) 每一个UE定义一个。指示对所有和UE相关的non-GBR承载允许的最大带宽；只适用于non-GBR承载的聚合带宽；这个是由HSS提供的签约信息（UE-AMBR-HSS）。但是仍然可以由MME修改，只要不超过所有APN的APN-AMBR的许可范围即可（在UE-AMBR-HSS范围之内）。 GBR SDF/承载 给这种类型的SDF/承载分配专用的网络资源来达到保证的GBR。当没有流量的时候，网络总是为GBR SDF/承载保持GBR指定的带宽。 non-GBR SDF/承载 给这种类型的SDF/承载不分配专用的网络资源。依据网络的拥挤程度以最大能力来传输流量。 IV. QoS Provisioning and Enforcement4.1节将讨论QoS分配：QoS参数是在哪个实体中设置的。4.2节讨论QoS实施：决定哪个实体设置和应用哪个用户流量参数。 4.1 QoS分配图3展示了QoS参数是在哪个实体中设置的； SDF QoS分配SDF所有的QoS参数是由PCRF提供的（Policy and Charging Rules Function）。 EPS承载QoS分配应用于默认承载的QoS参数是由网络运营商作为签约信息提供给HSS的。当默认承载激活的时候，MME从HSS中下载关于这个承载的QoS配置信息，并发送给相应的EPS实体。一旦EPS回话建立，QoS规则经过PDRF授权时，由HSS提供给默认承载的QoS参数可以修改。由HSS提供的UE-AMBR由eNB控制，但可以由MME修改。在修改的情况下，MME可以使用所有正在激活的PDN的聚合APN-AMBR取代UE-AMBR，只要这个值没有超过由HSS提供的UE-AMBR-HSS值即可。 应用于专用承载的QoS参数是由PCRF提供的。当承载激活时，PCRF基于从SPR接收到的签约信息来决定承载的QoS参数。 4.2 QoS实施在QoS实施过程中，执行用户流量的检测，然后对每一个检测到的SDF和EPS承载执行相应的QoS规则。图4显示了SDF和EPS承载是在哪个实体中设置和实施的。EPS承载QoS参数实施于SGW和实施于PGW是一样的，除了APN-AMBR之外。但是为了绘图方便，在这个图中只显示了QCI。 SDF QoS实施SDF QoS参数是存在于PGW中。表4显示了SDF QoS在哪个实体中实施。到达PGW的IP数据流使用SDF templates过滤为不同的SDF，接着这些SDF由SDF QoS参数控制安装在PGW中。 EPS承载QoS实施EPS承载的QoS参数实施在UE和PGW之间传输用户流量的EPS实体上。表5描述了每一个QoS参数在哪个EPS实体中实施。APN-AMBR被承载的两个端点（UE和PGW）应用在PDN上激活的所有non-GBR EPS承载。APN-AMBR在UE中仅仅用于上行流量，但是在PGW中应用于上行和下行流量。而UE-AMBR由所有PDN发端的eNB来应用在UE上激活的所有non-GBR EPS承载。也就是说APN-AMBR只应用于和它关联的APN所表示的PDN，而UE-AMBR应用于UE，所有和UE关联的PDN。MBR只用于GBR承载，在UE和eNB中是用于上行流量，而在SGW和PGW中只应用于下行流量。GBR只适用于GBR EPS承载，对上行和下行除了UE之外的所有实体都适用。 V. An Example for SDF and EPS Bearer QoS在第五章，举例说明LTE QoS是如何基于SDF和EPS承载QoS提供的。通过这个实例，可以学习SDF和EPS承载QoS怎么工作和他们是在哪个实体中提供的。使用的场景如下： UE连接到一个PDN（因特网） UE通过三个承载和因特网通信（一个默认承载，一个GBR承载和一个non-GBR承载） 他们承载的ID（EPS承载ID EBI）是5,8,10. 5.1 下行的QoS操作图5显示了下行QoS操作的实例。在每一个实体的操作详细在下面描述。这里，可适用的流量控制包括流量监管和流量成型。图5和图6是应用流量监管的实例。 ❶ [P-GW] 下行IP数据流到达IP数据流到达PGW，数据流1-5分别是语音数据（RTP），视频数据流，语音信令（SIP），双向的游戏，尽力而为的因特网流量。 ❷ [P-GW] IP数据包过滤 (SDF Templates)一旦PGW接收到数据包，IP数据通过IP数据包过滤器 (SDF templates)被过滤成不同的SDF。在这里，五元组（源IP地址，目的IP地址，源端口，目的端口，协议ID）用来充当过滤规则。IP数据流1被分类为GBR SDF1，数据流2被分类为GBR SDF2，IP数据流3/4被分类为non-GBR SDF3，IP数据流5被分类为non-GBR SDF4. ❸ [P-GW] SDF QoS实施: MBR速率策略MBR速率策略对每一个SDF执行，任何超过指定下行MBR的流量都将被丢弃。 ❹ [P-GW] SDF – EPS 承载映射: IP 数据包过滤 (Traffic Flow Templates; TFT)SDF使用IP数据包过滤TFT被过滤成不同的EPS承载。SDF1和SDF2映射到GBR专用承载EBI=10。SDF3被映射被non-GBR专用承载EBI=8，SDF4被映射为non-GBR默认承载EBI=5。 ❺ [P-GW] EPS 承载QoS 实施: MBR/APN-AMBR 速率策略EPS承载QoS适用于每一个承载。对于GBR承载，MBR速率策略是使用下行MBR来执行，任何IP数据包超过指定下行MBR的都被丢弃。对于non-MBR承载，APN-AMBR速率策略被执行。也就是说，对于所有发往EBI=5/8的IP数据流都是适用速率策略，任何IP数据包超过指定的下行APN-AMBR的都被丢弃。 ❻ [eNB] EPS 承载QoS 实施: UE-AMBR 调度eNB对non-AMBR执行UE-AMBR速率策略，并且在无线链路上调度。也就是说对于所有发往EBI=5/8的IP数据流都执行下行UE-AMBR。在图5中，因为只有一个PDN，下行UE-AMBR和下行APN-AMBR是相等的。 5.2 上行QoS操作图6显示了上行LTE QoS的操作。不像下行，MBR和APN-AMBR的控制在上行方向在ＵＥ和PGW中都执行。 ❶ [UE] 上行IP 数据流到达从用户应用层的IP数据流到达ＵＥ，在这里，应用层和下行的是一样的。 ❷ [UE] IP数据包过滤 (TFT)上行IP数据流被IP数据包过滤TFT过滤为EPS承载。在这里，IP和TCP/UDP协议头中的五元组用于过滤规则。IP数据流1/2映射到GBR专用承载EBI=10，IP数据流3/4被映射到non-GBR专用承载EBI=8，IP数据流5被映射为默认承载EBI=5. ❸ [UE] EPS 承载QoS 实施: MBR/APN-AMBR速率策略EPS承载QoS应用于每一个EPS承载。对于映射到GBR专用承载EBI=10的IP数据流，使用上行的MBR来执行速率策略，对于non-GBR专用承载EBI=5/8的所有IP数据流使用上行APN-AMBR来执行速率策略。 ❹ [eNB] EPS 承载QoS 实施: MBR/UE-AMBR速率策略eNB对GBR承载EBI=10使用上行MBR执行速率策略和调度，对于non-GBR承载EBI=5/8使用上行UE-AMBR来执行速率策略和调度。认为只有一个PDN，上行UE-AMBR和上行APN-AMBR是相等的。 ❺ [P-GW] 承载流量到达承载数据流通过SGW到达PGW ❻ [P-GW] EPS 承载QoS 实施: APN-AMBR 速率策略对所有的从non-GBR承载接收到的IP数据流执行APN-AMBR。任何超过上行APN-AMBR的数据包都被丢弃。 ❼ [P-GW] IP数据包过滤 (SDF Templates)EPS bearers are filtered through IP packet filters (SDF templates) into different SDFs. IP flows 1 and 2 fromthe GBR dedicated bearer (EBI=10) are mapped to SDFs 1 and 2, IP flows 3 and 4 from non-GBR dedicatedbearer (EBI=8) are mapped to SDFs 3 and 4, and finally IP flows 5 from the default bearer (EBI=5) ismapped to SDF 5.EPS承载被IP数据包过滤SDF templates过滤成不同的SDF。GBR专用承载EBI=10的IP数据流1/2被映射为SDF1/2。non-GBR专用承载EBI=8的IP数据流3/4被映射为SDF3/4。默认承载的IP数据流5被映射为SDF5. ❽ [P-GW] SDF QoS 实施: MBR 速率策略对每一个SDF执行MBR速率策略，任何超过指定上行MBR的IP数据包都会被丢弃。 VI. Closing我们已经学习了在服务层次和承载层次上的LTE QoS机制。我们也学习了用户IP数据流在服务层次上被分为不同的SDF，接着用户数据流在承载层次上被分类为不同的EPS承载。我们也讨论了SDF和EPS的他们互相映射的关系。在eNB的MAC层给ＵＥ分配无线资源并基于EPS承载QoS参数来执行数据包调度。eNB数据包调度不在本文档的范围内。决定和鉴权QoS参数的具体过程将会在接下来的文档中描述。 References[1] Netmanias Technical Document, “LTE Identification III: EPS Session/Bearer Identifiers”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5907[2] 3GPP TS23.203, “Policy and charging control architecture”.[3] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6-LTE Security II: NAS and AS Security]]></title>
    <url>%2F2016%2F04%2F03%2F6-LTE-Security-II-NAS-and-AS-Security%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5903 I. Introduction在LTE安全的第一个文档，我们介绍了基于EPS AKA过程的LTE鉴权，并在鉴权结束后，UE和MME之间共享了相同的K-ASME。在这个文档中，我们将基于K-ASME来介绍NAS和AS安全，学习在安全建立过程后用户和控制面的数据是怎样传输的。 第二章将介绍NAS安全建立过程，和在这个过程后NAS消息时怎么发送和接收的。第三章介绍AS安全建立过程，并介绍RRC和IP数据包时怎么传输的。第四章在EPS实体上使用的EPS安全上下文和安全数据。最后第五章总结在两篇LTE安全文档中的所有安全秘钥。 在我们开始介绍安全建立过程之前，我们先看下NAS和AS所有应用的协议栈。图1表示NAS和AS安全建立相关的协议栈。 NAS安全：NAS安全的目的是为了确保UE和MME之间控制面NAS消息是使用NAS安全秘钥安全传送的。NAS安全秘钥是从K-ASME中计算出来，并且每次执行EPS AKA都会有一个新的秘钥。在NAS安全建立完成之后，UE和MME之间在传输之前共享了相同的NAS安全秘钥（K-NASenc）和NAS完整性秘钥（K-NASinc）分别用于加密和完整性保护。 AS安全：AS安全的目的是为了确保UE和eNB之间控制面RRC消息和用户面IP数据包是使用AS安全秘钥安全传送的。AS安全秘钥是从K-eNB中计算出来的，并且每次一个新的无线链路建立后都会产生一个新的秘钥。在AS安全建立完成后，UE和eNB之间共享了RRC完整性秘钥（K-RRCinc）、RRC加密秘钥（K-RRCenc）和用户加密秘钥（K-UPenc）。使用这些秘钥的加密和完整性包保护都是在PDCP层执行的。RRC完整性秘钥（K-RRCinc）、RRC加密秘钥（K-RRCenc）都用来确保在无线链路控制面上通过SRB传输的RRC消息的传输安全。RRC消息在发送之前在PDCP层使用K-RRCinc完整性保护和使用K-RRCenc加密。K-UPenc用于在无线链路上用户面通过DRB传输的IP数据包的安全传输。IP数据包在传输之前在PDCP层使用K-UPenc来加密。 II. NAS Security下面将对NAS安全展开详细描述。NAS安全建立过程包含在UE和MME之间的Security Mode Command消息（MME发送到UE的）和Security Mode complete消息（UE发送给MME的）。这个NAS安全过程和NAS消息怎么传输在2.1和2.2节分别阐述。 2.1 NAS安全建立（1）、Security Mode Command消息的传输图2展示了在NAS安全建立过程中Security Mode Command消息时怎么传送的。MME通过发送Security Mode Command消息给UE来通知UE，MME是被网络鉴权的，并且表示用于消息安全传输的NAS安全建立过程已经发起。Security Mode Command消息时完整性保护的，接着发送给ＵＥ，然后ＵE计算出NAS安全秘钥（加密秘钥和完整性秘钥）并使用完整性秘钥来验证这个消息的完整性。 NAS安全建立过程之前的LTE鉴权过程在图2中 显示。LTE鉴权的结果是在UE和MME之间共享了K-ASME。我们开始介绍NAS安全建立过程，假定MME分配KSI-ASME=1来标识K-ASME。 1、[MME]选择安全算法MME在从UE接收到的Attach Request消息中基于网络能力信息选择加密和完整性算法用于NAs消息。图2展示了选择EEA1作为加密算法，EIA1作为完整性算法。 2、[MME]计算出NAS安全秘钥MME使用算法ID（Alg-ID）和选择安全算法的算法分辨器来从K-ASME中计算出K-NASinc和K-NASenc。表1列出了算法ID和算法分辨器。 3、[MME]为完整性保护产生NAS-MACMME生成Security Mode Command消息发送给ＵＥ，并使用ＥＩＡ算法和输入参数计算出NAS-MAC。图3是展示了NAS-MAC是怎么生成的。参数说明： Count：32bit下行NAS计数 Message：NAS消息，在这里是Security Mode Command Direction：1bit表示传输的方向，0是上行，1是下行 Bearer：5bit的承载ID，固定值，设置为0 K-NASinc：128bit的NAS完整性秘钥 4、[UE&lt;-MME]发送Security mode command消息MME把计算出来的NAs-MAC包裹在Security mode command消息中发送给ＵＥ。这个消息时完整性保护而没有加密的。消息参数有以下几个： KSI-ASME：3bit和K-ASME关联的值，用来表示K-ASME 重返UE安全能力：UE安全能力包裹在UE发送的attach Request消息中的UE网络能力，指示UE可以支持的安全算法。 NAS加密算法：由MME选择的NAS加密算法，这里为EEA1 NAS完整性算法：由MME选择的NAS完整性算法，这里为EIA1 5、[UE]设置K-ASME表示（KSI-ASME）当UE从MME接收到Security mode command消息，UE设置在消息中的KSI-ASME，并使用它来表示当前的K-ASME。 6、[UE]产生NAS安全秘钥UE识别出MME选择的NAS安全算法，并使用算法ID和算法分辨器从K-ASME中计算出K-NASinc和K-NASenc。 7、[UE]检查Security mode command消息的完整性UE通过使用包裹在消息中的NAS-MAC来检查Security mode command消息的完整性。UE识别出由MME选择的NAS完整性算法是EIA1，并使用Security mode command消息中选择的EIA1算法计算出XNAS-MAC消息鉴权码和K-NASinc。图4是介绍XNAS-MAC是怎么通过相同的EIA计算出来的。UE通过比较由自己计算出来的XNAS-MAC和由MME计算出来NAS-MAC是否匹配来验证这个消息的完整性。如果匹配，它表示Security mode command消息是没有在途中被篡改的。 （2）、Security mode complete消息的传输图5展示了Security mode complete消息在NAS安全建立过程中是怎么传输的。UE通过发送Security mode complete消息给MME来通知MME在UE中生成了和MME中相同的NAS安全秘钥，并且Security mode command消息完整性验证通过。Security mode complete消息传输是加密和完整性保护的。 8、[UE]使用选择的加密算法EEA1加密消息UE生成和加密Security mode complete消息发送给MME。Security mode complete消息的加密数据流（Cipher Text Block加密数据块）是通过Security mode complete消息（Plane Text Block面数据块）和由EEA1、K-NASenc生成的加密秘钥流（Key Stream Block秘钥流块）经过bit位执行XOR异或操作来生成的。图6展示了NA消息时怎么加密的。用来产生秘钥流块的EEA算法的输入数据包括以下： Count：32bit上行NAS计数 Bearer：5bit的承载ID，固定值，设置为0 Direction：1bit表示传输的方向，0是上行，1是下行 Length：通过加密算法陈胜的秘钥流的长度 K-NASenc：128bit的NAS加密秘钥 9、[UE]产生NAS-MAC用于完整性保护UE使用EIA算法计算出NAS-MAC和K-NASint。图3a是NAS-MAC是怎么使用下面的EIA参数生成的。 Count：32bit上行NAS计数 Message：NAS消息，在这里是Security Mode complete Direction：1bit表示传输的方向，0是上行，1是下行 Bearer：5bit的承载ID，固定值，设置为0 K-NASinc：128bit的NAS完整性秘钥 10、[UE-&gt;MME]发送Security Mode complete消息UE把计算得到的NAS-MAC包裹在Security Mode complete消息中，并发送给MME。在这里这个消息是加密和完整性保护的，在这个之后，所有的UE发送给MME的NAS消息都是安全传输的。 11、[MME]验证Security Mode complete消息的完整性MME通过验证包含在消息中的NAS-MAC来检查Security Mode complete的完整性。MME使用在Security Mode complete消息中选择的EIA1算法和K-NASint来计算出XNAS-MAC。图4a展示了XNAS-MAC是怎么使用相同的EIA参数来计算出来的。MME通过检查自己计算出来的XNAS-MAC和从UE计算出来的NAS-MAC是否匹配来验证这个消息的完整性。如果匹配，它表示Security Mode complete消息在传输过程中没有被篡改。 12、[MME]解密Security Mode complete消息在成功验证Security Mode complete消息之后，MME开始使用EEA算法解密这个消息。Security Mode complete消息（UE产生的原来消息）是通过加密的Security Mode complete消息和秘钥流块XOR异或产生的。图7表示这个消息怎么使用EEA算法被解密的。 2.2 NAS安全建立后一旦NAS安全建立完成，在随后所有的UE和MME之间传输的NAS消息都是在发送之前加密和完整性保护的。图8显示了在NAS安全建立之后，ＵＥ和MME之间的NAS消息时怎么传送的。 当NAS消息发送之前，首先加密然后完整性保护。原NAS消息首先使用K-NASenc加密然后包含K-NASint计算出来的NAS-MAC做完整性保护，所有这些消息都是加密和完整性保护传送的。 当接收到NAS消息，首先做完整性验证，然后解密，和发送时相反的过程。首先对比使用K-NASint计算出来的XNAS-MAC和接收到的NAS-MAC对比来检查NAS消息的完整性，接着解密得到原始的NAS消息。 III. AS Security下面详细介绍AS安全。AS安全建立过程包含在UE和MME之间的Security Mode Command消息（MME发送到UE的）和Security Mode complete消息（UE发送给MME的）。通过RRC信令来AS安全建立过程的描述和RRC消息在控制面、IP数据包在用户面怎么传输在3.1和3.2节分别阐述。 3.1 AS安全建立（1）、Security mode command消息的传送图9和图10描述了在AS建立过程中Security mode command消息是怎样传输的。首先，在图9中显示eNB怎样生成AS安全秘钥，并传输Security mode command消息给UE。K-eNB（AS安全基本秘钥）是从K-ASME计算出的，然后eNB从K-eNB中计算出AS安全秘钥。因为K-ASME不会传送到eNB，所以MME从K-ASME计算出K-eNB，然后传输给eNB，接着从传递的K-eNB中计算出AS安全秘钥。1和2展示了LTE鉴权过程。 1、【MME】计算出K-eNBMME使用秘钥生成函数KDF用K-ASME和UL NAS Count计算出K-eNB。 2、【eNB&lt;-MME】发送K-eNBMME作为对attach Request的响应发送attach accept消息给UE。这个NAS消息时通过initial context setup Request消息（这是一个eNB和MME之间的S1信令消息）传输的。消息的参数如下： UE安全能力：MME从UE发送的attach Request中的UE网络能力中选择的安全算法。 Security key：256bit K-eNB 3、【eNB】选择安全算法eNB根据从MME接收到的initial context setup Request消息中包含的UE安全能力选择加密和完整性保护算法应用于RRc消息和IP数据包。图9展示了选择EEA1作为加密算法，选择EIA1作为完整性保护算法。 4、【eNB】产生AS安全秘钥eNB使用算法ID和选择的安全算法的算法分辨器从K-eNB中衍生出K-RRCint、K-RRCenc、K-UPenc。 5、【eNB】为完整性保护产生MAC-IeNB生成Security Mode Command消息发送给ＵＥ，并使用ＥＩＡ算法和K-RRCint计算出MAC-I。图3是展示了MAC-I是怎么生成的。参数说明： Count：32bit下行PDCP计数 Message：RRC消息，在这里是Security Mode Command Direction：1bit表示传输的方向，0是上行，1是下行 Bearer：5bit的承载ID K-RRCinc：128bit的NAS完整性秘钥（此处原文有误） 6、[UE&lt;-eNB]发送Security mode command消息eNB把计算出来的MAC-I包裹在Security mode command消息中发送给ＵＥ。这个消息时完整性保护而没有加密的。消息参数有以下几个： AS加密算法：由eNB选择的AS加密算法，这里为EEA1 AS完整性算法：由eNB选择的AS完整性算法，这里为EIA1 图10展示了UE怎么从Security mode command消息中获得AS秘钥并用于消息的完整性检查。 7、[UE]识别安全算法：EEA1、EIA1UE从接收到的Security mode command消息中识别出eNB选择的AS安全算法和完整性保护算法，图10是选择EEA1和EIA1的实例。 8、[UE]产生AS安全秘钥UE并使用算法ID和算法分辨器从K-eNB中计算出K-RRCinc和K-RRCenc和K-UPenc。 9、[UE]检查Security mode command消息的完整性UE通过使用K-RRCint来验证包裹在消息中的MAC-I来检查Security mode command消息的完整性。UE通过比较由自己计算出来的XMAC-I和由eNB计算出来MAC-I是否匹配来验证这个消息的完整性。如果匹配，它表示Security mode command消息是没有在途中被篡改的。图4是XMAC-I计算的过程。 （2）、Security mode complete消息的传输图11展示了Security mode complete消息在AS安全建立过程中是怎么传输的。UE通过发送Security mode complete消息给MME来通知MME在UE中生成了和MME中相同的AS安全秘钥，并且Security mode command消息完整性验证通过。Security mode complete消息传输是加密和完整性保护的。 10、[UE]产生NAS-MAC用于完整性保护UE使用EIA算法计算出MAC-I和K-RRCint。图3是MAC-I是怎么使用下面的EIA参数生成的 11、[UE-&gt;MME]发送Security Mode complete消息UE把计算得到的MAC-I包裹在Security Mode complete消息中，并发送给eNB。在这里这个消息是加密和完整性保护的。 12、[MME]验证Security Mode complete消息的完整性MME通过验证包含在消息中的MAC-I来检查Security Mode complete的完整性。eNB使用在Security Mode complete消息中选择的EIA1算法和K-RRCint来计算出XMAC-I。eNB通过检查自己计算出来的XMAC-I和从UE计算出来的MAC-I是否匹配来验证这个消息的完整性。如果匹配，它表示Security Mode complete消息在传输过程中没有被篡改。 3.2 AS安全建立后一旦AS安全建立完成，在随后所有的UE和eNB之间传输的RRC消息都是在发送之前加密和完整性保护的，所有的IP数据包也是加密的。图12显示了在AS安全建立之后，ＵＥ和eNB之间的RRC消息和IP数据包是怎么传送的。 当RRC消息发送之前，不像NAS消息，它会首先完整性保护然后加密发送。原NAS消息首先包含K-RRCint计算出来的MAC-I做完整性保护接着使用K-RRCenc加密，所有这些消息都是加密和完整性保护传送的。 当接收到RRC消息，首先做解密，然后完整性验证，和发送时相反的过程。首先使用K-RRCenc解密获得完整性保护的RRC消息，然后对比使用K-NASint计算出来的XNAS-MAC和接收到的NAS-MAC对比来检查NAS消息的完整性，确认得到原始的NAS消息。 用户面数据是加密的但是不进行完整性保护。用户数据包在发送端使用K-UPenc进行加密，在接收端使用K-UPenc进行解密获得原始的用户数据包。 IV. Security Context到目前为止，我们已经讨论完了LTE鉴权过程，NAS安全和AS安全过程。在这些过程中和安全相关的数据会在EPS实体中设置，这些数据叫EPS安全上下文，可以使NAS安全上文也可以是AS安全上下文。NAS安全上下文可以有两种类型：”full native” or “partial native”。在EPS AKA执行之后，第一个SMC进行之前的NAS安全上下文叫”partial native”。一个”partial native”的EPS NAS安全上下文在SMC过程完成之后转变为”full native” 。表2列出了这些EPS安全上下文。 图13显示了在EPS AKA和NAS/AS安全建立之后存储在EPS实体中的LTE安全数据。它显示了这些每一个安全数据是如何生成的，并且数据传输流指示从哪个数据开始安全数据开始传输。 V. ClosingLTE安全文档已经覆盖包括基于EPS AKA的LTE鉴权，和NAS、AS安全建立过程、在EPS实体中安全数据等的LTE安全技术。我们还学会了LTE安全秘钥的层次结构，他们是分离的，用于不同的目的。顶级的秘钥是K（LTE秘钥），它是一个固定的值存储在USIM和HSS/AuC中。从K，衍生出了CK、IK，然后从CK、IK衍生出K-ASME。NAS秘钥和K-eNB从K-ASME中衍生。从K-eNB又衍生出了AS安全秘钥。我们还发现从UE、eNB、MME衍生的秘钥取决于他们是用于NAS层还是AS，是用于控制面还是用户面，是用于加密还是完整性保护，或者是使用哪一个种算法。表3列出了所有的LTE安全秘钥。 References[1] Netmanias Technical Document, “LTE Security I: LTE Security Concept and LTE Authentication”, July2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5902[2] 3GPP TS 33.401, “3GPP System Architecture Evolution (SAE); Security architecture”.[3] 3GPP TS 24.301, “Non-Access-Stratum (NAS) protocol for Evolved Packet System (EPS); Stage 3”.[4] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5-LTE Security I: LTE Security Concept and LTE Authentication]]></title>
    <url>%2F2016%2F04%2F03%2F5-LTE-Security-I-LTE-Security-Concept-and-LTE-Authentication%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5902 I. Introduction实际中的无线通信，因为数据是原始的发送和接收的，这些数据可能被接收，并被意想不到的用户非法使用，存在窃听和篡改的风险。用户的位置和移动轨迹也是可以通过追踪用户连接的小区很容易的跟踪。这将会引起隐私侵权。移动通信提供安全特性来保证在空中接口传输的数据避免被篡改，且阻止意想不到的用户非授权的接入来接收数据，并保护用户的隐私。 LTE安全文档描述LTE网络提供的基本安全特征，包括LTE鉴权，NAS安全，AS安全。LTE鉴权是判定试图接入网络的用户是否是合法的签约用户。NAS安全和AS安全是在NAS和AS级别上在LTE空中接口上传输的数据确保能安全地传送。 LTE安全文档包含两个部分，part I II。第一个部分主要介绍LTE安全的概念和LTE鉴权的详细过程，第二部分主要介绍NAS和AS安全建立过程。 第一部分组成如下：在第二章，将介绍这两个文档的范围和概述，第三张介绍LTE鉴权过程，第四章总结LTE鉴权和LTE鉴权相关的秘钥。 II. LTE Security Concept2.1 LTE安全的范围和概念图1展示了LTE安全文档的范围和概念。这些文档的将包含以下三个区域。1、LTE鉴权：在UE和网络之间执行相互的鉴权。2、NAS安全：在UE和MME之间执行完整性保护验证和NAS信令的加密（加密和解密）3、AS安全，在UE和eNB之间执行完整性保护验证和RRC信令消息的加密，执行用户数据的加密。 LTE鉴权在移动网络中，鉴权是判定试图接入网络的用户是否是合法的签约用户。在多种多样的可用的鉴权过程中，在LTE网络中，在用户和网络之间使用EPS AKA（Authentication and Key Agreement鉴权和秘钥协商）过程来相互鉴权。 EPS AKA过程是由两步组成，第一步，HSS生成EPS鉴权向量（RAND, AUTN, XRES, K-ASME），并把他们发送给MME。第二步，MME选择EPS鉴权向量中的一个，并使用它来双向鉴权，并相互共享这同一个鉴权秘钥-KASME。相互鉴权是网络和UE相关鉴权的过程。在LTE网络，因为当生成鉴权向量时用户服务网络的ID是需要的，所以网络的鉴权是由用户来执行，用户的鉴权是由网络来执行。 ASME（Access Security Management Entity 接入安全管理实体）是一个从HSS接收顶层秘钥的实体，用在接入网络中。在EPS中，MME充当ASME的功能，K-ASME作为一个顶层秘钥在接入网络中使用。MME代表HSS使用K-ASME和UE实施相互鉴权。一旦相互鉴权，UE和MME共享K-ASME作为鉴权秘钥。 为了避免在无线链路上数据的窃听和篡改，K-ASME不是通过E-UTRAN传输给UE。而是，MME传输鉴权向量的部分内容给UE，使用这些内容来鉴权网络，并像HSS那样生成K-ASME。 NAS安全NAS安全，是设计用来在无线链路UE和MME之间安全地传输信令信息的，用来执行NAS信令消息的完整性检查和加密。不懂得秘钥用于完整性检查和加密。完整性检查是必须的，而加密是可选的功能。NAS安全秘钥，例如，完整性秘钥（K-NASint）和加密秘钥（K-NASenc）。 AS安全AS安全是用来确保在无线链路上UE和eNB之间数据传输的安全。在控制面对RRC信令消息实施完整性检查和加密，在用户面对IP数据包仅执行加密。不同的秘钥用于RRC信令消息的完整性检查/加密和IP数据包的加密。完整性保护是必须的，而加密是可选的功能。AS安全秘钥，例如，K-RRCint，K-RRCenc和K-UPenc，是由UE和eNB从K-eNB中衍生的，K-RRCint和K-RRCenc是用于控制面数据的完整性检查和加密，K-UPenc用于用户面数据的加密。完整性检查和加密是在PDCP层执行的。 UE可以从K-ASME中衍生出K-eNB，因为K-ASME是不传输到eNB的，而是由MME从K-ASME中衍生出K-eNB，然后传递给eNB。 2.2 LTE安全过程的概述图2展示了LTE安全过程的概述。1显示了LTE鉴权过程， 2和3展示了相应的NAS和AS安全建立过程。下面对每一个过程的简要描述。然后在第三章和第二篇文档中详细介绍每一个过程。 1、LTE鉴权当用户请求接入LTE网络时，在用户和网络之间使用EPS KAK过程来进行相互鉴权。MME一旦接收到了这样的请求，使用用户的IMSI来标识用户，并向HSS请求鉴权向量（AV）。HSS使用EPS AKA算法生成AV，AV={RAND, XRES, AUTN-HSS, K-ASME}，并转发给MME。 在MME存储AV之后，MME从中选择一个，使用这个AV来和UE执行相互鉴权。MME会转发RAND和AUTH-HSS给UE，然后UE使用EPS AKA算法计算出RES，AUTN-UE和K-ASME。UE比较自己的AUTN-UE和从MME接收到的AUTH-HSS来执行网络鉴权。一旦鉴权完成，发送RES给MME，MME比较从HSS接收到的XRES和从UE接收到的RES来执行用户鉴权。如果ＵＥ和网络都鉴权了，则他们就共享了相同的Ｋ－ＡＳＭＥ（尽管Ｋ－ＡＳＭＥ不在UE和MME之间传送）。 2、NAS安全一旦UE和MME相互鉴权完毕并具有相同的秘钥K-ASME，NAS安全过程开始。在这个过程中，当传送NAS信令消息时，NAS安全秘钥从K-ASME中衍生，用于这些NAS消息的安全传送。这个过程包含NAS消息的一个来回（Security Mode Command 和 Security Mode Complete消息），并在MME传送Security Mode Command 消息给UE是开始。 第一，MME选择一个NAS安全算法（Alg-ID：算法ID），并使用它们来从K-ASME来产生K-NASinc和K-NASenc。接着MME把K-NASinc算法用于Security Mode Command消息产生一个NAS消息鉴权码（NAS-MAC：Message Authentication Code for NAS for Integrity)。MME接着传输包含选择的NAS安全算法和NAS-MAC的Security Mode Command消息给UE。因为UE并不知道选择的加密算法，所以这个消息是完整性保护的，但是没有加密。 一旦接收到了Security Mode Command消息，UE使用MME选择的NAS完整性算法来验证完整性，并使用NAS完整性/加密算法从K-ASME中产生NAS安全秘钥（K-NASinc，K-NASenc）。接着使用K-NASenc加密Security Command Complete消息，并使用K-NASinc生成消息鉴权码NAS-MAC用于加密的消息。现在UE可以传输包含NAS-MAC的加密和完整性保护的消息到MME了。 一旦NAS安全建立起来，在UE和MME之间的NAS信令都是通过NAS安全秘钥加密和完整性保护的，在无线链路上安全的传输。 3、AS 安全在NAS安全建立完成之后，在UE和eNB之间AS安全建立过程开始。在这个过程中，当传输RRC信令消息和IP数据包时，使用从K-eNB产生的AS安全秘钥用于这些数据的安全传输。这个过程包括RRC信令消息的一个来回（Security Mode Command 和 Security Mode Complete 消息），并且这个过程在eNB传输Security Mode Command消息给UE时开始。 第一，MME从K-ASME中计算出K-eNB并传输给eNB，eNB使用K-eNB来执行AS安全过程。eNB选择AS安全算法（Alg-ID：算法ID）并使用这个算法ID从K-eNB中计算出完整性秘钥（K-RRCinc）和加密秘钥（K-RRCenc）用于RRC信令消息，计算出加密秘钥（K-UPenc）用于用户面。接着，应用K-RRCint到Security Mode Command消息产生一个消息鉴权码（MAC-I，Message Authentication Code for Integrity）。现在eNB开始传输包含选择的AS安全算法和MAC-I的Security Mode Command消息到UE。 一旦从eNB接收到Security Mode Command消息，UE使用eNB选择的AS完整性算法验证完整性，并使用AS完整性/加密算法来计算出AS加密秘钥 (K-RRCint, K-RRCenc and K-UPenc)。接着UE使用RRC完整性秘钥产生一个消息鉴权码MAC-I给Security Mode Complete 消息，接着转发包含MAC-I的这条消息给eNB。 当eNB使用AS安全秘钥成功的验证了接收到的Security Mode Complete 消息的完整性，AS安全建立过程完成的。 在AS安全建立之后，UE和eNB之间的RRC信令消息都是使用AS安全秘钥加密的和完整性保护的，在空中链路上传输的用户IP数据包是加密的。 III. LTE Authentication Procedure在第二章简要介绍了LTE鉴权过程，接下来将详细介绍。图3是当UE附着到LTE网络时执行基于EPS AKA的LTE鉴权过程。在USIM和HSS/AuC上存储着固定的秘钥（LTE 秘钥K，IMSI）。当UE被生产的时候，在USIM卡上就存储了LTE K和IMSI，并且当用户开始签约LTE网络时在HSS/AuC中提供。 3.1 由UE请求的鉴权1、[UE -&gt; MME] UE请求对网络的鉴权 当UE在初始附着时试图接入网络，UE传送Attach Request消息给MME，这个消息触发了EPS AKA过程。在Attach Request消息中包含(IMSI, UE网络能力, KSIA-SME=7)参数。其中 IMSI：（ International Mobile Subscriber Identity），是和用户关联的唯一的ID。 UE网络能力：UE可用的安全算法。 KSIA-SME=7：指示UE没有安全秘钥。 UE网络能力通知MME 连接到EPS的UE具有什么样的能力，并指示UE支持的NAS和AS算法，比如EEA和EIA（EPS Encryption Algorithms 和 EPS Integrity Algorithms）。他们是用1bit的值来标识是否存在，（比如EEA0=0，EEA1=1……EIA1=1，EIA2=1….），表1列出了UE网络能力信息。 KSI-ASME标识UE和MME中的K-ASME，由3bit组成，从000到111（0-7），7是标识在UE中没有可用的K-ASME。 3.2 在MME和HSS之间鉴权数据的交换2、[MME -&gt; HSS]MME向HSS请求鉴权数据 MME识别到UE没有可用的K-ASME，通过向HSS发送Authentication Information Request消息来发起LTE鉴权过程获取新的鉴权数据。Authentication Information Request消息包含(IMSI, SN ID, n, Network Type)参数。其中 IMSI：和用户关联的唯一的ID。 SN ID（Serving Network ID服务网络ID）：是指用户接入的网络，由PLMN ID组成。 n（鉴权向量的个数）：MME请求鉴权向量的个数 Network Type：UE接入网络的类型（在此是E-UTRAN）。 一旦从MME接收到Authentication Information Request消息，HSS生成RAND和SQN，并使用EPS AKA算法用LTE K，SQN，RAND计算出XRES，AUTN，CK，IK。然后使用KDF（Key Derivation Function秘钥派生函数）用CK，IK，SQN和SN ID（PLMN）计算出接入网络的顶级秘钥（K-ASME），然后传输给MME。KDF是一个单向函数。因为在生成K-ASME时需要SN ID，所以当服务网络发生变化时K-ASME需要重新生成。在K-ASME生成后，HSS形成鉴权向量组AV-i=（RAND-i，AUTN-i，XRES-i，K-ASME-i），i=0….n-1. 3、[MME &lt;- HSS]HSS响应鉴权数据的请求 HSS应MME请求生成需要AV，然后发送Authentication Information Answer (AVs)消息给MME。 3.3 UE和MME之间的相互鉴权MME存储从HSS接收到的AV，然后在UE的LTE鉴权中选择其中一个使用。在图3中，MME选择第i个AV。K-ASME是MME基本的秘钥，在接入网络中作为一个顶级的秘钥起作用。它只存在于EPC中，不会通过E-UTRAN传送给UE，因为那样传输是不安全的。MME分配KSI-ASME（K-ASME的索引）代替K-ASME传送给ＵＥ，因此UE和MME都能使用KSI-ASME来代替K-ASME（在图3中，KSI-ASME=1）。 4、[UE&lt;-MME]MME请求对用户鉴权MME保留在AV中的K-ASME-i和XRES-i，把KSI-ASME-i代替K-ASME-i，RAND-i，AUTN-i包含在Authentication Request消息中传递给ＵＥ。XRES-i会在待会鉴权用户的时候用到。 UE一旦从MME接收到Authentication Request消息，传递RAND-i和AUTN-i给USIM，USIM使用和HSS相同的EPS AKA算法用存储的LTE K和接收到的RAND-i和HSS生成的SQN（SQN隐藏在AUTN中）计算出RES，AUTN-UE，CK，IK。UE比较通过EPS AKA算法产生AUTN-UE和从MME接收到的AUTN来鉴权LTE网络。 5、[UE-&gt;MME]UE响应对用户的鉴权一旦UE完成网络鉴权，UE发送包含由EPS AKA算法生成RES的Authentication Response消息给MME。如果使用AUTN网络鉴权失败，UE包含失败原因的Authentication Failure消息给MME。 当MME接收到从UE的Authentication Response消息，将对比由UE生成的RES和从HSS接收到的AV中的XRES-i来鉴权用户。 在完成网络鉴权之后，USIM卡传输CK，IK给UE。UE使用KDF函数用CK，IK，SQN，SN ID生成K-ASME，并使用从MME接收到的KSI-ASME作为它的索引存储。然后，在UE和MME之间NAS安全监理时用KSI-ASME代替K-ASME。 IV. Closing上面，我们已经讨论了LTE鉴权过程。LTE鉴权是基于EPS AKA过程的用户和网络之间的相互鉴权。在服务网络中的MME和UE代替HSS来执行相互鉴权，鉴权的结果是在UE和MME之间具有相同的K-ASME。在表2中总结了LTE鉴权相关的秘钥。在第二个文档将基于K-ASME来介绍NAS和AS安全。 References[1] Netmanias Technical Document, “LTE Security II: NAS and AS Security”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5903.[2] 3GPP TS 24.301, “Non-Access-Stratum (NAS) protocol for Evolved Packet System (EPS); Stage 3”.[3] 3GPP TS 33.401, “3GPP System Architecture Evolution (SAE); Security architecture”.[4] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4-LTE Identification III: EPS Session/Bearer Identifiers]]></title>
    <url>%2F2016%2F04%2F03%2F4-LTE-Identification-III-EPS-Session-Bearer-Identifiers%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5907 I. Introduction在LTE Identification I II中我们学习了UE ID，ME ID，NE ID和Location ID。这篇文档将学习和用户数据传输有关的EPS会话/承载ID。端到端的会话包含应用层实体不在本篇文档讨论范围，仅仅包含提供用户用于PDN连接的EPS会话。在表1表示这篇文档讨论的ID。我们在LTE identification I II中学习了不同的UE，ME，NE，有多个EPS会话ID和承载ID在一个UE中使用。这意味着，在一个UE中可以同时建立不止一个EPS会话和承载，所以需要ID来标识他们。 II. EPS Session and EPS Bearer: Overview在我们讨论和EPS会话和承载相关的ID之前，我们需要了解一下EPS会话和承载是什么，并且描述一下这些ID之间的关系。图1显示了一个用户的EPS会话和承载，并在下面标识了ID。 2.1 EPS会话UE和PDN之间的IP连接叫PDN连接或EPS会话。每一个PDN连接是由UE的IP地址和PDN ID（也叫APN）描述的。它有不止一个EPS承载来传输用户数据（IP数据包），并应用从PCRF到EPS承载获得的服务质量（QoS）策略。最小最基本的承载是EPS会话的一个默认EPS承载。 一旦EPS会话建立意味着1）已经选择一个用户使用服务的PDN（通过用户的输入或者基于HSS提供的签约信息），2）已经为用户分配了用于PDN内的IP地址，3）已经选择了用于用户IP数据包的策略规则（QoS和计费策略），4）在LTE网络上传送IP数据包的默认EPS承载已经建立了。通过已经建立的这个EPS承载，IP数据报可以通过运营商提供的策略在用户和PDN之间相关交换。会话的管理和操作，包括PCRF会在其他文档讨论，PDN ID（APN）将会作为和EPS会话相关的一个ID在本文档中讨论。 2.2 EPS承载EPS承载负责传送和处理标记了UE IP地址的IP数据流，并在UE和PDN之间传输（UE – P-GW – PDN）。另一个方面，一个EPS承载就是LTE网络上传输IP数据包的管道，例如，在UE和PGW之间(UE – eNB – SGW - P-GW)。一个UE可以同时又多个EPS承载。不同EPS承载使用MME分配的EPS bearer ID来标识。如图1所示，一个EPS承载是由以下三个承载串接起来的（DRB，S1承载和S5承载）: [UE] - [eNB]: 无线数据承载 (DRB)，EPS承载在LTE-Uu接口上建立。用户数据（IP数据包）通过DRB来传输。不同的DRB使用eNB分配的不同的DRB ID来标识。 [eNB] - [S-GW]: S1承载，EPS承载在S1-U接口上建立。用户数据通过GTP隧道传输。不同的S1承载使用由GTP隧道端点（(eNB and S-GW)）分配的TEID来标识。 [S-GW] - [P-GW]: S5承载，EPS承载在S5接口上建立。用户数据通过GTP隧道传输。不同的S5承载使用由GTP隧道端点（(S-GW and P-GW) ）分配的TEID来标识。 E-RAB是有UE和SGW两个端点的承载，包含DRB和S1承载。E-RAB是由DRB和S1承载串接，并在从UE到SGW连接(UE –eNB – S-GW)。不同的E-RAB使用由MME分配的E-RAB ID来标识。DRB ID和E-RAB ID是和EPS承载ID一对一映射的。 2.3 EPS承载的类型之前我们描述了EPS相关的承载ID，现在我们看看EPS承载的不同类型和他们是怎么工作的。图2描述了EPS承载的不同类型：默认承载和专用承载。每一个PDN必须有一个默认的EPS承载，但可以没有或者有多个专用ESP承载。 LTE网络是全IP网络，提供给用户永久在线的IP连接。这就意味着，一旦UE使用初始附着到网络分配的IP地址连接到PDN，在LTE网络上在默认EPS承载建立之后，IP连接将一直保持连接，直到UE从LTE网络去附着（比如，PDN连接终止了）。即使用户没有数据要发送，这个默认的EPS承载也是一直保持激活，并准备着可能到达的用户数据。 如果默认的EPS承载不能足够满足QoS，则需要建立额外的EPS承载。建立的额外EPS承载叫做专用EPS承载，并且根据用户或者网络的需要可以建立多个专用承载。当没有用户数据，这些专用EPS承载可以被移除，但默认的EPS承载不会被移除，一直保持用户和网络之间的连接，直到用户从网络去附着。专用EPS承载是和默认EPS承载联接在一起的。这个联接的承载是用LBI（Linked EPS Bearer Identity）标识，指示他们都联接到同一个默认EPS承载。 UE发送或者UE接收的IP数据都是在LTE网络上根据QoS等级通过适当的EPS承载来传输。上行IP数据从UE一直映射到EPS承载，而下行IP数据是从PGW一直映射到EPS承载。 根据2.2和2.3节讨论的，和EPS承载相关的ID有EPS Bearer ID，E-RAB ID，DRB，TEID，LBI。第三章将详细介绍这些EPS会话和承载ID。 III. Identifiers for EPS Session/Bearer (Session/Bearer IDs)3.1 识别PDN的ID：PDN ID(APN)PDN使用PDN ID（APN）来标识。一个APN关联一个用户想连接PDN的接入点。在图3是APN和格式。APN是由网络ID和运营商ID组成。网络ID用来识别PDN，像因特网、企业VPN，或者用来识别PDN提供的服务，像IMS。 APN是在用户签约时由HSS作为签约信息提供的。一旦UE初始附着，一个默认的APN从HSS下载到MME。MME首先基于APN选择一个PDN连接UE，接着通过UE连接到的PDN选择PGW。在图3中，MME基于APN1选择PDN1，然后选择PGW 1建立PDN1连接。 3.2 在EPS网络标识用户数据传输的ID：EPS承载IDEPS承载是UE和PGW之间虚拟连接集合，用来LTE网络上传输用户数据。EPS承载中不同的承载是用4bit的EPS承载ID标识的。表2是EPS承载ID值。一个UE可以最多11个EPS承载，他们的ID值从5-15。 图4是EPS承载相关的ID和他们是谁分配的。EPS承载ID，不论默认的还是专用的，都是由MME分配的。当UE初始附着到LTE网络，MME从HSS中获得建立默认EPS承载需要的QoS配置文件，并基于接收到的QoS建立起承载。当MME分配EPS承载ID时，发起默认EPS承载建立的过程。EPS承载的两个端点是UE和PGW。他们都执行数据流过滤（UE过滤上行用户数据流，PGW过滤下行数据流）来通过数据流要发送的哪一个承载来决定。图2是包含五个IP数据流（1-5）的下行用户传输。当IP数据流从PDN到达PGW时，PGW实行数据流过滤来决定IP数据流传输使用哪一个承载，并使用相应的承载来传输。下行EPS承载数据是通过S5承载，S1承载和DRB最终到达UE，并把数据流以IP流的方式传输到上层。为了让这个过程进行，每一个实体都必须对每一个承载映射承载ID，如表3。图5是映射的过程。 3.3 在UE和EPC之间来识别EPS的ID：E-RAB ID如图1/4/5所示，E-RAB是UE和SGW之间的一个EPS承载集合，用4bit的E-RAB ID来标识。E-RAB ID是由MME分配，通常和EPS承载ID有相同的值（根据EPS承载的建立），并和EPS承载ID一对一的对应。在EPS承载建立过程中，当MME请求eNB建立E-RAB时，eNB和UE创建DRB，和SGW创建S1承载。 默认EPS承载使UE一直和网络保持连接。当没有用户数据，UE保持在空闲状态，E-RAB是去激活的，只有S5承载保持存在。但是，只要用户数据到达，E-RAB重建，然后允许传送数据流从UE到PGW。 3.4 在无线链路上标识EPS承载的ID：DRB ID如图1/4/5所示，DRB是在UE和eNB之间在无线链路上的一个集合，用4bit的DRB ID来标识。一旦建立EPS承载，DRB ID由eNB分配，并且和EPS承载ID一对一对应。在EPS承载建立过程中，当MME请求eNB建立E-RAB时，eNB分配DRB ID创建DRB来和UE通信，并基于需求的QoS选择合适的逻辑信道配置参数。 3.5 识别GTP隧道端点的ID：TEIDS1承载和S5承载，都是EPS承载的一个部分，分别在eNB和SGW之间，在SGW和PGW之间以GTP隧道的方式建立。GTP隧道是以上行和下行两个端点的TEID标识的，TEID是32bit。图4显示S1和S5 GTP隧道上TEID的分配。当EPS承载建立时，对于S5承载，SGW分配DL S5 TEID，PGW分配UL S5 TEID。对于S1承载，SGW分配UL S1 TEID，eNB分配DL S1 TEID。 3.6 连接默认EPS承载和专用EPS承载的ID：LBI如图2所示，一个EPS会话有不止一个EPS承载。默认EPS承载在当EPS会建立时建立，在EPS会话结束时结束。另一方面，专用EPS承载可以在EPS会话建立后随时创建和删除。因为默认承载和专用承载都属于同一个用户的同一个PDN，所以需要一个ID来标识用于同一个PDN的两个不同的承载。这个引入的ID是LBI，默认EPS承载ID用作LBI。 当默认EPS承载创建时，MME分配一个承载ID，这个ID也作为一个LBI指定。接着，当专用EPS承载创建时，MME分配LBI（和承载ID一起）来标识默认承载。 IV. Summary我们已经表1中分类了EPS会话和承载相关的ID。表4分类和列出他们使用的范围等。表5总结所有的LTE ID。 V. Closing通过LTE identification文档，我们全部介绍了表1中的LTE ID，并且简要的介绍了他们的功能和目的。基于我们经学到的LTE网络架构和LTE identification，我们可以继续讨论高主要的议题。 References[1] Netmanias Technical Document, “LTE Identification I: UE and ME Identifiers”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5905[2] Netmanias Technical Document, “LTE Identification II: NE and Location Identifiers”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5906[3] Netmanias Technology Document, “LTE Network Architecture: Basic”, July 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5904[4] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3-LTE Identification II: NE and Location Identifiers]]></title>
    <url>%2F2016%2F04%2F03%2F3-LTE-Identification-II-NE-and-Location-Identifiers%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5906 I. Introduction在之前的文档，LTE identification I介绍了UE和ME的标识。这篇文档，将介绍网络设备（Network Equipment）和Location ID。在这篇文章中被标识的网络设备包括eNB，MME，PGW，都是EPS实体。另外小区（eNB下由一个天线覆盖的区域）和这些网络设备一起讨论。Location ID包括所有标识UE位置的ID。UE在网络中是以TA级别注册的。所以，在这篇文档中TA相关的ID和Location ID一起讨论。 在第二章和第三章，NE ID和Location ID基于分类分别讨论。在第四章，总结这些ID的共同特征。 这篇文档设计的ID的范围和类型在图1和表1中展示。如果运营商的策略需要eNB报告UE（属于这个eNB）的位置，在方框中的ID（ECGI，TAI）会从eNB到PCRF传输。 II. Identifiers for Network Equipment (NE IDs)这章描述LTE 网络设备相关的ID。属于NE ID组的ID有MME的GUMMEI和MMEI，eNB的全球eNB ID和eNB ID，小区的ECGI和ECI，PGW的PGW ID。LTE NE ID被分为两类，一类是有PLMN ID，一类是没有PLMN ID，取决于他们是在PLMN内或者是全球的唯一标识。 2.1 标识MME的ID： GUMMEI, MMEI, MMEGI and MMECMME处于E-UTRAN和EPC之间。它是关键性的控制设备，它通过和HSS交换控制信号允许UE附着到LTE网络上，在HSS中包含UE的用户签约信息。它在核心网侧通过和SGW（或PGW）交换控制信号支持承载的管理，在E-UTRAN侧通过和eNB交换控制信号支持UE的移动性。通常，LTE运营商把多个MME分为一组，把他们作为MME组来操作。MME ID用来标识MME，是当MME安装时由运营商分配的。 MMEI用来标识在运营商的网络中的MME（比如，A LTE运营商的网络管理人员需要标识在A LTE网络中的MME）。GUMMEI包含PLMN ID和MMEI，是在运营商外部用来识别MME的（比如，当C操作A和B LTE运营商的网络时，C需要标识在A LTE网络中的MME）。MME组是由运营商构建的，MMEI包含MMEGI和MMEC，MMEGI代表MME组，MMEC代表一个组内的特定的MME。图2是MME相关的ID和他们的格式。 2.2 标识eNB的ID：eNB ID和Global eNB IDeNB ID是用来标识运营商网络内的一个eNB，而Global eNB ID是由PLMN ID和eNB ID组成，是用来在网络外面标识一个eNB。图3是eNB和小区相关的ID和他们格式。为了标识属于一个eNB的小区，通过在eNB ID和Global eNB ID上加上一个小区ID。 eNB ID和小区ID是在eNB安装时由网络运营商分配的。一旦安装，eNB开始和MME之间建立S1连接的过程。当eNB请求MME 建立S1连接时，eNB报告Global eNB ID/所支持的TA/所支持的CSG（Closed Subscriber Group）。CSG是一种只对一部分签约用户开放的小区，它是由单一或者一些小区组成。MME发送服务的GUMMEI给eNB作为对S1连接建立请求的响应，并提供MME池的信息。 2.3 识别PGW的ID：PGW ID当一个UE尝试附着在LTE 网络上，LTE网络提供给UE PDN连接。为了在UE和PDN之间建立PDN连接，MME需要知道UE连接的PDN和UE附着的PGW。默认的PDN作为签约用户的配置文件在HSS中已经提供了。所有，MME只需要从HSS中下载这些信息就可以了。对于PGW，有两种方式分配固定分配（由网络运营商提供，在HSS中作为签约用户的配置文件）和动态分配（根据运营商提供的PGW选择策略，MME选择一个PGW）。对于固定分配，HSS把PGW ID通知给MME，所以MME可以请求PGW建立PDN连接。 PGW ID用来标识PGW，可以是IP地址或者FQDN（Fully Qualified Domain name全称域名）格式。图4是依据固定分配策略分配的PGW ID和格式。举例，UE的默认PDN中一个PDN1用于因特网服务，一个PDN2用于语音服务。当UE发起接入到LTE网络，MME向HSS请求UE的签约信息，HSS通知MME 1）UE的默认PDN是PDN1（因特网）和PDN2（IMS），2）PGW连接PDN1的是PGW 1，连接PDN2的是PGW 3。MME接着通过PGW 1在UE和因特网之间建立PDN连接，通过PGW 3在UE和IMS之间建立PDN连接。对于根据动态分配策略的PGW ID分配，MME从DNS中获取PGW IP地址列表，从列表中选择一个，然后请求PGW建立PDN连接。如果PGW列表是由DNS提供，MME按照PGW选择策略从列表中选择一个。 III. Identifiers for UE Location (Location IDs)MME负责管理UE的移动性，所以必须根据UE的位置来更新信息。如果UE在激活状态并且使用服务，UE的位置在LTE网络中是小区级别已知的。如果UE是在空闲状态并没有使用服务时，UE的位置则是TA级别已知的。因为在第二章已经介绍了小区ID，所以这一章只介绍TA ID。 3.1 识别UE位置的ID：TAC和TAIUE在TA级别注册到网络。MME在TA级别定位空闲状态的UE。标识TA的ID是TAC(Tracking Area Code)和TAI (Tracking Area Identifier)。TAC用来在一个运营商网络中标识一个TA。TAI是包括PLMN ID和TAC，用来唯一的标识一个TA。图5是TA ID不同类型和格式。当UE初始附着到一个LTE网络上，UE通过MME注册到网络上。在初始附着时，MME为UE分配一个TAI列表，并保持对UE位置的更新。UE把自己的新位置通知给MME，并当离开注册的TA时请求TA更新。用这种方法，MME就知道UE当前所待在的TA，并保存UE更新过的TAI列表。如果UE移动到包含在TAI列表中的TA区域，UE不会请求TA更新。但是，如果当前TA的更新周期超时，UE需要把自己当前的TA通知给MME，即使UE待在的TA包含在TAI列表中，让MME知道UE可以接收数据。 当在LTE网络有到达UE的数据，MME需要知道UE的位置来发送数据。如果UE是在激活状态，MME知道UE待在哪一个小区，因此可以容易地转发数据。但是如果UE在空闲状态，MME不知道UE待在哪一个具体的小区。所以，MME搜索UE最后一次报告的TA。空闲状态下的UE会在特定的周期醒来检查是否有寻呼消息。如果发现被寻呼了（通过检查在寻呼消息中的S-TMSI），它会相应寻呼消息来接收数据。TA区域越大意味着能容易地找到UE的概率越大。但是，在同一时间，TA区域越大意味着需要寻呼更多的eNB，因此需要更多的信令消耗。怎么分配TAI列表是一个优化的问题。 eNB通过安装时服务开通消息知道它属于哪个MME和TA。eNB中的每一个小区在系统消息中广播自己的小区ID（ECI，ECGI）和TA信息（TAC，TAI）。尝试接入新小区的UE通过监听广播系统消息判断新的小区是否和当前的小区有不同的TA，它的TA需要改变，或者新小区在UE的当前TA。图5展示了分配TA列表的UE的行为。在图中，eNB1是在TA1，eNB在TA2，eNB3和eNB4是在TA3（一个TA可以包括几个小区和eNB）。UE1注册到MME1，被分配了{TAI1, TAI2}的TAI列表。UE2注册到MME2，被分配了{TAI2, TAI3}的TAI列表。在UE1接入到eNB1后变为空闲状态，因为它沿着点线移动（eNB1 -&gt;eNB2-&gt;eNB3）,UE1的行为描述如下（TA在小区级别检测，但，当在同一个eNB下不同小区之间转移不在这里讨论）： 在eNB1：UE当前的TA是TA1 当从eNB1移动到eNB2：UE1当尝试接入新小区时，从新小区广播的系统信息知道新小区是TA2。UE检查TAI列表，发现TA2包含在TAI列表，所以，不需要请求TA更新。 当从eNB2移动到eNB3：UE1当尝试接入新小区时，从新小区广播的系统信息知道新小区是TA3。UE检查TAI列表，发现TA3不包含在TAI列表，所以，需要发送TAU请求消息到MME来更新自己的位置。 IV. Closing我们在之前的文档知道了LTE ID中的UE ID和ME ID，在当前文档学习了NE ID和Location ID。表2总结了这篇文档涉及的ID，其他的ID将会在第三篇文档中介绍。 References[1] Netmanias Technical Document, “LTE Identification I: UE and ME Identifiers”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5905[2] Netmanias Technology Document, “LTE Network Architecture: Basic”, July 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5904[3] 3GPP TS 23.003, “Numbering, addressing and identification”.[4] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-LTE Identification I: UE and ME Identifiers]]></title>
    <url>%2F2016%2F04%2F03%2F2-LTE-Identification-I-UE-and-ME-Identifiers%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5905 I. Introduction在LTE网络中，根据和其他ID的关系使用不同的ID来标识每一个实体。就像在人际网络中使用不同的名字和头衔来标识一个人。理解这些ID和EPS实体是对理解LTE技术很必要。 我们之前讨论了第一个问题—LTE网络架构。现在我们讨论LTE标识，这是我们的第二个问题，将会有三个相关的文档来讨论。这个文档是第一个，聚焦在用户设备（UE） ID。第二个和第三个文档将f分别涉及到网络设备（NE）ID和EPS会话/承载标识。 这个文档组织如下。第二章，对LTE ID分为几个组。第三章和第四章，将分别描述UE ID和ME ID。第五章，总结UE和ME ID的总体特征。 II. Classification of LTE Identification图1表示，在LTE网络参考模型一些实体和接口使用和定义的ID。这些LTE ID将按照他们的生成时间/属性类型（固定的或暂时的）/其唯一标识的范围。 创建时间：LTE ID的创建时间有以下几种 一旦设备安装上就委任的 在服务操作之前或者进行中由运营商提供的 根据需求，当用户接入网络或者使用服务才创建 LTE ID的分配或者提供是在图1中在相应的实体上用蓝色方块表示。 类型：LTE ID有一个属性类型，固定的（一旦创建就保持固定），临时的（当激活时发生变化）。被委任的或者分配都有固定的值，但根据需求，当用户接入网络或者使用服务时分配的是临时的值。 范围（其ID被唯一标识的内部）：每一个LTE ID在全世界/运营商网络/实体还是信道上是唯一标识的。图1中，不同的ID根据LTE标识实际执行的地方来使用，例如，在哪个层，在哪个接口，或者在哪个物理区域。为了描述的方便，图1中的ID被分类展示在表1中。首先，EPS实体的ID被分组为UE ID，ME ID，NE ID。这些EPS实体被分类为UE和NE。ME是UE的一部分，被从UE中分离，被分为一个独立的组。NE是由LTE运营商操作的网络实体，比如，MME，eNB，PGW。像IMSI/GUTI/S-TMSI/IP地址/C-RNTI/UE S1AP ID/UE X2AP ID这样子的ID标识一个用户的，属于UE ID组。像IMEI/IMEISV这样的ID标识一个设备的，属于ME ID组。像MME的GUMMEI和MMEI，eNB的全球eNB ID和eNB ID，小区的ECGI和ECI，PGW的PGW ID，这些都属于NE ID组。像TAI和TAC这样的Location ID来标识用户附着的区域。最后，像PDN ID（or APN），EPS承载ID，E-RAB ID，DRB ID，TEID，LBI这样的会话/承载ID是和用户数据传送有关，用来识别EPS会话和EPS承载。 这个文档，描述了在表1中灰色的UE和ME的LTE ID。第二个文档将涉及LTE NE ID和Location ID用来标识UE的位置区域。第三个文档将讨论EPS会话和承载ID。 表1，LTE ID的分类 ID group LTE ID 相关的文档 UE ID IMSI, GUTI, S-TMSI, IP address (PDN address), C-RNTI, eNB UE S1AP ID,MME UE S1AP ID, Old UE X2AP ID, UE X2AP ID LTE Identification I ME ID IMEI LTE Identification I NE ID GUMMEI, MMEI, Global eNB ID, eNB ID, ECGI, ECI, P-GW ID LTE Identification II Location ID TAI TAC LTE Identification II 会话/承载ID PDN ID(APN), EPS Bearer ID, E-RAB ID, DRB ID, TEID, LBI LTE Identification III III. Identifiers for User Equipment (UE IDs)LTE网络是全IP网络。因为这个特性，在LTE网络中的UEs共享无线和网络资源。LTE网络的EPS实体给每一个UE分配UE ID来识别不同的UE。因为UEs在不同层和接口共享资源，所以需要多种多样的UE ID。在移动通信网络中最必要的ID是PLMN ID，用来识别特定网络的运营商。我们首先开始包含PLMN ID的UE ID的描述。 3.1 PLMN ID指示用户需要签约的网络PLMN是运营商分配和操作的，用来为公众提供移动通信服务。PLMN ID通常用来识别用户需要签约的移动通信网络。它包含MCC和MNC，如图2所示。MCC的三个数字表示用户所在的移动网络所属的国家。每一个国家有一个或多个PLMN ID。MCC的分配需要ITU-T的授权，定义在ITU-T E.212 [3]。例如韩国的MCC是450.一个MNC标识移动通信网络的运营商，是由每一个国家分配的。例如，在韩国有三个移动运营商，SK电信，KT和LG U+，他们的MNC如图2所示。 3.2 IMSI:分配给签约用户的固定IDIMSI（International Mobile Subscriber Identity）是全球为一个号码来标识一个签约用户。图3表示了IMSI的分配过程和IMSI的格式。一个IMSI是由指示签约用户网络的PLMN和由运营商分配的MSIN（Mobile Subscriber Identification Number）。IMSI长度最大15个数字。MSIN识别一个PLMN中的签约用户。当用户购买一个USIM卡并签约一个移动网络，就有了一个内建的唯一的IMSI开始启用并和用户关联。IMSI是存储在手机的USIM卡中，IMSI和用户签约信息是由运营商提供给HSS和SPR。在提供之后，当UE attach LTE网络的时候，UE发送IMSI给移动网络。在接收到UE的IMSI之后，MME开始LTE网络的默认EPS承载和基本传输路径的建立（通过1）基于从UE接收到的IMSI，识别出签约用户的本地网络，2）选择持有用户签约信息的HSS，3）从HSS中下载信息）。 存放在USIM/HSS/SPR中的IMSI是不可移除的固定值。另一方面，存储在MME/SGW/PGW/PCRF中的IMSI，在UE初始附着过程建立默认EPS承载时是一个临时值，当默认承载终止时被移除。 3.3 IDs Used at MME: GUTI, S-TMSI and M-TMSIIMSI是一个固定唯一的ID来标识签约用户。如果它经常暴露在无线链路上将会不安全。为了增强安全性，当UE附着在网络时MME给UE分配一个GUTI（Globally Unique Temporary Identifier）用来代替IMSI来标识UE。图4是GUTI的分配过程和格式。GUTI分配：当UE第一次附着到LTE网络时，它使用IMSI请求接入网络并从网络获得GUTI。当UE再次附着网络时，UE使用GUTI代替IMSI。当再次附着到网络时，UE使用IMSI或者GUTI作为ID取决于下次更新时临时标识（TIN）设置的是什么。 一旦UE的初始附着过程和TAU过程是成功执行，MME分配和发送GUTI给UE，接着设置GUTI作为它的TIN。其后，当UE附着网络或者请求TAU更新时都使用GUTI代替IMSI。 GUTI格式：LTE运营商有一个或者多个MME组包含多个MME。因此MMEI（MME Identifier）是由代表MME组的MMEGI（MME Group Identifier）和代表组内一个MME的MMEC（ MME Code）组成。GUMMEI（Globally Unique MME Identifier）是在MMEI基础上加上PLMN。每一个MME每一个注册的用户分配M-TMSI，这是在MME中唯一的值，来保护签约用户的机密性。 GUTI是由GUMMEI和M-TMSI组成，是全球唯一的值，用来代替IMSI标识UE。不像IMSI有一个固定的值，GUTI是临时的值，当UE注册到LTE网络时由MME分配的。所以，当GUTI经常暴露在无线链路上也是保持安全的。S-TMSI由MMEC和M-TMSI组成，用来唯一标识MME组中的UE。如果运营商没有多个MME组时，可以使用比较短的S-TMSI来提高在无线链路上传输的有效性。 3.4 IP地址：连接PDN必须的IDIP地址，也称为PDN地址，是当UE初始附着在LTE网络时LTE网络分配给UE的用来连接PDN。因为UE可以根据不同的服务通过LTE网络连接到多个PDN，所以LTE网络针对每一个UE连接到的PDN为UE分配不同的IP地址（例如两个IP地址用于两个连接的PDN，三个IP地址用于三个连接的PDN等等）。当IP数据包从LTE网络到PDN转发，或者从PDN接收数据包时，这些IP地址用来标示IP数据包发送或接收的UE。 IP地址固定或者动态地分配用于UE连接PDN。这两种分配方式称为静态IP分配和动态IP地址分配。对于静态IP地址分配，运营商在签约的时候分配给UE一个固定的IP地址，并把这个UE的IP地址提供给HSS。不管UE附着的时间和地点，每次UE发起附着到PDN时，UE都被分配相同的IP地址。对于动态的IP地址分配，PGW有一个IP地址池，每次UE执行初始附着到LTE网络时，UE被动态地从IP地址池中分配一个可用的IP地址。因此，每次UE初始附着LTE网络时，分配给UE的IP地址都不一样。 图5是动态IP地址分配的实例。它简单介绍了在初始附着过程，默认承载建立时，PGW动态分配临时IP地址的过程和在初始附着过程分配动态IP地址后，UE使用因特网服务的过程。 3.5 C-RNTI：在一个小区内分辨UE需要的IDC-RNTI（Cell Radio Network Temporary Identifier）是在随机接入过程中由eNB分配的，并仅仅在当前的服务小区有效。在小区中的UE是使用C-RNTI来唯一标识的。当UE离开当前小区，通过随机接入过程移动到一个新的小区时，分配一个新的C-RNTI。图6是C-RNTI是怎么样分配的，和C-RNTI应用于哪一层。 在上行和下行链路，eNB负责无线资源的分配。它通过在PDCCH（Physical Downlink Control Channel）上广播C-RNTI通知在下一个TTI（Transmission Time Interval）哪一个UE可以使用无线资源。如果UE在它所接入小区的PDCCH信道上发现自己的C-RNTI，则UE就获知在在下一个上行或下行TTI上可以使用无线资源。 3.6 在S1-MME接口上需要成对的UE S1AP ID来分辨UES1AP层成功优酷S1-MME接口上eNB和MME之间的控制信息。在同一时间有多个UE和eNB保持连接。eNB和UE对应的MME交换所有的S1AP控制信息时使用相同的S1链路。所以，为了识别那个S1AP消息对应于哪一个UE，当eNB发送UE的第一个S1AP消息给MME时，eNB为每一个UE分配了一个ID（eNB UE S1AP ID）。同样的，MME通过多个S1链路和多个eNB交换S1AP信息。为了识别哪一个S1AP消息对应于哪一个eNB的哪一个UE，当MME发送第一个UE消息给eNB时分配一个ID（MME UE S1AP ID）。 在S1AP消息的第一个来回后，在S1-MME接口上交换的所有用户控制消息（S1AP）是使用一对UE S1AP ID来传输的（eNB UE S1AP ID, MME UE S1AP ID），目的是为了eNB和MME都能分辨出来哪一个S1AP消息对应于哪一个UE。然后，根据这对ID，MME可以找到接收到的S1AP消息是来自哪一个eNB的哪一个UE，并且eNB可能知道接收到S1AP消息来自哪一个UE。图7是UE S1AP ID的分配过程和UE S1AP ID应用在S1AP层。 3.7 在X2接口上需要成对的UE X2AP ID来区别UEX2AP层处理在X2接口上两个相邻的eNB之间的控制信息。在两个相邻的eNB之间UE的切换时，X2AP消息使用相同的X2链路从UE发送到对端的eNB。第一次eNB（源eNB或者目的eNB）发送X2AP给对端eNB时，eNB为每一个UE分配ID，并使用这个ID发送消息来标识是哪一个UE的X2AP消息。源eNB在第一个到目的额NB的消息（切换请求消息）中分配一个Old eNB UE X2AP ID，目的eNB在第一个到源eNB的响应消息（切换请求确认消息）中分配一个New eNB UE X2AP ID。 在第一次来回信息交换后，所有的在X2接口上和切换相关的X2AP消息都使用成对的ID(Old eNB UE X2AP ID, New eNB UE X2AP ID)来交换，目的是为了源eNB和目的eNB都能识别出来哪一个X2AP消息对应于哪一个UE。图8是UE X2AP ID的分配过程和UE X2AP ID应用在X2AP层。 IV. Identifiers for Mobile Equipment (ME IDs)第四章将描述ME ID。在讨论ME ID之前先认识下UE和ME的关系。一个UE由ME和USIM（UMTS Subscriber identity Module）卡组成。ME可以分为TE（Terminal Equipment）和MT（Mobile Terminal）。MT是负责无线接入协议工作，而TE是负责MT控制功能工作。图9是这些功能组的组成。MT和TE是集成在手机里，但是在note PC上是分开的。 4.1 IMEI和IMEISV：ME拥有的固定IDIMEI（International Mobile Equipment Identity）是为每一个ME分配的唯一值。IMEI是在ME出厂的时候被给出的，包含了和生产厂商的信息，型号，和ME的序列号。图10是IMEI的格式和IMEI使用的举例。IMEI是由TAC（Type Allocation Code）和SNR（Serial Number）和CD（Check Digit）组成。一个IMEI/SV是由TAC（Type Allocation Code）和SNR（Serial Number）和SVN（Software Version Number）组成。TAC是由RBID和ME type ID组成，其中RBID是指示认证机构的RBID（Reporting Body Identifier），ME type ID代表生产厂商的名字和型号ID。序列号是由生产厂商所分配的。在图10的例子中，RBID=35标示ME是由BABT（British Approvals Board for Telecommunications英国电信认证委员会）批准的，ME ID=643205表示ME是由三星生产的智能手机。 运营商有数据库存储IMEI信息，使用这个数据库可以拒绝任何被报告被盗和丢失ME的接入尝试。 V. Closing在我们认识LTE技术之前，我们已经讨论了LTE标识。在这个文档，我们首先解释了UE和ME ID，接下来我们根据他们的范围/分配/属性分类和总结了这些ID，见表2。其他的ID将会在LTE identification II III中讨论。 References[1] Netmanias Technology Document, “LTE Network Architecture: Basic”, July 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5904[2] 3GPP TS 23.003, “Numbering, addressing and identification”.[3] ITU-T E.212, “The international identification plan for public networks and subscriptions”.[4] GSMA TS.06, “IMEI Allocation and Approval Guidelines”.[5] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1-LTE Network Architecture: Basic]]></title>
    <url>%2F2016%2F04%2F03%2F1-LTE-Network-Architecture-Basic%2F</url>
    <content type="text"><![CDATA[原文地址：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5904 I. Introduction这篇文章主要介绍LTE网络结构，是LTE的第一篇技术文章。LTE网络也叫EPS，是一个端到端的全IP网络；EPS分为两个部分，LTE部分负责处理和接入网络E-UTRAN相关的技术，EPC部分负责处理和核心网相关的技术。一个端到端的全IP网络一位置所有的数据流，从UE到连接服务实体的PDN之间的所有通路，在EPS内部，所有的传输都是基于IP协议的。 为了通过LTE网络提供给用户LTE服务，引入了一个端到端LTE网络的参考模型（NRM），这个模型除了基本的EPS域之外，还包含三个额外的域（用户的BSS/OSS域，提供服务的应用域，发送IP包的IP传输网络域）。这篇文章的范围集中在基本的EPS域。其他的EPS域特性，例如，LTE和其他3gpp/3gpp2的互操作性和漫游，这些特性是在本文档范围之外，后续会在其他文档中涉及。 这个文档剩余部分的组织如下，在第二章，定义LTE网络参考模型，解释EPS实体和接口。第三章描述协议栈架构。第四章描述整个LTE网络的数据流。 II. LTE Network Reference Model图1是LT网络的参考模型，包含LTE实体（UE和eNB）和EPC实体（SGW/PGW/MME/HSS/PCRF/SPR/PCSOFCS）。PDN是和UE进行通信的运营商内部或者外面IP域，它提供给UE服务，比如，因特网，IMS。表1和表2是LTE和EPC实体的功能。表3列出了LTE网络参考模型的参考点，并对EPS实体之间的接口进行了描述。 表格1：LTE实体 实体 描述 UE UE通过LTE-Uu接口连接eNB eNB eNB提供用户无线接口，并负责无线资源管理功能，例如，动态资源分配（调度器），eNB测量配置和规定，无线准入控制，连接移动性控制，无线承载控制，小区间干扰协调。 表格2：EPC实体 实体 描述 MME MME是E-UTRAN的主控制实体。它和HSS通信来用户鉴权和用户配置文件下载，并使用NAS信令提供给UE EPS移动性管理（EMM）和EPS会话管理（ESM）功能。MME支持的主要功能包括：NAS信令（EMM/ESM/NAS安全）；通过S6a接口和HSS通信负责用户鉴权和漫游；移动性管理（寻呼/TAI管理/切换管理）；EPS承载管理。 SGW SGW终止E-UTRAN方向的接口。它为eNB间和3gpp间切换的数据传输提供了本地移动锚点。 PGW PGW通过从PDN的地址空间分配IP地址提供给UE接入PDN的能力。PGW作为在3gpp和non-3gpp之间切换的移动锚点。PGW也执行策略实施，数据包过滤和由PCRF提供的基于PCC规则的计费。PGW主要的功能包括：IP路由和转发，数据包过滤，UE IP地址分配，在3gpp和non-3gpp之间切换的移动锚点，PCEF功能，计费。 HSS HSS是存储用户配置的中心数据库。它提供给MME用户鉴权信息和用户配置文件。 PCRF PCRF是策略和计费控制实体。它为服务数据流（SDF）提供策略决策，并且提供给PCEF（PCEF在PGW内）策略和计费控制（PCC）规则（包括QoS和计费规则） SPR SPR提供给PCRF用户信息（每个用户的接入配置文件）。PCRF接收到这个信息后，将执行基于用户的策略并创建策略和计费控制（PCC）规则。 OCS OCS提供实时的信用控制和基于体积/时间/事件的计费功能。 OFCS OFCS提供基于计费数据记录（CDR）的计费信息。 CDR：charging data recordOCS：online charging systemOFCS：offline charging systemOSS：operations support systemPCC：policy and charging controlPCEF：policy and charging enforcement functionPCRF：policy and charging rules functionSDF：service data flowSPR：subscriber profile repository 表3：LTE接口 参考点 协议 描述 LTE-Uu E-UTRA（控制面和用户面） UE和E-UTRAN（eNB）之间控制和用户面的接口。在LTE-Uu接口上，信令连接是用SRB表示的RRC连接，用户面连接是用DRB表示的逻辑信道。 X2 X2-AP（控制面）GTP-U（用户面） 两个eNB之间的控制和用户面的接口。它用于在X2切换或自组网（SON）相关的功能。控制面是使用的X2-AP协议，用户面为数据转发的每一个承载提供GTP-U隧道。 S1-U GTP-U 在eNB和SGW之间用户面的接口。它为每一个承载提供GTP隧道。 S1-MME S1-AP eNB和MME之间控制面的接口。 S11 GTP-C MME和SGW之间控制面的接口。它为每一个承载提供GTP隧道。 S5 GTP-C（控制面）GTP-U（用户面） SGW和PGW之间的控制和用户面接口。S5接口为用户面每一个承载提供GTP隧道，为控制面的每一个用户提供GTP隧道管理（创建/修改/删除）。对PLMN间，使用S8接口替代。S8接口在本文档范围之外，将在其他文档中描述。 S6a Diameter HSS和MME之间控制面的接口。它用于交换用户订阅和鉴权信息 Sp Diameter SPR和PCRF之间控制面的接口。 Gx Diameter PCRF和PGW之间控制面的接口。它从PCRF到PGW传输策略控制和计费规则来支持QoS策略和计费控制。 Gy Diameter OCS和PGW之间控制面的接口。 Gz GTP’ OFCS和PGW之间控制面的接口。 SGi IP PGW和PDN之间控制和用户面的接口。在用户面使用基于IETF的IP数据包转发协议，在控制面使用DHCP和RADIUS/Diameter协议。 III. LTE Protocol Stacks这一章主要介绍LTE用户面和控制面的协议栈。 3.1 用户面协议栈图2是LTE网络参考模型的用户面协议栈。接着介绍协议栈主要层的功能描述。 1）LTE-Uu接口 PDCP：PDCP支持在无线链路上IP数据包的有效性传输。它可以执行协议头压缩，接入层安全（加密和完整性保护），数据包重排序和重传。 RLC：在发送端，RLC构建RLC PDU，并提供给MAC层。RLC协议负责PDCP PDU的分片和串接。在接收端，RLC协议通过对RLC PDU的重组来重新构建PDCP PDU。RLC协议有三种操作模式（透明模式，确认模式，非确认模式），每一种模式提供不同的可靠性级别。RLC也数据包（RLC PDU）的重排序和重传。 MAC：MAC层在RLC和PHY层之间。它通过逻辑信道和RLC层连接，通过传输信道和PHY层连接。因此，MAC层协议在逻辑信道和传输信道之间支持复用和解复用。高层使用不同的逻辑信道来满足不同的QoS要求。MAC层通过对逻辑信道数据的调度和优先级来支持不同的QoS。eNB调度器可以使无线资源动态分配给UE，并通过执行QoS控制来确保每一个承载都分配了协商的QoS。 2) S1-U/S5/X2 接口 GTP-U：GTP-U协议通过在S1-U/S5/X2接口上来转发IP数据包。当在LTE切换过程中已经建立了用于数据转发的GTP隧道，则结束标记数据包应该在GTP隧道上作为最后一个数据包传输。 3.2 控制面协议栈图3是LTE网络参考模型的控制面协议栈。接着介绍协议栈主要层的功能描述。 1) LTE-Uu接口 NAS：NAS协议负责移动性管理和承载管理功能。 RRC：RRC协议对NAS信令的传输提供支持。它也负责无线资源的有效性管理功能。主要的功能包括：系统消息的广播，RRC连接的建立/重配/重建/释放，无线承载的建立/修改/释放。 2) X2接口 X2AP：X2AP协议支持在E-UTRAN内UE的移动性和自组网功能。为了支持UE移动性，X2AP协议提供了例如用户数据转发，序列号状态的传输，UE上下文的释放的功能。对自组网功能，eNB之间交换资源状态信息，负载信息，eNB配置更新信息，使用X2AP协议来相互协调来满足移动性参数。 3) S1-MME接口 S1AP：S1AP协议支持例如S1接口管理，E-RAB管理，NAS信令传输和UE上下文管理。它传输初始UE上下文给eNB来建立E-RAB，并且管理后续UE上下文的修改和释放。 4) S11/S5/S10接口 GTP-C：GTP-C协议支持GTP隧道的建立/修改/终止控制信息的交换。它在LTE切换时创建数据转发的隧道。 5) S6a接口 Diameter：Diameter协议支持在HSS和MME之间用户订阅和鉴权信息的交换。 6) Gx接口 Diameter：Diameter协议支持把PCC规则从PCRF发送到PCEF（PGW）。 7) Gy接口 Diameter：Diameter协议支持在PGW和OCS之间实时信用控制信息的交换。 8) Gz接口 GTP’：GTP’协议支持CDR从PGW发送到OFCS。 IV. Traffic Flow on the LTE Network图4是在LTE网络参考架构中，用户面数据流接入因特网的过程。图4a是数据流从UE到因特网，图4b是数据流从因特网到UE。IP数据包是在S1-U和S5接口上通过GTP隧道来转发的。这些隧道是在用户附着在LTE网络时对每一个EPS承载建立的。 在S1-U和S5的每一个接口上有多个EPS承载建立。因此，为了识别这些承载，每一个GTP隧道的端点都分配了一个TEID（隧道端点标识），（通常识别一个GTP隧道，采用TEID，IP地址，UDP端口号。但是，在这里，为了描述的方便，仅仅使用了TEID）。GTP隧道的接收端本地分配的TEID，发送端必须使用。TEID的交换是在隧道端点使用控制面协议交换的。 当在S1-U接口上建立了GTP隧道时，SGW分配一个TEID用于上行传输，eNB分配一个TEID用于下行传输。S1 GTP隧道TEID是在eNB和SGW之间使用S1AP和GTP-C消息来交换的。同样的，当在S5接口上建立了GTP隧道时，PGW分配一个TEID用于上行传输，SGW分配一个TEID用于下行传输。S5 GTP隧道TEID是在SGW和PGW之间使用GTP-C消息来交换的。 当用户的数据包在S1-U和S5接口上通过GTP隧道传输时，eNB/SGW/PGW通过封装接收对端GTP实体分配的TEID来转发用户IP数据包。在上行方向，SGW在S1 GTP（UL S1-TEID）隧道和S5 GTP（UL S5-TEID）隧道间建立一对一的映射，来终止S1 GTP隧道，并转发用户数据包到S5 GTP隧道。同样的，在下行方向，SGW在S5 GTP（DL S5-TEID）隧道和S1 GTP（DL S1-TEID）隧道间建立一对一的映射，来终止S5 GTP隧道，并转发用户数据包到S1 GTP隧道。在图4中，通过哪一个EPS实体转发因特网数据流的过程如下所示： a）上行方向数据流，从UE到因特网 UE通过LTE-Uu接口传输用户IP数据包到eNB。 eNB使用S1 GTP隧道协议头封装用户IP数据包，并转发封装好的IP数据包给SGW。在这里，eNB使用TEID/目的IP地址/源IP地址作为S1 GTP隧道协议头。 在接收到封装好的IP数据包后，SGW剥离掉S1 GTP隧道协议头，并且使用S5 GTP隧道协议头封装用户IP数据包，并转发封装后的IP数据包。在这里，SGW使用TEID/目的IP地址/源IP地址作为S5 GTP隧道协议头。 在接收到封装好的IP数据包之后，PGW剥离掉S5 GTP隧道协议头得到用户IP数据包，并通过IP路由转发到因特网。 b）下行方向数据流，从因特网到UE PGW从因特网接收到一个目的为UE的IP数据包。 PGW使用S5 GTP隧道协议头封装用户IP数据包，并转发封装好的IP数据包给SGW。在这里，PGW使用TEID/目的IP地址/源IP地址作为S5 GTP隧道协议头。 在接收到封装好的IP数据包后，SGW剥离掉S5 GTP隧道协议头，并且使用S1 GTP隧道协议头封装用户IP数据包，并转发封装后的IP数据包。在这里，SGW使用TEID/目的IP地址/源IP地址作为S1 GTP隧道协议头。 在接收到封装好的IP数据包之后，eNB剥离掉S1 GTP隧道协议头得到用户IP数据包，并在无线链路上通过DRB传输给UE。 V. ClosingLTE网络架构作为第一个LTE系列技术文档。这个文档描述的LTE网路架构只适用于单一运营商的LTE only网络，并描述EPS系统最基本的部分。为了更理解以后的LTE文档，对实体/接口的基本理解是必须的。下一个文档，是另一个基本的文档，讨论应用于LTE网络参考模型的LTE标识。这些基本文档对很好的理解后续的文档有很大帮助，会接着讨论LTE网络更高级的功能，包括LTE互操作和漫游。 References[1] 3GPP TS 36.300, “Evolved Universal Terrestrial Radio Access (E-UTRA) and Evolved UniversalTerrestrial Radio Access Network (E-UTRAN); Overall description; Stage 2”.[2] 3GPP TS 23.401, “General Packet Radio Service (GPRS) enhancements for Evolved UniversalTerrestrial Radio Access Network (E-UTRAN) access”.[3] Magnus Olsson, et. al., SAE and the Evolved Packet Core – Driving the Mobile Broadband Revolution,AP, 2009.[4] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
</search>
