---
title: MySQL必知应会-第13章-分组数据
date: 2018-04-13 18:04:34
tags:
 - mysql
 - 数据库
categories:
 - mysql
 - 数据库
---

# 第13章 分组数据
本章将介绍如何分组数据，以便能汇总表内容的子集。这涉及两个新SELECT语句子句，分别是GROUP BY子句和HAVING子句。

## 13.1 数据分组
从上一章知道， SQL聚集函数可用来汇总数据。这使我们能够对行进行计数，计算和与平均数，获得最大和最小值而不用检索所有数据。目前为止的所有计算都是在表的所有数据或匹配特定的WHERE子句的数据上进行的。提示一下，下面的例子返回供应商1003提供的产品数目：但如果要返回每个供应商提供的产品数目怎么办？或者返回只提供单项产品的供应商所提供的产品，或返回提供10个以上产品的供应商怎么办？这就是分组显身手的时候了。分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算。

## 13.2 创建分组分
组是在SELECT语句的GROUP BY子句中建立的。理解分组的最好办第 13 章输入输出11184 第 13 章 分 组 数 据法是看一个例子：上面的SELECT语句指定了两个列， vend_id包含产品供应商的ID，num_prods为计算字段（用COUNT(*)函数建立）。 GROUP BY子句指示MySQL按vend_id排序并分组数据。这导致对每个vend_id而不是整个表计算num_prods一次。从输出中可以看到，供应商1001有3个产品，供应商1002有2个产品，供应商1003有7个产品，而供应商1005有2个产品。因为使用了GROUP BY，就不必指定要计算和估值的每个组了。系统会自动完成。 GROUP BY子句指示MySQL分组数据，然后对每个组而不是整个结果集进行聚集。在具体使用GROUP BY子句前，需要知道一些重要的规定。? GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。? 如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。? GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。? 除聚集计算语句外， SELECT语句中的每个列都必须在GROUP BY子句中给出。? 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。? GROUP BY子句必须出现在WHERE子句之后， ORDER BY子句之前。分析输入输出11213.3 过滤分组 85使用ROLLUP 使用WITH ROLLUP关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值，如下所示：

## 13.3 过滤分组
除了能用GROUP BY分组数据外， MySQL还允许过滤分组，规定包括哪些分组，排除哪些分组。例如，可能想要列出至少有两个订单的所有顾客。为得出这种数据，必须基于完整的分组而不是个别的行进行过滤。我们已经看到了WHERE子句的作用（第6章中引入）。但是，在这个例子中WHERE不能完成任务，因为WHERE过滤指定的是行而不是分组。事实上， WHERE没有分组的概念。那么，不使用WHERE使用什么呢？ MySQL为此目的提供了另外的子句，那就是HAVING子句。 HAVING非常类似于WHERE。事实上，目前为止所学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是WHERE过滤行，而HAVING过滤分组。HAVING支持所有WHERE操作符 在第6章和第7章中，我们学习了WHERE子句的条件（包括通配符条件和带多个操作符的子句）。所学过的有关WHERE的所有这些技术和选项都适用于HAVING。它们的句法是相同的，只是关键字有差别。那么，怎么过滤分组呢？请看以下的例子：输入输出11386 第 13 章 分 组 数 据这条SELECT语句的前3行类似于上面的语句。最后一行增加了HAVING子句，它过滤COUNT(*) >=2（两个以上的订单）的那些分组。正如所见，这里WHERE子句不起作用，因为过滤是基于分组聚集值而不是特定行值的。HAVING和WHERE的差别 这里有另一种理解方法，WHERE在数据分组前进行过滤， HAVING在数据分组后进行过滤。这是一个重要的区别， WHERE排除的行不包括在分组中。这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组。那么， 有没有在一条语句中同时使用WHERE和HAVING子句的需要呢？事实上，确实有。假如想进一步过滤上面的语句，使它返回过去12个月内具有两个以上订单的顾客。为达到这一点，可增加一条WHERE子句，过滤出过去12个月内下过的订单。然后再增加HAVING子句过滤出具有两个以上订单的分组。为更好地理解，请看下面的例子，它列出具有2个（含）以上、价格为10（含）以上的产品的供应商：这条语句中，第一行是使用了聚集函数的基本SELECT，它与前面的例子很相像。 WHERE子句过滤所有prod_price至少为10的行。然后按vend_id分组数据， HAVING子句过滤计数为2或2以上的分组。如果没有WHERE子句，将会多检索出两行（供应商1002，销售的所有产品价格都在10以下；供应商1001，销售3个产品，但只有一个产品的价格大于等于10）：分析分析输入输出11411513.4 分组和排序 87

## 13.4 分组和排序
虽然GROUP BY和ORDER BY经常完成相同的工作，但它们是非常不同的。表13-1汇总了它们之间的差别。表13-1 ORDER BY与GROUP BYORDER BY GROUP BY排序产生的输出 分组行。但输出可能不是分组的顺序任意列都可以使用（甚至非选择的列也可以使用）只可能使用选择列或表达式列，而且必须使用每个选择列表达式不一定需要 如果与聚集函数一起使用列（或表达式），则必须使用表13-1中列出的第一项差别极为重要。我们经常发现用GROUP BY分组的数据确实是以分组顺序输出的。但情况并不总是这样，它并不是SQL规范所要求的。此外，用户也可能会要求以不同于分组的顺序排序。仅因为你以某种方式分组数据（获得特定的分组聚集值），并不表示你需要以相同的方式排序输出。应该提供明确的ORDER BY子句，即使其效果等同于GROUP BY子句也是如此。不要忘记ORDER BY 一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据。为说明GROUP BY和ORDER BY的使用方法，请看一个例子。下面的SELECT语句类似于前面那些例子。它检索总计订单价格大于等于50的订单的订单号和总计订单价格：输入输出11688 第 13 章 分 组 数 据为按总计订单价格排序输出，需要添加ORDER BY子句，如下所示：在这个例子中， GROUP BY子句用来按订单号（order_num列）分组数据，以便SUM(*)函数能够返回总计订单价格。 HAVING子句过滤数据，使得只返回总计订单价格大于等于50的订单。最后， 用ORDERBY子句排序输出。

## 13.5 SELECT子句
顺序下面回顾一下SELECT语句中子句的顺序。表13-2以在SELECT语句中使用时必须遵循的次序，列出迄今为止所学过的子句。表13-2 SELECT子句及其顺序子 句 说 明 是否必须使用SELECT 要返回的列或表达式 是FROM 从中检索数据的表 仅在从表选择数据时使用WHERE 行级过滤 否分析输入输出输入输出11811713.6 小结 89（续）子 句 说 明 是否必须使用GROUP BY 分组说明 仅在按组计算聚集时使用HAVING 组级过滤 否ORDER BY 输出排序顺序 否LIMIT 要检索的行数 否

## 13.6 小结
在第12章中，我们学习了如何用SQL聚集函数对数据进行汇总计算。本章讲授了如何使用GROUP BY子句对数据组进行这些汇总计算，返回每个组的结果。我们看到了如何使用HAVING子句过滤特定的组，还知道了ORDER BY和GROUP BY之间以及WHERE和HAVING之间的差异。 119