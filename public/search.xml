<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL必知应会-第6章-过滤数据]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC6%E7%AB%A0-%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[第六章 过滤数据本章将讲授如何使用SELECT语句的WHERE子句指定搜索条件。 6.1 使用WHERE子句数据库表一般包含大量的数据，很少需要检索表中所有行。通常只会根据特定操作或报告的需要提取表数据的子集。只检索所需数据需要指定搜索条件（ search criteria） ，搜索条件也称为过滤条件（ filtercondition） 。在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤。WHERE子句在表名（FROM子句）之后给出，如下所示： 这条语句从products表中检索两个列，但不返回所有行，只返回prod_price值为2.50的行。这个例子采用了简单的相等测试：它检查一个列是否具有指定的值，据此进行过滤。但是SQL允许做的事情不仅仅是相等测试。 过滤与应用过滤 数据也可以在应用层过滤。为此目的， SQL的SELECT语句为客户机应用检索出超过实际所需的数据，然后客户机代码对返回数据进行循环，以提取出需要的行。通常，这种实现并不令人满意。因此，对数据库进行了优化，以便快速有效地对数据进行过滤。让客户机应用（或开发语言）处理数据库的工作将会极大地影响应用的性能，并且使所创建的应用完全不具备可伸缩性。此外，如果在客户机上过滤数据，服务器不得不通过网络发送多余的数据，这将导致网络带宽的浪费。 WHERE子句的位置 在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后， 否则将会产生错误。 6.2 WHERE子句操作符我们在关于相等的测试时看到了第一个WHERE子句，它确定一个列是否包含特定的值。 MySQL支持表6-1列出的所有条件操作符。 6.2.1 检查单个值我们已经看到了测试相等的例子。再来看一个类似的例子： 检查WHERE prod_name=‘fuses’语句，它返回prod_name的值为Fuses的一行。 MySQL在执行匹配时默认不区分大小写，所以fuses与Fuses匹配。现在来看几个使用其他操作符的例子。第一个例子是列出价格小于10美元的所有产品： 下一条语句检索价格小于等于10美元的所有产品（输出的结果比第一个例子输出的结果多两种产品）： 6.2.2 不匹配检查以下例子列出不是由供应商1003制造的所有产品： 何时使用引号 如果仔细观察上述WHERE子句中使用的条件，会看到有的值括在单引号内（如前面使用的’fuses’），而有的值未括起来。单引号用来限定字符串。如果将值与串类型的列进行比较，则需要限定引号。用来与数值列进行比较的值不用引号。 下面是相同的例子，其中使用!=而不是&lt;&gt;操作符： 6.2.3 范围值检查为了检查某个范围的值，可使用BETWEEN操作符。其语法与其他WHERE子句的操作符稍有不同，因为它需要两个值，即范围的开始值和结束值。例如， BETWEEN操作符可用来检索价格在5美元和10美元之间或日期在指定的开始日期和结束日期之间的所有产品。下面的例子说明如何使用BETWEEN操作符，它检索价格在5美元和10美元之间的所有产品： 从这个例子中可以看到，在使用BETWEEN时，必须指定两个值——所需范围的低端值和高端值。这两个值必须用AND关键字分隔。 BETWEEN匹配范围中所有的值，包括指定的开始值和结束值。 6.2.4 空值检查在创建表时，表设计人员可以指定其中的列是否可以不包含值。在一个列不包含值时，称其为包含空值NULL。NULL 无值（no value），它与字段包含0、空字符串或仅仅包含空格不同。SELECT语句有一个特殊的WHERE子句，可用来检查具有NULL值的列。这个WHERE子句就是IS NULL子句。其语法如下： 这条语句返回没有价格（空prod_price字段，不是价格为0）的所有产品，由于表中没有这样的行，所以没有返回数据。但是， customers表确实包含有具有空值的列，如果在文件中没有某位顾客的电子邮件地分析则cust_email列将包含NULL值： NULL与不匹配 在通过过滤选择出不具有特定值的行时，你可能希望返回具有NULL值的行。但是，不行。因为未知具有特殊的含义，数据库不知道它们是否匹配，所以在匹配过滤或不匹配过滤时不返回它们。因此，在过滤数据时，一定要验证返回数据中确实给出了被过滤列具有NULL的行。 6.3 小结本章介绍了如何用SELECT语句的WHERE子句过滤返回的数据。我们学习了如何对相等、不相等、大于、小于、值的范围以及NULL值等进行测试。]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第5章-排序检索数据]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC5%E7%AB%A0-%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[第五章 排序检索数据本章将讲授如何使用SELECT语句的ORDER BY子句，根据需要排序检索出的数据。 5.1 排序数据正如前一章所述，下面的SQL语句返回某个数据库表的单个列。但请看其输出，并没有特定的顺序。 其实，检索出的数据并不是以纯粹的随机顺序显示的。如果不排序，数据一般将以它在底层表中出现的顺序显示。这可以是数据最初添加到表中的顺序。但是，如果数据后来进行过更新或删除，则此顺序将会受到MySQL重用回收存储空间的影响。因此，如果不明确控制的话，不能(也不应该)依赖该排序顺序。关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义。 子句(clause) SQL语句由子句构成，有些子句是必需的，而有的是可选的。一个子句通常由一个关键字和所提供的数据组成。子句的例子有SELECT语句的FROM子句，我们在前一章看到过这个子句。为了明确地排序用SELECT语句检索出的数据，可使用ORDER BY子句。ORDER BY子句取一个或多个列的名字，据此对输出进行排序。请看下面的例子： 这条语句除了指示MySQL对prod_name列以字母顺序排序数据的ORDER BY子句外，与前面的语句相同。通过非选择列进行排序 通常， ORDER BY子句中使用的列将是为显示所选择的列。但是，实际上并不一定要这样，用非检索的列排序数据是完全合法的。 5.2 按多个列排序经常需要按不止一个列进行数据排序。例如，如果要显示雇员清单，可能希望按姓和名排序（首先按姓排序，然后在每个姓中再按名排序）。如果多个雇员具有相同的姓，这样做很有用。为了按多个列排序，只要指定列名，列名之间用逗号分开即可（就像选择多个列时所做的那样）。下面的代码检索3个列，并按其中两个列对结果进行排序——首先按价格，然后再按名称排序。 重要的是理解在按多个列排序时，排序完全按所规定的顺序进行。换句话说，对于上述例子中的输出，仅在多个行具有相同的prod_price值时才对产品按prod_name进行排序。如果prod_price列中所有的值都是唯一的，则不会按prod_name排序。 5.3 指定排序方向数据排序不限于升序排序（从A到Z）。这只是默认的排序顺序，还可以使用ORDER BY子句以降序（从Z到A）顺序排序。为了进行降序排序，必须指定DESC关键字。下面的例子按价格以降序排序产品（最贵的排在最前面）： 但是，如果打算用多个列排序怎么办？下面的例子以降序排序产品（最贵的在最前面），然后再对产品名排序： DESC关键字只应用到直接位于其前面的列名。在上例中，只对prod_price列指定 DESC，对 prod_name列不指定。因此，prod_price列以降序排序，而prod_name列（在每个价格内）仍然按标准的升序排序。在多个列上降序排序 如果想在多个列上进行降序排序， 必须对每个列指定DESC关键字。与DESC相反的关键字是ASC（ASCENDING），在升序排序时可以指定它。但实际上， ASC没有多大用处，因为升序是默认的（如果既不指定ASC也不指定DESC，则假定为ASC）。区分大小写和排序顺序 在对文本性的数据进行排序时， A与a相同吗？ a位于B之前还是位于Z之后？这些问题不是理论问题，其答案取决于数据库如何设置。在字典（ dictionary）排序顺序中，A被视为与a相同，这是MySQL（和大多数数据库管理系统）的默认行为。但是，许多数据库管理员能够在需要时改变这种行为（如果你的数据库包含大量外语字符，可能必须这样做）。这里，关键的问题是，如果确实需要改变这种排序顺序，用简单的ORDER BY子句做不到。你必须请求数据库管理员的帮助。使用ORDER BY和LIMIT的组合，能够找出一个列中最高或最低的值。下面的例子演示如何找出最昂贵物品的值： prod_price DESC保证行是按照由最昂贵到最便宜检索的，而LIMIT 1告诉MySQL仅返回一行。ORDER BY子句的位置 在给出ORDER BY子句时，应该保证它位于FROM子句之后。如果使用LIMIT，它必须位于ORDER BY之后。使用子句的次序不对将产生错误消息。 5.4 小结本章学习了如何用SELECT语句的ORDER BY子句对检索出的数据进行排序。这个子句必须是SELECT语句中的最后一条子句。可根据需要，利用它在一个或多个列上对数据进行排序。分析]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第4章-检索数据]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC4%E7%AB%A0-%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[第四章 检索数据本章将介绍如何使用SELECT语句从表中检索一个或多个数据列。 4.1 SELECT语句正如第1章所述， SQL语句是由简单的英语单词构成的。这些单词称为关键字，每个SQL语句都是由一个或多个关键字构成的。大概，最经常使用的SQL语句就是SELECT语句了。它的用途是从一个或多个表中检索信息。为了使用SELECT检索表数据，必须至少给出两条信息——想选择什么，以及从什么地方选择。 4.2 检索单个列我们将从简单的SQL SELECT语句开始介绍，此语句如下所示： 上述语句利用 SELECT语句从 products表中检索一个名为prod_name的列。所需的列名在SELECT关键字之后给出， FROM关键字指出从其中检索数据的表名。 未排序数据 如果读者自己试验这个查询，可能会发现显示输出的数据顺序不同。出现这种情况很正常。如果没有明确排序查询结果，则返回的数据的顺序没有特殊意义。返回数据的顺序可能是数据被添加到表中的顺序，也可能不是。只要返回相同数目的行，就是正常的。如上的一条简单SELECT语句将返回表中所有行。数据没有过滤(过滤将得出结果集的一个子集)， 也没有排序。 结束SQL语句 多条SQL语句必须以分号(；)分隔。 MySQL如同多数DBMS一样，不需要在单条SQL语句后加分号。但特定的DBMS可能必须在单条SQL语句后加上分号。当然，如果愿意可以总是加上分号。事实上，即使不一定需要，但加上分号肯定没有坏处。如果你使用的是mysql命令行，必须加上分号来结束SQL语句。 SQL语句和大小写 请注意， SQL语句不区分大小写，因此SELECT与select是相同的。同样，写成Select也没有关系。许多SQL开发人员喜欢对所有SQL关键字使用大写，而对所有列和表名使用小写，这样做使代码更易于阅读和调试。不过，一定要认识到虽然SQL是不区分大小写的，但有些标识符(如数据库名、表名、列名)可能不同：最佳方式是按照大小写的惯例，且使用时保持一致。 使用空格 在处理SQL语句时，其中所有空格都被忽略。 SQL语句可以在一行上给出，也可以分成许多行。多数SQL开发人员认为将SQL语句分成多行更容易阅读和调试。 4.3 检索多个列要想从一个表中检索多个列，使用相同的SELECT语句。唯一的不同是必须在SELECT关键字后给出多个列名，列名之间必须以逗号分隔。当心逗号 在选择多个列时，一定要在列名之间加上逗号，但最后一个列名后不加。如果在最后一个列名后加了逗号，将出现错误。 下面的SELECT语句从products表中选择3列： 与前一个例子一样，这条语句使用SELECT语句从表products中选择数据。在这个例子中，指定了3个列名，列名之间用逗号分隔。 数据表示 从上述输出可以看到， SQL语句一般返回原始的、无格式的数据。数据的格式化是一个表示问题，而不是一个检索问题。因此，表示(对齐和显示上面的价格值，用货币符号和逗号表示其金额)一般在显示该数据的应用程序中规定。一般很少使用实际检索出的原始数据(没有应用程序提供的格式)。 4.4 检索所有列除了指定所需的列外(如上所述，一个或多个列)， SELECT语句还可以检索所有的列而不必逐个列出它们。这可以通过在实际列名的位置使用星号(*)通配符来达到，如下所示： 如果给定一个通配符(*)，则返回表中所有列。列的顺序一般是列在表定义中出现的顺序。但有时候并不是这样的，表的模式的变化(如添加或删除列)可能会导致顺序的变化。使用通配符 一般，除非你确实需要表中的每个列，否则最好别使用*通配符。虽然使用通配符可能会使你自己省事，不用明确列出所需列，但检索不需要的列通常会降低检索和应用程序的性能。 检索未知列 使用通配符有一个大优点。由于不明确指定列名(因为星号检索每个列)，所以能检索出名字未知的列。 4.5 检索不同的行正如所见， SELECT返回所有匹配的行。但是，如果你不想要每个值每次都出现，怎么办？例如，假如你想得出products表中产品的所有供应商ID： SELECT语句返回14行(即使表中只有4个供应商)，因为products表中列出了14个产品。那么，如何检索出有不同值的列表呢？解决办法是使用DISTINCT关键字，顾名思义，此关键字指示MySQL只返回不同的值。 SELECT DISTINCT vend_id告诉MySQL只返回不同(唯一)的vend_id行，因此只返回4行。如果使用DISTINCT关键字，它必须直接放在列名的前面。 不能部分使用DISTINCT, DISTINCT关键字应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT vend_id,prod_price，除非指定的两个列都不同，否则所有行都将被检索出来。 4.6 限制结果SELECT语句返回所有匹配的行，它们可能是指定表中的每个行。为了返回第一行或前几行，可使用LIMIT子句。下面举一个例子： 此语句使用SELECT语句检索单个列。 LIMIT 5指示MySQL返回不多于5行。为得出下一个5行，可指定要检索的开始行和行数，如下所示：LIMIT 5, 5指示MySQL返回从行5开始的5行。第一个数为开始位置，第二个数为要检索的行数。 所以， 带一个值的LIMIT总是从第一行开始，给出的数为返回的行数。带两个值的LIMIT可以指定从行号为第一个值的位置开始。行0 检索出来的第一行为行0而不是行1。因此， LIMIT 1, 1将检索出第二行而不是第一行。在行数不够时 LIMIT中指定要检索的行数为检索的最大行数。如果没有足够的行(例如，给出LIMIT 10, 5，但只有13行)， MySQL将只返回它能返回的那么多行。MySQL 5的LIMIT语法 LIMIT 3, 4的含义是从行4开始的3行还是从行3开始的4行？如前所述，它的意思是从行3开始的4行，这容易把人搞糊涂。由于这个原因， MySQL 5支持LIMIT的另一种替代语法。 LIMIT4 OFFSET 3意为从行3开始取4行，就像LIMIT 3, 4一样。 4.7 使用完全限定的表名迄今为止使用的SQL例子只通过列名引用列。也可能会使用完全限定的名字来引用列(同时使用表名和列字)。请看以下例子： 这条SQL语句在功能上等于本章最开始使用的那一条语句，但这里指定了一个完全限定的列名。表名也可以是完全限定的，如下所示： 这条语句在功能上也等于刚使用的那条语句(当然，假定products表确实位于crashcourse数据库中)。正如以后章节所介绍的那样，有一些情形需要完全限定名。现在，需要注意这个语法，以便在遇到时知道它的作用。 4.8 小结本章学习了如何使用SQL的SELECT语句来检索单个表列、多个表列以及所有表列。下一章将讲授如何排序检索出来的数据。]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第3章-使用MySQL]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC3%E7%AB%A0-%E4%BD%BF%E7%94%A8MySQL%2F</url>
    <content type="text"><![CDATA[第三章 使用MySQL本章将学习如何连接和登录到MySQL，如何执行MySQL语句，以及如何获得数据库和表的信息。 3.1 连接在具有可供使用的MySQL DBMS和客户机软件之后，有必要简要讨论一下如何连接到数据库。MySQL与所有客户机—服务器DBMS一样，要求在能执行命令之前登录到DBMS。MySQL在内部保存自己的用户列表，并且把每个用户与各种权限关联起来。在最初安装MySQL时，很可能会要求你输入一个管理登录(通常为root)和一个口令。如果你使用的是自己的本地服务器，并且是简单地试验一下MySQL，使用上述登录就可以了。但现实中，管理登录受到密切保护(因为对它的访问授予了创建表、删除整个数据库、更改登录和口令等完全的权限)。使用MySQL Administrator MySQL Administrator Users视图提供了一个简单的界面，可用来定义新用户，包括赋予口令和访问权限。 为了连接到MySQL，需要以下信息： 主机名(计算机名)——如果连接到本地MySQL服务器， 为localhost； 端口(如果使用默认端口3306之外的端口)； 一个合法的用户名； 用户口令（如果需要）。所有这些信息都可以传递给mysql命令行实用程序，或输入到MySQL Administrator和MySQL Query Browser的服务器连接屏幕。在连接之后，你就可以访问你的登录名能够访问的任意数据库和表了。 3.2 选择数据库在你最初连接到MySQL时，没有任何数据库打开供你使用。在你能执行任意数据库操作前，需要选择一个数据库。为此，可使用USE关键字。关键字(key word) 作为MySQL语言组成部分的一个保留字。决不要用关键字命名一个表或列。例如，为了使用crashcourse数据库，应该输入以下内容： USE语句并不返回任何结果。依赖于使用的客户机，显示某种形式的通知。例如，这里显示出的Database changed消息是mysql命令行实用程序在数据库选择成功后显示的。使用MySQL Query Browser 在MySQL Query Browser中，双击Schemata列表中列出的任一数据库以使用它。你看不到USE命令的实际执行，但会看到被选择的数据库（黑体加亮），而且应用标题栏将显示所选择的数据库名。记住，必须先使用USE打开数据库，才能读取其中的数据。 3.3 了解数据库和表如果你不知道可以使用的数据库名时怎么办？这时 ， MySQLAdministrator和MySQL Query Browser怎样能显示可用的数据库列表？数据库、表、列、用户、权限等的信息被存储在数据库和表中（MySQL使用MySQL来存储这些信息）。不过，内部的表一般不直接访问。可用MySQL的SHOW命令来显示这些信息（MySQL从内部表中提取这些信息）。请看下面的例子： SHOW DATABASES;返回可用数据库的一个列表。包含在这个列表中的可能是MySQL内部使用的数据库（如例子中的mysql和information_schema）。 为了获得一个数据库内的表的列表，使用SHOW TABLES; 如下所示： SHOW TABLES;返回当前选择的数据库内可用表的列表。SHOW也可以用来显示表列：输出SHOW COLUMNS 要 求 给 出 一 个 表 名 （ 这 个 例 子 中 的 FROM customers），它对每个字段返回一行，行中包含字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息（如字段cust_id的auto_increment）。 什么是自动增量？ 某些表列需要唯一值。在每个行添加到表中时， MySQL可以自动地为每个行分配下一个可用编号，不用在添加一行时手动分配唯一值（这样做必须记住最后一次使用的值）。这个功能就是所谓的自动增量。如果需要它，则必须在用CREATE语句创建表时把它作为表定义的组成部分。 DESCRIBE语句 MySQL支持用DESCRIBE作为SHOW COLUMNSFROM的一种快捷方式。换句话说， DESCRIBE customers;是SHOW COLUMNS FROM customers;的一种快捷方式。 所支持的其他SHOW语句还有： SHOW STATUS，用于显示广泛的服务器状态信息； SHOW CREATE DATABASE和SHOW CREATE TABLE，分别用来显示创建特定数据库或表的MySQL语句； SHOW GRANTS，用来显示授予用户（所有用户或特定用户）的安全权限； SHOW ERRORS和SHOW WARNINGS， 用来显示服务器错误或警告消息。 值得注意的是，客户机应用程序使用与这里相同的MySQL命令。显示数据库和表的交互式列表、允许交互式创建和编辑表、便于数据录入和编辑或允许管理用户账号和权限等的应用全都使用你可以直接执行的相同的MySQL命令完成它们的工作。进一步了解SHOW 请在mysql命令行实用程序中，执行命令HELP SHOW;显示允许的SHOW语句。 MySQL 5 的 新 增 内 容 MySQL 5 支 持 一 个 新 的 INFORMATION_SCHEMA命令，可用它来获得和过滤模式信息。 3.4 小结本章介绍了如何连接和登录MySQL，如何用USE选择数据库，如何用SHOW查看MySQL数据库、表和内部信息。在这些知识的帮助下，我们可以进一步深入学习所有重要的SELECT语句了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第2章-MySQL简介]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC2%E7%AB%A0-MySQL%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[第二章 MySQL简介本章将介绍什么是MySQL，以及在MySQL中可以应用什么工具。 2.1 什么是MySQL正如所述，数据的所有存储、检索、管理和处理实际上是由数据库软件——DBMS(数据库管理系统)完成的。MySQL是一种DBMS，即它是一种数据库软件。使用MySQL的原因： 成本——MySQL是开放源代码的，一般可以免费使用(甚至可以免费修改)。 性能——MySQL执行很快(非常快)。 可信赖——某些非常重要和声望很高的公司、站点使用MySQL，这些公司和站点都用MySQL来处理自己的重要数据。 简单——MySQL很容易安装和使用。 2.1.1 客户机—服务器软件DBMS可分为两类： 一类为基于共享文件系统的DBMS，(包括诸如Microsoft Access和FileMaker)用于桌面用途，通常不用于高端或更关键的应用。 另一类为基于客户机—服务器的DBMS，MySQL、 Oracle以及Microsoft SQL Server等数据库是基于客户机—服务器的数据库。 客户机—服务器应用分为两个不同的部分。 服务器部分是负责所有数据访问和处理的一个软件。这个软件运行在称为数据库服务器的计算机上。与数据文件打交道的只有服务器软件。关于数据、数据添加、删除和数据更新的所有请求都由服务器软件完成。这些请求或更改来自运行客户机软件的计算机。 客户机是与用户打交道的软件。例如，如果你请求一个按字母顺序列出的产品表，则客户机软件通过网络提交该请求给服务器软件。服务器软件处理这个请求，根据需要过滤、丢弃和排序数据；然后把结果送回到你的客户机软件。 客户机和服务器软件可能安装在两台计算机或一台计算机上。不管它们在不在相同的计算机上，为进行所有数据库交互，客户机软件都要与服务器软件进行通信。所有这些活动对用户都是透明的。数据存储在别的地方，或者数据库服务器为你完成这个处理这一事实是隐藏的。你不需要直接访问数据文件。事实上，多数网络的建立使用户不具有对数据的访问权，甚至不具有对存储数据的驱动器的访问权。这样的意义何在？因为为了使用MySQL，你需要访问运行MySQL服务器软件的计算机和发布命令到MySQL的客户机软件的计算机。 服务器软件为MySQL DBMS。你可以在本地安装的副本上运行，也可以连接到运行在你具有访问权的远程服务器上的一个副本。 客户机可以是MySQL提供的工具、脚本语言(如Perl)、 Web应用开发语言(如ASP、 ColdFusion、 JSP和PHP)、程序设计语言(如C、 C++、 Java)等。 安装mysql-linux 2.1.2 MySQL版本MySQL的当前版本为版本5版本要求说明，如果某章针对具体某个MySQL版本，则将在该章开始处明确说明。 2.2 MySQL工具MySQL是一个客户机—服务器DBMS，因此，为了使用MySQL，需要有一个客户机，即你需要用来与MySQL打交道(给MySQL提供要执行的命令)的一个应用。有许多客户机应用可供选择，但在学习MySQL(确切地说，在编写和测试MySQL脚本时)，最好是使用专门用途的实用程序。特别是有3个工具需要提及。 2.2.1 mysql命令行实用程序每个MySQL安装都有一个名为mysql的简单命令行实用程序。MySQL选项和参数 如果仅输入mysql， 可能会出现一个错误消息。因为可能需要安全证书，或者是因为MySQL没有运行在本地或默认端口上。 mysql接受你可以(和可能需要)使用的一组命令行参数。例如，为了指定用户登录名ben，应该使用mysql -u ben。为了给出用户名、主机名、端口和口令，应该使用mysql -u ben -p -h myserver -P 9999。完整的命令行选项和参数列表可用mysql –help获得。 在操作系统命令提示符下输入mysql将出现一个如下的简单提示： 当然，具体的版本和连接信息可能不同，但都可以使用这个实用程序。请注意： 命令输入在mysql&gt;之后； 命令用;或\g结束，换句话说，仅按Enter不执行命令； 输入help或\h获得帮助，也可以输入更多的文本获得特定命令的帮助(如，输入help select获得使用SELECT语句的帮助)； 输入quit或exit退出命令行实用程序。 mysql命令行实用程序是使用最多的实用程序之一，它对于快速测试和执行脚本非常有价值。 熟悉mysql命令行实用程序 即使你选择使用后面描述的某个图形工具，也应该保证熟悉mysql命令行实用程序，因为它是你可以安全地依靠的一个总是会被给出的客户机(因为它是核心MySQL安装的一部分)。 2.2.2 MySQL AdministratorMySQL Administrator(MySQL管理器)是一个图形交互客户机，用来简化MySQL服务器的管理。MySQL Administrator不作为核心MySQL 的 组 成 部 分 安 装 。必须从链接下载。在Ubuntu下安装 MySQL Administrator提示输入服务器和登录信息(并且允许你保存服务器定义供以后选择)，然后显示允许选择不同视图的图标。其中： Server Information(服务器信息)显示客户机和被连接的服务器的状态和版本信息； Service Control(服务控制)允许停止和启动MySQL以及指定服务器特性； User Administration(用户管理)用来定义MySQL用户、登录和权限； Catalogs(目录)列出可用的数据库并允许创建数据库和表。 MySQL Administrator工具菜单包含有启动mysql命令行实用程序和MySQL Query Browser( MySQL查询浏览器)的选项。MySQL Query Browser也包含启动mysql命令行实用程序和MySQL Administrator的菜单选项。 2.2.3 MySQL Query BrowserMySQL Query Browser为一个图形交互客户机，用来编写和执行MySQL命令。获得MySQL Query Browser 与MySQL Administrator一样，MySQL Query Browser不作为核心MySQL安装的成分。必须从链接下载。 MySQL Query Browser要求输入服务器和登录信息(在MySQL QueryBrowser和MySQL Administrator之间共享保存的定义)，然后显示应用界面。注意下面几点。 输入MySQL命令到屏幕顶上的窗口中。在输入语句后，单击Execute按钮把它提交给MySQL处理。 结果(如果有)显示在屏幕左边的大区域网格中。 多条语句和结果显示在它们自己的标签中，并且允许快速切换。 屏幕右边是一个标签，它列出所有可能的数据源(这里称为大纲)，展开任一数据源查看它的表，展开任一个表查看它的列。 你还可以选择表和列让MySQL Query Browser为你编写MySQL语句。 Schemata(大纲)标签的右边是一个History(历史)标签，它保持MySQL语句的执行历史。在需要测试不同版本的MySQL语句时，它非常有用。 关于MySQL语法、函数等的帮助可在屏幕右下角得到。 执行保存的脚本 可用MySQL Query Browser执行保存的脚本(如用来创建和填充本书中使用的表的脚本)。为执行保存的脚本，请选择File, Open Script，选择相应的脚本(它将显示在一个新标签中)，然后单击Execute按钮。 2.3 小结本章介绍了什么是MySQL，并引入了几个客户机实用程序(一个命20 令行实用程序，两个可选但强烈建议使用的图形实用程序)。]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL必知应会-第1章-了解SQL]]></title>
    <url>%2F2018%2F04%2F13%2FMySQL%E5%BF%85%E7%9F%A5%E5%BA%94%E4%BC%9A-%E7%AC%AC1%E7%AB%A0-%E4%BA%86%E8%A7%A3SQL%2F</url>
    <content type="text"><![CDATA[第一章 了解SQL本章将介绍数据库和SQL，它们是学习MySQL的先决条件。 1.1 数据库基础1.1.1 什么是数据库数据库是一个以某种有组织的方式存储的数据集合。数据库(database)保存有组织的数据的容器(通常是一个文件或一组文件)。数据库软件应称为DBMS(数据库管理系统)。数据库是通过DBMS创建和操纵的容器。数据库可以是保存在硬设备上的文件，但也可以不是。在很大程度上说，数据库究竟是文件还是别的什么东西并不重要，因为你并不直接访问数据库；你使用的是DBMS，它替你访问数据库。 1.1.2 表表是一种结构化的文件，可用来存储某种特定类型的数据。表(table) 某种特定类型数据的结构化清单。数据库中的每个表都有一个名字，用来标识自己。此名字是唯一的，这表示数据库中没有其他表具有相同的名字。表名的唯一性取决于多个因素，如数据库名和表名等的结合。表具有一些特性，这些特性定义了数据在表中如何存储，如可以存储什么样的数据，数据如何分解，各部分信息如何命名，等等。描述表的这组信息就是所谓的模式，模式可以用来描述数据库中特定的表以及整个数据库(和其中表的关系)。模式(schema) 关于数据库和表的布局及特性的信息。 1.1.3 列和数据类型表由列组成。列中存储着表中某部分的信息。列(column) 表中的一个字段。所有表都是由一个或多个列组成的。 SQL数据库中每个列都有相应的数据类型。数据类型定义列可以存储的数据种类。数据类型(datatype) 所容许的数据的类型。每个表列都有相应的数据类型，它限制(或容许)该列中存储的数据。数据类型限制可存储在列中的数据种类(例如，防止在数值字段中录入字符值)。数据类型还帮助正确地排序数据，并在优化磁盘使用方面起重要的作用。 1.1.4 行表中的数据是按行存储的，所保存的每个记录存储在自己的行内。如果将表想象为网格，网格中垂直的列为表列，水平行为表行。表中的行数为记录的总数。行(row) 表中的一个记录。 1.1.5 主键表中每一行都应该有可以唯一标识自己的一列(或一组列)。主键(primary key) 一列(或一组列)，其值能够唯一区分表中每个行。唯一标识表中每行的这个列(或这组列)称为主键。主键用来表示一个特定的行。大多数数据库设计人员都应保证他们创建的每个表具有一个主键，以便于以后的数据操纵和管理。表中的任何列都可以作为主键，只要它满足以下条件： 任意两行都不具有相同的主键值； 每个行都必须具有一个主键值(主键列不允许NULL值)。这里列出的规则是MySQL本身强制实施的。 主键通常定义在表的一列上，但这并不是必需的，也可以一起使用多个列作为主键。在使用多列作为主键时，上述条件必须应用到构成主键的所有列，所有列值的组合必须是唯一的(但单个列的值可以不唯一)。 主键的最好习惯除MySQL强制实施的规则外，应该坚持的几个普遍认可的最好习惯为： 不更新主键列中的值； 不重用主键列的值； 不在主键列中使用可能会更改的值。(例如，如果使用一个名字作为主键以标识某个供应商，当该供应商合并和更改其名字时，必须更改这个主键。) 还有一种非常重要的键，称为外键，我们将在第15章中介绍。 1.2 什么是SQLSQL(发音为字母S-Q-L或sequel)是结构化查询语言(Structured QueryLanguage)的缩写。 SQL是一种专门用来与数据库通信的语言。设计SQL的目的是很好地完成一项任务，即提供一种从数据库中读写数据的简单有效的方法。SQL有如下的优点： SQL不是某个特定数据库供应商专有的语言。几乎所有重要的DBMS都支持SQL。 SQL简单易学。它的语句全都是由描述性很强的英语单词组成，而且这些单词的数目不多。 SQL尽管看上去很简单，但它实际上是一种强有力的语言，灵活使用其语言元素，可以进行非常复杂和高级的数据库操作。 DBMS专用的SQLSQL不是一种专利语言，而且存在一个标准委员会，他们试图定义可供所有DBMS使用的SQL语法，但事实上任意两个DBMS实现的SQL都不完全相同。本书QL是专门针对MySQL的。 1.3 动手实践本书所有章节都采用可上机运行的例子来说明SQL语法，它的功能是什么，为什么起这样的作用。作者强烈建议读者试验每个例子，以便掌握MySQL的第一手资料。 1.4 小结这一章介绍了什么是SQL以及它为什么很有用。因为SQL是用来与数据库打交道的，所以，我们也复习了一些基本的数据库术语。]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第11章-识别手写数字]]></title>
    <url>%2F2018%2F04%2F12%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC11%E7%AB%A0-%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[第11章 识别手写体数字 27111.1 手写体识别 27111.2 用scikit-learn识别手写体数字 27111.3 Digits数据集 27211.4 学习和预测 27411.5 小结 276 12from sklearn import svmsvc = svm.SVC(gamma=0.001, C=100.) 123from sklearn import datasetsdigits = datasets.load_digits() 1digits.images[0] array([[ 0., 0., 5., 13., 9., 1., 0., 0.], [ 0., 0., 13., 15., 10., 15., 5., 0.], [ 0., 3., 15., 2., 0., 11., 8., 0.], [ 0., 4., 12., 0., 0., 8., 8., 0.], [ 0., 5., 8., 0., 0., 9., 8., 0.], [ 0., 4., 11., 0., 1., 12., 7., 0.], [ 0., 2., 14., 5., 10., 12., 0., 0.], [ 0., 0., 6., 13., 10., 0., 0., 0.]]) 1digits.target.size 1797 1digits.target array([0, 1, 2, ..., 8, 9, 8]) 1234import matplotlib.pyplot as plt%matplotlib inlineplt.imshow(digits.images[0], cmap=plt.cm.gray_r, interpolation='nearest') &lt;matplotlib.image.AxesImage at 0x16657400&gt; 1svc.fit(digits.data[1:1790], digits.target[1:1790]) SVC(C=100.0, cache_size=200, class_weight=None, coef0=0.0, degree=3, gamma=0.001, kernel=&apos;rbf&apos;, max_iter=-1, probability=False, random_state=None, shrinking=True, tol=0.001, verbose=False) 123456789101112131415import matplotlib.pyplot as plt%matplotlib inlineplt.subplot(321)plt.imshow(digits.images[1791], cmap=plt.cm.gray_r, interpolation='nearest')plt.subplot(322)plt.imshow(digits.images[1792], cmap=plt.cm.gray_r, interpolation='nearest')plt.subplot(323)plt.imshow(digits.images[1793], cmap=plt.cm.gray_r, interpolation='nearest')plt.subplot(324)plt.imshow(digits.images[1794], cmap=plt.cm.gray_r, interpolation='nearest')plt.subplot(325)plt.imshow(digits.images[1795], cmap=plt.cm.gray_r, interpolation='nearest')plt.subplot(326)plt.imshow(digits.images[1796], cmap=plt.cm.gray_r, interpolation='nearest') &lt;matplotlib.image.AxesImage at 0x175e6b00&gt; 1svc.predict(digits.data[1791:1976]) array([4, 9, 0, 8, 9, 8]) 1digits.target[1791:1976] array([4, 9, 0, 8, 9, 8])]]></content>
      <tags>
        <tag>python</tag>
        <tag>手写字体</tag>
        <tag>机器学习</tag>
        <tag>SVC</tag>
        <tag>SVM</tag>
        <tag>sklearn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第10章-ipythonNotebook内嵌JavaScript库D3]]></title>
    <url>%2F2018%2F04%2F12%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC10%E7%AB%A0-ipythonNotebook%E5%86%85%E5%B5%8CJavaScript%E5%BA%93D3%2F</url>
    <content type="text"><![CDATA[第10章 IPython Notebook内嵌JavaScript库D3 25210.1 开放的人口数据源 25210.2 JavaScript库D3 25510.3 绘制簇状条状图 25910.4 地区分布图 26210.5 2014年美国人口地区分布图 26610.6 小结 270 123456789101112131415import numpy as npimport pandas as pdimport matplotlib.pyplot as plt%matplotlib inline# from urllib.request import urlopen# pop2014 = pd.read_csv(# urlopen('http://www.census.gov/popest/data/counties/totals/2014/files/CO-EST2014-alldata.csv'),# encoding='latin-1',# dtype=&#123;'STATE': 'str', 'COUNTY': 'str'&#125;# )pop2014 = pd.read_csv('CO-EST2014-alldata.csv',encoding='latin-1',dtype=&#123;'STATE': 'str', 'COUNTY': 'str'&#125;)print(pop2014.shape)print(pop2014.columns) (3193, 84) Index([&apos;SUMLEV&apos;, &apos;REGION&apos;, &apos;DIVISION&apos;, &apos;STATE&apos;, &apos;COUNTY&apos;, &apos;STNAME&apos;, &apos;CTYNAME&apos;, &apos;CENSUS2010POP&apos;, &apos;ESTIMATESBASE2010&apos;, &apos;POPESTIMATE2010&apos;, &apos;POPESTIMATE2011&apos;, &apos;POPESTIMATE2012&apos;, &apos;POPESTIMATE2013&apos;, &apos;POPESTIMATE2014&apos;, &apos;NPOPCHG_2010&apos;, &apos;NPOPCHG_2011&apos;, &apos;NPOPCHG_2012&apos;, &apos;NPOPCHG_2013&apos;, &apos;NPOPCHG_2014&apos;, &apos;BIRTHS2010&apos;, &apos;BIRTHS2011&apos;, &apos;BIRTHS2012&apos;, &apos;BIRTHS2013&apos;, &apos;BIRTHS2014&apos;, &apos;DEATHS2010&apos;, &apos;DEATHS2011&apos;, &apos;DEATHS2012&apos;, &apos;DEATHS2013&apos;, &apos;DEATHS2014&apos;, &apos;NATURALINC2010&apos;, &apos;NATURALINC2011&apos;, &apos;NATURALINC2012&apos;, &apos;NATURALINC2013&apos;, &apos;NATURALINC2014&apos;, &apos;INTERNATIONALMIG2010&apos;, &apos;INTERNATIONALMIG2011&apos;, &apos;INTERNATIONALMIG2012&apos;, &apos;INTERNATIONALMIG2013&apos;, &apos;INTERNATIONALMIG2014&apos;, &apos;DOMESTICMIG2010&apos;, &apos;DOMESTICMIG2011&apos;, &apos;DOMESTICMIG2012&apos;, &apos;DOMESTICMIG2013&apos;, &apos;DOMESTICMIG2014&apos;, &apos;NETMIG2010&apos;, &apos;NETMIG2011&apos;, &apos;NETMIG2012&apos;, &apos;NETMIG2013&apos;, &apos;NETMIG2014&apos;, &apos;RESIDUAL2010&apos;, &apos;RESIDUAL2011&apos;, &apos;RESIDUAL2012&apos;, &apos;RESIDUAL2013&apos;, &apos;RESIDUAL2014&apos;, &apos;GQESTIMATESBASE2010&apos;, &apos;GQESTIMATES2010&apos;, &apos;GQESTIMATES2011&apos;, &apos;GQESTIMATES2012&apos;, &apos;GQESTIMATES2013&apos;, &apos;GQESTIMATES2014&apos;, &apos;RBIRTH2011&apos;, &apos;RBIRTH2012&apos;, &apos;RBIRTH2013&apos;, &apos;RBIRTH2014&apos;, &apos;RDEATH2011&apos;, &apos;RDEATH2012&apos;, &apos;RDEATH2013&apos;, &apos;RDEATH2014&apos;, &apos;RNATURALINC2011&apos;, &apos;RNATURALINC2012&apos;, &apos;RNATURALINC2013&apos;, &apos;RNATURALINC2014&apos;, &apos;RINTERNATIONALMIG2011&apos;, &apos;RINTERNATIONALMIG2012&apos;, &apos;RINTERNATIONALMIG2013&apos;, &apos;RINTERNATIONALMIG2014&apos;, &apos;RDOMESTICMIG2011&apos;, &apos;RDOMESTICMIG2012&apos;, &apos;RDOMESTICMIG2013&apos;, &apos;RDOMESTICMIG2014&apos;, &apos;RNETMIG2011&apos;, &apos;RNETMIG2012&apos;, &apos;RNETMIG2013&apos;, &apos;RNETMIG2014&apos;], dtype=&apos;object&apos;) 12pop2014_by_state = pop2014[pop2014.SUMLEV == 40]pop2014_by_state.shape (51, 84) 12states = pop2014_by_state[['STNAME','POPESTIMATE2011', 'POPESTIMATE2012', 'POPESTIMATE2013','POPESTIMATE2014']] 12temp = states.sort_values(['POPESTIMATE2014'], ascending=False)[:5]print(temp) STNAME POPESTIMATE2011 POPESTIMATE2012 POPESTIMATE2013 \ 190 California 37701901 38062780 38431393 2566 Texas 25657477 26094422 26505637 329 Florida 19107900 19355257 19600311 1860 New York 19521745 19607140 19695680 608 Illinois 12858725 12873763 12890552 POPESTIMATE2014 190 38802500 2566 26956958 329 19893297 1860 19746227 608 12880580 123456%%javascriptrequire.config(&#123;paths: &#123;d3: '//cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min'&#125;&#125;); &lt;IPython.core.display.Javascript object&gt; 1234567891011121314151617181920212223from IPython.core.display import display, Javascript, HTMLdisplay(HTML("""&lt;style&gt;.bar &#123;fill: steelblue;&#125;.bar:hover&#123;fill: brown;&#125;.axis &#123;font: 10px sans-serif;&#125;.axis path,.axis line &#123;fill: none;stroke: #000;&#125;.x.axis path &#123;display: none;&#125;&lt;/style&gt;&lt;div id="chart_d3" /&gt;""")) .bar {fill: steelblue;}.bar:hover{fill: brown;}.axis {font: 10px sans-serif;}.axis path,.axis line {fill: none;stroke: #000;}.x.axis path {display: none;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import jinja2myTemplate = jinja2.Template("""require(["d3"], function(d3)&#123;var data = []&#123;% for row in data %&#125;data.push(&#123; 'state': '&#123;&#123; row[1] &#125;&#125;', 'population': &#123;&#123; row[5] &#125;&#125; &#125;);&#123;% endfor %&#125;d3.select("#chart_d3 svg").remove()var margin = &#123;top: 20, right: 20, bottom: 30, left: 40&#125;,width = 800 - margin.left - margin.right,height = 400 - margin.top - margin.bottom;var x = d3.scale.ordinal().rangeRoundBands([0, width], .25);var y = d3.scale.linear().range([height, 0]);var xAxis = d3.svg.axis().scale(x).orient("bottom");var yAxis = d3.svg.axis().scale(y).orient("left").ticks(10).tickFormat(d3.format('.1s'));var svg = d3.select("#chart_d3").append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");x.domain(data.map(function(d) &#123; return d.state; &#125;));y.domain([0, d3.max(data, function(d) &#123; return d.population; &#125;)]);svg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);svg.append("g").attr("class", "y axis").call(yAxis).append("text").attr("transform", "rotate(-90)").attr("y", 6).attr("dy", ".71em").style("text-anchor", "end").text("Population");svg.selectAll(".bar").data(data).enter().append("rect").attr("class", "bar").attr("x", function(d) &#123; return x(d.state); &#125;).attr("width", x.rangeBand()).attr("y", function(d) &#123; return y(d.population); &#125;).attr("height", function(d) &#123; return height - y(d.population); &#125;);&#125;);"""); 123display(Javascript(myTemplate.render(data=states.sort_values(['POPESTIMATE2012'], ascending=False)[:10].itertuples()))) &lt;IPython.core.display.Javascript object&gt; 12345678910111213141516171819202122232425262728display(HTML("""&lt;style&gt;.bar2011 &#123;fill: steelblue;&#125;.bar2012 &#123;fill: red;&#125;.bar2013 &#123;fill: yellow;&#125;.bar2014 &#123;fill: green;&#125;.axis &#123;font: 10px sans-serif;&#125;.axis path,.axis line &#123;fill: none;stroke: #000;&#125;.x.axis path &#123;display: none;&#125;&lt;/style&gt;&lt;div id="chart_d3" /&gt;""")) .bar2011 {fill: steelblue;}.bar2012 {fill: red;}.bar2013 {fill: yellow;}.bar2014 {fill: green;}.axis {font: 10px sans-serif;}.axis path,.axis line {fill: none;stroke: #000;}.x.axis path {display: none;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import jinja2myTemplate = jinja2.Template("""require(["d3"], function(d3)&#123;var data = []var data2 = []var data3 = []var data4 = []&#123;% for row in data %&#125;data.push(&#123; 'state': '&#123;&#123; row[1] &#125;&#125;', 'population': &#123;&#123; row[2] &#125;&#125; &#125;);data2.push(&#123; 'state': '&#123;&#123; row[1] &#125;&#125;', 'population': &#123;&#123; row[3] &#125;&#125; &#125;);data3.push(&#123; 'state': '&#123;&#123; row[1] &#125;&#125;', 'population': &#123;&#123; row[4] &#125;&#125; &#125;);data4.push(&#123; 'state': '&#123;&#123; row[1] &#125;&#125;', 'population': &#123;&#123; row[5] &#125;&#125; &#125;);&#123;% endfor %&#125;d3.select("#chart_d3 svg").remove()var margin = &#123;top: 20, right: 20, bottom: 30, left: 40&#125;,width = 800 - margin.left - margin.right,height = 400 - margin.top - margin.bottom;var x = d3.scale.ordinal().rangeRoundBands([0, width], .25);var y = d3.scale.linear().range([height, 0]);var xAxis = d3.svg.axis().scale(x).orient("bottom");var yAxis = d3.svg.axis().scale(y).orient("left").ticks(10).tickFormat(d3.format('.1s'));var svg = d3.select("#chart_d3").append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");x.domain(data.map(function(d) &#123; return d.state; &#125;));y.domain([0, d3.max(data, function(d) &#123; return d.population; &#125;)]);svg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);svg.append("g").attr("class", "y axis").call(yAxis).append("text").attr("transform", "rotate(-90)").attr("y", 6).attr("dy", ".71em").style("text-anchor", "end").text("Population");svg.selectAll(".bar2011").data(data).enter().append("rect").attr("class", "bar2011").attr("x", function(d) &#123; return x(d.state); &#125;).attr("width", x.rangeBand()/4).attr("y", function(d) &#123; return y(d.population); &#125;).attr("height", function(d) &#123; return height - y(d.population); &#125;);svg.selectAll(".bar2012").data(data2).enter().append("rect").attr("class", "bar2012").attr("x", function(d) &#123; return (x(d.state)+x.rangeBand()/4); &#125;).attr("width", x.rangeBand()/4).attr("y", function(d) &#123; return y(d.population); &#125;).attr("height", function(d) &#123; return height - y(d.population); &#125;);svg.selectAll(".bar2013").data(data3).enter().append("rect").attr("class", "bar2013").attr("x", function(d) &#123; return (x(d.state)+2*x.rangeBand()/4); &#125;).attr("width", x.rangeBand()/4).attr("y", function(d) &#123; return y(d.population); &#125;).attr("height", function(d) &#123; return height - y(d.population); &#125;);svg.selectAll(".bar2014").data(data4).enter().append("rect").attr("class", "bar2014").attr("x", function(d) &#123; return (x(d.state)+3*x.rangeBand()/4); &#125;).attr("width", x.rangeBand()/4).attr("y", function(d) &#123; return y(d.population); &#125;).attr("height", function(d) &#123; return height - y(d.population); &#125;);&#125;);"""); 123display(Javascript(myTemplate.render(data=states.sort_values(['POPESTIMATE2014'], ascending=False)[:5].itertuples()))) &lt;IPython.core.display.Javascript object&gt; 12345678%%javascriptrequire.config(&#123;paths: &#123;d3: '//cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min',queue: '//cdnjs.cloudflare.com/ajax/libs/queue-async/1.0.7/queue.min',topojson: '//cdnjs.cloudflare.com/ajax/libs/topojson/1.6.19/topojson.min'&#125;&#125;); &lt;IPython.core.display.Javascript object&gt; 1234567891011121314151617181920212223from IPython.core.display import display, Javascript, HTMLdisplay(HTML("""&lt;style&gt;.counties &#123;fill: none;&#125;.states &#123;fill: none;stroke: #fff;stroke-linejoin: round;&#125;.q0-9 &#123; fill:rgb(247,251,255); &#125;.q1-9 &#123; fill:rgb(222,235,247); &#125;.q2-9 &#123; fill:rgb(198,219,239); &#125;.q3-9 &#123; fill:rgb(158,202,225); &#125;.q4-9 &#123; fill:rgb(107,174,214); &#125;.q5-9 &#123; fill:rgb(66,146,198); &#125;.q6-9 &#123; fill:rgb(33,113,181); &#125;.q7-9 &#123; fill:rgb(8,81,156); &#125;.q8-9 &#123; fill:rgb(8,48,107); &#125;&lt;/style&gt;&lt;div id="choropleth" /&gt;""")) .counties {fill: none;}.states {fill: none;stroke: #fff;stroke-linejoin: round;}.q0-9 { fill:rgb(247,251,255); }.q1-9 { fill:rgb(222,235,247); }.q2-9 { fill:rgb(198,219,239); }.q3-9 { fill:rgb(158,202,225); }.q4-9 { fill:rgb(107,174,214); }.q5-9 { fill:rgb(66,146,198); }.q6-9 { fill:rgb(33,113,181); }.q7-9 { fill:rgb(8,81,156); }.q8-9 { fill:rgb(8,48,107); } 12345678910111213141516171819202122232425262728293031323334353637383940414243import jinja2choropleth = jinja2.Template("""require(["d3","queue","topojson"], function(d3,queue,topojson)&#123;// var data = []// &#123;% for row in data %&#125;// data.push(&#123; 'state': '&#123;&#123; row[1] &#125;&#125;', 'population': &#123;&#123; row[2] &#125;&#125; &#125;);// &#123;% endfor %&#125;d3.select("#choropleth svg").remove()var width = 960,height = 600;var rateById = d3.map();ar quantize = d3.scale.quantize().domain([0, .15]).range(d3.range(9).map(function(i) &#123; return "q" + i + "-9"; &#125;));var projection = d3.geo.albersUsa().scale(1280).translate([width / 2, height / 2]);var path = d3.geo.path().projection(projection);//row to modifyvar svg = d3.select("#choropleth").append("svg").attr("width", width).attr("height", height);queue().defer(d3.json, "us.json").defer(d3.tsv, "unemployment.tsv", function(d) &#123; rateById.set(d.id, +d.rate); &#125;).await(ready);function ready(error, us) &#123;if (error) throw error;svg.append("g").attr("class", "counties").selectAll("path").data(topojson.feature(us, us.objects.counties).features).enter().append("path").attr("class", function(d) &#123; return quantize(rateById.get(d.id)); &#125;).attr("d", path);svg.append("path").datum(topojson.mesh(us, us.objects.states, function(a, b) &#123; return a !== b; &#125;)).attr("class", "states").attr("d", path);&#125;&#125;);"""); 1display(Javascript(choropleth.render())) &lt;IPython.core.display.Javascript object&gt; 12pop2014_by_county = pop2014[pop2014.SUMLEV == 50]pop2014_by_county.shape (3142, 84) 123# USJSONnames = pd.read_table(urlopen('http://bl.ocks.org/mbostock/raw/4090846/us-countynames.tsv'))USJSONnames = pd.read_table('world-country-names.tsv')USJSONnames.shape (252, 2)]]></content>
      <tags>
        <tag>pyhton</tag>
        <tag>javascript</tag>
        <tag>D3</tag>
        <tag>jinja2</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第9章-数据分析实例气象数据]]></title>
    <url>%2F2018%2F04%2F12%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC9%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E4%BE%8B%E6%B0%94%E8%B1%A1%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[第9章 数据分析实例——气象数据 2309.1 待检验的假设：靠海对气候的影响 2309.2 数据源 2339.3 用IPython Notebook做数据分析 2349.4 风向频率玫瑰图 2469.5 小结 251 123import numpy as npimport pandas as pdimport datetime 1ferrara = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Ferrara,IT') 1torino = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Torino,IT') 1mantova = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Mantova,IT') 1milano = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Milano,IT') 1ravenna = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Ravenna,IT') 1asti = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Asti,IT') 1bologna = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Bologna,IT') 1piacenza = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Piacenza,IT') 1cesena = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Cesena,IT') 1faenza = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Faenza,IT') 1234567891011121314151617181920212223def prepare(city_list,city_name): temp = [ ] humidity = [ ] pressure = [ ] description = [ ] dt = [ ] wind_speed = [ ] wind_deg = [ ] for row in city_list: temp.append(row['main']['temp']-273.15) humidity.append(row['main']['humidity']) pressure.append(row['main']['pressure']) description.append(row['weather'][0]['description']) dt.append(row['dt']) wind_speed.append(row['wind']['speed']) wind_deg.append(row['wind']['deg']) headings = ['temp','humidity','pressure','description','dt','wind_speed','wind_deg'] data = [temp,humidity,pressure,description,dt,wind_speed,wind_deg] df = pd.DataFrame(data,index=headings) city = df.T city['city'] = city_name city['day'] = city['dt'].apply(datetime.datetime.fromtimestamp) return city 1234567891011df_ferrara = prepare(ferrara.list,'Ferrara')df_milano = prepare(milano.list,'Milano')df_mantova = prepare(mantova.list,'Mantova')df_ravenna = prepare(ravenna.list,'Ravenna')df_torino = prepare(torino.list,'Torino')#df_alessandria = prepare(alessandria.list,'Alessandria')df_asti = prepare(asti.list,'Asti')df_bologna = prepare(bologna.list,'Bologna')df_piacenza = prepare(piacenza.list,'Piacenza')df_cesena = prepare(cesena.list,'Cesena')df_faenza = prepare(faenza.list,'Faenza') 12345678910print df_ferrara.shapeprint df_milano.shapeprint df_mantova.shapeprint df_ravenna.shapeprint df_torino.shapeprint df_asti.shapeprint df_bologna.shapeprint df_piacenza.shapeprint df_cesena.shapeprint df_faenza.shape (24, 9) (24, 9) (24, 9) (24, 9) (24, 9) (24, 9) (24, 9) (24, 9) (24, 9) (24, 9) 123456789101112#http://it.thetimenow.com/distance-calculator.php#(Comacchio)df_ravenna['dist'] = 8df_cesena['dist'] = 14df_faenza['dist'] = 37df_ferrara['dist'] = 47df_bologna['dist'] = 71df_mantova['dist'] = 121 df_piacenza['dist'] = 200df_milano['dist'] = 250df_asti['dist'] = 315df_torino['dist'] = 357 123456789101112131415161718192021import pandas as pd#df_ferrara.to_csv('ferrara_270615.csv')#df_milano.to_csv('milano_270615.csv')#df_mantova.to_csv('mantova_270615.csv')#df_ravenna.to_csv('ravenna_270615.csv')#df_torino.to_csv('torino_270615.csv')#df_asti.to_csv('asti_270615.csv')#df_bologna.to_csv('bologna_270615.csv')#df_piacenza.to_csv('piacenza_270615.csv')#df_cesena.to_csv('cesena_270615.csv')#df_faenza.to_csv('faenza_270615.csv')df_ferrara = pd.read_csv('ferrara_270615.csv')df_milano = pd.read_csv('milano_270615.csv')df_mantova = pd.read_csv('mantova_270615.csv')df_ravenna = pd.read_csv('ravenna_270615.csv')df_torino = pd.read_csv('torino_270615.csv')df_asti = pd.read_csv('asti_270615.csv')df_bologna = pd.read_csv('bologna_270615.csv')df_piacenza = pd.read_csv('piacenza_270615.csv')df_cesena = pd.read_csv('cesena_270615.csv')df_faenza = pd.read_csv('faenza_270615.csv') 1df_cesena.columns Index([&apos;Unnamed: 0&apos;, &apos;temp&apos;, &apos;humidity&apos;, &apos;pressure&apos;, &apos;description&apos;, &apos;dt&apos;, &apos;wind_speed&apos;, &apos;wind_deg&apos;, &apos;city&apos;, &apos;day&apos;, &apos;dist&apos;], dtype=&apos;object&apos;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455dist = [df_ravenna['dist'][0], df_cesena['dist'][0], df_faenza['dist'][0], df_ferrara['dist'][0], df_bologna['dist'][0], df_mantova['dist'][0], df_piacenza['dist'][0], df_milano['dist'][0], df_asti['dist'][0], df_torino['dist'][0]]temp_max = [df_ravenna['temp'].max(), df_cesena['temp'].max(), df_faenza['temp'].max(), df_ferrara['temp'].max(), df_bologna['temp'].max(), df_mantova['temp'].max(), df_piacenza['temp'].max(), df_milano['temp'].max(), df_asti['temp'].max(), df_torino['temp'].max()]temp_min = [df_ravenna['temp'].min(), df_cesena['temp'].min(), df_faenza['temp'].min(), df_ferrara['temp'].min(), df_bologna['temp'].min(), df_mantova['temp'].min(), df_piacenza['temp'].min(), df_milano['temp'].min(), df_asti['temp'].min(), df_torino['temp'].min()]hum_min = [df_ravenna['humidity'].min(), df_cesena['humidity'].min(), df_faenza['humidity'].min(), df_ferrara['humidity'].min(), df_bologna['humidity'].min(), df_mantova['humidity'].min(), df_piacenza['humidity'].min(), df_milano['humidity'].min(), df_asti['humidity'].min(), df_torino['humidity'].min()]hum_max = [df_ravenna['humidity'].max(), df_cesena['humidity'].max(), df_faenza['humidity'].max(), df_ferrara['humidity'].max(), df_bologna['humidity'].max(), df_mantova['humidity'].max(), df_piacenza['humidity'].max(), df_milano['humidity'].max(), df_asti['humidity'].max(), df_torino['humidity'].max()] 123%matplotlib inlineimport matplotlib.pyplot as pltimport matplotlib.dates as mdates 12#temperatura massimaplt.plot(dist,temp_max,'ro') [&lt;matplotlib.lines.Line2D at 0xd697650&gt;] 12345678x = np.array(dist)y = np.array(temp_max)x1 = x[x&lt;100]x1 = x1.reshape((x1.size,1))y1 = y[x&lt;100]x2 = x[x&gt;50]x2 = x2.reshape((x2.size,1))y2 = y[x&gt;50] 123456789from sklearn.svm import SVRsvr_lin1 = SVR(kernel='linear', C=1e3)svr_lin2 = SVR(kernel='linear', C=1e3)svr_lin1.fit(x1, y1)svr_lin2.fit(x2, y2)xp1 = np.arange(10,100,10).reshape((9,1))xp2 = np.arange(50,400,50).reshape((7,1))yp1 = svr_lin1.predict(xp1)yp2 = svr_lin2.predict(xp2) 1234plt.plot(xp1, yp1, c='r', label='Strong sea effect')plt.plot(xp2, yp2, c='b', label='Light sea effect')plt.axis((0,400,20,40))plt.scatter(x, y, c='k', label='data') &lt;matplotlib.collections.PathCollection at 0x18627cf8&gt; 1234567891011121314151617from scipy.optimize import fsolvedef line1(x): a1 = svr_lin1.coef_[0][0] b1 = svr_lin1.intercept_[0] return -a1*x + b1def line2(x): a2 = svr_lin2.coef_[0][0] b2 = svr_lin2.intercept_[0] return -a2*x + b2def findIntersection(fun1,fun2,x0): return fsolve(lambda x : fun1(x) - fun2(x),x0)result = findIntersection(line1,line2,0.0)print "[x,y] = [ %d , %d ]" % (result,line1(result))x = numpy.linspace(0,300,31)plt.plot(x,line1(x),x,line2(x),result,line1(result),'ro') [x,y] = [ 101 , 34 ] --------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-25-389f5c694cae&gt; in &lt;module&gt;() 14 result = findIntersection(line1,line2,0.0) 15 print &quot;[x,y] = [ %d , %d ]&quot; % (result,line1(result)) ---&gt; 16 x = numpy.linspace(0,300,31) 17 plt.plot(x,line1(x),x,line2(x),result,line1(result),&apos;ro&apos;) NameError: name &apos;numpy&apos; is not defined 123#temperatures minplt.axis((0,400,15,25))plt.plot(dist,temp_min,'bo') [&lt;matplotlib.lines.Line2D at 0x18716320&gt;] 12#min humidityplt.plot(dist,hum_min,'bo') [&lt;matplotlib.lines.Line2D at 0x18b3de80&gt;] 12#max humidityplt.plot(dist,hum_max,'bo') [&lt;matplotlib.lines.Line2D at 0x18bc8080&gt;] 12345678#temperaturey1 = df_milano['temp']x1 = df_milano['day']fig, ax = plt.subplots()plt.xticks(rotation=70)hours = mdates.DateFormatter('%H:%M')ax.xaxis.set_major_formatter(hours)ax.plot(x1,y1,'r') [&lt;matplotlib.lines.Line2D at 0x1a109f28&gt;] 12345678#humidityy1 = df_milano['humidity']x1 = df_milano['day']fig, ax = plt.subplots()plt.xticks(rotation=70)hours = mdates.DateFormatter('%H:%M')ax.xaxis.set_major_formatter(hours)ax.plot(x1,y1,'r') [&lt;matplotlib.lines.Line2D at 0x1a2f47f0&gt;] 1234567891011y1 = df_ravenna['temp']x1 = df_ravenna['day']y2 = df_ferrara['temp']x2 = df_ferrara['day']y3 = df_milano['temp']x3 = df_milano['day']fig, ax = plt.subplots()plt.xticks(rotation=70)hours = mdates.DateFormatter('%H:%M')ax.xaxis.set_major_formatter(hours)plt.plot(x1,y1,'r',x2,y2,'b',x3,y3,'g') [&lt;matplotlib.lines.Line2D at 0x1a432e10&gt;, &lt;matplotlib.lines.Line2D at 0x1a586748&gt;, &lt;matplotlib.lines.Line2D at 0x1a586b38&gt;] 1234567891011y1 = df_ravenna['humidity']x1 = df_ravenna['day']y2 = df_ferrara['humidity']x2 = df_ferrara['day']y3 = df_milano['humidity']x3 = df_milano['day']fig, ax = plt.subplots()plt.xticks(rotation=70)hours = mdates.DateFormatter('%H:%M')ax.xaxis.set_major_formatter(hours)plt.plot(x1,y1,'r',x2,y2,'b',x3,y3,'g') [&lt;matplotlib.lines.Line2D at 0x1a5d6f60&gt;, &lt;matplotlib.lines.Line2D at 0x1a7fb9b0&gt;, &lt;matplotlib.lines.Line2D at 0x1a7fbda0&gt;] 123456789101112131415161718y1 = df_ravenna['humidity']x1 = df_ravenna['day']y2 = df_faenza['humidity']x2 = df_faenza['day']y3 = df_cesena['humidity']x3 = df_cesena['day']y4 = df_milano['humidity']x4 = df_milano['day']y5 = df_asti['humidity']x5 = df_asti['day']y6 = df_torino['humidity']x6 = df_torino['day']fig, ax = plt.subplots()plt.xticks(rotation=70)hours = mdates.DateFormatter('%H:%M')ax.xaxis.set_major_formatter(hours)plt.plot(x1,y1,'r',x2,y2,'r',x3,y3,'r')plt.plot(x4,y4,'g',x5,y5,'g',x6,y6,'g') [&lt;matplotlib.lines.Line2D at 0x18606668&gt;, &lt;matplotlib.lines.Line2D at 0x1a86ec18&gt;, &lt;matplotlib.lines.Line2D at 0x1a861470&gt;] 123456789101112131415161718y1 = df_ravenna['temp']x1 = df_ravenna['day']y2 = df_faenza['temp']x2 = df_faenza['day']y3 = df_cesena['temp']x3 = df_cesena['day']y4 = df_milano['temp']x4 = df_milano['day']y5 = df_asti['temp']x5 = df_asti['day']y6 = df_torino['temp']x6 = df_torino['day']fig, ax = plt.subplots()plt.xticks(rotation=70)hours = mdates.DateFormatter('%H:%M')ax.xaxis.set_major_formatter(hours)plt.plot(x1,y1,'r',x2,y2,'r',x3,y3,'r')plt.plot(x4,y4,'g',x5,y5,'g',x6,y6,'g') [&lt;matplotlib.lines.Line2D at 0x1aa22a90&gt;, &lt;matplotlib.lines.Line2D at 0x1ac54ba8&gt;, &lt;matplotlib.lines.Line2D at 0x1ac49518&gt;] 123456789101112hum_mean = [df_ravenna['humidity'].mean(), df_cesena['humidity'].mean(), df_faenza['humidity'].mean(), df_ferrara['humidity'].mean(), df_bologna['humidity'].mean(), df_mantova['humidity'].mean(), df_piacenza['humidity'].mean(), df_milano['humidity'].mean(), df_asti['humidity'].mean(), df_torino['humidity'].mean()]plt.plot(dist,hum_mean,'bo') [&lt;matplotlib.lines.Line2D at 0x1acbfb70&gt;] 12345678y1 = df_ravenna['wind_speed']*20y2 = df_ravenna['humidity']x = df_ravenna['day']fig, ax = plt.subplots()plt.xticks(rotation=70)hours = mdates.DateFormatter('%H:%M')ax.xaxis.set_major_formatter(hours)plt.plot(x,y1,'r',x,y2,'b') [&lt;matplotlib.lines.Line2D at 0x1ab2ee80&gt;, &lt;matplotlib.lines.Line2D at 0x1b0a0668&gt;] 1plt.plot(df_ravenna['wind_deg'],df_ravenna['wind_speed'],'ro') [&lt;matplotlib.lines.Line2D at 0x1b11c4e0&gt;] 1234plt.subplot(211)plt.plot(df_cesena['wind_deg'],df_cesena['humidity'],'bo')plt.subplot(212)plt.plot(df_cesena['wind_deg'],df_cesena['wind_speed'],'bo') [&lt;matplotlib.lines.Line2D at 0x1b4db6d8&gt;] 123hist, bins = np.histogram(df_ravenna['wind_deg'],8,[0,360])print histprint bins [3 4 9 6 1 1 0 0] [ 0. 45. 90. 135. 180. 225. 270. 315. 360.] 12345678def showRoseWind(values,city_name,max_value): N = 8 theta = np.arange(0.,2 * np.pi, 2 * np.pi / N) radii = np.array(values) plt.axes([0.025, 0.025, 0.95, 0.95], polar=True) colors = [(1-x/max_value, 1-x/max_value, 0.75) for x in radii] plt.bar(theta, radii, width=(2*np.pi/N), bottom=0.0, color=colors) plt.title(city_name,x=0.2, fontsize=20) 123hist, bin = np.histogram(df_ravenna['wind_deg'],8,[0,360])print histshowRoseWind(hist,'Ravenna', 15.0) [3 4 9 6 1 1 0 0] 123hist, bin = np.histogram(df_piacenza['wind_deg'],8,[0,360])print histshowRoseWind(hist,'Piacenza', 15.0) [8 3 4 2 4 1 1 1] 12print df_milano[df_milano['wind_deg']&lt;45]['wind_speed']print df_milano[df_milano['wind_deg']&lt;45]['wind_speed'].mean() 1 2.6 3 2.1 5 2.1 13 0.5 14 1 18 1 21 1 Name: wind_speed, dtype: object 1.47142857143 12345678910print df_milano[df_milano['wind_deg']&lt;45]['wind_speed'].mean()#print df_milano[(df_milano['wind_deg']&gt;0) &amp; (df_milano['wind_deg']&lt;45)]['wind_speed'].mean()print df_milano[(df_milano['wind_deg']&gt;44) &amp; (df_milano['wind_deg']&lt;90)]['wind_speed'].mean()print df_milano[(df_milano['wind_deg']&gt;89) &amp; (df_milano['wind_deg']&lt;135)]['wind_speed'].mean()print df_milano[(df_milano['wind_deg']&gt;134) &amp; (df_milano['wind_deg']&lt;180)]['wind_speed'].mean()print df_milano[(df_milano['wind_deg']&gt;179) &amp; (df_milano['wind_deg']&lt;225)]['wind_speed'].mean()print df_milano[(df_milano['wind_deg']&gt;224) &amp; (df_milano['wind_deg']&lt;270)]['wind_speed'].mean()print df_milano[(df_milano['wind_deg']&gt;269) &amp; (df_milano['wind_deg']&lt;315)]['wind_speed'].mean()#print df_milano[(df_milano['wind_deg']&gt;314) &amp; (df_milano['wind_deg']&lt;360)]['wind_speed'].mean()print df_milano[df_milano['wind_deg']&gt;314]['wind_speed'].mean() 1.47142857143 2.04 2.06666666667 2.05 2.68333333333 2.1 nan nan 12degs = np.arange(45,361,45)print degs [ 45 90 135 180 225 270 315 360] 123456tmp = []for deg in degs: #print df_milano[(df_milano['wind_deg']&gt;(deg-46)) &amp; (df_milano['wind_deg']&lt;deg)]['wind_speed'].mean() tmp.append(df_milano[(df_milano['wind_deg']&gt;(deg-46)) &amp; (df_milano['wind_deg']&lt;deg)]['wind_speed'].mean())speeds = np.array(tmp)print speeds [ 1.675 nan nan nan 2.93333333 3.13636364 2.58 nan] 1234567N = 8theta = np.arange(0.,2 * np.pi, 2 * np.pi / N)radii = np.array(speeds)plt.axes([0.025, 0.025, 0.95, 0.95], polar=True)colors = [(1-x/10.0, 1-x/10.0, 0.75) for x in radii]bars = plt.bar(theta, radii, width=(2*np.pi/N), bottom=0.0, color=colors)plt.title('Milano',x=0.2, fontsize=20) &lt;matplotlib.text.Text at 0x1be13ef0&gt; 123456def RoseWind_Speed(df_city): degs = np.arange(45,361,45) tmp = [] for deg in degs: tmp.append(df_city[(df_city['wind_deg']&gt;(deg-46)) &amp; (df_city['wind_deg']&lt;deg)]['wind_speed'].mean()) return np.array(tmp) 12345678def showRoseWind_Speed(speeds,city_name): N = 8 theta = np.arange(0.,2 * np.pi, 2 * np.pi / N) radii = np.array(speeds) plt.axes([0.025, 0.025, 0.95, 0.95], polar=True) colors = [(1-x/10.0, 1-x/10.0, 0.75) for x in radii] bars = plt.bar(theta, radii, width=(2*np.pi/N), bottom=0.0, color=colors) plt.title(city_name,x=0.2, fontsize=20) 1showRoseWind(RoseWind_Speed(df_milano),'Milano',10) 1showRoseWind_Speed(RoseWind_Speed(df_ravenna),'Ravenna') 1showRoseWind_Speed(RoseWind_Speed(df_faenza),'Faenza') 1showRoseWind_Speed(RoseWind_Speed(df_cesena),'Cesena') 1showRoseWind_Speed(RoseWind_Speed(df_ferrara),'Ferrara') 1showRoseWind_Speed(RoseWind_Speed(df_torino),'Torino') 1showRoseWind_Speed(RoseWind_Speed(df_mantova),'Mantova') 1ferrara = pd.read_json('http://api.openweathermap.org/data/2.5/history/city?q=Ferrara,IT') 12345678910df_ferrara.to_csv('ferrara.csv')df_milano.to_csv('milano.csv')df_mantova.to_csv('mantova.csv')df_ravenna.to_csv('ravenna.csv')df_torino.to_csv('torino.csv')df_asti.to_csv('asti.csv')df_bologna.to_csv('bologna.csv')df_piacenza.to_csv('piacenza.csv')df_cesena.to_csv('cesena.csv')df_faenza.to_csv('faenza.csv')]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第8章-用scikit-learn库实现机器学习]]></title>
    <url>%2F2018%2F04%2F12%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC8%E7%AB%A0-%E7%94%A8scikit-learn%E5%BA%93%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[第8章 用scikit-learn库实现机器学习 2058.1 scikit-learn库 2058.2 机器学习 2058.2.1 有监督和无监督学习 2058.2.2 训练集和测试集 2068.3 用scikit-learn实现有监督学习 2068.4 Iris数据集 20612345678from sklearn import datasetsiris = datasets.load_iris()print(iris.data.shape)print(iris.data[:5])print()print(iris.target[:5])print()print(iris.target_names) (150, 4) [[5.1 3.5 1.4 0.2] [4.9 3. 1.4 0.2] [4.7 3.2 1.3 0.2] [4.6 3.1 1.5 0.2] [5. 3.6 1.4 0.2]] [0 0 0 0 0] [&apos;setosa&apos; &apos;versicolor&apos; &apos;virginica&apos;] 1234567891011121314151617181920212223import matplotlib.pyplot as pltimport matplotlib.patches as mpatchesfrom sklearn import datasets% matplotlib inlineiris = datasets.load_iris()x = iris.data[:,0] #X-Axis - sepal lengthy = iris.data[:,1] #Y-Axis - sepal lengthspecies = iris.target #Speciesx_min, x_max = x.min() - .5,x.max() + .5y_min, y_max = y.min() - .5,y.max() + .5#SCATTERPLOTplt.figure()plt.title('Iris Dataset - Classification By Sepal Sizes')plt.scatter(x,y, c=species)plt.xlabel('Sepal length')plt.ylabel('Sepal width')plt.xlim(x_min, x_max)plt.ylim(y_min, y_max)plt.xticks(())plt.yticks(()) ([], &lt;a list of 0 Text yticklabel objects&gt;) 12345678910111213141516171819202122import matplotlib.pyplot as pltimport matplotlib.patches as mpatchesfrom sklearn import datasetsiris = datasets.load_iris()x = iris.data[:,2] #X-Axis - petal lengthy = iris.data[:,3] #Y-Axis - petal lengthspecies = iris.target #Speciesx_min, x_max = x.min() - .5,x.max() + .5y_min, y_max = y.min() - .5,y.max() + .5#SCATTERPLOTplt.figure()plt.title('Iris Dataset - Classification By Petal Sizes', size=14)plt.scatter(x,y, c=species)plt.xlabel('Petal length')plt.ylabel('Petal width')plt.xlim(x_min, x_max)plt.ylim(y_min, y_max)plt.xticks(())plt.yticks(()) ([], &lt;a list of 0 Text yticklabel objects&gt;) 主成分分解123456789101112131415161718192021import matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dfrom sklearn import datasetsfrom sklearn.decomposition import PCAiris = datasets.load_iris()x = iris.data[:,1] #X-Axis - petal lengthy = iris.data[:,2] #Y-Axis - petal lengthspecies = iris.target #Speciesx_reduced = PCA(n_components=3).fit_transform(iris.data)#SCATTERPLOT 3Dfig = plt.figure()ax = Axes3D(fig)ax.set_title('Iris Dataset by PCA', size=14)ax.scatter(x_reduced[:,0],x_reduced[:,1],x_reduced[:,2], c=species)ax.set_xlabel('First eigenvector')ax.set_ylabel('Second eigenvector')ax.set_zlabel('Third eigenvector')ax.w_xaxis.set_ticklabels(())ax.w_yaxis.set_ticklabels(())ax.w_zaxis.set_ticklabels(()) [] 8.5 K-近邻分类器 211123456789101112131415161718import numpy as npfrom sklearn import datasetsnp.random.seed(0)iris = datasets.load_iris()x = iris.datay = iris.targeti = np.random.permutation(len(iris.data))x_train = x[i[:-10]]y_train = y[i[:-10]]x_test = x[i[-10:]]y_test = y[i[-10:]]from sklearn.neighbors import KNeighborsClassifierknn = KNeighborsClassifier()knn.fit(x_train,y_train)y_pre = knn.predict(x_test)print(y_pre)print(y_test) [1 2 1 0 0 0 2 1 2 0] [1 1 1 0 0 0 2 1 2 0] 123456789101112131415161718192021222324import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.colors import ListedColormapfrom sklearn import datasetsfrom sklearn.neighbors import KNeighborsClassifieriris = datasets.load_iris()x = iris.data[:,:2] #X-Axis - sepal length-widthy = iris.target #Y-Axis - speciesx_min, x_max = x[:,0].min() - .5,x[:,0].max() + .5y_min, y_max = x[:,1].min() - .5,x[:,1].max() + .5#MESHcmap_light = ListedColormap(['#AAAAFF','#AAFFAA','#FFAAAA'])h = .02xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))knn = KNeighborsClassifier()knn.fit(x,y)Z = knn.predict(np.c_[xx.ravel(),yy.ravel()])Z = Z.reshape(xx.shape)plt.figure()plt.pcolormesh(xx,yy,Z,cmap=cmap_light)#Plot the training pointsplt.scatter(x[:,0],x[:,1],c=y)plt.xlim(xx.min(),xx.max())plt.ylim(yy.min(),yy.max()) (1.5, 4.900000000000003) 123456789101112131415161718192021222324import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.colors import ListedColormapfrom sklearn import datasetsfrom sklearn.neighbors import KNeighborsClassifieriris = datasets.load_iris()x = iris.data[:,2:4] #X-Axis - petals length-widthy = iris.target #Y-Axis - speciesx_min, x_max = x[:,0].min() - .5,x[:,0].max() + .5y_min, y_max = x[:,1].min() - .5,x[:,1].max() + .5#MESHcmap_light = ListedColormap(['#AAAAFF','#AAFFAA','#FFAAAA'])h = .02xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))knn = KNeighborsClassifier()knn.fit(x,y)Z = knn.predict(np.c_[xx.ravel(),yy.ravel()])Z = Z.reshape(xx.shape)plt.figure()plt.pcolormesh(xx,yy,Z,cmap=cmap_light)#Plot the training pointsplt.scatter(x[:,0],x[:,1],c=y)plt.xlim(xx.min(),xx.max())plt.ylim(yy.min(),yy.max()) (-0.4, 2.980000000000003) 8.6 Diabetes数据集 214123from sklearn import datasetsdiabetes = datasets.load_diabetes()diabetes.data[0] array([ 0.03807591, 0.05068012, 0.06169621, 0.02187235, -0.0442235 , -0.03482076, -0.04340085, -0.00259226, 0.01990842, -0.01764613]) 1np.sum(diabetes.data[:,0]**2) 1.0000000000000746 1diabetes.target[:10] array([151., 75., 141., 206., 135., 97., 138., 63., 110., 310.]) 8.7 线性回归：最小平方回归 215123456789101112from sklearn import linear_modellinreg = linear_model.LinearRegression()from sklearn import datasetsdiabetes = datasets.load_diabetes()x_train = diabetes.data[:-20]y_train = diabetes.target[:-20]x_test = diabetes.data[-20:]y_test = diabetes.target[-20:]linreg.fit(x_train,y_train)linreg.coef_ array([ 3.03499549e-01, -2.37639315e+02, 5.10530605e+02, 3.27736980e+02, -8.14131709e+02, 4.92814588e+02, 1.02848452e+02, 1.84606489e+02, 7.43519617e+02, 7.60951722e+01]) 123y_pre = linreg.predict(x_test)print(y_pre)print(y_test) [197.61846908 155.43979328 172.88665147 111.53537279 164.80054784 131.06954875 259.12237761 100.47935157 117.0601052 124.30503555 218.36632793 61.19831284 132.25046751 120.3332925 52.54458691 194.03798088 102.57139702 123.56604987 211.0346317 52.60335674] [233. 91. 111. 152. 120. 67. 310. 94. 183. 66. 173. 72. 49. 64. 48. 178. 104. 132. 220. 57.] 1linreg.score(x_test, y_test) 0.5850753022690571 123456789101112131415161718import numpy as npimport matplotlib.pyplot as pltfrom sklearn import linear_modelfrom sklearn import datasetsdiabetes = datasets.load_diabetes()x_train = diabetes.data[:-20]y_train = diabetes.target[:-20]x_test = diabetes.data[-20:]y_test = diabetes.target[-20:]x0_test = x_test[:,0]x0_train = x_train[:,0]x0_test = x0_test[:,np.newaxis]x0_train = x0_train[:,np.newaxis]linreg = linear_model.LinearRegression()linreg.fit(x0_train,y_train)y = linreg.predict(x0_test)plt.scatter(x0_test,y_test,color='k')plt.plot(x0_test,y,color='b',linewidth=3) [&lt;matplotlib.lines.Line2D at 0xeecd990&gt;] 1234567891011121314151617181920import numpy as npimport matplotlib.pyplot as pltfrom sklearn import linear_modelfrom sklearn import datasetsdiabetes = datasets.load_diabetes()x_train = diabetes.data[:-20]y_train = diabetes.target[:-20]x_test = diabetes.data[-20:]y_test = diabetes.target[-20:]plt.figure(figsize=(8,12))for f in range(0,10): xi_test = x_test[:,f] xi_train = x_train[:,f] xi_test = xi_test[:,np.newaxis] xi_train = xi_train[:,np.newaxis] linreg.fit(xi_train,y_train) y = linreg.predict(xi_test) plt.subplot(5,2,f+1) plt.scatter(xi_test,y_test,color='k') plt.plot(xi_test,y,color='b',linewidth=3) 8.8 支持向量机 2198.8.1 支持向量分类 2191234567import numpy as npimport matplotlib.pyplot as pltfrom sklearn import svmx = np.array([[1,3],[1,2],[1,1.5],[1.5,2],[2,3],[2.5,1.5],[2,1],[3,1],[3,2],[3.5,1],[3.5,3]])y = [0]*6 + [1]*5plt.scatter(x[:,0],x[:,1],c=y,s=50,alpha=0.9) &lt;matplotlib.collections.PathCollection at 0xf811110&gt; 12345678910111213import numpy as npimport matplotlib.pyplot as pltfrom sklearn import svmx = np.array([[1,3],[1,2],[1,1.5],[1.5,2],[2,3],[2.5,1.5],[2,1],[3,1],[3,2],[3.5,1],[3.5,3]])y = [0]*6 + [1]*5svc = svm.SVC(kernel='linear').fit(x,y)X,Y = np.mgrid[0:4:200j,0:4:200j]Z = svc.decision_function(np.c_[X.ravel(),Y.ravel()])Z = Z.reshape(X.shape)plt.contourf(X,Y,Z &gt; 0,alpha=0.4)plt.contour(X,Y,Z,colors=['k'], linestyles=['-'],levels=[0])plt.scatter(x[:,0],x[:,1],c=y,s=50,alpha=0.9) &lt;matplotlib.collections.PathCollection at 0xf84ce50&gt; 1svc.predict([[1.5,2.5]]) array([0]) 1svc.predict([[2.5,1]]) array([1]) 1234567891011121314import numpy as npimport matplotlib.pyplot as pltfrom sklearn import svmx = np.array([[1,3],[1,2],[1,1.5],[1.5,2],[2,3],[2.5,1.5],[2,1],[3,1],[3,2],[3.5,1],[3.5,3]])y = [0]*6 + [1]*5svc = svm.SVC(kernel='linear',C=1).fit(x,y)X,Y = np.mgrid[0:4:200j,0:4:200j]Z = svc.decision_function(np.c_[X.ravel(),Y.ravel()])Z = Z.reshape(X.shape)plt.contourf(X,Y,Z &gt; 0,alpha=0.4)plt.contour(X,Y,Z,colors=['k','k','k'], linestyles=['--','-','--'],levels=[-1,0,1])plt.scatter(svc.support_vectors_[:,0],svc.support_vectors_[:,1],s=120,facecolors='none')plt.scatter(x[:,0],x[:,1],c=y,s=50,alpha=0.9) &lt;matplotlib.collections.PathCollection at 0xfe387b0&gt; 8.8.2 非线性SVC 2231234567891011121314import numpy as npimport matplotlib.pyplot as pltfrom sklearn import svmx = np.array([[1,3],[1,2],[1,1.5],[1.5,2],[2,3],[2.5,1.5],[2,1],[3,1],[3,2],[3.5,1],[3.5,3]])y = [0]*6 + [1]*5svc = svm.SVC(kernel='linear',C=0.1).fit(x,y)X,Y = np.mgrid[0:4:200j,0:4:200j]Z = svc.decision_function(np.c_[X.ravel(),Y.ravel()])Z = Z.reshape(X.shape)plt.contourf(X,Y,Z &gt; 0,alpha=0.4)plt.contour(X,Y,Z,colors=['k','k','k'], linestyles=['--','-','--'],levels=[-1,0,1])plt.scatter(svc.support_vectors_[:,0],svc.support_vectors_[:,1],s=120,facecolors='none')plt.scatter(x[:,0],x[:,1],c=y,s=50,alpha=0.9) &lt;matplotlib.collections.PathCollection at 0xff1eb90&gt; 1234567891011121314import numpy as npimport matplotlib.pyplot as pltfrom sklearn import svmx = np.array([[1,3],[1,2],[1,1.5],[1.5,2],[2,3],[2.5,1.5],[2,1],[3,1],[3,2],[3.5,1],[3.5,3]])y = [0]*6 + [1]*5svc = svm.SVC(kernel='poly',C=1, degree=3).fit(x,y)X,Y = np.mgrid[0:4:200j,0:4:200j]Z = svc.decision_function(np.c_[X.ravel(),Y.ravel()])Z = Z.reshape(X.shape)plt.contourf(X,Y,Z &gt; 0,alpha=0.4)plt.contour(X,Y,Z,colors=['k','k','k'], linestyles=['--','-','--'],levels=[-1,0,1])plt.scatter(svc.support_vectors_[:,0],svc.support_vectors_[:,1],s=120,facecolors='none')plt.scatter(x[:,0],x[:,1],c=y,s=50,alpha=0.9) &lt;matplotlib.collections.PathCollection at 0xf99b8d0&gt; 1234567891011121314import numpy as npimport matplotlib.pyplot as pltfrom sklearn import svmx = np.array([[1,3],[1,2],[1,1.5],[1.5,2],[2,3],[2.5,1.5],[2,1],[3,1],[3,2],[3.5,1],[3.5,3]])y = [0]*6 + [1]*5svc = svm.SVC(kernel='rbf', C=1, gamma=3).fit(x,y)X,Y = np.mgrid[0:4:200j,0:4:200j]Z = svc.decision_function(np.c_[X.ravel(),Y.ravel()])Z = Z.reshape(X.shape)plt.contourf(X,Y,Z &gt; 0,alpha=0.4)plt.contour(X,Y,Z,colors=['k','k','k'], linestyles=['--','-','--'],levels=[-1,0,1])plt.scatter(svc.support_vectors_[:,0],svc.support_vectors_[:,1],s=120,facecolors='none')plt.scatter(x[:,0],x[:,1],c=y,s=50,alpha=0.9) &lt;matplotlib.collections.PathCollection at 0xe575f90&gt; 8.8.3 绘制SVM分类器对Iris数据集的分类效果图 2251234567891011121314151617import numpy as npimport matplotlib.pyplot as pltfrom sklearn import svm, datasetsiris = datasets.load_iris()x = iris.data[:,:2]y = iris.targeth = .05svc = svm.SVC(kernel='linear',C=1.0).fit(x,y)x_min,x_max = x[:,0].min() - .5, x[:,0].max() + .5y_min,y_max = x[:,1].min() - .5, x[:,1].max() + .5h = .02X, Y = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min,y_max,h))Z = svc.predict(np.c_[X.ravel(),Y.ravel()])Z = Z.reshape(X.shape)plt.contourf(X,Y,Z,alpha=0.4)plt.contour(X,Y,Z,colors='k')plt.scatter(x[:,0],x[:,1],c=y) &lt;matplotlib.collections.PathCollection at 0xd3aac90&gt; 1234567891011121314151617import numpy as npimport matplotlib.pyplot as pltfrom sklearn import svm, datasetsiris = datasets.load_iris()x = iris.data[:,:2]y = iris.targeth = .05svc = svm.SVC(kernel='poly',C=1.0,degree=3).fit(x,y)x_min,x_max = x[:,0].min() - .5, x[:,0].max() + .5y_min,y_max = x[:,1].min() - .5, x[:,1].max() + .5h = .02X, Y = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min,y_max,h))Z = svc.predict(np.c_[X.ravel(),Y.ravel()])Z = Z.reshape(X.shape)plt.contourf(X,Y,Z,alpha=0.4)plt.contour(X,Y,Z,colors='k')plt.scatter(x[:,0],x[:,1],c=y) &lt;matplotlib.collections.PathCollection at 0xf705250&gt; 1234567891011121314151617import numpy as npimport matplotlib.pyplot as pltfrom sklearn import svm, datasetsiris = datasets.load_iris()x = iris.data[:,:2]y = iris.targeth = .05svc = svm.SVC(kernel='rbf',C=1.0,degree=3).fit(x,y)x_min,x_max = x[:,0].min() - .5, x[:,0].max() + .5y_min,y_max = x[:,1].min() - .5, x[:,1].max() + .5h = .02X, Y = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min,y_max,h))Z = svc.predict(np.c_[X.ravel(),Y.ravel()])Z = Z.reshape(X.shape)plt.contourf(X,Y,Z,alpha=0.4)plt.contour(X,Y,Z,colors='k')plt.scatter(x[:,0],x[:,1],c=y) &lt;matplotlib.collections.PathCollection at 0xe419a50&gt; 8.8.4 支持向量回归 227123456789101112131415161718192021222324252627282930import numpy as npimport matplotlib.pyplot as pltfrom sklearn import svmfrom sklearn import datasetsdiabetes = datasets.load_diabetes()x_train = diabetes.data[:-20]y_train = diabetes.target[:-20]x_test = diabetes.data[-20:]y_test = diabetes.target[-20:]x0_test = x_test[:,2]x0_train = x_train[:,2]x0_test = x0_test[:,np.newaxis]x0_train = x0_train[:,np.newaxis]x0_test.sort(axis=0)x0_test = x0_test*100x0_train = x0_train*100svr = svm.SVR(kernel='linear',C=1000)svr2 = svm.SVR(kernel='poly',C=1000,degree=2)svr3 = svm.SVR(kernel='poly',C=1000,degree=3)svr.fit(x0_train,y_train)svr2.fit(x0_train,y_train)svr3.fit(x0_train,y_train)y = svr.predict(x0_test)y2 = svr2.predict(x0_test)y3 = svr3.predict(x0_test)plt.scatter(x0_test,y_test,color='k')plt.plot(x0_test,y,color='b')plt.plot(x0_test,y2,c='r')plt.plot(x0_test,y3,c='g') [&lt;matplotlib.lines.Line2D at 0xf068670&gt;] 8.9 小结 229]]></content>
      <categories>
        <category>机器学习</category>
        <category>sklearn</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>SVC</tag>
        <tag>sklearn</tag>
        <tag>scikit-learn</tag>
        <tag>KNN</tag>
        <tag>SVR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第7章-用matplotlib实现数据可视化]]></title>
    <url>%2F2018%2F04%2F12%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC7%E7%AB%A0-%E7%94%A8matplotlib%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[第7章 用matplotlib实现数据可视化 1497.1 matplotlib库 1497.2 安装 1507.3 IPython和IPython QtConsole 1507.4 matplotlib架构 151 7.4.1 Backend层 1527.4.2 Artist层 152 7.4.3 Scripting层（pyplot） 1537.4.4 pylab和pyplot 1537.5 pyplot 1547.5.1 生成一幅简单的交互式图表 154123import matplotlib.pyplot as plt%matplotlib inlineplt.plot([1,2,3,4]) [&lt;matplotlib.lines.Line2D at 0xb50aa10&gt;] 7.5.2 设置图形的属性 1561plt.plot([1,2,3,4],[1,4,9,16],'ro') [&lt;matplotlib.lines.Line2D at 0xc78c450&gt;] 123plt.axis([0,5,0,20])plt.title('My first plot')plt.plot([1,2,3,4],[1,4,9,16],'ro') [&lt;matplotlib.lines.Line2D at 0xc7ab610&gt;] 7.5.3 matplotlib和NumPy 1581234567import mathimport numpy as npt = np.arange(0,2.5,0.1)y1 = list(map(math.sin,math.pi*t))y2 = list(map(math.sin,math.pi*t+math.pi/2))y3 = list(map(math.sin,math.pi*t-math.pi/2))plt.plot(t,y1,'b*',t,y2,'g^',t,y3,'ys') [&lt;matplotlib.lines.Line2D at 0xc9e7ff0&gt;, &lt;matplotlib.lines.Line2D at 0xc9f3110&gt;, &lt;matplotlib.lines.Line2D at 0xc9f3430&gt;] 1plt.plot(t,y1,'b--',t,y2,'g',t,y3,'r-.') [&lt;matplotlib.lines.Line2D at 0xca757b0&gt;, &lt;matplotlib.lines.Line2D at 0xca758b0&gt;, &lt;matplotlib.lines.Line2D at 0xca75bd0&gt;] 7.6 使用kwargs 1601plt.plot([1,2,4,2,1,0,1,2,1,4],linewidth=2.0) [&lt;matplotlib.lines.Line2D at 0xcaba9d0&gt;] 处理多个Figure和Axes对象 12345678t = np.arange(0,5,0.1)y1 = np.sin(2*np.pi*t)y2 = np.sin(2*np.pi*t)plt.subplot(211)plt.plot(t,y1,'b-.')plt.subplot(212)plt.plot(t,y2,'r--') [&lt;matplotlib.lines.Line2D at 0xcb219b0&gt;] 12345678t = np.arange(0.,1.,0.05)y1 = np.sin(2*np.pi*t)y2 = np.cos(2*np.pi*t)plt.subplot(121)plt.plot(t,y1,'b-.')plt.subplot(122)plt.plot(t,y2,'r--') [&lt;matplotlib.lines.Line2D at 0xcb8c670&gt;] 7.7 为图表添加更多元素 1627.7.1 添加文本 16212345plt.axis([0,5,0,20])plt.title('My first plot')plt.xlabel('Counting')plt.ylabel('Square values')plt.plot([1,2,3,4],[1,4,9,16],'ro') [&lt;matplotlib.lines.Line2D at 0xcbdf930&gt;] 12345plt.axis([0,5,0,20])plt.title('My first plot',fontsize=20,fontname='Times New Roman')plt.xlabel('Counting',color='gray')plt.ylabel('Square values',color='gray')plt.plot([1,2,3,4],[1,4,9,16],'ro') [&lt;matplotlib.lines.Line2D at 0xcc19fb0&gt;] 123456789plt.axis([0,5,0,20])plt.title('My first plot',fontsize=20,fontname='Times New Roman')plt.xlabel('Counting',color='gray')plt.ylabel('Square values',color='gray')plt.text(1,1.5,'First')plt.text(2,4.5,'Second')plt.text(3,9.5,'Third')plt.text(4,16.5,'Fourth')plt.plot([1,2,3,4],[1,4,9,16],'ro') [&lt;matplotlib.lines.Line2D at 0xcc5ca50&gt;] 12345678910plt.axis([0,5,0,20])plt.title('My first plot',fontsize=20,fontname='Times New Roman')plt.xlabel('Counting',color='gray')plt.ylabel('Square values',color='gray')plt.text(1,1.5,'First')plt.text(2,4.5,'Second')plt.text(3,9.5,'Third')plt.text(4,16.5,'Fourth')plt.text(1.1,12,r'$y = x^2$',fontsize=20,bbox=&#123;'facecolor':'yellow','alpha':0.2&#125;)plt.plot([1,2,3,4],[1,4,9,16],'ro') [&lt;matplotlib.lines.Line2D at 0xcca15f0&gt;] 7.7.2 添加网格 1651234567891011plt.axis([0,5,0,20])plt.title('My first plot',fontsize=20,fontname='Times New Roman')plt.xlabel('Counting',color='gray')plt.ylabel('Square values',color='gray')plt.text(1,1.5,'First')plt.text(2,4.5,'Second')plt.text(3,9.5,'Third')plt.text(4,16.5,'Fourth')plt.text(1.1,12,r'$y = x^2$',fontsize=20,bbox=&#123;'facecolor':'yellow','alpha':0.2&#125;)plt.grid(True)plt.plot([1,2,3,4],[1,4,9,16],'ro') [&lt;matplotlib.lines.Line2D at 0xcd2e6b0&gt;] 7.7.3 添加图例 1661234567891011plt.axis([0,5,0,20])plt.title('My first plot',fontsize=20,fontname='Times New Roman')plt.xlabel('Counting',color='gray')plt.ylabel('Square values',color='gray')plt.text(2,4.5,'Second')plt.text(3,9.5,'Third')plt.text(4,16.5,'Fourth')plt.text(1.1,12,'$y = x^2$',fontsize=20,bbox=&#123;'facecolor':'yellow','alpha':0.2&#125;)plt.grid(True)plt.plot([1,2,3,4],[1,4,9,16],'ro')plt.legend(['First series']) &lt;matplotlib.legend.Legend at 0xcd71750&gt; 123456789101112131415import matplotlib.pyplot as pltplt.axis([0,5,0,20])plt.title('My first plot',fontsize=20,fontname='Times New Roman')plt.xlabel('Counting',color='gray')plt.ylabel('Square values',color='gray')plt.text(1,1.5,'First')plt.text(2,4.5,'Second')plt.text(3,9.5,'Third')plt.text(4,16.5,'Fourth')plt.text(1.1,12,'$y = x^2$',fontsize=20,bbox=&#123;'facecolor':'yellow','alpha':0.2&#125;)plt.grid(True)plt.plot([1,2,3,4],[1,4,9,16],'ro')plt.plot([1,2,3,4],[0.8,3.5,8,15],'g^')plt.plot([1,2,3,4],[0.5,2.5,4,12],'b*')plt.legend(['First series','Second series','Third series'],loc=2) &lt;matplotlib.legend.Legend at 0xcdca450&gt; Location Code Location String0 best1 upper-right2 upper-left3 lower-right4 lower-left5 right6 center-left7 center-right8 lower-center9 upper-center10 centerChapter 7.8 保存图表 1687.8.1 保存代码 1697.8.2 将会话转换为HTML文件 1707.8.3 将图表直接保存为图片 171123456789101112131415plt.axis([0,5,0,20])plt.title('My first plot',fontsize=20,fontname='Times New Roman')plt.xlabel('Counting',color='gray')plt.ylabel('Square values',color='gray')plt.text(1,1.5,'First')plt.text(2,4.5,'Second')plt.text(3,9.5,'Third')plt.text(4,16.5,'Fourth')plt.text(1.1,12,'$y = x^2$',fontsize=20,bbox=&#123;'facecolor':'yellow','alpha':0.2&#125;)plt.grid(True)plt.plot([1,2,3,4],[1,4,9,16],'ro')plt.plot([1,2,3,4],[0.8,3.5,8,15],'g^')plt.plot([1,2,3,4],[0.5,2.5,4,12],'b*')plt.legend(['First series','Second series','Third series'],loc=2)plt.savefig('my_chart.png') 7.9 处理日期值 17112345678import datetimeimport numpy as npimport matplotlib.pyplot as pltevents = [datetime.date(2015,1,23),datetime.date(2015,1,28),datetime.date(2015,2,3),datetime.date(2015,2,21),datetime.date(2015,3,15),datetime.date(2015,3,24),datetime.date(2015,4,8),datetime.date(2015,4,24)]readings = [12,22,25,20,18,15,17,14]plt.plot(events,readings) [&lt;matplotlib.lines.Line2D at 0xcdfa2d0&gt;] 12345678910111213141516import datetimeimport numpy as npimport matplotlib.pyplot as pltimport matplotlib.dates as mdatesmonths = mdates.MonthLocator()days = mdates.DayLocator()timeFmt = mdates.DateFormatter('%Y-%m')events = [datetime.date(2015,1,23),datetime.date(2015,1,28),datetime.date(2015,2,3),datetime.date(2015,2,21),datetime.date(2015,3,15),datetime.date(2015,3,24),datetime.date(2015,4,8),datetime.date(2015,4,24)]readings = [12,22,25,20,18,15,17,14]fig, ax = plt.subplots()plt.plot(events,readings)ax.xaxis.set_major_locator(months)ax.xaxis.set_major_formatter(timeFmt)ax.xaxis.set_minor_locator(days) 7.10 图表类型 1737.11 线性图 17312345import matplotlib.pyplot as pltimport numpy as npx = np.arange(-2*np.pi,2*np.pi,0.01)y = np.sin(3*x)/xplt.plot(x,y) [&lt;matplotlib.lines.Line2D at 0xcf9eab0&gt;] 123456789import matplotlib.pyplot as pltimport numpy as npx = np.arange(-2*np.pi,2*np.pi,0.01)y = np.sin(x)/xy2 = np.sin(2*x)/xy3 = np.sin(3*x)/xplt.plot(x,y)plt.plot(x,y2)plt.plot(x,y3) [&lt;matplotlib.lines.Line2D at 0xcdc4ff0&gt;] 123456789import matplotlib.pyplot as pltimport numpy as npx = np.arange(-2*np.pi,2*np.pi,0.01)y = np.sin(x)/xy2 = np.sin(2*x)/xy3 = np.sin(3*x)/xplt.plot(x,y,'k--',linewidth=3)plt.plot(x,y2,'m-.')plt.plot(x,y3,color='#87a3cc',linestyle='--') [&lt;matplotlib.lines.Line2D at 0xe00f2d0&gt;] Code Colorb blueg greenr redc cyanm magentay yellowk blackw white 12345678910111213import matplotlib.pyplot as pltimport numpy as npx = np.arange(-2*np.pi,2*np.pi,0.01)y = np.sin(3*x)/xy2 = np.sin(2*x)/xy3 = np.sin(x)/xplt.plot(x,y,color='b')plt.plot(x,y2,color='r')plt.plot(x,y3,color='g')plt.xticks([-2*np.pi, -np.pi, 0, np.pi, 2*np.pi],[r'$-2\pi$',r'$-\pi$',r'$0$',r'$+\pi$',r'$+2\pi$'])plt.yticks([-1,0,+1,+2,+3],[r'$-1$',r'$0$',r'$+1$',r'$+2$',r'$+3$']) ([&lt;matplotlib.axis.YTick at 0xe0358f0&gt;, &lt;matplotlib.axis.YTick at 0xe00f7f0&gt;, &lt;matplotlib.axis.YTick at 0xe035eb0&gt;, &lt;matplotlib.axis.YTick at 0xe05b430&gt;, &lt;matplotlib.axis.YTick at 0xe05b8b0&gt;], &lt;a list of 5 Text yticklabel objects&gt;) 1234567891011121314151617181920import matplotlib.pyplot as pltimport numpy as npx = np.arange(-2*np.pi,2*np.pi,0.01)y = np.sin(3*x)/xy2 = np.sin(2*x)/xy3 = np.sin(x)/xplt.plot(x,y,color='b')plt.plot(x,y2,color='r')plt.plot(x,y3,color='g')plt.xticks([-2*np.pi, -np.pi, 0, np.pi, 2*np.pi],[r'$-2\pi$',r'$-\pi$',r'$0$',r'$+\pi$',r'$+2\pi$'])plt.yticks([-1,0,+1,+2,+3],[r'$-1$',r'$0$',r'$+1$',r'$+2$',r'$+3$'])ax = plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position('bottom')ax.spines['bottom'].set_position(('data',0))ax.yaxis.set_ticks_position('left')ax.spines['left'].set_position(('data',0)) 1234567891011121314151617181920212223import matplotlib.pyplot as pltimport numpy as npx = np.arange(-2*np.pi,2*np.pi,0.01)y = np.sin(3*x)/xy2 = np.sin(2*x)/xy3 = np.sin(x)/xplt.plot(x,y,color='b')plt.plot(x,y2,color='r')plt.plot(x,y3,color='g')plt.xticks([-2*np.pi, -np.pi, 0, np.pi, 2*np.pi],[r'$-2\pi$',r'$-\pi$',r'$0$',r'$+\pi$',r'$+2\pi$'])plt.yticks([-1,0,+1,+2,+3],[r'$-1$',r'$0$',r'$+1$',r'$+2$',r'$+3$'])plt.annotate(r'$\lim_&#123;x\to 0&#125;\frac&#123;\sin(x)&#125;&#123;x&#125;= 1$', xy=[0,1],xycoords='data',xytext=[30,30],fontsize=16,textcoords='offset points',arrowprops=dict(arrowstyle="-&gt;",connectionstyle="arc3,rad=.2"))ax = plt.gca()ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')ax.xaxis.set_ticks_position('bottom')ax.spines['bottom'].set_position(('data',0))ax.yaxis.set_ticks_position('left')ax.spines['left'].set_position(('data',0)) 1234567891011import matplotlib.pyplot as pltimport numpy as npimport pandas as pddata = &#123;'series1':[1,3,4,3,5],'series2':[2,4,5,2,4],'series3':[3,2,3,1,3]&#125;df = pd.DataFrame(data)x = np.arange(5)plt.axis([0,5,0,7])plt.plot(x,df)plt.legend(data, loc=2) &lt;matplotlib.legend.Legend at 0xf047270&gt; 7.12 直方图 1801234import matplotlib.pyplot as pltimport numpy as nppop = np.random.randint(0,100,100)pop array([32, 29, 53, 8, 43, 91, 54, 31, 81, 54, 28, 56, 43, 39, 96, 44, 6, 71, 29, 26, 34, 41, 78, 45, 1, 22, 94, 89, 19, 6, 95, 3, 86, 10, 1, 54, 51, 5, 20, 18, 87, 12, 92, 50, 82, 3, 56, 23, 57, 92, 25, 2, 86, 32, 75, 13, 85, 90, 8, 77, 91, 5, 31, 34, 44, 67, 30, 15, 42, 63, 15, 38, 56, 83, 2, 18, 94, 49, 31, 47, 25, 5, 20, 70, 47, 65, 29, 44, 23, 35, 73, 96, 34, 27, 11, 70, 96, 21, 71, 69]) 1n,bins,patches = plt.hist(pop,bins=20) 7.13 条状图 1811234import matplotlib.pyplot as pltindex = [0,1,2,3,4]values = [5,7,3,4,6]plt.bar(index,values) &lt;Container object of 5 artists&gt; 12345import numpy as npindex = np.arange(5)values1 = [5,7,3,4,6]plt.bar(index,values1)plt.xticks(index+0.4,['A','B','C','D','E']) ([&lt;matplotlib.axis.XTick at 0xf3246f0&gt;, &lt;matplotlib.axis.XTick at 0xf261bd0&gt;, &lt;matplotlib.axis.XTick at 0xf31c310&gt;, &lt;matplotlib.axis.XTick at 0xf3423f0&gt;, &lt;matplotlib.axis.XTick at 0xf342790&gt;], &lt;a list of 5 Text xticklabel objects&gt;) 123456789import numpy as npindex = np.arange(5)values1 = [5,7,3,4,6]std1 = [0.8,1,0.4,0.9,1.3]plt.title('A Bar Chart')plt.bar(index,values1,yerr=std1,error_kw=&#123;'ecolor':'0.1','capsize':6&#125;,alpha=0.7,label='First')plt.xticks(index+0.4,['A','B','C','D','E'])plt.legend(loc=2) &lt;matplotlib.legend.Legend at 0xf389970&gt; 7.13.1 水平条状图 18312345678910import matplotlib.pyplot as pltimport numpy as npindex = np.arange(5)values1 = [5,7,3,4,6]std1 = [0.8,1,0.4,0.9,1.3]plt.title('A Horizontal Bar Chart')plt.barh(index,values1,xerr=std1,error_kw=&#123;'ecolor':'0.1','capsize':6&#125;,alpha=0.7,label='First')plt.yticks(index+0.4,['A','B','C','D','E'])plt.legend(loc=5) &lt;matplotlib.legend.Legend at 0xf3c9630&gt; 7.13.2 多序列条状图 18412345678910111213import matplotlib.pyplot as pltimport numpy as npindex = np.arange(5)values1 = [5,7,3,4,6]values2 = [6,6,4,5,7]values3 = [5,6,5,4,6]bw = 0.3plt.axis([0,5,0,8])plt.title('A Multiseries Bar Chart',fontsize=20)plt.bar(index,values1,bw,color='b')plt.bar(index+bw,values2,bw,color='g')plt.bar(index+2*bw,values3,bw,color='r')plt.xticks(index+1.5*bw,['A','B','C','D','E']) ([&lt;matplotlib.axis.XTick at 0xf39dcd0&gt;, &lt;matplotlib.axis.XTick at 0xf39ded0&gt;, &lt;matplotlib.axis.XTick at 0xf3ef4b0&gt;, &lt;matplotlib.axis.XTick at 0xf42d230&gt;, &lt;matplotlib.axis.XTick at 0xf42d5d0&gt;], &lt;a list of 5 Text xticklabel objects&gt;) 12345678910111213import matplotlib.pyplot as pltimport numpy as npindex = np.arange(5)values1 = [5,7,3,4,6]values2 = [6,6,4,5,7]values3 = [5,6,5,4,6]bw = 0.3plt.axis([0,8,0,5])plt.title('A Multiseries Horizontal Bar Chart',fontsize=20)plt.barh(index,values1,bw,color='b')plt.barh(index+bw,values2,bw,color='g')plt.barh(index+2*bw,values3,bw,color='r')plt.yticks(index+0.4,['A','B','C','D','E']) ([&lt;matplotlib.axis.YTick at 0xf43e810&gt;, &lt;matplotlib.axis.YTick at 0xf43e0f0&gt;, &lt;matplotlib.axis.YTick at 0xf44f330&gt;, &lt;matplotlib.axis.YTick at 0xf473f50&gt;, &lt;matplotlib.axis.YTick at 0xf47d310&gt;], &lt;a list of 5 Text yticklabel objects&gt;) 7.13.3 为pandas DataFrame生成多序列条状图 18512345678import matplotlib.pyplot as pltimport numpy as npimport pandas as pddata = &#123;'series1':[1,3,4,3,5],'series2':[2,4,5,2,4],'series3':[3,2,3,1,3]&#125;df = pd.DataFrame(data)df.plot(kind='bar') &lt;matplotlib.axes._subplots.AxesSubplot at 0xf3a3330&gt; 12345678import matplotlib.pyplot as pltimport numpy as npimport pandas as pddata = &#123;'series1':[1,3,4,3,5],'series2':[2,4,5,2,4],'series3':[3,2,3,1,3]&#125;df = pd.DataFrame(data)df.plot(kind='barh') &lt;matplotlib.axes._subplots.AxesSubplot at 0xf3bf030&gt; 7.13.4 多序列堆积条状图 1861234567891011import matplotlib.pyplot as pltimport numpy as npseries1 = np.array([3,4,5,3])series2 = np.array([1,2,2,5])series3 = np.array([2,3,3,4])index = np.arange(4)plt.axis([0,4,0,15])plt.bar(index,series1,color='r')plt.bar(index,series2,color='b',bottom=series1)plt.bar(index,series3,color='g',bottom=(series2+series1))plt.xticks(index+0.4,['Jan15','Feb15','Mar15','Apr15']) ([&lt;matplotlib.axis.XTick at 0xf53e9f0&gt;, &lt;matplotlib.axis.XTick at 0xf549250&gt;, &lt;matplotlib.axis.XTick at 0xf53ef70&gt;, &lt;matplotlib.axis.XTick at 0xf5790b0&gt;], &lt;a list of 4 Text xticklabel objects&gt;) 123456789101112import matplotlib.pyplot as pltimport numpy as npindex = np.arange(4)series1 = np.array([3,4,5,3])series2 = np.array([1,2,2,5])series3 = np.array([2,3,3,4])plt.axis([0,15,0,4])plt.title('A Multiseries Horizontal Stacked Bar Chart')plt.barh(index,series1,color='r')plt.barh(index,series2,color='g',left=series1)plt.barh(index,series3,color='b',left=(series1+series2))plt.yticks(index+0.4,['Jan15','Feb15','Mar15','Apr15']) ([&lt;matplotlib.axis.YTick at 0xf58b1d0&gt;, &lt;matplotlib.axis.YTick at 0xf549ff0&gt;, &lt;matplotlib.axis.YTick at 0xf58bcf0&gt;, &lt;matplotlib.axis.YTick at 0xf5bf2b0&gt;], &lt;a list of 4 Text yticklabel objects&gt;) 123456789101112import matplotlib.pyplot as pltimport numpy as npindex = np.arange(4)series1 = np.array([3,4,5,3])series2 = np.array([1,2,2,5])series3 = np.array([2,3,3,4])plt.axis([0,15,0,4])plt.title('A Multiseries Horizontal Stacked Bar Chart')plt.barh(index,series1,color='w',hatch='xx')plt.barh(index,series2,color='w',hatch='///', left=series1)plt.barh(index,series3,color='w',hatch='\\\\\\',left=(series1+series2))plt.yticks(index+0.4,['Jan15','Feb15','Mar15','Apr15']) ([&lt;matplotlib.axis.YTick at 0xf5d0c10&gt;, &lt;matplotlib.axis.YTick at 0xf5b6790&gt;, &lt;matplotlib.axis.YTick at 0xf5dc170&gt;, &lt;matplotlib.axis.YTick at 0xf6066b0&gt;], &lt;a list of 4 Text yticklabel objects&gt;) 7.13.5 为pandas DataFrame绘制堆积条状图 1891234567import matplotlib.pyplot as pltimport pandas as pddata = &#123;'series1':[1,3,4,3,5],'series2':[2,4,5,2,4],'series3':[3,2,3,1,3]&#125;df = pd.DataFrame(data)df.plot(kind='bar', stacked=True) &lt;matplotlib.axes._subplots.AxesSubplot at 0xf5e74f0&gt; 7.13.6 其他条状图 19012345678910111213import matplotlib.pyplot as pltx0 = np.arange(8)y1 = np.array([1,3,4,6,4,3,2,1])y2 = np.array([1,2,5,4,3,3,2,1])plt.ylim(-7,7)plt.bar(x0,y1,0.9,facecolor='r',edgecolor='w')plt.bar(x0,-y2,0.9,facecolor='b',edgecolor='w')plt.xticks(())plt.grid(True)for x, y in zip(x0, y1): plt.text(x + 0.4, y + 0.05, '%d' % y, ha='center', va= 'bottom')for x, y in zip(x0, y2): plt.text(x + 0.4, (-y) - 0.05, '%d' % y, ha='center', va= 'top') 7.14 饼图 190123456import matplotlib.pyplot as pltlabels = ['Nokia','Samsung','Apple','Lumia']values = [10,30,45,15]colors = ['yellow','green','red','blue']plt.pie(values,labels=labels,colors=colors)plt.axis('equal') (-1.11637372803214, 1.1007797090739162, -1.1163737124158366, 1.1007797083302826) 12345678import matplotlib.pyplot as pltlabels = ['Nokia','Samsung','Apple','Lumia']values = [10,30,45,15]colors = ['yellow','green','red','blue']explode = [0.3,0,0,0]plt.title('A Pie Chart')plt.pie(values,labels=labels,colors=colors,explode=explode,startangle=180)plt.axis('equal') (-1.4003625034945653, 1.130639575385504, -1.1007797083302826, 1.1163737124158366) 123456789import matplotlib.pyplot as pltlabels = ['Nokia','Samsung','Apple','Lumia']values = [10,30,45,15]colors = ['yellow','green','red','blue']explode = [0.3,0,0,0]plt.title('A Pie Chart')plt.pie(values,labels=labels,colors=colors,explode=explode,shadow=True,autopct='%1.1f%%',startangle=180)plt.axis('equal') (-1.4003625034945653, 1.130639575385504, -1.1007797083302826, 1.1163737124158366) 1234567import matplotlib.pyplot as pltimport pandas as pddata = &#123;'series1':[1,3,4,3,5],'series2':[2,4,5,2,4],'series3':[3,2,3,1,3]&#125;df = pd.DataFrame(data)df['series1'].plot(kind='pie',figsize=(6,6)) &lt;matplotlib.axes._subplots.AxesSubplot at 0xf7d2ed0&gt; 7.15 高级图表 1937.15.1 等值线图 1931234567891011import matplotlib.pyplot as pltimport numpy as npdx = 0.01; dy = 0.01x = np.arange(-2.0,2.0,dx)y = np.arange(-2.0,2.0,dy)X,Y = np.meshgrid(x,y)def f(x,y): return (1 - y**5 + x**5)*np.exp(-x**2-y**2)C = plt.contour(X,Y,f(X,Y),8,colors='black')plt.contourf(X,Y,f(X,Y),8)plt.clabel(C, inline=1, fontsize=10) &lt;a list of 16 text.Text objects&gt; 12345678910import matplotlib.pyplot as pltimport numpy as npdx = 0.01; dy = 0.01x = np.arange(-2.0,2.0,dx)y = np.arange(-2.0,2.0,dy)X,Y = np.meshgrid(x,y)C = plt.contour(X,Y,f(X,Y),8,colors='black')plt.contourf(X,Y,f(X,Y),8,cmap=plt.cm.hot)plt.clabel(C, inline=1, fontsize=10)plt.colorbar() &lt;matplotlib.colorbar.Colorbar at 0x1100f0b0&gt; 7.15.2 极区图 195123456789import matplotlib.pyplot as pltimport numpy as npN = 8theta = np.arange(0.,2 * np.pi, 2 * np.pi / N)radii = np.array([4,7,5,3,1,5,6,7])plt.axes([0.025, 0.025, 0.95, 0.95], polar=True)colors = np.array(['#4bb2c5', '#c5b47f', '#EAA228', '#579575', '#839557', '#958c12','#953579', '#4b5de4'])bars = plt.bar(theta, radii, width=(2*np.pi/N), bottom=0.0, color=colors) 123456789import matplotlib.pyplot as pltimport numpy as npN = 8theta = np.arange(0.,2 * np.pi, 2 * np.pi / N)radii = np.array([4,7,5,3,1,5,6,7])plt.axes([0.025, 0.025, 0.95, 0.95], polar=True)colors = np.array(['lightgreen', 'darkred', 'navy', 'brown', 'violet', 'plum','yellow', 'darkgreen'])bars = plt.bar(theta, radii, width=(2*np.pi/N), bottom=0.0, color=colors) 7.16 mplot3d 1977.16.1 3D曲面 19712345678910from mpl_toolkits.mplot3d import Axes3Dimport matplotlib.pyplot as pltfig = plt.figure()ax = Axes3D(fig)X = np.arange(-2,2,0.1)Y = np.arange(-2,2,0.1)X,Y = np.meshgrid(X,Y)def f(x,y): return (1 - y**5 + x**5)*np.exp(-x**2-y**2)ax.plot_surface(X,Y,f(X,Y), rstride=1, cstride=1) &lt;mpl_toolkits.mplot3d.art3d.Poly3DCollection at 0x11eade50&gt; 1234567891011from mpl_toolkits.mplot3d import Axes3Dimport matplotlib.pyplot as pltfig = plt.figure()ax = Axes3D(fig)X = np.arange(-2,2,0.1)Y = np.arange(-2,2,0.1)X,Y = np.meshgrid(X,Y)def f(x,y): return (1 - y**5 + x**5)*np.exp(-x**2-y**2)ax.plot_surface(X,Y,f(X,Y), rstride=1, cstride=1, cmap=plt.cm.hot)ax.view_init(elev=30,azim=125) 7.16.2 3D散点图 1981234567891011121314151617181920import matplotlib.pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3Dxs = np.random.randint(30,40,100)ys = np.random.randint(20,30,100)zs = np.random.randint(10,20,100)xs2 = np.random.randint(50,60,100)ys2 = np.random.randint(30,40,100)zs2 = np.random.randint(50,70,100)xs3 = np.random.randint(10,30,100)ys3 = np.random.randint(40,50,100)zs3 = np.random.randint(40,50,100)fig = plt.figure()ax = Axes3D(fig)ax.scatter(xs,ys,zs)ax.scatter(xs2,ys2,zs2,c='r',marker='^')ax.scatter(xs3,ys3,zs3,c='g',marker='*')ax.set_xlabel('X Label')ax.set_ylabel('Y Label')ax.set_zlabel('Z Label') Text(0.5,0,&apos;Z Label&apos;) 7.16.3 3D条状图 19912345678910111213141516171819202122import matplotlib.pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3Dx = np.arange(8)y = np.random.randint(0,10,8)y2 = y + np.random.randint(0,3,8)y3 = y2 + np.random.randint(0,3,8)y4 = y3 + np.random.randint(0,3,8)y5 = y4 + np.random.randint(0,3,8)clr = ['#4bb2c5', '#c5b47f', '#EAA228', '#579575', '#839557', '#958c12', '#953579','#4b5de4']fig = plt.figure()ax = Axes3D(fig)ax.bar(x,y,0,zdir='y',color=clr)ax.bar(x,y2,10,zdir='y',color=clr)ax.bar(x,y3,20,zdir='y',color=clr)ax.bar(x,y4,30,zdir='y',color=clr)ax.bar(x,y5,40,zdir='y',color=clr)ax.set_xlabel('X Axis')ax.set_ylabel('Y Axis')ax.set_zlabel('Z Axis')ax.view_init(elev=40) 7.17 多面板图形 2007.17.1 在其他子图中显示子图 2001234import matplotlib.pyplot as pltfig = plt.figure()ax = fig.add_axes([0.1,0.1,0.8,0.8])inner_ax = fig.add_axes([0.6,0.6,0.25,0.25]) 1234567891011import matplotlib.pyplot as pltimport numpy as npfig = plt.figure()ax = fig.add_axes([0.1,0.1,0.8,0.8])inner_ax = fig.add_axes([0.6,0.6,0.25,0.25])x1 = np.arange(10)y1 = np.array([1,2,7,1,5,2,4,2,3,1])x2 = np.arange(10)y2 = np.array([1,3,4,5,4,5,2,6,4,3])ax.plot(x1,y1)inner_ax.plot(x2,y2) [&lt;matplotlib.lines.Line2D at 0x12144fd0&gt;] 7.17.2 子图网格 20212345678import matplotlib.pyplot as pltgs = plt.GridSpec(3,3)fig = plt.figure(figsize=(6,6))fig.add_subplot(gs[1,:2])fig.add_subplot(gs[0,:2])fig.add_subplot(gs[2,0])fig.add_subplot(gs[:2,2])fig.add_subplot(gs[2,1:]) &lt;matplotlib.axes._subplots.AxesSubplot at 0x12177a70&gt; 123456789101112131415161718import matplotlib.pyplot as pltimport numpy as npgs = plt.GridSpec(3,3)fig = plt.figure(figsize=(6,6))x1 = np.array([1,3,2,5])y1 = np.array([4,3,7,2])x2 = np.arange(5)y2 = np.array([3,2,4,6,4])s1 = fig.add_subplot(gs[1,:2])s1.plot(x,y,'r')s2 = fig.add_subplot(gs[0,:2])s2.bar(x2,y2)s3 = fig.add_subplot(gs[2,0])s3.barh(x2,y2,color='g')s4 = fig.add_subplot(gs[:2,2])s4.plot(x2,y2,'k')s5 = fig.add_subplot(gs[2,1:])s5.plot(x1,y1,'b^',x2,y2,'yo') [&lt;matplotlib.lines.Line2D at 0x1238a410&gt;, &lt;matplotlib.lines.Line2D at 0x1238a4d0&gt;] 7.18 小结 204]]></content>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第6章-深入pandas数据处理]]></title>
    <url>%2F2018%2F04%2F12%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC6%E7%AB%A0-%E6%B7%B1%E5%85%A5pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[第6章 深入pandas：数据处理 1176.1 数据准备 117合并 1234567891011#merge是两个dataframe共同包含的项import numpy as npimport pandas as pdframe1 = pd.DataFrame( &#123;'id':['ball','pencil','pen','mug','ashtray'], 'price': [12.33,11.44,33.21,13.23,33.62]&#125;)print(frame1)print()frame2 = pd.DataFrame( &#123;'id':['pencil','pencil','ball','pen'],'color': ['white','red','red','black']&#125;)print(frame2)print()temp = pd.merge(frame1,frame2)print(temp) id price 0 ball 12.33 1 pencil 11.44 2 pen 33.21 3 mug 13.23 4 ashtray 33.62 color id 0 white pencil 1 red pencil 2 red ball 3 black pen id price color 0 ball 12.33 red 1 pencil 11.44 white 2 pencil 11.44 red 3 pen 33.21 black 1234567891011121314151617181920frame1 = pd.DataFrame( &#123;'id':['ball','pencil','pen','mug','ashtray'], 'color': ['white','red','red','black','green'], 'brand': ['OMG','ABC','ABC','POD','POD']&#125;)print(frame1)print()frame2 = pd.DataFrame( &#123;'id':['pencil','pencil','ball','pen'], 'brand': ['OMG','POD','ABC','POD']&#125;)print(frame2)print()temp = pd.merge(frame1,frame2)print(temp)print()temp = pd.merge(frame1,frame2,on='id')print(temp)print()temp = pd.merge(frame1,frame2,on='brand')print(temp) brand color id 0 OMG white ball 1 ABC red pencil 2 ABC red pen 3 POD black mug 4 POD green ashtray brand id 0 OMG pencil 1 POD pencil 2 ABC ball 3 POD pen Empty DataFrame Columns: [brand, color, id] Index: [] brand_x color id brand_y 0 OMG white ball ABC 1 ABC red pencil OMG 2 ABC red pencil POD 3 ABC red pen POD brand color id_x id_y 0 OMG white ball pencil 1 ABC red pencil ball 2 ABC red pen ball 3 POD black mug pencil 4 POD black mug pen 5 POD green ashtray pencil 6 POD green ashtray pen 12345678print(frame1)print()frame2.columns = ['brand','sid']print(frame2)print()temp = pd.merge(frame1, frame2, left_on='id', right_on='sid')print(temp) brand color id 0 OMG white ball 1 ABC red pencil 2 ABC red pen 3 POD black mug 4 POD green ashtray brand sid 0 OMG pencil 1 POD pencil 2 ABC ball 3 POD pen brand_x color id brand_y sid 0 OMG white ball ABC ball 1 ABC red pencil OMG pencil 2 ABC red pencil POD pencil 3 ABC red pen POD pen 123frame2.columns = ['brand','id']temp = pd.merge(frame1,frame2,on='id')print(temp) brand_x color id brand_y 0 OMG white ball ABC 1 ABC red pencil OMG 2 ABC red pencil POD 3 ABC red pen POD 12temp = pd.merge(frame1,frame2,on='id',how='outer')print(temp) brand_x color id brand_y 0 OMG white ball ABC 1 ABC red pencil OMG 2 ABC red pencil POD 3 ABC red pen POD 4 POD black mug NaN 5 POD green ashtray NaN 12temp = pd.merge(frame1,frame2,on='id',how='left')print(temp) brand_x color id brand_y 0 OMG white ball ABC 1 ABC red pencil OMG 2 ABC red pencil POD 3 ABC red pen POD 4 POD black mug NaN 5 POD green ashtray NaN 12temp = pd.merge(frame1,frame2,on='id',how='right')print(temp) brand_x color id brand_y 0 OMG white ball ABC 1 ABC red pencil OMG 2 ABC red pencil POD 3 ABC red pen POD 12temp = pd.merge(frame1,frame2,on=['id','brand'],how='outer')print(temp) brand color id 0 OMG white ball 1 ABC red pencil 2 ABC red pen 3 POD black mug 4 POD green ashtray 5 OMG NaN pencil 6 POD NaN pencil 7 ABC NaN ball 8 POD NaN pen 根据索引合并 12temp = pd.merge(frame1,frame2,right_index=True, left_index=True) print(temp) brand_x color id_x brand_y id_y 0 OMG white ball OMG pencil 1 ABC red pencil POD pencil 2 ABC red pen ABC ball 3 POD black mug POD pen 123frame2.columns = ['brand2','id2']temp = frame1.join(frame2)print(temp) brand color id brand2 id2 0 OMG white ball OMG pencil 1 ABC red pencil POD pencil 2 ABC red pen ABC ball 3 POD black mug POD pen 4 POD green ashtray NaN NaN 6.2 拼接 12212array1 = np.arange(9).reshape((3,3))array1 array([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) 12array2 = np.arange(9).reshape((3,3))+6array2 array([[ 6, 7, 8], [ 9, 10, 11], [12, 13, 14]]) 1np.concatenate([array1,array2],axis=1) array([[ 0, 1, 2, 6, 7, 8], [ 3, 4, 5, 9, 10, 11], [ 6, 7, 8, 12, 13, 14]]) 1np.concatenate([array1,array2],axis=0) array([[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8], [ 6, 7, 8], [ 9, 10, 11], [12, 13, 14]]) 12ser1 = pd.Series(np.random.rand(4), index=[1,2,3,4])ser1 1 0.480270 2 0.440535 3 0.378281 4 0.799113 dtype: float64 12ser2 = pd.Series(np.random.rand(4), index=[5,6,7,8])ser2 5 0.134120 6 0.703728 7 0.657262 8 0.020803 dtype: float64 12temp = pd.concat([ser1,ser2])print(temp) 1 0.444507 2 0.690626 3 0.595412 4 0.030619 5 0.134120 6 0.703728 7 0.657262 8 0.020803 dtype: float64 12ser3 = pd.concat([ser1,ser2],axis=1)print(ser3) 0 1 1 0.444507 NaN 2 0.690626 NaN 3 0.595412 NaN 4 0.030619 NaN 5 NaN 0.134120 6 NaN 0.703728 7 NaN 0.657262 8 NaN 0.020803 12temp = pd.concat([ser1,ser3],axis=1,join='inner')print(temp) 0 0 1 1 0.444507 0.444507 NaN 2 0.690626 0.690626 NaN 3 0.595412 0.595412 NaN 4 0.030619 0.030619 NaN 12temp = pd.concat([ser1,ser2], keys=[1,2])print(temp) 1 1 0.444507 2 0.690626 3 0.595412 4 0.030619 2 5 0.134120 6 0.703728 7 0.657262 8 0.020803 dtype: float64 12temp = pd.concat([ser1,ser2], axis=1, keys=[1,2])print(temp) 1 2 1 0.444507 NaN 2 0.690626 NaN 3 0.595412 NaN 4 0.030619 NaN 5 NaN 0.134120 6 NaN 0.703728 7 NaN 0.657262 8 NaN 0.020803 12345678frame1 = pd.DataFrame(np.random.rand(9).reshape(3,3), index=[1,2,3], columns=['A','B','C'])print(frame1)print()frame2 = pd.DataFrame(np.random.rand(9).reshape(3,3), index=[4,5,6], columns=['A','B','C'])print(frame2)print()temp = pd.concat([frame1, frame2])print(temp) A B C 1 0.918894 0.884497 0.451266 2 0.990586 0.412664 0.289380 3 0.058831 0.746895 0.911668 A B C 4 0.256936 0.837374 0.677940 5 0.379119 0.453602 0.858519 6 0.832512 0.736023 0.583485 A B C 1 0.918894 0.884497 0.451266 2 0.990586 0.412664 0.289380 3 0.058831 0.746895 0.911668 4 0.256936 0.837374 0.677940 5 0.379119 0.453602 0.858519 6 0.832512 0.736023 0.583485 12temp = pd.concat([frame1, frame2], axis=1)print(temp) A B C A B C 1 0.918894 0.884497 0.451266 NaN NaN NaN 2 0.990586 0.412664 0.289380 NaN NaN NaN 3 0.058831 0.746895 0.911668 NaN NaN NaN 4 NaN NaN NaN 0.256936 0.837374 0.677940 5 NaN NaN NaN 0.379119 0.453602 0.858519 6 NaN NaN NaN 0.832512 0.736023 0.583485 6.2.1 组合 12412345678ser1 = pd.Series(np.random.rand(5),index=[1,2,3,4,5])print(ser1)print()ser2 = pd.Series(np.random.rand(4),index=[2,4,5,6])print(ser2)print()temp = ser1.combine_first(ser2)print(temp) 1 0.598971 2 0.143975 3 0.080446 4 0.437893 5 0.033583 dtype: float64 2 0.326416 4 0.732483 5 0.476231 6 0.468597 dtype: float64 1 0.598971 2 0.143975 3 0.080446 4 0.437893 5 0.033583 6 0.468597 dtype: float64 12temp = ser2.combine_first(ser1)print(temp) 1 0.598971 2 0.326416 3 0.080446 4 0.732483 5 0.476231 6 0.468597 dtype: float64 12temp = ser1[:3].combine_first(ser2[:3])print(temp) 1 0.598971 2 0.143975 3 0.080446 4 0.732483 5 0.476231 dtype: float64 6.2.2 轴向旋转 125按等级索引旋转123456frame1 = pd.DataFrame(np.arange(9).reshape(3,3),index=['white','black','red'],columns=['ball','pen','pencil'])print(frame1)ser5 = frame1.stack()ser5 ball pen pencil white 0 1 2 black 3 4 5 red 6 7 8 white ball 0 pen 1 pencil 2 black ball 3 pen 4 pencil 5 red ball 6 pen 7 pencil 8 dtype: int32 12temp = ser5.unstack()print(temp) ball pen pencil white 0 1 2 black 3 4 5 red 6 7 8 12temp = ser5.unstack(0)print(temp) white black red ball 0 3 6 pen 1 4 7 pencil 2 5 8 从长格式向宽格式旋转12345678longframe = pd.DataFrame(&#123; 'color':['white','white','white', 'red','red','red', 'black','black','black'], 'item':['ball','pen','mug', 'ball','pen','mug', 'ball','pen','mug'], 'value': np.random.rand(9)&#125;)print(longframe) color item value 0 white ball 0.905908 1 white pen 0.476735 2 white mug 0.569165 3 red ball 0.483042 4 red pen 0.663438 5 red mug 0.866178 6 black ball 0.752131 7 black pen 0.616940 8 black mug 0.713100 12wideframe = longframe.pivot('color','item')print(wideframe) value item ball mug pen color black 0.752131 0.713100 0.616940 red 0.483042 0.866178 0.663438 white 0.905908 0.569165 0.476735 6.2.3 删除 127123456789frame1 = pd.DataFrame(np.arange(9).reshape(3,3), index=['white','black','red'], columns=['ball','pen','pencil'])print(frame1)del frame1['ball']print(frame1)temp = frame1.drop('white')print(temp)print(frame1) ball pen pencil white 0 1 2 black 3 4 5 red 6 7 8 pen pencil white 1 2 black 4 5 red 7 8 pen pencil black 4 5 red 7 8 pen pencil white 1 2 black 4 5 red 7 8 6.3 数据转换 1286.3.1 删除重复元素 1281234567dframe = pd.DataFrame(&#123; 'color': ['white','white','red','red','white'], 'value': [2,1,3,3,2]&#125;)print(dframe)temp = dframe.duplicated()print(temp)temp = dframe[dframe.duplicated()]print(temp) color value 0 white 2 1 white 1 2 red 3 3 red 3 4 white 2 0 False 1 False 2 False 3 True 4 True dtype: bool color value 3 red 3 4 white 2 6.3.2 映射 129用映射替换元素12345678910frame = pd.DataFrame(&#123; 'item':['ball','mug','pen','pencil','ashtray'], 'color':['white','rosso','verde','black','yellow'],'price':[5.56,4.20,1.30,0.56,2.75]&#125;)print(frame)newcolors = &#123; 'rosso': 'red', 'verde': 'green' &#125;temp = frame.replace(newcolors)print(temp) color item price 0 white ball 5.56 1 rosso mug 4.20 2 verde pen 1.30 3 black pencil 0.56 4 yellow ashtray 2.75 color item price 0 white ball 5.56 1 red mug 4.20 2 green pen 1.30 3 black pencil 0.56 4 yellow ashtray 2.75 1234ser = pd.Series([1,3,np.nan,4,6,np.nan,3])print(ser)temp = ser.replace(np.nan,0)print(temp) 0 1.0 1 3.0 2 NaN 3 4.0 4 6.0 5 NaN 6 3.0 dtype: float64 0 1.0 1 3.0 2 0.0 3 4.0 4 6.0 5 0.0 6 3.0 dtype: float64 用映射添加元素1234567891011121314frame = pd.DataFrame(&#123; 'item':['ball','mug','pen','pencil','ashtray'], 'color':['white','red','green','black','yellow']&#125;)print(frame)price = &#123; 'ball' : 5.56, 'mug' : 4.20, 'bottle' : 1.30, 'scissors' : 3.41, 'pen' : 1.30, 'pencil' : 0.56, 'ashtray' : 2.75 &#125;frame['price'] = frame['item'].map(price)print(frame) color item 0 white ball 1 red mug 2 green pen 3 black pencil 4 yellow ashtray color item price 0 white ball 5.56 1 red mug 4.20 2 green pen 1.30 3 black pencil 0.56 4 yellow ashtray 2.75 重命名轴索引12345678reindex = &#123; 0: 'first', 1: 'second', 2: 'third', 3: 'fourth', 4: 'fifth'&#125;temp = frame.rename(reindex)print(temp) color item price first white ball 5.56 second red mug 4.20 third green pen 1.30 fourth black pencil 0.56 fifth yellow ashtray 2.75 12345recolumn = &#123; 'item':'object', 'price': 'value'&#125;temp = frame.rename(index=reindex, columns=recolumn)print(temp) color object value first white ball 5.56 second red mug 4.20 third green pen 1.30 fourth black pencil 0.56 fifth yellow ashtray 2.75 12temp = frame.rename(index=&#123;1:'first'&#125;, columns=&#123;'item':'object'&#125;)print(temp) color object price 0 white ball 5.56 first red mug 4.20 2 green pen 1.30 3 black pencil 0.56 4 yellow ashtray 2.75 6.4 离散化和面元划分 1321234results = [12,34,67,55,28,90,99,12,3,56,74,44,87,23,49,89,87]bins = [0,25,50,75,100]cat = pd.cut(results, bins)cat [(0, 25], (25, 50], (50, 75], (50, 75], (25, 50], ..., (75, 100], (0, 25], (25, 50], (75, 100], (75, 100]] Length: 17 Categories (4, interval[int64]): [(0, 25] &lt; (25, 50] &lt; (50, 75] &lt; (75, 100]] 1cat.labels D:\ProgramData\Anaconda3_32\lib\site-packages\ipykernel_launcher.py:1: FutureWarning: &apos;labels&apos; is deprecated. Use &apos;codes&apos; instead &quot;&quot;&quot;Entry point for launching an IPython kernel. array([0, 1, 2, 2, 1, 3, 3, 0, 0, 2, 2, 1, 3, 0, 1, 3, 3], dtype=int8) 1pd.value_counts(cat) (75, 100] 5 (50, 75] 4 (25, 50] 4 (0, 25] 4 dtype: int64 12bin_names = ['unlikely','less likely','likely','highly likely']pd.cut(results, bins, labels=bin_names) [unlikely, less likely, likely, likely, less likely, ..., highly likely, unlikely, less likely, highly likely, highly likely] Length: 17 Categories (4, object): [unlikely &lt; less likely &lt; likely &lt; highly likely] 1pd.cut(results, 5) [(2.904, 22.2], (22.2, 41.4], (60.6, 79.8], (41.4, 60.6], (22.2, 41.4], ..., (79.8, 99.0], (22.2, 41.4], (41.4, 60.6], (79.8, 99.0], (79.8, 99.0]] Length: 17 Categories (5, interval[float64]): [(2.904, 22.2] &lt; (22.2, 41.4] &lt; (41.4, 60.6] &lt; (60.6, 79.8] &lt; (79.8, 99.0]] 12quintiles = pd.qcut(results, 5)quintiles [(2.999, 24.0], (24.0, 46.0], (62.6, 87.0], (46.0, 62.6], (24.0, 46.0], ..., (62.6, 87.0], (2.999, 24.0], (46.0, 62.6], (87.0, 99.0], (62.6, 87.0]] Length: 17 Categories (5, interval[float64]): [(2.999, 24.0] &lt; (24.0, 46.0] &lt; (46.0, 62.6] &lt; (62.6, 87.0] &lt; (87.0, 99.0]] 1pd.value_counts(quintiles) (62.6, 87.0] 4 (2.999, 24.0] 4 (87.0, 99.0] 3 (46.0, 62.6] 3 (24.0, 46.0] 3 dtype: int64 异常值检测和过滤123randframe = pd.DataFrame(np.random.randn(1000,3))temp = randframe.describe()print(temp) 0 1 2 count 1000.000000 1000.000000 1000.000000 mean -0.017081 0.009233 -0.016035 std 0.983899 0.986440 0.961825 min -3.834283 -3.725847 -2.810249 25% -0.651448 -0.645679 -0.674606 50% -0.031185 0.004074 -0.006893 75% 0.633531 0.721898 0.669395 max 3.006011 3.018671 3.290535 1randframe.std() 0 0.983899 1 0.986440 2 0.961825 dtype: float64 12temp = randframe[(np.abs(randframe) &gt; (3*randframe.std())).any(1)]print(temp) 0 1 2 66 -1.552807 1.813374 3.141080 169 -1.154864 -3.725847 -0.647544 226 -3.411732 1.907356 -0.004208 426 3.006011 0.554358 0.687883 457 -1.282513 -1.312958 3.290535 465 -3.834283 -0.310886 1.280224 748 2.977327 -0.937580 0.361383 764 -0.000591 3.018671 -1.180475 6.5 排序 13612nframe = pd.DataFrame(np.arange(25).reshape(5,5))print(nframe) 0 1 2 3 4 0 0 1 2 3 4 1 5 6 7 8 9 2 10 11 12 13 14 3 15 16 17 18 19 4 20 21 22 23 24 12new_order = np.random.permutation(5)print(new_order) [4 2 1 3 0] 12temp = nframe.take(new_order)print(temp) 0 1 2 3 4 4 20 21 22 23 24 2 10 11 12 13 14 1 5 6 7 8 9 3 15 16 17 18 19 0 0 1 2 3 4 123new_order = [3,4,2]temp = nframe.take(new_order)print(temp) 0 1 2 3 4 3 15 16 17 18 19 4 20 21 22 23 24 2 10 11 12 13 14 随机取样12sample = np.random.randint(0, len(nframe), size=3)sample array([3, 3, 3]) 12temp = nframe.take(sample)print(temp) 0 1 2 3 4 3 15 16 17 18 19 3 15 16 17 18 19 3 15 16 17 18 19 6.6 字符串处理 1376.6.1 内置的字符串处理方法 13712text = '16 Bolton Avenue , Boston'text.split(',') [&apos;16 Bolton Avenue &apos;, &apos; Boston&apos;] 12tokens = [s.strip() for s in text.split(',')]tokens [&apos;16 Bolton Avenue&apos;, &apos;Boston&apos;] 123address, city = [s.strip() for s in text.split(',')]print(address)print(city) 16 Bolton Avenue Boston 1address + ',' + city &apos;16 Bolton Avenue,Boston&apos; 12strings = ['A+','A','A-','B','BB','BBB','C+']';'.join(strings) &apos;A+;A;A-;B;BB;BBB;C+&apos; 1'Boston' in text True 1text.index('Boston') 19 1text.find('Boston') 19 1text.index('New York') --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-113-e44f5210d36c&gt; in &lt;module&gt;() ----&gt; 1 text.index(&apos;New York&apos;) ValueError: substring not found 1text.count('e') 2 1text.count('Avenue') 1 1text.replace('Avenue','Street') &apos;16 Bolton Street , Boston&apos; 1text.replace('1','') &apos;6 Bolton Avenue , Boston&apos; 6.6.2 正则表达式 139123import retext = "This is an\t odd \n text!"re.split('\s+', text) [&apos;This&apos;, &apos;is&apos;, &apos;an&apos;, &apos;odd&apos;, &apos;text!&apos;] 12regex = re.compile('\s+')regex.split(text) [&apos;This&apos;, &apos;is&apos;, &apos;an&apos;, &apos;odd&apos;, &apos;text!&apos;] 12text = 'This is my address: 16 Bolton Avenue, Boston're.findall('A\w+',text) [&apos;Avenue&apos;] 1re.findall('[A,a]\w+',text) [&apos;address&apos;, &apos;Avenue&apos;] 1re.search('[A,a]\w+',text) &lt;_sre.SRE_Match object; span=(11, 18), match=&apos;address&apos;&gt; 12search = re.search('[A,a]\w+',text)search.start() 11 1search.end() 18 1text[search.start():search.end()] &apos;address&apos; 1re.match('[A,a]\w+',text) 1re.match('T\w+',text) &lt;_sre.SRE_Match object; span=(0, 4), match=&apos;This&apos;&gt; 12match = re.match('T\w+',text)text[match.start():match.end()] &apos;This&apos; 6.7 数据聚合 1406.7.1 GroupBy 141 6.7.2 实例 14112345frame = pd.DataFrame(&#123; 'color': ['white','red','green','red','green'], 'object': ['pen','pencil','pencil','ashtray','pen'], 'price1' : [5.56,4.20,1.30,0.56,2.75], 'price2' : [4.75,4.12,1.60,0.75,3.15]&#125;)print(frame) color object price1 price2 0 white pen 5.56 4.75 1 red pencil 4.20 4.12 2 green pencil 1.30 1.60 3 red ashtray 0.56 0.75 4 green pen 2.75 3.15 12group = frame['price1'].groupby(frame['color'])group &lt;pandas.core.groupby.SeriesGroupBy object at 0x06923E30&gt; 1group.groups {&apos;green&apos;: Int64Index([2, 4], dtype=&apos;int64&apos;), &apos;red&apos;: Int64Index([1, 3], dtype=&apos;int64&apos;), &apos;white&apos;: Int64Index([0], dtype=&apos;int64&apos;)} 1group.mean() color green 2.025 red 2.380 white 5.560 Name: price1, dtype: float64 1group.sum() color green 4.05 red 4.76 white 5.56 Name: price1, dtype: float64 12ggroup = frame['price1'].groupby([frame['color'],frame['object']])ggroup.groups {(&apos;green&apos;, &apos;pen&apos;): Int64Index([4], dtype=&apos;int64&apos;), (&apos;green&apos;, &apos;pencil&apos;): Int64Index([2], dtype=&apos;int64&apos;), (&apos;red&apos;, &apos;ashtray&apos;): Int64Index([3], dtype=&apos;int64&apos;), (&apos;red&apos;, &apos;pencil&apos;): Int64Index([1], dtype=&apos;int64&apos;), (&apos;white&apos;, &apos;pen&apos;): Int64Index([0], dtype=&apos;int64&apos;)} 1ggroup.sum() color object green pen 2.75 pencil 1.30 red ashtray 0.56 pencil 4.20 white pen 5.56 Name: price1, dtype: float64 6.7.3 等级分组 14212temp = frame[['price1','price2']].groupby(frame['color']).mean()print(temp) price1 price2 color green 2.025 2.375 red 2.380 2.435 white 5.560 4.750 12temp = frame.groupby(frame['color']).mean()print(temp) price1 price2 color green 2.025 2.375 red 2.380 2.435 white 5.560 4.750 6.8 组迭代 143123for name, group in frame.groupby('color'): print(name) print(group) green color object price1 price2 2 green pencil 1.30 1.60 4 green pen 2.75 3.15 red color object price1 price2 1 red pencil 4.20 4.12 3 red ashtray 0.56 0.75 white color object price1 price2 0 white pen 5.56 4.75 6.8.1 链式转换 14412result1 = frame['price1'].groupby(frame['color']).mean()type(result1) pandas.core.series.Series 12result2 = frame.groupby(frame['color']).mean()type(result2) pandas.core.frame.DataFrame 1frame['price1'].groupby(frame['color']).mean() color green 2.025 red 2.380 white 5.560 Name: price1, dtype: float64 1frame.groupby(frame['color'])['price1'].mean() color green 2.025 red 2.380 white 5.560 Name: price1, dtype: float64 1(frame.groupby(frame['color']).mean())['price1'] color green 2.025 red 2.380 white 5.560 Name: price1, dtype: float64 12means = frame.groupby('color').mean().add_prefix('mean_')print(means) mean_price1 mean_price2 color green 2.025 2.375 red 2.380 2.435 white 5.560 4.750 6.8.2 分组函数 14512group = frame.groupby('color')group['price1'].quantile(0.6) color green 2.170 red 2.744 white 5.560 Name: price1, dtype: float64 12def myrange(series): return series.max() - series.min() 1group['price1'].agg(myrange) color green 1.45 red 3.64 white 0.00 Name: price1, dtype: float64 12temp = group.agg(myrange)print(temp) price1 price2 color green 1.45 1.55 red 3.64 3.37 white 0.00 0.00 12temp = group['price1'].agg(['mean','std',myrange])print(temp) mean std myrange color green 2.025 1.025305 1.45 red 2.380 2.573869 3.64 white 5.560 NaN 0.00 6.9 高级数据聚合 1451234frame = pd.DataFrame(&#123; 'color':['white','red','green','red','green'], 'price1':[5.56,4.20,1.30,0.56,2.75], 'price2':[4.75,4.12,1.60,0.75,3.15]&#125;)print(frame) color price1 price2 0 white 5.56 4.75 1 red 4.20 4.12 2 green 1.30 1.60 3 red 0.56 0.75 4 green 2.75 3.15 12sums = frame.groupby('color').sum().add_prefix('tot_')print(sums) tot_price1 tot_price2 color green 4.05 4.75 red 4.76 4.87 white 5.56 4.75 12temp = pd.merge(frame,sums,left_on='color',right_index=True)print(temp) color price1 price2 tot_price1 tot_price2 0 white 5.56 4.75 5.56 4.75 1 red 4.20 4.12 4.76 4.87 3 red 0.56 0.75 4.76 4.87 2 green 1.30 1.60 4.05 4.75 4 green 2.75 3.15 4.05 4.75 12temp = frame.groupby('color').transform(np.sum).add_prefix('tot_')print(temp) tot_price1 tot_price2 0 5.56 4.75 1 4.76 4.87 2 4.05 4.75 3 4.76 4.87 4 4.05 4.75 12345frame = pd.DataFrame( &#123; 'color':['white','black','white','white','black','black'], 'status':['up','up','down','down','down','up'], 'value1':[12.33,14.55,22.34,27.84,23.40,18.33], 'value2':[11.23,31.80,29.99,31.18,18.25,22.44]&#125;)print(frame) color status value1 value2 0 white up 12.33 11.23 1 black up 14.55 31.80 2 white down 22.34 29.99 3 white down 27.84 31.18 4 black down 23.40 18.25 5 black up 18.33 22.44 12temp = frame.groupby(['color','status']).apply( lambda x: x.max())print(temp) color status value1 value2 color status black down black down 23.40 18.25 up black up 18.33 31.80 white down white down 27.84 31.18 up white up 12.33 11.23 12temp = frame.rename(index=reindex, columns=recolumn)print(temp) color status value1 value2 first white up 12.33 11.23 second black up 14.55 31.80 third white down 22.34 29.99 fourth white down 27.84 31.18 fifth black down 23.40 18.25 5 black up 18.33 22.44 12temp = pd.date_range('1/1/2015', periods=10, freq= 'H')print(temp) DatetimeIndex([&apos;2015-01-01 00:00:00&apos;, &apos;2015-01-01 01:00:00&apos;, &apos;2015-01-01 02:00:00&apos;, &apos;2015-01-01 03:00:00&apos;, &apos;2015-01-01 04:00:00&apos;, &apos;2015-01-01 05:00:00&apos;, &apos;2015-01-01 06:00:00&apos;, &apos;2015-01-01 07:00:00&apos;, &apos;2015-01-01 08:00:00&apos;, &apos;2015-01-01 09:00:00&apos;], dtype=&apos;datetime64[ns]&apos;, freq=&apos;H&apos;) 12timeseries = pd.Series(np.random.rand(10), index=temp)timeseries 2015-01-01 00:00:00 0.463135 2015-01-01 01:00:00 0.170738 2015-01-01 02:00:00 0.542155 2015-01-01 03:00:00 0.536056 2015-01-01 04:00:00 0.606624 2015-01-01 05:00:00 0.011034 2015-01-01 06:00:00 0.277493 2015-01-01 07:00:00 0.301076 2015-01-01 08:00:00 0.170235 2015-01-01 09:00:00 0.165120 Freq: H, dtype: float64 123timetable = pd.DataFrame( &#123;'date': temp, 'value1' : np.random.rand(10), 'value2' : np.random.rand(10)&#125;)print(timetable) date value1 value2 0 2015-01-01 00:00:00 0.783525 0.025861 1 2015-01-01 01:00:00 0.829443 0.642484 2 2015-01-01 02:00:00 0.260990 0.350753 3 2015-01-01 03:00:00 0.699793 0.118472 4 2015-01-01 04:00:00 0.349411 0.228708 5 2015-01-01 05:00:00 0.382496 0.902575 6 2015-01-01 06:00:00 0.896227 0.934669 7 2015-01-01 07:00:00 0.829987 0.941199 8 2015-01-01 08:00:00 0.479027 0.203317 9 2015-01-01 09:00:00 0.132429 0.102593 12timetable['cat'] = ['up','down','left','left','up','up','down','right','right','up']print(timetable) date value1 value2 cat 0 2015-01-01 00:00:00 0.783525 0.025861 up 1 2015-01-01 01:00:00 0.829443 0.642484 down 2 2015-01-01 02:00:00 0.260990 0.350753 left 3 2015-01-01 03:00:00 0.699793 0.118472 left 4 2015-01-01 04:00:00 0.349411 0.228708 up 5 2015-01-01 05:00:00 0.382496 0.902575 up 6 2015-01-01 06:00:00 0.896227 0.934669 down 7 2015-01-01 07:00:00 0.829987 0.941199 right 8 2015-01-01 08:00:00 0.479027 0.203317 right 9 2015-01-01 09:00:00 0.132429 0.102593 up 6.10 小结 148]]></content>
      <tags>
        <tag>pandas</tag>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-zip函数使用]]></title>
    <url>%2F2018%2F04%2F12%2Fpython-zip%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[zip((1,2,3),(10,20,30),(100,200,300))[(1, 10, 100), (2, 20, 200), (3, 30, 300)] [sum(x) for x in zip((1,2,3),(10,20,30),(100,200,300))][111, 222, 333]To do this with an arbitrarily large set of tuples: myTuples = [(1,2,3), (10,20,30), (100,200,300)][sum(x) for x in zip(*myTuples)][111, 222, 333]sidenote: in python3, note that zip returns a lazy iterable, which you can always explicitly turn into a list like any other kind of iterable: list(zip(…))]]></content>
      <tags>
        <tag>python</tag>
        <tag>zip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL数据库基本操作]]></title>
    <url>%2F2018%2F04%2F12%2FPostgreSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[postgresql学习站点 创建用户 12345sudo -s -u postgrespsqlpostgres# CREATE USER xxxx1 WITH PASSWORD &apos;xxxx&apos;;postgres# CREATE DATABASE xxxx2;postgres# GRANT ALL PRIVILEGES ON DATABASE xxxx2 to xxxx1; 修改密码 1alter user postgres with password &apos;foobar&apos;; 创建数据库 12345createdb--encoding=UTF8 --owner=foo --template=template_postgis -Ufoo 参数： --encoding=UTF8 设置数据库的字符集 --owner=foo 设置数据库的所有者 --tmplate=template_postgis 设置建库的模板，该模板支持空间数据操作 --Ufoo 用foo用户身份建立数据库]]></content>
      <tags>
        <tag>PostgreSQL - 数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-mysql-python2和3的差异]]></title>
    <url>%2F2018%2F04%2F12%2Fpython-mysql-python2%E5%92%8C3%E7%9A%84%E5%B7%AE%E5%BC%82%2F</url>
    <content type="text"><![CDATA[运行12from sqlalchemy import create_engineengine = create_engine(&apos;mysql+mysqldb://scott:tiger@localhost/foo&apos;) 提示：No module named MySQLdb 对于python2和python3安装的软件包不一样1234pip install mysql-python (mix os/ python 2)pip install mysqlclient (mix os/ python 3)apt-get install python-mysqldb (Linux Ubuntu, ...)]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>python</tag>
        <tag>sqlalchemy</tag>
        <tag>MySQLdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第5章-pandas数据读写]]></title>
    <url>%2F2018%2F04%2F12%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%AB%A0-pandas%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[第5章 pandas：数据读写 915.1 I/O API 工具 915.2 CSV和文本文件 925.3 读取CSV或文本文件中的数据 921from pandas import * myCSV_01.csvwhite,red,blue,green,animal1,5,2,3,cat2,7,8,5,dog3,3,6,7,horse2,2,8,3,duck4,4,2,1,mouse 12csvframe = read_csv('myCSV_01.csv')print(csvframe) white red blue green animal 0 1 5 2 3 cat 1 2 7 8 5 dog 2 3 3 6 7 horse 3 2 2 8 3 duck 4 4 4 2 1 mouse white,red,blue,green,animal1,5,2,3,cat2,7,8,5,dog3,3,6,7,horse2,2,8,3,duck4,4,2,1,mouse 12temp = read_table('ch05_01.csv',sep=',')print(temp) white red blue green animal 0 1 5 2 3 cat 1 2 7 8 5 dog 2 3 3 6 7 horse 3 2 2 8 3 duck 4 4 4 2 1 mouse 1,5,2,3,cat2,7,8,5,dog3,3,6,7,horse2,2,8,3,duck4,4,2,1,mouse 12temp = read_csv('ch05_02.csv')print(temp) 1 5 2 3 cat 0 2 7 8 5 dog 1 3 3 6 7 horse 2 2 2 8 3 duck 3 4 4 2 1 mouse 12temp = read_csv('ch05_02.csv', header=None)print(temp) 0 1 2 3 4 0 1 5 2 3 cat 1 2 7 8 5 dog 2 3 3 6 7 horse 3 2 2 8 3 duck 4 4 4 2 1 mouse 12temp = read_csv('ch05_02.csv', names=['white','red','blue','green','animal'])print(temp) white red blue green animal 0 1 5 2 3 cat 1 2 7 8 5 dog 2 3 3 6 7 horse 3 2 2 8 3 duck 4 4 4 2 1 mouse color,status,item1,item2,item3black,up,3,4,6black,down,2,6,7white,up,5,5,5white,down,3,3,2white,left,1,2,1red,up,2,2,2red,down,1,1,4 12temp = read_csv('ch05_03.csv', index_col=['color','status'])print(temp) item1 item2 item3 color status black up 3 4 6 down 2 6 7 white up 5 5 5 down 3 3 2 left 1 2 1 red up 2 2 2 down 1 1 4 5.3.1 用RegExp解析TXT文件 94white red blue green1 5 2 32 7 8 5 3 3 6 7 12temp = read_table('ch05_04.txt',sep='\s+')print(temp) white red blue green 0 1 5 2 3 1 2 7 8 5 2 3 3 6 7 ch05_05.txt000END123AAA122001END124BBB321002END125CCC333 12temp = read_table('ch05_05.txt',sep='\D+',header=None)print(temp) 0 1 2 0 0 123 122 1 1 124 321 2 2 125 333 D:\ProgramData\Anaconda3_32\lib\site-packages\ipykernel_launcher.py:1: ParserWarning: Falling back to the &apos;python&apos; engine because the &apos;c&apos; engine does not support regex separators (separators &gt; 1 char and different from &apos;\s+&apos; are interpreted as regex); you can avoid this warning by specifying engine=&apos;python&apos;. &quot;&quot;&quot;Entry point for launching an IPython kernel. Table 5-1. Metacharacters. single character, except newline\d digit\D non-digit character\s whitespace character\S non-whitespace character\n new line character\t tab character\uxxxx unicode character specified by the hexadecimal number xxxxch05_06.txt ########### LOG FILE ############This file has been generated by automatic systemwhite,red,blue,green,animal12-Feb-2015: Counting of animals inside the house1,5,2,3,cat2,7,8,5,dog13-Feb-2015: Counting of animals outside the house3,3,6,7,horse2,2,8,3,duck4,4,2,1,mouse 12temp = read_table('ch05_06.txt',sep=',',skiprows=[0,1,3,6])print(temp) white red blue green animal 0 1 5 2 3 cat 1 2 7 8 5 dog 2 3 3 6 7 horse 3 2 2 8 3 duck 4 4 4 2 1 mouse 5.3.2 从TXT文件读取部分数据 961,5,2,3,cat2,7,8,5,dog3,3,6,7,horse2,2,8,3,duck4,4,2,1,mouse 12temp = read_csv('ch05_02.csv',skiprows=[2],nrows=3,header=None)print(temp) 0 1 2 3 4 0 1 5 2 3 cat 1 2 7 8 5 dog 2 2 2 8 3 duck white,red,blue,green,animal1,5,2,3,cat2,7,8,5,dog3,3,6,7,horse2,2,8,3,duck4,4,2,1,mouse 12345678out = Series()i = 0pieces = read_csv('ch05_01.csv',chunksize=3)for piece in pieces: print(piece) out.set_value(i,piece['white'].sum()) i = i + 1print(out) white red blue green animal 0 1 5 2 3 cat 1 2 7 8 5 dog 2 3 3 6 7 horse white red blue green animal 3 2 2 8 3 duck 4 4 4 2 1 mouse 0 6 1 6 dtype: int64 5.3.3 往CSV文件写入数据 97123import numpy as npframe2 = DataFrame(np.arange(16).reshape((4,4)), columns = ['ball','pen','pencil','paper'])print(frame2) ball pen pencil paper 0 0 1 2 3 1 4 5 6 7 2 8 9 10 11 3 12 13 14 15 1frame2.to_csv('ch05_07.csv') 1frame2.to_csv('ch05_07b.csv', index=False, header=False) 12frame3 = read_csv('ch05_08.csv')print(frame3) Unnamed: 0 ball mug paper pen pencil 0 blue 6.0 NaN NaN 6.0 NaN 1 green NaN NaN NaN NaN NaN 2 red NaN NaN NaN NaN NaN 3 white 20.0 NaN NaN 20.0 NaN 4 yellow 19.0 NaN NaN 19.0 NaN 1frame3.to_csv('ch05_08.csv') 1frame3.to_csv('ch05_09.csv', na_rep ='NaN') ch05_08.csv,ball,mug,paper,pen,pencilblue,6.0,,,6.0,green,,,,,red,,,,,white,20.0,,,20.0,yellow,19.0,,,19.0,ch05_09.csv,ball,mug,paper,pen,pencilblue,6.0,NaN,NaN,6.0,NaNgreen,NaN,NaN,NaN,NaN,NaNred,NaN,NaN,NaN,NaN,NaNwhite,20.0,NaN,NaN,20.0,NaNyellow,19.0,NaN,NaN,19.0,NaN 5.4 读写HTML文件 985.4.1 写入数据到HTML文件 9912import pandas as pdframe = pd.DataFrame(np.arange(4).reshape(2,2)) 1print(frame.to_html()) &lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt; &lt;thead&gt; &lt;tr style=&quot;text-align: right;&quot;&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;0&lt;/th&gt; &lt;th&gt;1&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;0&lt;/th&gt; &lt;td&gt;0&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;1&lt;/th&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 1234frame = pd.DataFrame( np.random.random((4,4)), index = ['white','black','red','blue'], columns = ['up','down','right','left'])print(frame) up down right left white 0.821537 0.070376 0.131624 0.718632 black 0.723164 0.409424 0.554343 0.361086 red 0.671485 0.993762 0.316291 0.999724 blue 0.834104 0.565786 0.922212 0.166467 12345678910s = ['&lt;HTML&gt;']s.append('&lt;HEAD&gt;&lt;TITLE&gt;My DataFrame&lt;/TITLE&gt;&lt;/HEAD&gt;')s.append('&lt;BODY&gt;')s.append(frame.to_html())s.append('&lt;/BODY&gt;&lt;/HTML&gt;')html = ''.join(s)html_file = open('myFrame.html','w')html_file.write(html)html_file.close() 打开html 5.4.2 从HTML文件读取数据 10012web_frames = pd.read_html('myFrame.html')print(web_frames[0]) Unnamed: 0 up down right left 0 white 0.821537 0.070376 0.131624 0.718632 1 black 0.723164 0.409424 0.554343 0.361086 2 red 0.671485 0.993762 0.316291 0.999724 3 blue 0.834104 0.565786 0.922212 0.166467 12ranking = pd.read_html('http://www.meccanismocomplesso.org/en/meccanismo-complesso-sito-2/classifica-punteggio/')print(ranking[0]) # Nome Exp Livelli 0 1 Fabio Nelli 17521 NaN 1 2 admin 9029 NaN 2 3 BrunoOrsini 2124 NaN 3 4 Berserker 700 NaN 4 5 Dnocioni 543 NaN 5 6 albertosallusti 409 NaN 6 7 Jon 231 NaN 7 8 Mr.Y 180 NaN 8 9 michele sisinni 157 NaN 9 10 Selina 136 NaN 10 11 Massimo 127 NaN 11 12 Beniamino Feula 122 NaN 12 13 stefano gustin 121 NaN 13 14 Maurizio Andreoli 111 NaN 14 15 Pietro Baima 108 NaN 15 16 Cecilia Lalatta Costerbosa 108 NaN 16 17 Leonardo Zampi 108 NaN 17 18 Davide Aloisi 106 NaN 18 19 gildalombardi 105 NaN 19 20 Telerobotlabs 104 NaN 20 21 Marco Contigiani 101 NaN 21 22 berillio 58 NaN 22 23 ron 55 NaN 23 24 Titanic4wd 43 NaN 24 25 deg 40 NaN 25 26 al45 40 NaN 26 27 il_mix 38 NaN 27 28 AndreaC 35 NaN 28 29 Sergio fly 32 NaN 29 30 bigazzi 32 NaN .. ... ... ... ... 220 221 pozi 3 NaN 221 222 mattia 3 NaN 222 223 mauro.menegazzi 3 NaN 223 224 cico89 3 NaN 224 225 eta38 3 NaN 225 226 Chinje Chang 3 NaN 226 227 fraschettin 2 NaN 227 228 Rocco 2 NaN 228 229 Dimitri 2 NaN 229 230 Arturo 2 NaN 230 231 Paolo Indennidate 2 NaN 231 232 fabioroberto 2 NaN 232 233 ycomyca 2 NaN 233 234 bdb 2 NaN 234 235 paolotirispetta 2 NaN 235 236 Roberto72 2 NaN 236 237 Christian76 2 NaN 237 238 paolos46 2 NaN 238 239 Giolat90 2 NaN 239 240 giampyypmaig 1 NaN 240 241 Marco Corbetta 1 NaN 241 242 softeng 1 NaN 242 243 strechum 1 NaN 243 244 an6991 1 NaN 244 245 plato 1 NaN 245 246 CarloAlberto98 1 NaN 246 247 cris 1 NaN 247 248 emilibassi 1 NaN 248 249 mehrbano 1 NaN 249 250 NIKITA PANCHAL 1 NaN [250 rows x 4 columns] 5.5 从XML读取数据 101books.xml&lt;?xml version=”1.0”?&gt; 272103_1_EnRoss, Mark XML Cookbook Computer 23.56 2014-22-01 272103_1_EnBracket, Barbara XML for Dummies Computer 35.95 2014-12-16 1from lxml import objectify 12xml = objectify.parse('books.xml')xml &lt;lxml.etree._ElementTree at 0xc5d74b8&gt; 123root = xml.getroot()print(root.Book.Author)print(root.Book.PublishDate) 272103_1_EnRoss, Mark 2014-22-01 1root.getchildren() [&lt;Element Book at 0xc761378&gt;, &lt;Element Book at 0xc761d78&gt;] 1[child.tag for child in root.Book.getchildren()] [&apos;Author&apos;, &apos;Title&apos;, &apos;Genre&apos;, &apos;Price&apos;, &apos;PublishDate&apos;] 1[child.text for child in root.Book.getchildren()] [&apos;272103_1_EnRoss, Mark&apos;, &apos;XML Cookbook&apos;, &apos;Computer&apos;, &apos;23.56&apos;, &apos;2014-22-01&apos;] 1234567891011121314151617def etree2df(root): column_names = [] for i in range(0,len(root.getchildren()[0].getchildren())): column_names.append(root.getchildren()[0].getchildren()[i].tag) xml_frame = pd.DataFrame(columns=column_names) for j in range(0, len(root.getchildren())): obj = root.getchildren()[j].getchildren() texts = [] for k in range(0, len(column_names)): texts.append(obj[k].text) row = dict(zip(column_names, texts)) row_s = pd.Series(row) row_s.name = j xml_frame = xml_frame.append(row_s) return xml_frame 12temp = etree2df(root)print(temp) Author Title Genre Price PublishDate 0 272103_1_EnRoss, Mark XML Cookbook Computer 23.56 2014-22-01 1 272103_1_EnBracket, Barbara XML for Dummies Computer 35.95 2014-12-16 5.6 读写Microsoft Excel文件 10312temp = pd.read_excel('data.xls')print(temp) white red green black a 12 23 17 18 b 22 16 19 18 c 14 23 22 21 12temp = pd.read_excel('data.xls','Sheet2')print(temp) yellow purple blue orange A 11 16 44 22 B 20 22 23 44 C 30 31 37 32 12temp = pd.read_excel('data.xls',1)print(temp) yellow purple blue orange A 11 16 44 22 B 20 22 23 44 C 30 31 37 32 1234frame = pd.DataFrame(np.random.random((4,4)), index = ['exp1','exp2','exp3','exp4'], columns = ['Jan2015','Fab2015','Mar2015','Apr2005'])print(frame) Jan2015 Fab2015 Mar2015 Apr2005 exp1 0.610508 0.434578 0.019900 0.099366 exp2 0.306480 0.961355 0.073820 0.742758 exp3 0.232366 0.197025 0.312307 0.697120 exp4 0.374647 0.123761 0.521675 0.641097 1frame.to_excel('data2.xlsx') 5.7 JSON数据 10512345frame = pd.DataFrame(np.arange(16).reshape(4,4), index=['white','black','red','blue'], columns=['up','down','right','left'])print(frame)frame.to_json('frame.json') up down right left white 0 1 2 3 black 4 5 6 7 red 8 9 10 11 blue 12 13 14 15 {“up”:{“white”:0,”black”:4,”red”:8,”blue”:12},”down”:{“white”:1,”black”:5,”red”:9,”blue”:13},”right”:{“white”:2,”black”:6,”red”:10,”blue”:14},”left”:{“white”:3,”black”:7,”red”:11,”blue”:15}} 12temp = pd.read_json('frame.json')print(temp) down left right up black 5 7 6 4 blue 13 15 14 12 red 9 11 10 8 white 1 3 2 0 123456789from pandas.io.json import json_normalizefile = open('books.json','r')text = file.read()text = json.loads(text)temp = json_normalize(text,'books')print(temp)print()temp = json_normalize(text,'books',['writer','nationality'])print(temp) price title 0 23.56 XML Cookbook 1 50.70 Python Fundamentals 2 12.30 The NumPy library 3 28.60 Java Enterprise 4 31.35 HTML5 5 28.00 Python for Dummies price title writer nationality 0 23.56 XML Cookbook Mark Ross USA 1 50.70 Python Fundamentals Mark Ross USA 2 12.30 The NumPy library Mark Ross USA 3 28.60 Java Enterprise Barbara Bracket UK 4 31.35 HTML5 Barbara Bracket UK 5 28.00 Python for Dummies Barbara Bracket UK D:\ProgramData\Anaconda3_32\lib\site-packages\ipykernel_launcher.py:4: FutureWarning: pandas.json is deprecated and will be removed in a future version. You can access loads as pandas.io.json.loads after removing the cwd from sys.path. 5.8 HDF5格式 1071234567from pandas.io.pytables import HDFStoreframe = pd.DataFrame(np.arange(16).reshape(4,4), index=['white','black','red','blue'], columns=['up','down','right','left'])store = HDFStore('mydata.h5')store['obj1'] = framestore &lt;class &apos;pandas.io.pytables.HDFStore&apos;&gt; File path: mydata.h5 /obj1 frame (shape-&gt;[4,4]) 12temp = store['obj1']print(temp) up down right left white 0 1 2 3 black 4 5 6 7 red 8 9 10 11 blue 12 13 14 15 5.9 pickle——Python对象序列化 1085.9.1 用pickle实现Python对象序列化 1091234import pickle as pickledata = &#123; 'color': ['white','red'], 'value': [5, 7]&#125;pickled_data = pickle.dumps(data)print(pickled_data) b&apos;\x80\x03}q\x00(X\x05\x00\x00\x00colorq\x01]q\x02(X\x05\x00\x00\x00whiteq\x03X\x03\x00\x00\x00redq\x04eX\x05\x00\x00\x00valueq\x05]q\x06(K\x05K\x07eu.&apos; 12nframe = pickle.loads(pickled_data)nframe {&apos;color&apos;: [&apos;white&apos;, &apos;red&apos;], &apos;value&apos;: [5, 7]} 5.9.2 用pandas实现对象序列化 10912345frame = pd.DataFrame(np.arange(16).reshape(4,4), index = ['up','down','left','right'])frame.to_pickle('frame.pkl')temp = pd.read_pickle('frame.pkl')print(temp) 0 1 2 3 up 0 1 2 3 down 4 5 6 7 left 8 9 10 11 right 12 13 14 15 5.10 对接数据库 1101234567891011from sqlalchemy import create_engine#For PostgreSQLengine = create_engine('postgresql://scott:tiger@localhost:5432/mydatabase')#For MySQLengine = create_engine('mysql+mysqldb://scott:tiger@localhost/foo')#For Oracleengine = create_engine('oracle://scott:tiger@127.0.0.1:1521/sidname')#For MSSQLengine = create_engine('mssql+pyodbc://mydsn')#For SQLiteengine = create_engine('sqlite:///foo.db') 上面代码运行可能会出现错误，根据运行结果，缺少什么使用pip安装什么就可以了。 5.10.1 SQLite3数据读写 111123frame = pd.DataFrame( np.arange(20).reshape(4,5), columns=['white','red','blue','black','green'])print(frame) white red blue black green 0 0 1 2 3 4 1 5 6 7 8 9 2 10 11 12 13 14 3 15 16 17 18 19 12345engine = create_engine('sqlite:///foo.db')frame.to_sql('colors',engine)temp = pd.read_sql('colors',engine)print(temp) index white red blue black green 0 0 0 1 2 3 4 1 1 5 6 7 8 9 2 2 10 11 12 13 14 3 3 15 16 17 18 19 1234567891011121314151617import sqlite3query = """CREATE TABLE test(a VARCHAR(20), b VARCHAR(20),c REAL, d INTEGER);"""con = sqlite3.connect(':memory:')con.execute(query)con.commit()data = [('white','up',1,3), ('black','down',2,8), ('green','up',4,4), ('red','down',5,5)]stmt = "INSERT INTO test VALUES(?,?,?,?)"con.executemany(stmt, data)con.commit() 1234cursor = con.execute('select * from test')print(cursor)rows = cursor.fetchall()rows &lt;sqlite3.Cursor object at 0x0D591820&gt; [(&apos;white&apos;, &apos;up&apos;, 1.0, 3), (&apos;black&apos;, &apos;down&apos;, 2.0, 8), (&apos;green&apos;, &apos;up&apos;, 4.0, 4), (&apos;red&apos;, &apos;down&apos;, 5.0, 5)] 1cursor.description ((&apos;a&apos;, None, None, None, None, None, None), (&apos;b&apos;, None, None, None, None, None, None), (&apos;c&apos;, None, None, None, None, None, None), (&apos;d&apos;, None, None, None, None, None, None)) 12temp = pd.DataFrame(rows, columns=['a','b','c','d'])print(temp) a b c d 0 white up 1.0 3 1 black down 2.0 8 2 green up 4.0 4 3 red down 5.0 5 5.10.2 PostgreSQL数据读写 1121engine = create_engine('postgresql://scott:tiger@localhost:5432/mydatabase') 123456import pandas as pdimport numpy as npframe = pd.DataFrame(np.random.random((4,4)), index=['exp1','exp2','exp3','exp4'], columns=['feb','mar','apr','may']);frame.to_sql('dataframe',engine) postgres=# SELECT * FROM DATAFRAME; 12temp = pd.read_sql_table('dataframe',engine)print(temp) index feb mar apr may 0 exp1 0.406820 0.964683 0.181662 0.660217 1 exp2 0.573869 0.940819 0.426104 0.484574 2 exp3 0.649881 0.059990 0.616504 0.681356 3 exp4 0.061554 0.733131 0.998748 0.127283 12temp = pd.read_sql_query('SELECT index,apr,may FROM DATAFRAME WHERE apr &gt; 0.5',engine)print(temp) index apr may 0 exp3 0.616504 0.681356 1 exp4 0.998748 0.127283 5.11 NoSQL数据库MongoDB数据读写 1141234import pymongoclient = pymongo.MongoClient('localhost',27017)db = client.mydatabasedb Database(MongoClient(host=[&apos;localhost:27017&apos;], document_class=dict, tz_aware=False, connect=True), &apos;mydatabase&apos;) 1client['mydatabase'] Database(MongoClient(host=[&apos;localhost:27017&apos;], document_class=dict, tz_aware=False, connect=True), &apos;mydatabase&apos;) 12collection = db.mycollectiondb['mycollection'] Collection(Database(MongoClient(host=[&apos;localhost:27017&apos;], document_class=dict, tz_aware=False, connect=True), &apos;mydatabase&apos;), &apos;mycollection&apos;) 1collection Collection(Database(MongoClient(host=[&apos;localhost:27017&apos;], document_class=dict, tz_aware=False, connect=True), &apos;mydatabase&apos;), &apos;mycollection&apos;) 123frame = pd.DataFrame( np.arange(20).reshape(4,5), columns=['white','red','blue','black','green'])print(frame) white red blue black green 0 0 1 2 3 4 1 5 6 7 8 9 2 10 11 12 13 14 3 15 16 17 18 19 123import jsonrecord = json.loads(frame.T.to_json()).values()record dict_values([{&apos;white&apos;: 0, &apos;red&apos;: 1, &apos;blue&apos;: 2, &apos;black&apos;: 3, &apos;green&apos;: 4}, {&apos;white&apos;: 5, &apos;red&apos;: 6, &apos;blue&apos;: 7, &apos;black&apos;: 8, &apos;green&apos;: 9}, {&apos;white&apos;: 10, &apos;red&apos;: 11, &apos;blue&apos;: 12, &apos;black&apos;: 13, &apos;green&apos;: 14}, {&apos;white&apos;: 15, &apos;red&apos;: 16, &apos;blue&apos;: 17, &apos;black&apos;: 18, &apos;green&apos;: 19}]) 1collection.mydocument.insert(record) 123456cursor = collection['mydocument'].find()print(type(cursor))dataframe = (list(cursor))data = pd.DataFrame(dataframe)del data['_id']print(data) &lt;class &apos;pymongo.cursor.Cursor&apos;&gt; black blue green red white 0 3 2 4 1 0 1 8 7 9 6 5 2 13 12 14 11 10 3 18 17 19 16 15 5.12 小结 116]]></content>
      <tags>
        <tag>pandas</tag>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux防火墙设置]]></title>
    <url>%2F2018%2F04%2F11%2Flinux%E9%98%B2%E7%81%AB%E5%A2%99%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[UFW防火墙UFW防火墙是一个主机端的iptables类防火墙配置工具。这个工具的目的是提供给用户一个可以轻松驾驭的界面，就像包集成和动态检测开放的端口一样。 自2.4版本以后的Linux内核中， 提供了一个非常优秀的防火墙工具。这个工具可以对出入服务的网络数据进行分割、过滤、转发等等细微的控制，进而实现诸如防火墙、NAT等功能。一般来说， 我们会使用名气比较的大iptables等程序对这个防火墙的规则进行管理。iptables可以灵活的定义防火墙规则，功能非常强大。但是由此产生的副作用便是配置过于复杂。一向以简单易用著称Ubuntu在它的发行版中，附带了一个相对iptables简单很多的防火墙配置工具：ufw。ufw默认是没有启用的。也就是说， ubuntu中的端口默认都是开放的。使用如下命令启动ufw： UFW安装与使用 安装sudo apt-get install ufw 启用sudo ufw enablesudo ufw default deny运行以上两条命令后，开启了防火墙，并在系统启动时自动开启。关闭所有外部对本机的访问，但本机访问外部正常。 开启/禁用sudo ufw allow|deny [service]打开或关闭某个端口，例如：sudo ufw allow smtp 允许所有的外部IP访问本机的25/tcp (smtp)端口sudo ufw allow 22/tcp 允许所有的外部IP访问本机的22/tcp (ssh)端口sudo ufw allow 53 允许外部访问53端口(tcp/udp)sudo ufw allow from 192.168.1.100 允许此IP访问所有的本机端口sudo ufw allow proto udp 192.168.0.1 port 53 to 192.168.0.2 port 53sudo ufw deny smtp 禁止外部访问smtp服务sudo ufw delete allow smtp 删除上面建立的某条规则 查看防火墙状态sudo ufw status一般用户，只需如下设置：sudo apt-get install ufwsudo ufw enablesudo ufw default deny以上三条命令已经足够安全了，如果你需要开放某些服务，再使用sudo ufw allow开启。开启/关闭防火墙 (默认设置是’disable’)sudo ufw enable|disable转换日志状态sudo ufw logging on|off设置默认策略 (比如 “mostly open” vs “mostly closed”)sudo ufw default allow|deny许可或者屏蔽端口 (可以在“status” 中查看到服务列表)。可以用“协议：端口”的方式指定一个存在于/etc/services中的服务名称，也可以通过包的meta-data。 ‘allow’ 参数将把条目加入 /etc/ufw/maps ，而 ‘deny’ 则相反。基本语法如下：sudo ufw allow|deny [service]显示防火墙和端口的侦听状态，参见 /var/lib/ufw/maps。括号中的数字将不会被显示出来。sudo ufw statusUFW 使用范例：允许 53 端口$ sudo ufw allow 53禁用 53 端口$ sudo ufw delete allow 53允许 80 端口$ sudo ufw allow 80/tcp禁用 80 端口$ sudo ufw delete allow 80/tcp允许 smtp 端口$ sudo ufw allow smtp删除 smtp 端口的许可$ sudo ufw delete allow smtp允许某特定 IP$ sudo ufw allow from 192.168.254.254删除上面的规则$ sudo ufw delete allow from 192.168.254.254 加载sudo ufw reload ubuntu iptables设置删除原来 iptables 里面已经有的规则iptables -Fiptables -X 抛弃所有不符合三种链规则的数据包iptables -P INPUT DROPiptables -P OUTPUT DROPiptables -P FORWARD DROP 设置：本地进程 lo 的 INPUT 和 OUTPUT 链接 ； eth1的 INPUT链iptables -A INPUT -i lo -j ACCEPTiptables -A INPUT -i eth1 -m state –state ESTABLISHED,RELATED -j ACCEPTiptables -A INPUT -i eth1 -m state –state NEW,INVALID -j LOGiptables -A OUTPUT -o lo -j ACCEPT 对其他主要允许的端口的 OUTPUT设置： DNSiptables -A OUTPUT -o eth1 -p TCP –sport 1024:65535 –dport 53 -j ACCEPTiptables -A OUTPUT -o eth1 -p UDP –sport 1024:65535 –dport 53 -j ACCEPT HTTPiptables -A OUTPUT -o eth1 -p TCP –sport 1024:65535 –dport 80 -j ACCEPT HTTPSiptables -A OUTPUT -o eth1 -p TCP –sport 1024:65535 –dport 443 -j ACCEPT Email 接受 和发送iptables -A OUTPUT -o eth1 -p TCP –sport 1024:65535 –dport 110 -j ACCEPTiptables -A OUTPUT -o eth1 -p TCP –sport 1024:65535 –dport 25 -j ACCEPT FTP 数据和控制iptables -A OUTPUT -o eth1 -p TCP –sport 1024:65535 –dport 20 -j ACCEPTiptables -A OUTPUT -o eth1 -p TCP –sport 1024:65535 –dport 21 -j ACCEPT DHCPiptables -A OUTPUT -o eth1 -p TCP –sport 1024:65535 –dport 68 -j ACCEPTiptables -A OUTPUT -o eth1 -p UDP –sport 1024:65535 –dport 68 -j ACCEPT POP3S Email安全接收iptables -A OUTPUT -o eth1 -p TCP –sport 1024:65535 –dport 995 -j ACCEPT 时间同步服务器 NTPiptables -A OUTPUT -o eth1 -p TCP –sport 1024:65535 –dport 123 -j ACCEPT 拒绝 eth1 其他剩下的iptables -A OUTPUT -o eth1 –match state –state NEW,INVALID -j LOG 最后是有关于iptables存储的命令：代码:iptables-save &gt; /etc/iptables.up.rule - 存在你想存的地方 代码:iptables-restore &lt; /etc/iptables.up.rules - 调用 因为iptables 在每次机器重新启动以后，需要再次输入或者调用，为了方便操作，使用代码:sudo gedit /etc/network/interfaces 在代码:auto ath0iface ath0 inet dhcp后面加上代码:pre-up iptables-restore &lt; /etc/iptables.up.rules - 启动自动调用已存储的iptables 代码:post-down iptables-save &gt; /etc/iptables.up.rule #关机时，把当前iptables 储存]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第4章-pandas库]]></title>
    <url>%2F2018%2F04%2F11%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC4%E7%AB%A0-pandas%E5%BA%93%2F</url>
    <content type="text"><![CDATA[第4章 pandas库简介 564.1 pandas：Python数据分析库 564.2 安装 574.2.1 用Anaconda安装 574.2.2 用PyPI安装 584.2.3 在Linux系统的安装方法 584.2.4 用源代码安装 584.2.5 Windows模块仓库 594.3 测试pandas是否安装成功 594.4 开始pandas之旅 5912import pandas as pdimport numpy as np 4.5 pandas数据结构简介 604.5.1 Series对象 6012s = pd.Series([12,-4,7,9])s 0 12 1 -4 2 7 3 9 dtype: int64 12s = pd.Series([12,-4,7,9], index=['a','b','c','d'])s a 12 b -4 c 7 d 9 dtype: int64 1s.values array([12, -4, 7, 9]) 1s.index Index([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;], dtype=&apos;object&apos;) 1s[2], s['b'] (7, -4) 1s[0:2] a 12 b -4 dtype: int64 1s[['b','c']] b -4 c 7 dtype: int64 12s[1] = 0s a 12 b 0 c 7 d 9 dtype: int64 12s['b'] = 1s a 12 b 1 c 7 d 9 dtype: int64 123arr = np.array([1,2,3,4])s3 = pd.Series(arr)s3 0 1 1 2 2 3 3 4 dtype: int64 12s4 = pd.Series(s)s4 a 12 b 1 c 7 d 9 dtype: int64 12arr[2] = -2s3 0 1 1 2 2 -2 3 4 dtype: int64 1s[s &gt; 8] a 12 d 9 dtype: int64 1s / 2 a 6.0 b 0.5 c 3.5 d 4.5 dtype: float64 1np.log(s) a 2.484907 b 0.000000 c 1.945910 d 2.197225 dtype: float64 1serd = pd.Series([1,0,2,1,2,3], index=['white','white','blue','green','green','yellow']) 1serd white 1 white 0 blue 2 green 1 green 2 yellow 3 dtype: int64 1serd.unique() array([1, 0, 2, 3]) 1serd.value_counts() 2 2 1 2 3 1 0 1 dtype: int64 1serd.isin([0,3]) white False white True blue False green False green False yellow True dtype: bool 1serd[serd.isin([0,3])] white 0 yellow 3 dtype: int64 12s2 = pd.Series([5,-3,np.NaN,14])s2 0 5.0 1 -3.0 2 NaN 3 14.0 dtype: float64 1s2.isnull() 0 False 1 False 2 True 3 False dtype: bool 1s2.notnull() 0 True 1 True 2 False 3 True dtype: bool 1s2[s2.notnull()] 0 5.0 1 -3.0 3 14.0 dtype: float64 1s2[s2.isnull()] 2 NaN dtype: float64 123mydict = &#123;'red': 2000, 'blue': 1000, 'yellow': 500, 'orange': 1000&#125;myseries = pd.Series(mydict)myseries blue 1000 orange 1000 red 2000 yellow 500 dtype: int64 123colors = ['red','yellow','orange','blue','green']myseries = pd.Series(mydict, index=colors)myseries red 2000.0 yellow 500.0 orange 1000.0 blue 1000.0 green NaN dtype: float64 123mydict2 = &#123;'red':400,'yellow':1000,'black':700&#125;myseries2 = pd.Series(mydict2)myseries2 black 700 red 400 yellow 1000 dtype: int64 1myseries + myseries2 black NaN blue NaN green NaN orange NaN red 2400.0 yellow 1500.0 dtype: float64 4.5.2 DataFrame对象 6612345data = &#123;'color' : ['blue','green','yellow','red','white'],'object' : ['ball','pen','pencil','paper','mug'],'price' : [1.2,1.0,0.6,0.9,1.7]&#125;frame = pd.DataFrame(data)frame …. color object price 0 blue ball 1.2 1 green pen 1.0 2 yellow pencil 0.6 3 red paper 0.9 4 white mug 1.7 12frame2 = pd.DataFrame(data, columns=['object','price'])frame2 ….. object price 0 ball 1.2 1 pen 1.0 2 pencil 0.6 3 paper 0.9 4 mug 1.7 12frame2 = pd.DataFrame(data, index=['one','two','three','four','five'])frame2 …. color object price one blue ball 1.2 two green pen 1.0 three yellow pencil 0.6 four red paper 0.9 five white mug 1.7 1234frame3 = pd.DataFrame(np.arange(16).reshape((4,4)), index=['red','blue','yellow','white'], columns=['ball','pen','pencil','paper'])frame3 ….. ball pen pencil paper red 0 1 2 3 blue 4 5 6 7 yellow 8 9 10 11 white 12 13 14 15 1frame.columns Index([&apos;color&apos;, &apos;object&apos;, &apos;price&apos;], dtype=&apos;object&apos;) 1frame.index RangeIndex(start=0, stop=5, step=1) 1frame.values array([[&apos;blue&apos;, &apos;ball&apos;, 1.2], [&apos;green&apos;, &apos;pen&apos;, 1.0], [&apos;yellow&apos;, &apos;pencil&apos;, 0.6], [&apos;red&apos;, &apos;paper&apos;, 0.9], [&apos;white&apos;, &apos;mug&apos;, 1.7]], dtype=object) 1frame['price'] 0 1.2 1 1.0 2 0.6 3 0.9 4 1.7 Name: price, dtype: float64 1frame.price 0 1.2 1 1.0 2 0.6 3 0.9 4 1.7 Name: price, dtype: float64 1frame.ix[2] color yellow object pencil price 0.6 Name: 2, dtype: object 1frame.ix[[2,4]] 1frame[0:1] color object price 0 blue ball 1.2 1frame[1:3] color object price 1 green pen 1.02 yellow pencil 0.6 1frame['object'][3] &apos;paper&apos; 123frame.index.name = 'id'; frame.columns.name = 'item'frame item color object priceid0 blue ball 1.21 green pen 1.02 yellow pencil 0.63 red paper 0.94 white mug 1.7 12frame['new'] = 12frame item color object price newid0 blue ball 1.2 121 green pen 1.0 122 yellow pencil 0.6 123 red paper 0.9 124 white mug 1.7 12 12frame['new'] = [3.0,1.3,2.2,0.8,1.1]frame item color object price newid0 blue ball 1.2 3.01 green pen 1.0 1.32 yellow pencil 0.6 2.23 red paper 0.9 0.84 white mug 1.7 1.1 12ser = pd.Series(np.arange(5))ser 0 0 1 1 2 2 3 3 4 4 dtype: int64 12frame['new'] = serframe item color object price newid0 blue ball 1.2 01 green pen 1.0 12 yellow pencil 0.6 23 red paper 0.9 34 white mug 1.7 4 12frame['price'][2] = 3.3frame /home/vivoadmin/anaconda3/lib/python3.6/site-packages/ipykernel_launcher.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy &quot;&quot;&quot;Entry point for launching an IPython kernel. item color object price newid0 blue ball 1.2 01 green pen 1.0 12 yellow pencil 3.3 23 red paper 0.9 34 white mug 1.7 4 1frame.isin([1.0,'pen']) item color object price newid0 False False False False1 False True True True2 False False False False3 False False False False4 False False False False 1frame[frame.isin([1.0,'pen'])] item color object price newid0 NaN NaN NaN NaN1 NaN pen 1.0 1.02 NaN NaN NaN NaN3 NaN NaN NaN NaN4 NaN NaN NaN NaN 12del frame['new']frame item color object priceid0 blue ball 1.21 green pen 1.02 yellow pencil 3.33 red paper 0.94 white mug 1.7 1frame[frame &lt; 1] item color object priceid0 blue ball NaN1 green pen NaN2 yellow pencil NaN3 red paper 0.94 white mug NaN 12345nestdict = &#123;'red':&#123;2012: 22, 2013: 33&#125;, 'white':&#123;2011: 13, 2012: 22, 2013: 16&#125;, 'blue': &#123;2011: 17, 2012: 27, 2013: 18&#125;&#125;frame2 = pd.DataFrame(nestdict)frame2 blue red white 2011 17 NaN 132012 27 22.0 222013 18 33.0 16 1frame2.T 2011 2012 2013 blue 17.0 27.0 18.0red NaN 22.0 33.0white 13.0 22.0 16.0 4.5.3 Index对象 7212ser = pd.Series([5,0,3,8,4], index=['red','blue','yellow','white','green'])ser.index Index([&apos;red&apos;, &apos;blue&apos;, &apos;yellow&apos;, &apos;white&apos;, &apos;green&apos;], dtype=&apos;object&apos;) 1ser.idxmin(), ser.idxmax() (&apos;blue&apos;, &apos;white&apos;) 12serd = pd.Series(range(6), index=['white','white','blue','green','green','yellow'])serd white 0 white 1 blue 2 green 3 green 4 yellow 5 dtype: int64 1serd['white'] white 0 white 1 dtype: int64 1serd.index.is_unique False 1frame.index.is_unique True 4.6 索引对象的其他功能 744.6.1 更换索引 7412ser = pd.Series([2,5,7,4], index=['one','two','three','four'])ser one 2 two 5 three 7 four 4 dtype: int64 1ser.reindex(['three','four','five','one']) three 7.0 four 4.0 five NaN one 2.0 dtype: float64 12ser3 = pd.Series([1,5,6,3],index=[0,3,5,6])ser3 0 1 3 5 5 6 6 3 dtype: int64 1ser3.reindex(range(6),method='ffill') 0 1 1 1 2 1 3 5 4 5 5 6 dtype: int64 1ser3.reindex(range(6),method='bfill') 0 1 1 5 2 5 3 5 4 6 5 6 dtype: int64 item colors price new objectid0 blue 1.2 blue ball1 green 1.0 green pen2 yellow 3.3 yellow pencil3 red 0.9 red paper4 white 1.7 white mug 4.6.2 删除 7512ser = pd.Series(np.arange(4.), index=['red','blue','yellow','white'])ser red 0.0 blue 1.0 yellow 2.0 white 3.0 dtype: float64 1ser.drop('yellow') red 0.0 blue 1.0 white 3.0 dtype: float64 1ser.drop(['blue','white']) red 0.0 yellow 2.0 dtype: float64 1234frame = pd.DataFrame(np.arange(16).reshape((4,4)), index=['red','blue','yellow','white'], columns=['ball','pen','pencil','paper'])frame ball pen pencil paper red 0 1 2 3blue 4 5 6 7yellow 8 9 10 11white 12 13 14 15 1frame.drop(['blue','yellow']) ball pen pencil paperred 0 1 2 3white 12 13 14 15 1frame.drop(['pen','pencil'],axis=1) ball paper red 0 3blue 4 7yellow 8 11white 12 15 4.6.3 算术和数据对齐 7712s1 = pd.Series([3,2,5,1],['white','yellow','green','blue'])s2 = pd.Series([1,4,7,2,1],['white','yellow','black','blue','brown']) 1s1 + s2 black NaN blue 3.0 brown NaN green NaN white 4.0 yellow 6.0 dtype: float64 123456frame1 = pd.DataFrame(np.arange(16).reshape((4,4)), index=['red','blue','yellow','white'], columns=['ball','pen','pencil','paper'])frame2 = pd.DataFrame(np.arange(12).reshape((4,3)), index=['blue','green','white','yellow'], columns=['mug','pen','ball']) 1frame1 ball pen pencil paper red 0 1 2 3blue 4 5 6 7yellow 8 9 10 11white 12 13 14 15 1frame2 mug pen ball blue 0 1 2green 3 4 5white 6 7 8yellow 9 10 11 1frame1 + frame2 ball mug paper pen pencil blue 6.0 NaN NaN 6.0 NaNgreen NaN NaN NaN NaN NaNred NaN NaN NaN NaN NaNwhite 20.0 NaN NaN 20.0 NaNyellow 19.0 NaN NaN 19.0 NaN 4.7 数据结构之间的运算 784.7.1 灵活的算术运算方法 781frame1.add(frame2) ball mug paper pen pencil blue 6.0 NaN NaN 6.0 NaNgreen NaN NaN NaN NaN NaNred NaN NaN NaN NaN NaNwhite 20.0 NaN NaN 20.0 NaNyellow 19.0 NaN NaN 19.0 NaN 4.7.2 DataFrame和Series对象之间的运算 781234frame = pd.DataFrame(np.arange(16).reshape((4,4)), index=['red','blue','yellow','white'], columns=['ball','pen','pencil','paper'])frame ball pen pencil paper red 0 1 2 3blue 4 5 6 7yellow 8 9 10 11white 12 13 14 15 12ser = pd.Series(np.arange(4), index=['ball','pen','pencil','paper'])ser ball 0 pen 1 pencil 2 paper 3 dtype: int64 1frame - ser ball pen pencil paper red 0 0 0 0blue 4 4 4 4yellow 8 8 8 8white 12 12 12 12 12ser['mug'] = 9ser ball 0 pen 1 pencil 2 paper 3 mug 9 dtype: int64 1frame - ser ball mug paper pen pencil red 0 NaN 0 0 0blue 4 NaN 4 4 4yellow 8 NaN 8 8 8white 12 NaN 12 12 12 4.8 函数应用和映射 794.8.1 操作元素的函数 791234frame = pd.DataFrame(np.arange(16).reshape((4,4)), index=['red','blue','yellow','white'], columns=['ball','pen','pencil','paper'])frame ball pen pencil paper red 0 1 2 3blue 4 5 6 7yellow 8 9 10 11white 12 13 14 15 1np.sqrt(frame) ball pen pencil paper red 0.000000 1.000000 1.414214 1.732051blue 2.000000 2.236068 2.449490 2.645751yellow 2.828427 3.000000 3.162278 3.316625white 3.464102 3.605551 3.741657 3.872983 4.8.2 按行或列执行操作的函数 80123f = lambda x: x.max() - x.min()def f(x): return x.max() - x.min() 1frame.apply(f) ball 12 pen 12 pencil 12 paper 12 dtype: int64 1frame.apply(f, axis=1) red 3 blue 3 yellow 3 white 3 dtype: int64 12def f(x): return pd.Series([x.min(), x.max()], index=['min','max']) 1frame.apply(f) ball pen pencil paper min 0 1 2 3max 12 13 14 15 4.8.3 统计函数 811frame.sum() ball 24 pen 28 pencil 32 paper 36 dtype: int64 1frame.mean() ball 6.0 pen 7.0 pencil 8.0 paper 9.0 dtype: float64 1frame.describe() ball pen pencil paper count 4.000000 4.000000 4.000000 4.000000mean 6.000000 7.000000 8.000000 9.000000std 5.163978 5.163978 5.163978 5.163978min 0.000000 1.000000 2.000000 3.00000025% 3.000000 4.000000 5.000000 6.00000050% 6.000000 7.000000 8.000000 9.00000075% 9.000000 10.000000 11.000000 12.000000max 12.000000 13.000000 14.000000 15.000000 4.9 排序和排位次 8112ser = pd.Series([5,0,3,8,4], index=['red','blue','yellow','white','green'])ser red 5 blue 0 yellow 3 white 8 green 4 dtype: int64 1ser.sort_index() blue 0 green 4 red 5 white 8 yellow 3 dtype: int64 1ser.sort_index(ascending=False) yellow 3 white 8 red 5 green 4 blue 0 dtype: int64 1234frame = pd.DataFrame(np.arange(16).reshape((4,4)), index=['red','blue','yellow','white'], columns=['ball','pen','pencil','paper'])frame ball pen pencil paper red 0 1 2 3blue 4 5 6 7yellow 8 9 10 11white 12 13 14 15 1frame.sort_index() ball pen pencil paper blue 4 5 6 7red 0 1 2 3white 12 13 14 15yellow 8 9 10 11 1frame.sort_index(axis=1) ball paper pen pencil red 0 3 1 2blue 4 7 5 6yellow 8 11 9 10white 12 15 13 14 1ser.order() --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-131-bb828ac4164f&gt; in &lt;module&gt;() ----&gt; 1 ser.order() ~/anaconda3/lib/python3.6/site-packages/pandas/core/generic.py in __getattr__(self, name) 3612 if name in self._info_axis: 3613 return self[name] -&gt; 3614 return object.__getattribute__(self, name) 3615 3616 def __setattr__(self, name, value): AttributeError: &apos;Series&apos; object has no attribute &apos;order&apos; 1frame.sort_index(by='pen') /home/vivoadmin/anaconda3/lib/python3.6/site-packages/ipykernel_launcher.py:1: FutureWarning: by argument to sort_index is deprecated, please use .sort_values(by=...) &quot;&quot;&quot;Entry point for launching an IPython kernel. ball pen pencil paper red 0 1 2 3blue 4 5 6 7yellow 8 9 10 11white 12 13 14 15 1frame.sort_index(by=['pen','pencil']) /home/vivoadmin/anaconda3/lib/python3.6/site-packages/ipykernel_launcher.py:1: FutureWarning: by argument to sort_index is deprecated, please use .sort_values(by=...) &quot;&quot;&quot;Entry point for launching an IPython kernel. ball pen pencil paperred 0 1 2 3blue 4 5 6 7yellow 8 9 10 11white 12 13 14 15 1ser.rank() red 4.0 blue 1.0 yellow 2.0 white 5.0 green 3.0 dtype: float64 1ser.rank(method='first') red 4.0 blue 1.0 yellow 2.0 white 5.0 green 3.0 dtype: float64 1ser.rank(ascending=False) red 2.0 blue 5.0 yellow 4.0 white 1.0 green 3.0 dtype: float64 4.10 相关性和协方差 8412seq2 = pd.Series([3,4,3,4,5,4,3,2],['2006','2007','2008','2009','2010','2011','2012','2013'])seq = pd.Series([1,2,3,4,4,3,2,1],['2006','2007','2008','2009','2010','2011','2012','2013']) 1seq.corr(seq2) 0.7745966692414835 1seq.cov(seq2) 0.8571428571428571 1234frame2 = pd.DataFrame([[1,4,3,6],[4,5,6,1],[3,3,1,5],[4,1,6,4]], index=['red','blue','yellow','white'], columns=['ball','pen','pencil','paper'])frame2 ball pen pencil paper red 1 4 3 6blue 4 5 6 1yellow 3 3 1 5white 4 1 6 4 1frame2.corr() ball pen pencil paper ball 1.000000 -0.276026 0.577350 -0.763763pen -0.276026 1.000000 -0.079682 -0.361403pencil 0.577350 -0.079682 1.000000 -0.692935paper -0.763763 -0.361403 -0.692935 1.000000 1frame2.cov() ball pen pencil paper ball 2.000000 -0.666667 2.000000 -2.333333pen -0.666667 2.916667 -0.333333 -1.333333pencil 2.000000 -0.333333 6.000000 -3.666667paper -2.333333 -1.333333 -3.666667 4.666667 1ser red 5 blue 0 yellow 3 white 8 green 4 dtype: int64 1frame2.corrwith(ser) ball -0.140028 pen -0.869657 pencil 0.080845 paper 0.595854 dtype: float64 1frame2.corrwith(frame) ball 0.730297 pen -0.831522 pencil 0.210819 paper -0.119523 dtype: float64 4.11 NaN数据 854.11.1 为元素赋NaN值 8512ser = pd.Series([0,1,2,np.NaN,9], index=['red','blue','yellow','white','green'])ser red 0.0 blue 1.0 yellow 2.0 white NaN green 9.0 dtype: float64 12ser['white'] = Noneser red 0.0 blue 1.0 yellow 2.0 white NaN green 9.0 dtype: float64 4.11.2 过滤NaN 861ser.dropna() red 0.0 blue 1.0 yellow 2.0 green 9.0 dtype: float64 1ser[ser.notnull()] red 0.0 blue 1.0 yellow 2.0 green 9.0 dtype: float64 1234frame3 = pd.DataFrame([[6,np.nan,6],[np.nan,np.nan,np.nan],[2,np.nan,5]], index = ['blue','green','red'], columns = ['ball','mug','pen'])frame3 ball mug pen blue 6.0 NaN 6.0green NaN NaN NaNred 2.0 NaN 5.0 1frame3.dropna() ball mug pen 1frame3.dropna(how='all') ball mug pen blue 6.0 NaN 6.0red 2.0 NaN 5.0 4.11.3 为NaN元素填充其他值 861frame3.fillna(0) ball mug pen blue 6.0 0.0 6.0green 0.0 0.0 0.0red 2.0 0.0 5.0 1frame3.fillna(&#123;'ball':1,'mug':0,'pen':99&#125;) ball mug pen blue 6.0 0.0 6.0green 1.0 0.0 99.0red 2.0 0.0 5.0 4.12 等级索引和分级 871234mser = pd.Series(np.random.rand(8), index=[['white','white','white','blue','blue','red','red','red'], ['up','down','right','up','down','up','down','left']])mser white up 0.941438 down 0.165728 right 0.492898 blue up 0.902410 down 0.879385 red up 0.646074 down 0.210103 left 0.476333 dtype: float64 1mser.index MultiIndex(levels=[[&apos;blue&apos;, &apos;red&apos;, &apos;white&apos;], [&apos;down&apos;, &apos;left&apos;, &apos;right&apos;, &apos;up&apos;]], labels=[[2, 2, 2, 0, 0, 1, 1, 1], [3, 0, 2, 3, 0, 3, 0, 1]]) 1mser['white'] up 0.941438 down 0.165728 right 0.492898 dtype: float64 1mser[:,'up'] white 0.941438 blue 0.902410 red 0.646074 dtype: float64 1mser['white','up'] 0.9414384939430696 1mser.unstack() down left right up blue 0.879385 NaN NaN 0.902410red 0.210103 0.476333 NaN 0.646074white 0.165728 NaN 0.492898 0.941438 1frame ball pen pencil paper red 0 1 2 3blue 4 5 6 7yellow 8 9 10 11white 12 13 14 15 1frame.stack() red ball 0 pen 1 pencil 2 paper 3 blue ball 4 pen 5 pencil 6 paper 7 yellow ball 8 pen 9 pencil 10 paper 11 white ball 12 pen 13 pencil 14 paper 15 dtype: int64 1234mframe = pd.DataFrame(np.random.randn(16).reshape(4,4), index=[['white','white','red','red'], ['up','down','up','down']], columns=[['pen','pen','paper','paper'],[1,2,1,2]])mframe pen paper 1 2 1 2white up 0.992202 -1.037634 -0.083882 -0.028204down -1.758579 1.832742 -0.167739 0.174567red up 0.983876 2.306897 -1.003258 -0.591767down 1.398166 0.054964 -1.705692 -0.375007 4.12.1 重新调整顺序和为层级排序 89123mframe.columns.names = ['objects','id']mframe.index.names = ['colors','status']mframe objects pen paper id 1 2 1 2colors statuswhite up 0.992202 -1.037634 -0.083882 -0.028204down -1.758579 1.832742 -0.167739 0.174567red up 0.983876 2.306897 -1.003258 -0.591767down 1.398166 0.054964 -1.705692 -0.375007 1mframe.swaplevel('colors','status') objects pen paper id 1 2 1 2status colorsup white 0.992202 -1.037634 -0.083882 -0.028204down white -1.758579 1.832742 -0.167739 0.174567up red 0.983876 2.306897 -1.003258 -0.591767down red 1.398166 0.054964 -1.705692 -0.375007 1mframe.sortlevel('colors') /home/vivoadmin/anaconda3/lib/python3.6/site-packages/ipykernel_launcher.py:1: FutureWarning: sortlevel is deprecated, use sort_index(level= ...) &quot;&quot;&quot;Entry point for launching an IPython kernel. objects pen paper id 1 2 1 2colors statusred down 1.398166 0.054964 -1.705692 -0.375007up 0.983876 2.306897 -1.003258 -0.591767white down -1.758579 1.832742 -0.167739 0.174567up 0.992202 -1.037634 -0.083882 -0.028204 4.12.2 按层级统计数据 891mframe.sum(level='colors') objects pen paperid 1 2 1 2colorswhite -0.766377 0.795107 -0.251622 0.146363red 2.382042 2.361861 -2.708950 -0.966774 1mframe.sum(level='id', axis=1) id 1 2 colors statuswhite up 0.908320 -1.065838down -1.926319 2.007309red up -0.019382 1.715131down -0.307526 -0.320044 4.13 小结 90]]></content>
      <tags>
        <tag>pandas</tag>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第3章-numpy库]]></title>
    <url>%2F2018%2F04%2F11%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC3%E7%AB%A0-numpy%E5%BA%93%2F</url>
    <content type="text"><![CDATA[第3章 NumPy库 323.1 NumPy简史 323.2 NumPy安装 323.3 ndarray：NumPy库的心脏 331import numpy as np 1a = np.array([1, 2, 3]) 1a array([1, 2, 3]) 1type(a), a.dtype, a.ndim, a.size, a.shape, a.itemsize (numpy.ndarray, dtype(&apos;int64&apos;), 1, 3, (3,), 8) 1b = np.array([[1.3, 2.4],[0.3, 4.1]]) 1b array([[1.3, 2.4], [0.3, 4.1]]) 1type(b), b.dtype, b.ndim, b.size, b.shape, b.itemsize (numpy.ndarray, dtype(&apos;float64&apos;), 2, 4, (2, 2), 8) 1b.data, type(b.data) (&lt;memory at 0x7f3df8064558&gt;, memoryview) 3.3.1 创建数组 341c = np.array([[1, 2, 3],[4, 5, 6]]) 1c array([[1, 2, 3], [4, 5, 6]]) 1d = np.array(((1, 2, 3),(4, 5, 6))) 1d array([[1, 2, 3], [4, 5, 6]]) 1e = np.array([(1, 2, 3), [4, 5, 6], (7, 8, 9)]) 1e array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 3.3.2 数据类型 341g = np.array([['a', 'b'],['c', 'd']]) 1g array([[&apos;a&apos;, &apos;b&apos;], [&apos;c&apos;, &apos;d&apos;]], dtype=&apos;&lt;U1&apos;) 1g.dtype, g.dtype.name (dtype(&apos;&lt;U1&apos;), &apos;str32&apos;) 3.3.3 dtype选项 351f = np.array([[1, 2, 3],[4, 5, 6]], dtype=complex) 1f array([[1.+0.j, 2.+0.j, 3.+0.j], [4.+0.j, 5.+0.j, 6.+0.j]]) 3.3.4 自带的数组创建方法 361np.zeros((3, 3)) array([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]]) 1np.ones((3, 3)) array([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]) 1np.arange(0, 10) array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 1np.arange(4, 10) array([4, 5, 6, 7, 8, 9]) 1np.arange(0, 12, 3) array([0, 3, 6, 9]) 1np.arange(0, 6, 0.6) array([0. , 0.6, 1.2, 1.8, 2.4, 3. , 3.6, 4.2, 4.8, 5.4]) 1np.arange(0, 12).reshape(3, 4) array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]) 1np.linspace(0,10,5) array([ 0. , 2.5, 5. , 7.5, 10. ]) 1np.random.random(3) array([0.71423775, 0.62229946, 0.97150108]) 1np.random.random((3,3)) array([[0.95155686, 0.10092046, 0.35220847], [0.96635154, 0.33764827, 0.44879963], [0.40573132, 0.97260092, 0.30105595]]) 3.4 基本操作 373.4.1 算术运算符 371a = np.arange(4) 1a array([0, 1, 2, 3]) 1a+4 array([4, 5, 6, 7]) 1a*2 array([0, 2, 4, 6]) 1b = np.arange(4,8) 1b array([4, 5, 6, 7]) 1a + b array([ 4, 6, 8, 10]) 1a - b array([-4, -4, -4, -4]) 1a * b array([ 0, 5, 12, 21]) 1a * np.sin(b) array([-0. , -0.95892427, -0.558831 , 1.9709598 ]) 1a * np.sqrt(b) array([0. , 2.23606798, 4.89897949, 7.93725393]) 1A = np.arange(0, 9).reshape(3, 3) 1A array([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) 1B = np.ones((3, 3)) 1B array([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]) 1A * B array([[0., 1., 2.], [3., 4., 5.], [6., 7., 8.]]) 3.4.2 矩阵积 381np.dot(A,B) array([[ 3., 3., 3.], [12., 12., 12.], [21., 21., 21.]]) 1A.dot(B) array([[ 3., 3., 3.], [12., 12., 12.], [21., 21., 21.]]) 1np.dot(B,A) array([[ 9., 12., 15.], [ 9., 12., 15.], [ 9., 12., 15.]]) 3.4.3 自增和自减运算符 391a = np.arange(4) 1a array([0, 1, 2, 3]) 1a += 1 1a array([1, 2, 3, 4]) 1a -= 1 1a array([0, 1, 2, 3]) 1a += 4 1a array([4, 5, 6, 7]) 1a *= 2 1a array([ 8, 10, 12, 14]) 3.4.4 通用函数 401a = np.arange(1, 5) 1a array([1, 2, 3, 4]) 1np.sqrt(a) array([1. , 1.41421356, 1.73205081, 2. ]) 1np.log(a) array([0. , 0.69314718, 1.09861229, 1.38629436]) 1np.sin(a) array([ 0.84147098, 0.90929743, 0.14112001, -0.7568025 ]) 3.4.5 聚合函数 401a = np.array([3.3, 4.5, 1.2, 5.7, 0.3]) 1a array([3.3, 4.5, 1.2, 5.7, 0.3]) 1a.sum() 15.0 1a.min() 0.3 1a.max() 5.7 1a.mean() 3.0 1a.std() 2.0079840636817816 3.5 索引机制、切片和迭代方法 413.5.1 索引机制 411a = np.arange(10, 16) 1a array([10, 11, 12, 13, 14, 15]) 1a[4], a[-1], a[-6] (14, 15, 10) 1a[[1, 3, 4]] array([11, 13, 14]) 1A = np.arange(10, 19).reshape((3, 3)) 1A array([[10, 11, 12], [13, 14, 15], [16, 17, 18]]) 1A[1, 2] 15 3.5.2 切片操作 421a = np.arange(10, 16) 1a array([10, 11, 12, 13, 14, 15]) 1a[1:5] array([11, 12, 13, 14]) 1a[1:5:2] array([11, 13]) 1a[::2] array([10, 12, 14]) 1a[:5:2] array([10, 12, 14]) 1a[:5:] array([10, 11, 12, 13, 14]) 1A = np.arange(10, 19).reshape((3, 3)) 1A array([[10, 11, 12], [13, 14, 15], [16, 17, 18]]) 1A[0,:] array([10, 11, 12]) 1A[:,0] array([10, 13, 16]) 1A[0:2, 0:2] array([[10, 11], [13, 14]]) 1A[[0,2], 0:2] array([[10, 11], [16, 17]]) 3.5.3 数组迭代 4312for i in a: print(i) 10 11 12 13 14 15 12for row in A: print(row) [10 11 12] [13 14 15] [16 17 18] 12for item in A.flat: print(item) 10 11 12 13 14 15 16 17 18 1np.apply_along_axis(np.mean, axis=0, arr=A) array([13., 14., 15.]) 1np.apply_along_axis(np.mean, axis=1, arr=A) array([11., 14., 17.]) 12def foo(x): return x/2 1np.apply_along_axis(foo, axis=1, arr=A) array([[5. , 5.5, 6. ], [6.5, 7. , 7.5], [8. , 8.5, 9. ]]) 1np.apply_along_axis(foo, axis=0, arr=A) array([[5. , 5.5, 6. ], [6.5, 7. , 7.5], [8. , 8.5, 9. ]]) 3.6 条件和布尔数组 451A = np.random.random((4, 4)) 1A array([[0.92122811, 0.55810739, 0.16604965, 0.98756188], [0.89990698, 0.45441885, 0.85233406, 0.32187075], [0.58032546, 0.01878004, 0.91573127, 0.63144651], [0.52282585, 0.57666091, 0.97865543, 0.54473589]]) 1A &lt; 0.5 array([[False, False, True, False], [False, True, False, True], [False, True, False, False], [False, False, False, False]]) 1A[A &lt; 0.5] array([0.04869294, 0.07669828, 0.26766679, 0.04023488, 0.10839496, 0.45508628, 0.48141253]) 3.7 形状变换 451a = np.random.random(12) 1a array([0.93015885, 0.01067508, 0.43200938, 0.24035759, 0.01564892, 0.09507133, 0.70143444, 0.46887118, 0.85551184, 0.61722919, 0.94688342, 0.92520351]) 1A = a.reshape(3, 4) 1A array([[0.93015885, 0.01067508, 0.43200938, 0.24035759], [0.01564892, 0.09507133, 0.70143444, 0.46887118], [0.85551184, 0.61722919, 0.94688342, 0.92520351]]) 1a.shape = (3, 4) 1a array([[0.93015885, 0.01067508, 0.43200938, 0.24035759], [0.01564892, 0.09507133, 0.70143444, 0.46887118], [0.85551184, 0.61722919, 0.94688342, 0.92520351]]) 1a.ravel() array([0.93015885, 0.01067508, 0.43200938, 0.24035759, 0.01564892, 0.09507133, 0.70143444, 0.46887118, 0.85551184, 0.61722919, 0.94688342, 0.92520351]) 1a.shape = (12) 1a array([0.93015885, 0.01067508, 0.43200938, 0.24035759, 0.01564892, 0.09507133, 0.70143444, 0.46887118, 0.85551184, 0.61722919, 0.94688342, 0.92520351]) 1A.transpose() array([[0.93015885, 0.01564892, 0.85551184], [0.01067508, 0.09507133, 0.61722919], [0.43200938, 0.70143444, 0.94688342], [0.24035759, 0.46887118, 0.92520351]]) 3.8 数组操作 463.8.1 连接数组 4612A = np.ones((3, 3))B = np.zeros((3, 3)) 1np.vstack((A, B)) array([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [0., 0., 0.], [0., 0., 0.], [0., 0., 0.]]) 1np.hstack((A,B)) array([[1., 1., 1., 0., 0., 0.], [1., 1., 1., 0., 0., 0.], [1., 1., 1., 0., 0., 0.]]) 123a = np.array([0, 1, 2])b = np.array([3, 4, 5])c = np.array([6, 7, 8]) 1np.column_stack((a, b, c)) array([[0, 3, 6], [1, 4, 7], [2, 5, 8]]) 1np.row_stack((a, b, c)) array([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) 3.8.2 数组切分 471A = np.arange(16).reshape((4, 4)) 1A array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) 1[B,C] = np.hsplit(A, 2) 1B array([[ 0, 1], [ 4, 5], [ 8, 9], [12, 13]]) 1C array([[ 2, 3], [ 6, 7], [10, 11], [14, 15]]) 1[B,C] = np.vsplit(A, 2) 1B array([[0, 1, 2, 3], [4, 5, 6, 7]]) 1C array([[ 8, 9, 10, 11], [12, 13, 14, 15]]) 1[A1,A2,A3] = np.split(A,[1,3],axis=1) 1A1 array([[ 0], [ 4], [ 8], [12]]) 1A2 array([[ 1, 2], [ 5, 6], [ 9, 10], [13, 14]]) 1A3 array([[ 3], [ 7], [11], [15]]) 1[A1,A2,A3] = np.split(A,[1,3],axis=0) 1A1 array([[0, 1, 2, 3]]) 1A2 array([[ 4, 5, 6, 7], [ 8, 9, 10, 11]]) 1A3 array([[12, 13, 14, 15]]) 3.9 常用概念 493.9.1 对象的副本或视图 4912a = np.array([1, 2, 3, 4])b = a 1b array([1, 2, 3, 4]) 1a[2] = 0 1b array([1, 2, 0, 4]) 1c = a[0:2] 1c array([1, 2]) 1a[0] = 0 1c array([0, 2]) 1a = np.array([1, 2, 3, 4]) 1c = a.copy() 1c array([1, 2, 3, 4]) 1a[0] = 0 1c array([1, 2, 3, 4]) 3.9.2 向量化 503.9.3 广播机制 501A = np.arange(16).reshape(4, 4) 1b = np.arange(4) 1A array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]]) 1b array([0, 1, 2, 3]) 1A + b array([[ 0, 2, 4, 6], [ 4, 6, 8, 10], [ 8, 10, 12, 14], [12, 14, 16, 18]]) 1m = np.arange(6).reshape(3, 1, 2) 1n = np.arange(6).reshape(3, 2, 1) 1m array([[[0, 1]], [[2, 3]], [[4, 5]]]) 1n array([[[0], [1]], [[2], [3]], [[4], [5]]]) 1m + n array([[[ 0, 1], [ 1, 2]], [[ 4, 5], [ 5, 6]], [[ 8, 9], [ 9, 10]]]) 3.10 结构化数组 521structured = np.array([(1, 'First', 0.5, 1+2j),(2, 'Second', 1.3, 2-2j), (3, 'Third', 0.8, 1+3j)],dtype=('i2, a6, f4, c8')) 1structured array([(1, b&apos;First&apos;, 0.5, 1.+2.j), (2, b&apos;Second&apos;, 1.3, 2.-2.j), (3, b&apos;Third&apos;, 0.8, 1.+3.j)], dtype=[(&apos;f0&apos;, &apos;&lt;i2&apos;), (&apos;f1&apos;, &apos;S6&apos;), (&apos;f2&apos;, &apos;&lt;f4&apos;), (&apos;f3&apos;, &apos;&lt;c8&apos;)]) 1structured = np.array([(1, 'First', 0.5, 1+2j),(2, 'Second', 1.3,2-2j),(3, 'Third', 0.8, 1+3j)],dtype=('int16, a6, float32, complex64')) 1structured array([(1, b&apos;First&apos;, 0.5, 1.+2.j), (2, b&apos;Second&apos;, 1.3, 2.-2.j), (3, b&apos;Third&apos;, 0.8, 1.+3.j)], dtype=[(&apos;f0&apos;, &apos;&lt;i2&apos;), (&apos;f1&apos;, &apos;S6&apos;), (&apos;f2&apos;, &apos;&lt;f4&apos;), (&apos;f3&apos;, &apos;&lt;c8&apos;)]) 1structured[1] (2, b&apos;Second&apos;, 1.3, 2.-2.j) 1structured['f1'] array([b&apos;First&apos;, b&apos;Second&apos;, b&apos;Third&apos;], dtype=&apos;|S6&apos;) 1structured = np.array([(1,'First',0.5,1+2j),(2,'Second',1.3,2-2j),(3,'Third',0.8,1+3j)],dtype=[('id','i2'),('position','a6'),('value','f4'),('complex','c8')]) 1structured array([(1, b&apos;First&apos;, 0.5, 1.+2.j), (2, b&apos;Second&apos;, 1.3, 2.-2.j), (3, b&apos;Third&apos;, 0.8, 1.+3.j)], dtype=[(&apos;id&apos;, &apos;&lt;i2&apos;), (&apos;position&apos;, &apos;S6&apos;), (&apos;value&apos;, &apos;&lt;f4&apos;), (&apos;complex&apos;, &apos;&lt;c8&apos;)]) 1structured.dtype.names = ('id','order','value','complex') 1structured['order'] array([b&apos;First&apos;, b&apos;Second&apos;, b&apos;Third&apos;], dtype=&apos;|S6&apos;) 3.11 数组数据文件的读写 533.11.1 二进制文件的读写 541data = np.random.random(16).reshape(4,4) 1data array([[0.87899377, 0.11342252, 0.6682891 , 0.90832539], [0.33643193, 0.49913359, 0.46395367, 0.38503354], [0.30343769, 0.74571053, 0.16758969, 0.11507577], [0.00213888, 0.12661618, 0.71188585, 0.95622255]]) 1np.save('saved_data',data) 1loaded_data = np.load('saved_data.npy') 1loaded_data array([[0.87899377, 0.11342252, 0.6682891 , 0.90832539], [0.33643193, 0.49913359, 0.46395367, 0.38503354], [0.30343769, 0.74571053, 0.16758969, 0.11507577], [0.00213888, 0.12661618, 0.71188585, 0.95622255]]) 3.11.2 读取文件中的列表形式数据 541data = np.genfromtxt('data.csv', delimiter=',', names=True) 1data array([(1., 123., 1.4, 23.), (2., 110., 0.5, 18.), (3., 164., 2.1, 19.)], dtype=[(&apos;id&apos;, &apos;&lt;f8&apos;), (&apos;value1&apos;, &apos;&lt;f8&apos;), (&apos;value2&apos;, &apos;&lt;f8&apos;), (&apos;value3&apos;, &apos;&lt;f8&apos;)]) 1data2 = np.genfromtxt('data2.csv', delimiter=',', names=True) 1data2 array([(1., 123., 1.4, 23.), (2., 110., nan, 18.), (3., nan, 2.1, 19.)], dtype=[(&apos;id&apos;, &apos;&lt;f8&apos;), (&apos;value1&apos;, &apos;&lt;f8&apos;), (&apos;value2&apos;, &apos;&lt;f8&apos;), (&apos;value3&apos;, &apos;&lt;f8&apos;)]) 3.12 小结 55]]></content>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第2章-ptyhon世界简介]]></title>
    <url>%2F2018%2F04%2F11%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC2%E7%AB%A0-ptyhon%E4%B8%96%E7%95%8C%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[这一章主要是回顾一些python的知识点。 第2章 Python世界简介 122.1 Python——编程语言 122.2 Python——解释器 132.2.1 Cython 142.2.2 Jython 142.2.3 PyPy 142.3 Python 2和Python 3 142.4 安装Python 152.5 Python发行版 152.5.1 Anaconda 152.5.2 Enthought Canopy 162.5.3 Python(x,y) 172.6 使用Python 172.6.1 Python shell 172.6.2 运行完整的Python程序 172.6.3 使用IDE编写代码 182.6.4 跟Python交互 182.7 编写Python代码 182.7.1 数学运算 1812345678910111213&gt;&gt;&gt; 1 + 23&gt;&gt;&gt; (1.045 * 3)/40.78375&gt;&gt;&gt; 4 ** 216&gt;&gt;&gt; ((4 + 5j) * (2 + 3j))(-7+22j)&gt;&gt;&gt; 4 &lt; (2*3)True&gt;&gt;&gt; a = 12 * 3.4&gt;&gt;&gt; a40.8 2.7.2 导入新的库和函数 191234567891011121314151617181920212223242526272829303132&gt;&gt;&gt; import math&gt;&gt;&gt; math.sin(a)&gt;&gt;&gt; from math import *&gt;&gt;&gt; sin(a)&gt;&gt;&gt; from math import sin&gt;&gt;&gt; dict = &#123;&apos;name&apos;:&apos;William&apos;, &apos;age&apos;:25, &apos;city&apos;:&apos;London&apos;&#125;&gt;&gt;&gt; dict[&quot;name&quot;]&apos;William&apos;&gt;&gt;&gt; for key, value in dict.items():... print(key,value)...name Williamcity Londonage 25&gt;&gt;&gt; list = [1,2,3,4]&gt;&gt;&gt; list[1, 2, 3, 4]&gt;&gt;&gt; list[2]3&gt;&gt;&gt; list[1:3][2, 3]&gt;&gt;&gt; list[-1]4&gt;&gt;&gt; items = [1,2,3,4,5]&gt;&gt;&gt; for item in items:... item + 1...23456 2.7.3 函数式编程 211234567891011121314151617181920&gt;&gt;&gt; items = [1,2,3,4,5]&gt;&gt;&gt; def inc(x): return x+1...&gt;&gt;&gt; list(map(inc,items))[2, 3, 4, 5, 6]&gt;&gt;&gt; list(map((lambda x: x+1),items))[2, 3, 4, 5, 6]filter函数只抽取函数返回结果为True的列表元素。reduce函数对列表中的而所有元素依次计算过后返回唯一结果。&gt;&gt;&gt; list(filter((lambda x: x &lt; 4), items))[1, 2, 3]&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; reduce((lambda x,y: x/y), items)0.008333333333333333&gt;&gt;&gt; S = [x**2 for x in range(5)]&gt;&gt;&gt; S[0, 1, 4, 9, 16] 2.7.4 缩进 22123456789101112131415&gt;&gt;&gt; a = 4&gt;&gt;&gt; if a &gt; 3:... if a &lt; 5:... print(&quot;I&apos;m four&quot;)... else:... print(&quot;I&apos;m a little number&quot;)...I&apos;m four&gt;&gt;&gt; if a &gt; 3:... if a &lt; 5:... print(&quot;I&apos;m four&quot;)... else:... print(&quot;I&apos;m a big number&quot;)...I&apos;m four 2.8 IPython 232.8.1 IPython shell 232.8.2 IPython Qt-Console 242.9 PyPI仓库——Python包索引 252.10 多种Python IDE 262.10.1 IDLE 262.10.2 Spyder 272.10.3 Eclipse（pyDev） 272.10.4 Sublime 282.10.5 Liclipse 292.10.6 NinjaIDE 292.10.7 Komodo IDE 292.11 SciPy 302.11.1 NumPy 302.11.2 pandas 302.11.3 matplotlib 312.12 小结 31]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开放数据源]]></title>
    <url>%2F2018%2F04%2F11%2F%E5%BC%80%E6%94%BE%E6%95%B0%E6%8D%AE%E6%BA%90%2F</url>
    <content type="text"><![CDATA[DataHub WorldHealthOrganization Data.gov EuropeanUnionOpenDataPortal AmazonWebServicepublicdatasets FacebookGraph Healthdata.gov GoogleTrends GoogleFinance GoogleBooksNgrams MachineLearningRepository 后续陆续更新中]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>数据源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析实战-第1章-数据分析简介]]></title>
    <url>%2F2018%2F04%2F11%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E7%AC%AC1%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[1.1数据分析什么是数据，数据不同于信息。信息实际上是对数据集进行处理，从中提炼出可用于其他场合的结论，也就是说，它是对数据进行处理后得到的结果。从原始数据中抽取信息的这个过程就叫做数据分析。 数据分析的目的正是抽取不易推断的信息，而一旦理解了这些信息，就能够对产生数据的系统的运行机制进行研究，从而对系统可能的响应和演变做出预测。 数据分析最初用于数据保护，现在已经发展成为数据建模的方法论，从而完成了到一门真正科学的转变。模型实际上是指将所研究的系统转化为数学形式。一旦建立数学或逻辑模型，对系统的响应能做出不同精度的预测，我们就可以预测在给定输入的情况下，系统会给出怎样的输出。这样看来，数据分析的目的不止是建模，更重要的是其预测能力。 模型的预测能力不仅取决于建模技术的质量，还取决于选择分析使用的优质数据集的能力。因此数据搜索、数据提取、数据准备也是属于数据分析的范畴，他们对最终结果有重要影响。 在数据分析的各个阶段还是有各种各样的数据可视化方法。无论是孤立的看数据，还是将其放到整个数据集来看，理解数据的最好的方法莫过于将其做成可视化的图形，从而传达出数字中蕴含的信息。 数据分析的产出为模型和图形化展示，据此可预测所研究系统的响应。随后进入测试阶段，用已知输出结果的一个数据集对模型进行测试。这些数据不是用来生成模型的，而是用来检验系统给的能否重现实际观察到的输出，从而掌握模型的误差，了解其有效性和局限。 拿新模型的测试结果与既有模型进行对比便可知道优劣。如果新模型胜出，既可尽心该数据分析的最后一步，部署。部署阶段需要根据摩西个给出的预测结果，实现相应的决策，同时还要防范模型预测到的潜在风险。 1.2数据分析师的知识范畴 计算机科学 数据和统计学 机器学习和人工智能 数据来源领域 1.3理解数据的性质数据 -&gt; 信息 -&gt; 知识 1.4数据分析过程数据分析过程可以用下图表示 问题定义 数据抽取 数据清洗 数据转换 数据探索 预测模型 模型评估/测试 结果可视化和阐释 解决方案部署 1.5 定量和定性数据分析 1.6 开放数据源开放数据源 1.7 python和数据分析python大量的库为数据分析和处理提供了完整的工具集，也广泛应用于科学计算领域。]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-Samba服务器配置]]></title>
    <url>%2F2018%2F04%2F11%2Flinux-Samba%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1.安装samba12345samba: sudo apt-get install sambasmbclient: sudo apt-get install smbclient 2.修改配置文件sudo vi /etc/samba/smb.conf在文件末尾加上如下[share] （相当于在home目录项增加了一个新用户）123456789101112[share]comment = Share Folder require passwordbrowseable = yespath = /home/sharecreate mask = 0777directory mask = 0777valid users = shareforce user = nobodyforce group = nogrouppublic = yeswritable = yesavailable = yes 3.保存退出后重启sambasudo /etc/init.d/samba restart 4.切换到 /home/目录下创建一个用户目录：sudo mkdir share 5.设置目录的权限： （777代表最高权限，可读可写可执行）chmod 777 share 6.增加相应的系统账号sudo groupadd share -g 6000sudo useradd share -u 6000 -s /shin/nologin -d /dev/null 7.最后打开我的电脑空白位置右键添加一个网络位置输入 \IP地址（linux）\share 按提示步骤输入用户名和密码。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令-压缩分割]]></title>
    <url>%2F2018%2F04%2F10%2Flinux%E5%91%BD%E4%BB%A4-%E5%8E%8B%E7%BC%A9%E5%88%86%E5%89%B2%2F</url>
    <content type="text"><![CDATA[1、tar压缩tar -zcvf cm-11.tar.gz cm-11//将cm-11文件夹压缩成cm-11.tar.gz tar -jcvf cm-11.tar.gz cm-11//将cm-11文件夹压缩成cm-11.tar.bz2 2、分割压缩后的文件太大，需要将cm-11.tar.gz分割成N个指定大小的文件split -b 4000M -d -a 1 cm-11.tar.gz cm-11.tar.gz. //使用split命令，-b 4000M 表示设置每个分割包的大小，单位还是可以k// -d “参数指定生成的分割包后缀为数字的形式//-a x来设定序列的长度(默认值是2)，这里设定序列的长度为1 3、解压tar -zxvf cm-11.tar.gztar -jxvf cm-11.tar.bz2 4、分割后的压缩包解压命令如下cat cm-11.tar.gz.* | tar -zxv]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas使用经验-拆分dataframe中的字典]]></title>
    <url>%2F2018%2F04%2F10%2Fpandas%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C-%E6%8B%86%E5%88%86dataframe%E4%B8%AD%E7%9A%84%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[如果导入的dataframe中包含有字典的，使用data.join(data[‘A10’].apply(json.loads).apply(pd.Series))来拆分字典，组合成不同的列。 123456789101112131415161718192021222324252627282930import pandas as pdimport jsonfilename = &apos;top5.txt&apos;data = pd.read_csv(filename, sep=&quot;\t&quot;, header=None)# test model.8.10 modelname 810 8101 2018-03-28 04:21:13 2018-03-28 04:21:13 # 1 0 2018-04-02 14:50:54 &#123;&quot;cell_info&quot;:&quot;LTE PLMN:46000 EARFCN:38400(B39) Cell Identity# :197539969 PCI:141 TAC:37884 RSSI:-65 RSRP:-95 RSRQ:-11 SINR*10: 133 EMM state:REGISTERED # service state:NORMAL reg domain:CS_PS lte_tx_power tx = 9 lte_rx_chain0 rssi=-64 rsrp=-94 # sinr=133 lte_rx_chain1 rssi=-69 rsrp=-99 sinr=118 &quot;,&quot;log_from&quot;:&quot;com.android.phone&quot;,# &quot;reg_at_time&quot;:&quot;31112&quot;,&quot;rat&quot;:&quot;14&quot;,&quot;reg_during_time&quot;:&quot;3554&quot;,&quot;hplmn&quot;:&quot;46002&quot;&#125; 2018-04-02columns = []for i in range(data.shape[1]): columns.append(&apos;A&apos; + str(i))data.columns = columnsprint(data.columns)# Index([&apos;A0&apos;, &apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;, &apos;A4&apos;, &apos;A5&apos;, &apos;A6&apos;, &apos;A7&apos;, &apos;A8&apos;, &apos;A9&apos;, &apos;A10&apos;,&apos;A11&apos;],# dtype=&apos;object&apos;)print(data[&apos;A10&apos;])# 0 &#123;&quot;cell_info&quot;:&quot;LTE PLMN:46000 EARFCN:38400(B39...data = data.join(data[&apos;A10&apos;].apply(json.loads).apply(pd.Series))print(data.columns)# Index([&apos;A0&apos;, &apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;, &apos;A4&apos;, &apos;A5&apos;, &apos;A6&apos;, &apos;A7&apos;, &apos;A8&apos;, &apos;A9&apos;, &apos;A10&apos;,# &apos;A11&apos;, &apos;cell_info&apos;, &apos;hplmn&apos;, &apos;log_from&apos;, &apos;rat&apos;, &apos;reg_at_time&apos;,# &apos;reg_during_time&apos;],# dtype=&apos;object&apos;)]]></content>
      <categories>
        <category>pandas</category>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>pandas</tag>
        <tag>数据导入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas使用经验-1]]></title>
    <url>%2F2018%2F04%2F10%2Fpandas%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C-fillna%2F</url>
    <content type="text"><![CDATA[函数原型：https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.fillna.html#pandas.DataFrame.fillna pad/ffill：用前一个非缺失值去填充该缺失值backfill/bfill：用下一个非缺失值填充该缺失值None:指定一个值去替换缺失值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# coding: utf-8import pandas as pddf = pd.DataFrame([[1, None, 2], [None, 3, None], [None, 4, 5],])print('origin')print(df)# 0 1 2# 0 1.0 NaN 2.0# 1 NaN 3.0 NaN# 2 NaN 4.0 5.0print('left')data = df.bfill(axis=1).iloc[:, 0]print(data)# 0 1.0# 1 3.0# 2 4.0print('up')data = df.bfill().iloc[:, -1]print(data)# 0 2.0# 1 5.0# 2 5.0print('left')data = df.fillna(method='bfill',axis=1)print(data)# 0 1 2# 0 1.0 2.0 2.0# 1 3.0 3.0 NaN# 2 4.0 4.0 5.0print('up')data = df.fillna(method='bfill')print(data)# 0 1 2# 0 1.0 3.0 2.0# 1 NaN 3.0 5.0# 2 NaN 4.0 5.0print('right')data = df.fillna(method='ffill',axis=1)print(data)# 0 1 2# 0 1.0 1.0 2.0# 1 NaN 3.0 3.0# 2 NaN 4.0 5.0print('down')data = df.fillna(method='ffill')print(data)# 0 1 2# 0 1.0 NaN 2.0# 1 1.0 3.0 2.0# 2 1.0 4.0 5.0print('left')data = df.fillna(method='backfill',axis=1)print(data)# 0 1 2# 0 1.0 2.0 2.0# 1 3.0 3.0 NaN# 2 4.0 4.0 5.0print('up')data = df.fillna(method='backfill')print(data)# 0 1 2# 0 1.0 3.0 2.0# 1 NaN 3.0 5.0# 2 NaN 4.0 5.0print('right')data = df.fillna(method='pad',axis=1)print(data)# 0 1 2# 0 1.0 1.0 2.0# 1 NaN 3.0 3.0# 2 NaN 4.0 5.0print('down')data = df.fillna(method='pad')print(data)# 0 1 2# 0 1.0 NaN 2.0# 1 1.0 3.0 2.0# 2 1.0 4.0 5.0 12345678910111213141516171819202122232425262728293031323334353637383940414243import pandas as pdimport numpy as npdf = pd.DataFrame([[np.nan, 2, np.nan, 0], [3, 4, np.nan, 1], [np.nan, np.nan, np.nan, 5], [np.nan, 3, np.nan, 4]], columns = list(&apos;ABCD&apos;))print(df)# A B C D# 0 NaN 2.0 NaN 0# 1 3.0 4.0 NaN 1# 2 NaN NaN NaN 5# 3 NaN 3.0 NaN 4print(df.fillna(0))# A B C D# 0 0.0 2.0 0.0 0# 1 3.0 4.0 0.0 1# 2 0.0 0.0 0.0 5# 3 0.0 3.0 0.0 4print(df.fillna(method=&apos;ffill&apos;))# A B C D# 0 NaN 2.0 NaN 0# 1 3.0 4.0 NaN 1# 2 3.0 4.0 NaN 5# 3 3.0 3.0 NaN 4values = &#123;&apos;A&apos;: 0, &apos;B&apos;: 1, &apos;C&apos;: 2, &apos;D&apos;: 3&#125;print(df.fillna(value=values))# A B C D# 0 0.0 2.0 2.0 0# 1 3.0 4.0 2.0 1# 2 0.0 1.0 2.0 5# 3 0.0 3.0 2.0 4print(df.fillna(value=values, limit=1))# A B C D# 0 0.0 2.0 2.0 0# 1 3.0 4.0 NaN 1# 2 NaN 1.0 NaN 5# 3 NaN 3.0 NaN 4]]></content>
      <categories>
        <category>pandas</category>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>pandas</tag>
        <tag>数据处理</tag>
        <tag>数据清洗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE 参数CQI RI PMI]]></title>
    <url>%2F2018%2F04%2F04%2FLTE-%E5%8F%82%E6%95%B0CQI-RI-PMI%2F</url>
    <content type="text"><![CDATA[原文链接：http://lteuniversity.com/get_trained/expert_opinion1/b/hongyanlei/archive/2009/08/06/cqi-reporting-in-lte.aspx CQI = Channel Quality Indicator;信道质量指示;RI = rank indication;秩指示;PMI = Precoding Matrix Indicator;预编码矩阵指示; CQI用来反映下行PDSCH的信道质量。用0~15来表示PDSCH的信道质量。0表示信道质量最差，15表示信道质量最好。–&gt;UE在PUCCH/PUSCH上发送CQI给eNB。eNB得到了这个CQI值，就质量当前PDSCH无线信道条件好不好。 这样就可以有根据的来调度PDSCH。–&gt;换句话说，LTE中下行的自适应编码调制（AMC）的依据是什么？其中一个依据就是CQI。–&gt;再通俗一点的说法：信道质量好，那eNB就多发送点数据；信道质量不好，那就保险点，少发送点数据。 RI用来指示PDSCH的有效的数据层数。用来告诉eNB，UE现在可以支持的CW数。也就是说RI=1，1CW，RI&gt;1，2 CW. CW-Code Word码字 PMI用来指示码本集合的index。由于LTE应用了多天线的MIMO技术。在PDSCH物理层的基带处理中，有一个预编码技术。–&gt;这里的预编码简单的说，就是乘以各种不同的precoding矩阵。而这个矩阵，可以采用TM3这样没有反馈的方式。–&gt;也可以采用TM4这样通过UE上报PMI来决定这个预编码矩阵。从原理上说，这样使得PDSCH信号是最优的。 下行的传输模式(TM)很多，在R9版本下行定义了TM1~TM8；其中TM4,6,8的情况下，才需要有PMI的反馈。 更多详细的内容参见36.211、213。 CQI（信道质量指示）报告是LTE的一个重要因素，并具有对系统性能显著影响。有两种类型的CQI报告在LTE中：周期性和非周期性。周期性CQI报告是由PUCCH携带。但是，如果UE需要在同一子帧发送的UL数据，周期性CQI报告将使用的PUSCH，连同UL数据传输。这是因为UE不能PUCCH和PUSCH的同时发送。在此情况下，周期性PUCCH资源将是空闲的。由于定期CQI报告带来了“永远在线”的信令开销，报告粒度相对粗糙。为了获得更详细的CQI报告，则eNB可以在需要时触发不定期CQI报告。非周期性CQI报告被发送PUSCH上，连同UL数据或独自发送。 CQI报告的粒度可分为三个层次：宽带，UE选择的子带，和更高层配置的子带。宽带报告为整个下行链路系统带宽一个CQI值。该UE选择子带CQI报告将系统带宽划分为多个子带，选择一组优选子带（最好的M个子带）中，然后报告了宽带和一个差分CQI值设定一个CQI值（假设传输只能通过选择M个子带）。高层配置的子带报告提供了最高的粒度。它将整个系统带宽划分为多个子带，然后报告一个宽带CQI值和多个差分CQI值，每个子带一个。 在闭环MIMO的情况下，PMI（预编码矩阵指示符）和RI（秩指示）也报告。基于对接收的参考信号的评价，PMI指示在eNB应该使用多个天线进行数据传输中的码本（预先约定的参数）。 RI指示传输层，该UE能够区分的数目。只有当RI&gt; 1，空间复用可被支持。对于空间复用，CQI是基于每码字的报告。码字的LTE中的最大数目是2。 在LTE中有七种传输模式，每一个对应于某多天线技术。对于每个传输模式下，CQI报告的某些组合在规范中定义的基础上，定期/不定期，宽带/ UE选择的子带/更高层配置的子带，没有PMI /单PMI /多PMI。因为RI变化比CQI / PMI慢，所以用一个较长的时间间隔报告。它与CQI / PMI报告一起在非周期性的报告，因为PUSCH资源是有限的。]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转载)ubuntu下使用woeusb创建windows启动U盘]]></title>
    <url>%2F2018%2F04%2F04%2F%E8%BD%AC%E8%BD%BD-ubuntu%E4%B8%8B%E4%BD%BF%E7%94%A8woeusb%E5%88%9B%E5%BB%BAwindows%E5%90%AF%E5%8A%A8U%E7%9B%98%2F</url>
    <content type="text"><![CDATA[ubuntu(16.04)创建windows启动U盘，使用woeusb，而不是dd 使用dd创建经常不能启动，听说是必须使用isohybrid转换以后才能到u盘（另外，对于克隆linux系统，如果已经有现成的linux系统，安装一个squashfs-tools,直接把光盘里的根unsquashfs拷贝到一个分区，然后chroot进去改一下密码就行了） 那么我们必须使用另外一个工具：woeusb 安装： 123sudo add-apt-repository ppa:nilarimogard/webupd8 sudo apt update sudo apt install woeusb 图形界面的使用就不讲了，讲了命令行的：123sudo woeusb --device &lt;/path/to/windows.iso&gt; &lt;device&gt; for example sudo woeusb --device /home/windows.iso /dev/sdc Update: if you get an error like this: “Error: Partition(s) on /dev/sdb are being used” when WinUSB / WoeUSB tries to format the USB stick from the command line, or “Error 256” in the beginning of the process when using the GUI, you must unmount the partitions. Firstly, to get a list of partitions, run the following command (“mount” also works):1df -aTh This should list all the partitions mounted on your system. If you got here, you should already know the USB device drive, e.g. /dev/sdc, so you need to look for the partitions (it could also only be one) on this drive, like /dev/sdc1, /dev/sdc2, etc. Then, unmount them like this (example):12sudo umount /dev/sdc1 sudo umount /dev/sdc2]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源硬件列表]]></title>
    <url>%2F2018%2F04%2F03%2F%E5%BC%80%E6%BA%90%E7%A1%AC%E4%BB%B6%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[通信类： RTLSDRUSRPHacking RF 流行的开源硬件ArduinoRaspberry Pi 树莓派社区http://www.raspberrypi.org/community/ Arduino论坛http://forum.arduino.cc/ 几个不错的开源硬件社区http://www.openhardware.net/https://wiki.debian.org/open_hardwarehttp://p2pfoundation.net/Category:Designhttp://harkopen.com/ 还有一些不错的HACK网站 ，以下这两个都是比较有意思的硬件hack的网站http://hackaday.com/http://hackedgadgets.com/ 几个有意思的开源硬件项目Hacking RF项目http://greatscottgadgets.com/hackrf/ 开源汽车http://www.osvehicle.com/download/ http://www.oschina.net/news/47698/10-incredible-open-source-hardware-projects-in-2013?from=20140112 http://www.csdn.net/article/2014-06-30/2820457/1http://www.csdn.net/article/2014-06-30/2820457/2]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>开源硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派更新源及设置代理配置]]></title>
    <url>%2F2018%2F04%2F03%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9B%B4%E6%96%B0%E6%BA%90%E5%8F%8A%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[修改树莓派更新源及设置代理配置 更新源12345678910111213141516171819202122默认树莓派的更新源使用的是英国的源，速度奇慢；改成国内树莓派的更新源方法，看下边：备份源列表文件sudo cp /etc/apt/sources.list /etc/apt/sources.list.old在这里找到适合国内的更新源，我一般使用的是中科大的源编辑源列表sudo nano /etc/apt/sources.list删除原先的内容deb http://mirror.ox.ac.uk/sites/archive.raspbian.org/archive/raspbian wheezy main contrib non-free rpi修改成以下内容deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ wheezy main contrib non-free rpiCtrl + X确认并保存系统更新（看速度是否上来了）sudo apt-get updatesudo apt-get upgrade 代理设置123456789101112131415161718有时候上网需要设定代理，方法看这边：到下面的路径cd /etc/apt/apt.conf.d新建一个名为10proxy的文件sudo nano 10proxy编辑其中内容sudo nano /etc/apt/apt.conf.d/10proxy如果不需要认证，以下格式即可Acquire::http::Proxy &quot;http://web-proxy.corp.xx.com:8080&quot;;如果需要认证，按照以下格式Acquire::http::Proxy &quot;http://username:password@yourproxyaddress:proxyport/&quot;;Ctrl + X确认并保存，然后查看树莓派是否可以在代理下上网]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派配置中文输入法]]></title>
    <url>%2F2018%2F04%2F03%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%2F</url>
    <content type="text"><![CDATA[12345sudo apt-get install ttf-wqy-zenheisudo apt-get install scim-pinyinsudo raspi-config然后选择change_locale，在Default locale for the system environment:中选择zh_CN.UTF-8,配置完成之后，输入命令sudo reboot]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派配置静态WLAN IP]]></title>
    <url>%2F2018%2F04%2F03%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81WLAN-IP%2F</url>
    <content type="text"><![CDATA[树莓派配置静态wlan IP1路径 /etc/network/interfaces]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>WLAN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派-配置raspi-config]]></title>
    <url>%2F2018%2F04%2F03%2F%E6%A0%91%E8%8E%93%E6%B4%BE-%E9%85%8D%E7%BD%AEraspi-config%2F</url>
    <content type="text"><![CDATA[1sudo raspi-config]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派-蓝牙 基础]]></title>
    <url>%2F2018%2F04%2F03%2F%E6%A0%91%E8%8E%93%E6%B4%BE-%E8%93%9D%E7%89%99-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[树莓派-蓝牙11bluetoothctl 12pairpaired-devices 123scan offpower offexit 1help]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RF Test and Measurement-2]]></title>
    <url>%2F2018%2F04%2F03%2FRF-Test-and-Measurement-2%2F</url>
    <content type="text"><![CDATA[&lt;continute….&gt; LTE特有的测量尽管LTE射频测量类似于其他技术有许多共同的特征，有几个测量是LTE唯一的。你能猜出这将是LTE具体测试？如果你还记得的LTE信号，我上面描述的独特性能，你会做一个很好的猜测。 IBE（In-Band Emission 带内放射) LTE的最独特的特征之一将是，在大多数情况下，UE不使用全系统带宽，这意味着它仅使用一部分射频带宽。对于射频特性而言，RF频带的这部分使用不会引起任何严重的问题，但如果所述部分被分配给中心频率的另外一边呢？你会看到频谱如下。（我无法解释这幅画的细节。只要仔细看，并试图在这张照片看，你会知道这个意思，为什么我们需要衡量这个项目）。UE发射器设计目标是尽量减少在中心频率和其他部分（image signal）的发射。 功率控制 - 绝对功率容差 当UE发送第一PUSCH发送时，功率由P0-NominalPUSCH和PUSCH功率控制算法来确定。这项测试是为了检查UE是否根据P0-NominalPUSCH和PUSCH功率控制算法设置精确的初始PUSCH功率（这和我们所说的在3G网络中开环功率控制不同的，当我们说“开环功率控制”，它通常意味着初始的PRACH功率。相反，绝对功率容差约为初始PUSCH功率）。 功率控制 - 相对功率容差 另一个方面我想提的是关于功率的控制。总体功率控制测试方法和WCDMA ILPC（内环功率控制）测试是非常相似的。网络（SS）发送TPC命令（发送功率控制命令）的连续序列，就像Up, Up, Up, Up… Down, Down, Down, Down,… 并检查UE是否正确解码命令，并设置UE TX各UP / DOWN指令（+ 1dB，1dB）指示功率。 LTE采用了类似的方法。但是，如果你看到下面的测试，你会看到在中间有一个巨大的跳跃，这是不与WCDMA相同。这是否意味着LTE具有特殊的TPC命令状10分贝或-10 dB的跳转呢？您在测试中看到的大的跳跃不是因为大的TPC命令的结果，而是RB的数量增加的结果。即使UE在每个子载波上发送相同的功率，如果UE正在使用更多的子载波，总功率就会变大。 总功率控制容差 这个测试是用来检查在无任何附加调整情况下，UL功率如何保持平稳。这个测试项是重要的，因为有在此期间，有很多种情况就像测量间隙或连接模式DRX时，UE将不能在接收任何功率控制的命令。由于该功率稳定被应用于PUCCH和PUSCH两者，此测试是有两个子试验，一个用于PUCCH和另一个用于PUSCH，如下所示。 下图是PUCCH总功率控制公差。 下图是PUSCH总功率控制公差。 射频测试设备与 UE连接图 射频一致性测试射频一致性测试的总体协议序列在36.508定义。但大多数的设备供应商有一个小的变化。我把下面有一个例子序列。 1) MIB2) SIB 1, 2, 33) RRC : PRACH Preamble4) RRC : RACH Response5) RRC : RRC Connection Request6) RRC : RRC Connection Setup7) RRC : RRC Connection Setup Complete + NAS : Attach Request8) RRC : DL Information Transfer + NAS : Authentication Request9) RRC : UL Information Transfer + NAS : Authentication Response10) RRC : DL Information Transfer + NAS : Security Mode Command11) RRC : UL Information Transfer + NAS : Security Mode Complete12) RRC: DLInformationTransfer + TC: ACTIVATE TEST MODE13) RRC: ULInformationTransfer + TC: ACTIVATE TEST MODE COMPLETE14) RRC : Security Mode Command15) RRC : Security Mode Complete16) RRC: UECapabilityEnquiry17) RRC: UECapabilityInformation15) RRC : RRC Connection Reconfiguration + NAS : Attach Accept + NAS : Activate Default EPS Bearer Context Req16) RRC : RRC Connection Reconfiguration Complete + NAS : Attach Complete17) RRC : RRC Connection Release&lt; MO or MT call &gt; : In MT call, Paging should be sent.18) RRC : PRACH Preamble19) RRC : RACH Response20) RRC : RRC Connection Request21) RRC : RRC Connection Setup22) RRC : RRC Connection Setup Complete23) RRC : Security Mode Command24) RRC : Security Mode Complete25) RRC : RRC Connection Reconfiguration26) RRC : RRC Connection Reconfiguration Complete&lt; Perform Test Case &gt;27) RRC : RRC Connection Release 和普通的呼叫处理协议序列不同的一个重要步骤，主要不同的部分是“TC：ACTIVE TEST MODE”。这一部分中详细地下列规格说明。 36.509 - 6.5 ACTIVATE TEST MODE36.509 - 5.3.2.3 Reception of ACTIVATE TEST MODE message by UE 不像在UMTS测试模式，LTE射频一致性测试的测试模式不建立环回模式。 LTE中的测试模式的主要目的，在36.509中描述 - 5.3.2.3如下。 当UE测试模式是激活的，则UE应当接受任何请求建立数据无线承载与相关联的EPS承载上下文，既包含在相同RRC消息，并在UE的无线接入功能。 射频一致性测试 - TRX一致性（36.521-1）似乎很多人都认为射频一致性仅用于测试手机的射频前端部分的性能/功能。这可能是事实，但这些测试的最终目的是为了确保UE在实网中的没有任何问题。所以每个测试项目都是和实网中的一个或多个步骤相关联。因此，具有实网中UE和网络之间交互过程的大画面是非常重要的，并发现这些一致性测试项目和步骤与实网过程/步骤之间的相关性。经常有人问我：“为什么我们需要测试这些测试项目？这些试验的目的是什么？”。如果你看到的3GPP规范（36.521），以查找对此类问题..答案被描述在“试验目的”部分，如下所示。下面的例子是6.3 动态输出功率。 当功率设置为最小值时，为了验证该UE是否有能力以一个低于测试设备上指定的输出功率传输。 这是否有任何意义吗？至少对我来说，没有太多。这说明有利于测试成功或者失败的标准，但并没有给我的测试目的有任何实际意义。 我建议是描述整个活网络程序以高层的水平如下，并尝试各一致性测试用例来映射到您的高层描述的步骤中。1）UE处于关闭状态2）UE开机3）&lt;频率搜索&gt;4）&lt;小区搜索&gt;：正常情况下，在这个过程中UE会发现多个小区5）&lt;小区选择&gt;6）MIB解码7）SIB 解码8）&lt;初始RACH过程&gt;9）&lt;注册/验证/连接&gt;10）&lt;默认EPS承载设置&gt;11）现在UE处于空闲模式12）&lt;（如果当前的电池变弱或UE移动到另一个小区注册）小区重选&gt;13）&lt;（当寻呼消息到来或用户拨打电话）RACH过程&gt;14）&lt;设置专用EPS承载&gt;15）接收数据16）发送数据17）（如果网络接收到UE功率太弱）网络发送TPC命令来增加UE Tx功率18）（如果网络接收到UE功率太强）网络发送TPC命令减少UE Tx功率19）&lt;（如果UE移动到另一小区区域）的网络和UE执行切换过程&gt;20）用户停止呼叫，UE进入空闲模式 如果你只是一味地寻找到一致性测试规范，你可能会对大量的测试用例的数量不知所措。有没有可能让我理解所有这些？我必须放弃挖掘细节，只按测试系统上的按钮，并采取盲目测试而不管机器吐出来什么东西？但是，一旦你得到了这些测试用例的大图，你会发现，所有这些测试用例可以分组称为这个框架的一部分。 首先我对你的建议是去理解每章的概念（大图），而不是直接跳跃到每个测试用例。 让我们来看看TRX一致性36.521-1的每个章节。这四个章节都与上述的3）5）19）相关联的。第6章，第7章是直截了当，他们是测试最广泛的，从开发阶段到生产线的测试。看到第8章的标题，你可能会得到一点点的混淆，当我们说“性能”，很多人会认为“IP吞吐量”。但在这种情况下，它是不正确的。在这种情况下，“性能”是指“UE如何在各种嘈杂的信道条件成功解码下行链路信号”。第9章是衡量“UE如何精确地测量各种信道条件，并报告给网络？”。总之，它是测量CQI（信道质量指示符），RI（秩指数），PMI（预编码矩阵索引）。 现在，让我们看看在每章每一个测试用例。第6章（发射机特性）有以下测试用例。正如你看到的，它只是衡量UE发射功率的不同情况和数据调制质量。大部分的测试项目，是LTE独有的。 第7章几乎是和WCDMA相同的接收机的测量。基本上这些测试用例都是测量多少数据被正确解码，在各种UE的接收机功率（网络传输功率）多少数据丢失。 第8章主要是测试关于各种嘈杂/衰落信道条件下，UE如何解调重要的下行信号（例如，PDSCH，PCFICH/ PDCCH，PHICH）。正如你可能已经猜到，这些测试用例是用像A9，A10，A11的测试系统配置（如前面的章节（TS36.508附录A））。 第9章是用于测量UE关于无线信道状态各种反馈（CQI，RI，PMI）。对于这个测量，我们要模仿各种信道条件，所以我们需要使用像A9，A10等测试配置如前面的章节（TS36.508附录A） 射频一致性测试 - RRM一致性（36.521-3） 射频/物理层性能测试概述性能测试RF/ PHY的基本理念是非常简单的。正如在下面的图中所见，一个DUT（UE）连接至SS（信令模拟器），单个小区和衰减器和AWGN，被连接到下行链路路径。目的是测试UE如何能够在恶劣的信道条件解码的各种下行链路物理信道（例如，在AWGN和/或衰落的存在）。 你可以找到来自36.521-18性能要求的性能测试的细节。有此章中相当多的测试用例如前一节的表格，但我们可以简化整套测试在一个简单的表如下。 测试信道（UE必须解码的信道）PDSCH，PCFICH/ PDCCH，PBCH，PHICH测试参数（测试条件）Rho A，Rho B，NOC，调制方式衰落条件EVA5，ETU70，ETU300，HSTSNR-1.0〜19.1 注意：如果你有兴趣更详尽的测试，是指物理层吞吐量/性能测试（我个人的测试） 《end》]]></content>
      <categories>
        <category>通信</category>
        <category>RF</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>RF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RF Test and Measurement-1]]></title>
    <url>%2F2018%2F04%2F03%2FRF-Test-and-Measurement-1%2F</url>
    <content type="text"><![CDATA[在任何无线通信设备，我们必须要经过两个大组的测试。一个用于检测发射路径，另一个用于测试接收路径。 用于无线通信装置要正常工作，它应满足下面的硬件要求1）该装置应传输是足够强大的功率，使之确保它到达通信对方的信号要求。2）设备不应发送太强的信号，而干扰其他各方之间的通信信号。3）该装置应发送足够好的信号质量，另一方可解码/校正的信号。4）该装置应当在已分配的用于通信的精确频率上发射信号。5）装置不应该产生任何噪音，除了分配给该装置的频率区域之外的其他频率区域。 如果任何这些条件和规范偏离过多，该装置不能与另一方进行通信或不能让一些其它设备进行通信。在测量设备中，1）和2）属于“功率测量”，3）是有关“调制分析”和4）属于“频率误差测量”。5）也是一种“功率测量”的，但是测量区的频域范围和1）2）不同。无论如何，如果你有一个可以执行以下三个测量你的通信技术的任何设备，你可以做传输路径的最关键的部分。 A）功率测量B）调制分析C）频率误差测量 现在，让我们想想接收路径测量。什么是用于通信设备的最重要的接收机特性？1）本接收机必须能够成功地解码从发射器来的信号，即使信号强度是很低。二）接收机必须能够成功地解码发射机传来的信号，即使当有一定水平的信号周围噪声。 在测量逻辑中，1）和2）的条件是相同的。设备发送已知信号，并让接收机解码，来比较由接收机解码信号和设备的原来信息有多大不同。差别越大，表明接收机质量越差。我们称这种方法叫“BER（误码率）测量”。1）是在输入信号非常低是测量BER，2）是在有噪声的输入信号时测量BER。 在我们前进到LTE测量之前，随便选中你已经很熟悉的技术，在你的测试计划列出来要测量的列表，并试图映射这些项目与我上面描述的测量原理。一旦你熟悉这种映射，你就会更容易明白LTE测量项目。 LTE射频测量项目现在，让我们来一点点看看LTE射频测量的细节。第一件事，我所做的是使来自3GPP36.521-1测量项目清单，并试图映射我的测量原理与每个测量项目。 在这里，首先进入的发射机测量项目。你看很多的“功率测量”和一些“调制分析”。为什么我们有这么多不同的功率测量和多种不同调制分析。他们如何各不相同？这是你必须要找到自己的答案。答案本身在3GPP36.521-1描述，但问题是，我多少可以理解所描述，那里只是通过阅读它。 第一步读每个测试的情况下的“测试目的”，“初始条件”，“测试程序”一节，并尝试至少要熟悉每个测试用例。下面是一些接收机测试项 LTE上行信号的RF测试快照正如我刚才所说，仅仅通过阅读说明书，这是不容易理解LTE射频测量的所有细节。我已阅读测试案例的目的，“初始条件”，“测试程序”一遍一遍地……但还是一切都是模糊的。当我试图让更多的进入细节，第一个障碍，阻止我的是很多描述测试条件复杂表。当然，我们看到了这种在其他技术规范像CDMA，WCDMA表，但似乎表LTE测量看起来更大，更复杂。所以，我决定去看看一些在频谱分析仪的说明书中描述的信号模式，以便我能得到的每个条件的整体RF特性的一些直观的想法。 例如，下表显示了关于MPR（最大功率衰减）的每个子测试的试验条件。如果你看到第一列上行链​​路配置 - RB分配。您将看到资源块分配的各种不同情况为同一道带宽。一些子试验使用“最大RB号”（FULL的RB）的特定信道的BW，但一些子测试的使用RB数，它比RB（部分的RB）的最大数目要少。 &lt; Full RB Signals &gt; &lt; Partial RB signals &gt;对于分配的RB的数量小于最大的RB（特别是指当RB的数量小于1/2最大的RB，可以有根据信号的位置，有许多不同的情况。例如，该信号可以位于在信道的最左侧或在中心或者最右边。从理论上讲，它可以位于频带的任何地方，但射频一致性仅指定三个地点作为测试点，低范围，中范围，高范围。最低范围意味着，从信道的最左侧的信号开始，中间装置的信号位于所述通道的中心，高范围意味着该信号是在的最右边侧渠道。 下面的示例信号是从生成一个非常好的信号质量的矢量信号发生器和功率也非常低，所以你看到的只是信号的一部分，没有任何载波泄漏或带图像。但在现实中，你会看到在大多数的情况下的载波泄漏和带图像信号。 尽管我们每隔几年都有新的技术和LTE对很多人来说是新的，RF测试和测量技术与其他无线通信技术具有很多共同点。如果你有经验，任何无线技术，如CDMA，GSM，WCDMA，蓝牙，WLAN，您可能会发现在LTE的共同逻辑。 对于LTE射频测试挑战在LTE测量中，UE开发或测试工程师面临的最大挑战将是，有太多的不同的参数设置。我进一步详细太多的子测试之前，我想通过从C2K整体射频测量简要说明。 我对C2K测量没有太多经验，但只有一点点的经验，我可以告诉你们，有在这方面相对于比较WCDMA / HSDPA，C2K测量项目要少得多，甚至相比GSM / GPRS网络相比较。至于我记得，下面是所有我做过的C2K。 1）总信道功率2）CDP（码域功率）3）Rho4）频谱辐射5）ACLR6）OBW（占用带宽） 但是，上面列出的项目超过我经历的C2K。对于一致性，我想我们可能要经过所有这些项目。但由于C2K是非常成熟的技术，现在在射频部分的开发阶段，我们不会去通过所有的这些测试项目。我听到的一个极端的情况下，“只是测量总功率，如果没有问题的。通常其它部件没有问题”。 现在让我们看看到WCDMA。对于WCDMA R99（non-HSPA），如果我简要地列入名单 1）最大功率2）最小功率3）开/关功率4）RACH 功率5）EVM6）频谱辐射7）ACLR8）OBW（占用带宽） 在名单上，它看起来并不像从C2K太大的差别。但实际上工程师将满足这看起来可能C2K完全不同的各种特性。我们能想到的第一件事是，和C2K相比，信道带宽得到了两倍，这将引入大量复杂的RF设计。另一个问题是在WCDMA的RACH过程比C2K的探测过程中添加几个重要的测试步骤，变的更为复杂。 现在，让我们再看看HSDPA。你可能会认为HSDPA在上行链路测量方面和R99不会有很大不同，因为HSDPA仅用于下行链路数据速率。这是在高层协议方面真实的，但在物理/ RF层上，在HSDPA上在上行加入了一个重要因素。它是HS-DPCCH。 HS-DPCCH是用于UE来报告CQI和ACK / NACK并发送到基站。问题是，即使有这样的附加信道的UE还必须保持总的上行链路功率和以前一样。因此，UE重新计算/重新安排每个物理信道的功率。所以，如果你看一下射频一致性测试案例列表中，你不会找到测试用例项目方面有很大的差异，但你会发现相当多的人加入到现有的测试用例子项目，就是因为引入HS-DPCCH。 （如果你想进入进一步的细节，开拓3GPP 34.121，找到测试用例关键字“HSDPCCH”的测试）。 往前一步到HSUPA，你还可能没有找到这样的测试项目方面有很大的区别。但如在HSDPA中的情况下，HSUPA也有一个新的物理信道被引入，它被称为E-DPCH。即使有这样的附加信道，UE还具有和R99一样保持总信道功率。所以，你可能已经猜到，UE必须重新计算/重新安排每个物理信道功率。其结果是，我们将得到几个附加子项添加到射频测试。 最后..让我们想想LTE。LTE在PHY / RF层方面和C2K / WCDMA / HSPA之间最大的区别是什么？这将是OFDM。是的。由于OFDM，什么样的附加测量项目将引入射频测试？因为OFDM是由大量具有非常窄的带宽子载波组成，我们必须对每个OFDM子载波测量上述列出的大部分特性。但是，如果我们对每个子载波做所有测试项目，只为一个项目也需要一整天。另一个很大的不同将是LTE规范允许许多不同类型的系统带宽，而在C2K / WCDMA，系统带宽始终是一样的。它意味着你要测量多个不同的系统带宽乘以在测量设备上测量时间和参数设置。根据LTE规范，LTE系统带宽可以是任何的1.4MHz，3MHz，5MHz，10MHz，15MHz，20MHz。而C2K只能有1.28MHz单带宽，WCDMA只能有3.84MHz单带宽。当然，特定的系统运营商在他们的网络中将只使用一个带宽，但是移动设备的制造商的应设计成它支持所有的这些带宽的UE。在此之上，还有另外一个因素，使LTE的测试更加复杂特别是对于手机设计/测试。它是被用来在特定的时间实际带宽可以动态地改变。 一个直观的例子如下面的测量屏幕。此捕获用于LTE呼叫连接和数据传输的RF信号。当您发起呼叫，移动设备会通过呼叫建立协议信令，然后数据流量将开始。如果您在测量屏幕的屏幕（频谱）的底部看，你会发现在此期间频率分配（正在使用的带宽）的变化。在这个屏幕上，数据流量的频率分配并没有改变，但是在现网中这个带宽会动态改变。 这些多系统带宽和动态带宽改变对手机设计和测试工程师意味着什么呢？对于设计师来说，最大的问题将是如何优化这些频段的各种设计参数是最适合的。对于测试工程师来说，最大的问题将是测试情况下，他们必须经历巨大数量的测试项目。所有这些在多个带宽和动态带宽改变的最终结果，可以举出如下所示的表。这仅用于一个测试用例的表。查看所有这些不同的系统带宽，你都要测试。不同的RB分配是我上面提到的动态频率分配。在LTE中，对于每一个测试用例，你会有这样的表，这对设计和测试工程师来说将是巨大的头痛。 《to be continue…》]]></content>
      <categories>
        <category>通信</category>
        <category>RF</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>RF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GSM RR信道请求/立即分配/信道释放]]></title>
    <url>%2F2018%2F04%2F03%2FGSM-RR%E4%BF%A1%E9%81%93%E8%AF%B7%E6%B1%82-%E7%AB%8B%E5%8D%B3%E5%88%86%E9%85%8D-%E4%BF%A1%E9%81%93%E9%87%8A%E6%94%BE%2F</url>
    <content type="text"><![CDATA[RR : Channel Request信道请求具有各种功能，在上电之后的信道请求相当于UMTS和LTE的RACH过程。简单地说，这个消息是告诉网络“我想驻留上你，我开始连接过程，请分配无线资源”。一个用于初始注册如下。 （在良好的信道状态，以及在开放的空间中，第一个信道请求将到达网络并获得立即分配，只有一个信道请求。以下为一种最坏的情况下的，其中初始信道请求不能由NW解码或UE对初始直接分配解码失败） 注：在“信道请求”的最后一个重传时启动T3126，并在UE得到“立即支配”时停止。如果UE没有得到“立即支配”，直到T3126到期时，UE开始小区重选。 一个信道请求的确切功能由消息的第一个8位和第一字节的描述中，由下表中44.018中指定决定。 RR : Immediate Assignment立即分配是对最初的“信道请求”的应答消息。这就是说，以MS“好吧，我会接受你的‘信道请求’，你可以使用以下步骤获得无线资源”。一个信道请求的例子将如下所示。你必须要注意的最重要的事情是，立即指派应该重放的整个信道请求消息。所有的MS（UE）的尝试连接的小区将接收相同的“立即指派”，但是，如果包含在“立即指派”的’信道请求”部分与它送出信道请求字节不匹配，UE应当丢弃“立即指派”消息，因为它不是对本身。 RR：Channel ReleaseGSM信道释放是基于44.018 3.4.13.1.1，信道释放过程是在专用模式和组传输模式下发起的。 什么时候使用？ 在呼叫释放后释放TCH 当分配给信令的专用信道被释放时用以释放DCCH 去激活SACCH UE在收到信道释放之后应该怎么做？ UE启动定时器T3110并断开主信令链路。当T3110超时，或当确认被断开时，移动台停用所有信道，认为RR连接已经释放，并返回到CCCH空闲模式，返回到PCCCH或CCCH分组空闲模式或进入数据包传送模式。 信道释放原因 有许多释放原因如下所示，但只有其中的一些在44.018 3.4.13.1.1中描述。我会继续增加更多的说明。 在信道释放消息中重要的IE 以下为信道释放进行整体结构和IE（信息元素）。BA范围：一个UE在其小区选择算法可以使用这个字段（参见3GPP TS45.008和3GPP TS23.022）。所有TCH的释放和SDCCH后的小区选择指示：移动台的所有TCH和SDCCH释放后在小区选择算法可以使用该指示（参见3GPP TS45.008）Individual priorities：移动台可以用它来传达单独优先级信息到MS（见第3.2.3.3）。当MS接收到一个单独优先级IE应启动定时器T3230的一个实例，在个人的优先级IE提供的值。《end》]]></content>
      <categories>
        <category>通信</category>
        <category>GSM</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>GSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GSM帧结构]]></title>
    <url>%2F2018%2F04%2F03%2FGSM%E5%B8%A7%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.sharetechnote.com/html/FrameStructure_GSM.html 帧结构概述当我第一次学习GSM的时候，我对帧结构感到很迷惑。主要的一个原因是整个结构的每一个周期都有需要实习和帧，很难在一张纸上形象化地画出整个帧结构。我没有找到任何形象化描述整个超帧中每一个时隙的方法，但是GSM帧层次图如下。你必须详细的理解时隙，帧，多帧，超帧。 有用的视频连接视频连接是YouTube上的，国内的小伙伴还是翻墙看吧。Teleysia - GSM TDMA Frame 1http://www.youtube.com/watch?v=HZtBIcUTop8&amp;feature=related Teleysia - GSM Logical Channels 1http://www.youtube.com/watch?v=wwEO_muXD2M 每一种Burst的结构每一种无线通信中，我们都会使用不同种类的信道类型。这些不同信道具有他们自己的物理（或者传输）结构。在GSM中，也有不同种类的物理和逻辑信道，这些信道在时隙层次上都是用他们自己的物理结构。下面是一些GSM/GPRA中使用的不同burst类型。 每一种GSM/GPRS物理信道都映射成这些burst类型。每一种物理信道也都映射为高层逻辑信道。这些信道的映射见其他文章描述。 &lt; Frequency Correction Burst &gt;频率校正突发脉冲序列 这个burst仅仅用于FCCH信道 整个数据区域有142bit，用于承载非调制的再摸（纯正弦），或者承载全零的调制载波。 频率为1625/24kHz（或者接近67kHz） 这个纯载波是beacon频率（定标频点，或者叫BCCH频率，基准频率）和FCCH时隙的标识。 &lt; Synchronization Burst &gt;同步脉冲序列 这个burst仅仅用于SCH信道 这个信道使手机和基站时钟保持时间同步。这也是相对于其他burst来说，这个burst的训练序列这个长的原因。 在这个burst中仅仅定义一个训练序列 &lt; Access Burst &gt;接入脉冲序列 这个burst用于RACH和AGCH信道 当手机发送RACH消息，并接收到AGCH回应，MS和BTS都没有时间提前信息。但是实际消息是相对较短，并且有较长的保护间隔（GP guard band），这是为了确保和下一个burst之间不会有重叠。在接入脉冲序列中保护间隔的长度（68.25bit x 3.69 = 251.16ms）是相当于37.5km传输时延。GSM允许小区半径是35km。也就说从最大距离基站35km的MS发送的RACH消息到达基站天线时是和下一个burst没有重叠的。FACCH信道是在切换操作的时候使用这个burst（当新小区的时间提前信息不知道的时候）。在这个burst中仅仅定义了一个训练序列。 &lt; Normal Burst &gt;正常脉冲序列 这个burst用于其他除FCCH/SCH/RACH/AGCH之外的所有的信道 正常burst用于TCH/SDCCH/SACCH/FACCH/BCCH/PCH 这个burst有一些重要的特征： 一个burst中最大传输57*2=114bit的语音或者数据 Flag bit是用来只是这个信道是携带的用户负载（flag=0）,或者是控制消息bit（flag=1）,也就是说，在TCH中，flag=0。在其他信道中，Flag=1。 &lt; Dummy Burst &gt;哑脉冲序列这个burst像正常脉冲学列，但是没有任何有意义的bit传输。 多帧的帧结构GSM中有两种类型的多帧。一种叫控制多帧，另外一种叫负载多帧。（slot–frame–multiframe(control or traffic)–super frame–hyperfame） 下面一个示例描述控制多帧。每一个multi-frame有51x8个时隙，值得注意的是在每一帧的第一个时隙都用于控制信道。在这个图中，每一帧的第二个时隙用于控制信道，但是不总是这样。 通信中时隙分配这个实例中的部分参考下面的文档。http://www6.conestogac.on.ca/~mkabir/TCOM1010_ConEd_Cellular/GSM%20Phy%20Part-1.pdfhttp://www.teletopix.org/gsm/how-26-and-51-multiframes-in-gsm/ 下面的图展示了时隙层面上的结构。可以看到，最小的单位是时隙，8个时隙组成一帧。 上面的图示很接近于实际物理信号流。但是很难描述出不同的调度信息，因为基本的调度室基于帧为单元的。 下面是一个traffic多帧的实例。有26个多帧用于TCH/FR和TCH/ER。 这个实例描述了两个用于在使用全速率语音信道FR。（一个用于使用每一帧的时隙2，另一个用户使用每一帧的时隙4）。在26帧traffic多帧的中间，也就是Frame-12，是SACCH，携带了ME和BTS之间的链路控制信息。最后的帧是一个空帧。所有剩余的帧都分配了负载。没有专用的FACCH帧或者时隙。FACCH会在需要的时候偷取TCH帧。 下面的这个是用于半速率语音信道HR的26多帧结构，两个用户使用HR语音。在这个实例中，两个用户交替共享每一帧中的时隙2。你可以注意到有两个SACCH。帧12用于用户1的SACCH，帧25用于用户2的SACCH。 控制信道的多帧结构更加复杂，结构会根据控制信道类型而变化。但是一个公共的地方是所有的控制信道帧结构都是基于51多帧的。 下面是Beacon信道（base信道）的控制系电脑多帧结构，它是由FCCH，SCH，BCCH，CCCH组成。图中描述的是下行多帧结构。对于上行base信道中，每一帧都是用于单一信道–RACH。下行base控制信道的主要特点有： 在51多帧结构中有5个等空间的FCCH 每一个FCCH后面跟随者SCH，意味着同样有5个SCH 四个帧（帧2-5）都用于BCCH 最后一个帧（帧50）是空的 所有剩余的帧都分配给CCCH（eg，PCH or AGCH） 上面的实例真是的独立信道。（例如，传输信道和控制信道相互独立的情况）。实际上，这些调度是融合在一起的，形成一个复杂的表格。 下面引用“GSM Phy part-1”中的描述。GSM的BTS有一个或者多个GSM频率信道（ARFCN）。这些频率信道使用base-frequency（beason频率或者BCCH频率）定义的。base-frequency的第一个时隙用于base-control信道，这个频率信道剩余的部分（slot1-7）用于传输和控制信道的混合。所有的其他频率都是用于traffic，但是也可以用于控制信道。traffic和控制信道的混合取决于每一BTS的频率信道数和traffic模式。例如： 很少电话需要很少的RACH信道 短电话需要很少的TCH 高traffic小区有大量的频率信道，可能base-frequency信道没有traffic信道。]]></content>
      <categories>
        <category>通信</category>
        <category>GSM</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>GSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GSM Basic Call Processing (Voice)]]></title>
    <url>%2F2018%2F04%2F03%2FGSM-Basic-Call-Processing-Voice%2F</url>
    <content type="text"><![CDATA[当前页是基于在MS与GSM网络模拟器之间的呼叫信令处理序列。序列和消息内容的细节将根据不同网络而有些不同，但我认为这将包含呼叫处理的所有重要组成部分。在值“时间/备注”一栏只是一个参考，让您的每一步和下一步的粗糙时间间隔。这不是很精确的绝对值。（这是在整个页面，我计划的早期阶段，所以我会持续更新很长一段时间）。]]></content>
      <categories>
        <category>通信</category>
        <category>GSM</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>GSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE-drop-part2]]></title>
    <url>%2F2018%2F04%2F03%2FLTE-drop-part2%2F</url>
    <content type="text"><![CDATA[在前面的博客，我们描述了UE执行评估无线电链路的状况的活动，以确定它是否是in-syn或不同步。根据供应商的实现，一个不同步指示的，可能会导致下降的会话。 在这篇博客中，我们将集中在由eNodeB进行的活动在检测到无线链接失败时。 失败的eNodeB可检测（再次，这些可以是供应商特定的）的类型是：A）DL失败（RLC失败）B）UL失败（物理层失败）。 在RLC层DL失败 在RLC层发生了故障时所通过空中发送数据或信令不成功并且所述RLC层停止尝试。当数据被发送的空气，但不正确地接收，接收机将发送NACK。此外，发射机可以发送请求对所有接收到的分组的确认，通过设置轮询位。接收机将发送所有接收到的分组的列表。如果没有接收到发送的分组时，它被认为是丢失的。在这两种情况下，发射器将重新传送。见下图。 这个过程可以重复，但在某些时候发射器将放弃该数据包。如果出现这种情况，发射器宣称无线链路失败，并启动程序，以传达给对方。 参数MaxRetxThreshold确定次数的分组被重发在RLC层中的下行链路的数目。如果这个数字达到中，eNodeB声明的DL RLC失败和“破坏”为示于下面的图像的背景。 在物理层UL失败 并非所有供应商的实现支持这种类型的故障检测。它本质上包括测量由UE在UL发送的探测参考信号（SRS）的功率。如果功率低于给定的SINR阈值，计时器被启动。如果SINR仍在定时器的整个持续时间的所述SINR的阈值，则e节点B宣告所述UL为不同步，并进入“杀死”的上下文。如果SRS的SINR变为上面的定时器持续时间期间的第二指定阈值，所述UL被说成是在型同步和没有动作的方式实施。 下面，由eNodeB的执行行动都显示检测到UL物理层故障时。 你是对的！！！但想想后果了！ 是的，增加maxretxthreshold的值可能会导致由于RLC DL失败降会话的数量减少。 但是，为了避免大量滴，做的最好的事情就是清理射频环境您的网络。]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE-drop-part1]]></title>
    <url>%2F2018%2F04%2F03%2FLTE-drop-part1%2F</url>
    <content type="text"><![CDATA[有多种原因可以使LTE drop。然而，会话是否被丢弃依赖于特定的供应商的实现。也就是说，下降可能会由UE消息或由eNodeB进行的测量所引起的。 两个UE和eNodeB可检查无线电链路是否in-syn。在该博客，我们将描述该UE执行，以确定是否所述无线电链路是in-syn及其后果的活动。这个博客的第2部分，将展示该eNodeB可进行以确定无线电链路是，同步或不活动。 什么时候无线链路in-syn？ UE监控下行链路中的RS。基于所述参考信号（即RSRP）的信号强度，则UE确定它是否能够基于在规范中提供的一组特定的参数来解码PDCCH。每个UE都会有不同的RSRP阈值，低于阈值它会认为它无法读取PDCCH。如果参考信号具有足够的强度，使得该UE能够始终如一解码PDCCH，则链路的in-syn。 我们如何确定无线链路不同步？ 确定是否由于不同步而链路失败的全部程序示于下图。在画面中，有示出三个参数： N310：该参数表示当UE由于检测到低的RSRP而无法成功解码PDCCH的200毫秒间隔。即该参数表示的时间内UE无法成功解码连续20帧在下行链路的数目。 T310：它是一个定时器，在几秒钟内，用于允许UE取回与所述eNodeB的同步。 N311：该参数表示的100毫秒的间隔，该UE必须成功解码所述PDCCH的数量，从而重新和eNodeB in-syn。即该参数表示的时间内在下行链路中UE必须成功解码连续10帧，为了使UE认为无线电链路是in-syn的数目。 如果UE检测N310连续失同步指示，它会启动T310定时器。如果计时器超时，链接失败。如果UE检测N311连续在同步之前的T310定时器没有超时，则定时器停止，链路没有失败。 UE检测到链路故障后，会发生什么？ 如果UE确定无线电链路失败，则UE将尝试重新连接的RRC连接重建请求消息。有一些情况下，可能发生基于供应商实现。 如果eNodeB不支持RRC连接重建呢？ 在下面的图中所示的情况是在eNB不支持RRC连接重建时最简单的情况。在这种情况下，eNB响应RRC连接重建拒绝消息。同时，则eNB将认识到，无线链路已失败，并请求连接释放到MME。它首先请求删除UE上下文或到UE的连接。原因值被设置为“与UE丢失无线连接。”该MME将UE Context Release Command作出响应。此时，所述eNodeB将响应UE Context Release Complete消息发送到MME，并通过发送RRC Connection Release消息到UE释放与UE的RRC连接。根据不同的射频情况下，则UE可以接收或不接收该消息。 如果eNodeB确实支持RRC连接重建？ 如果所述eNodeB支持RRC连接重建，并假设eNodeB发现两个UL和DL同步（当它接收到RRC连接重建请求消息时），可能会出现两种情况：RRC连接重建的成功和失败。 在一个RRC连接重建成功的情况下，下面的信令进行交换。 如果RRC连接被成功地重建，则会话不会被删除。 如果RRC连接重建过程失败的其步骤之一，则eNodeB将发送UE context release request消息发送到MME。需要注意的是在RRC连接重建过程可以在几个步骤失败。下面，在图中，仅示出一个案件。 如果RRC连接重建失败，则会话被丢弃。 如果增加了RS的功率，如果增加N310，如果增加T310，或者如果你减少N311为最小值，drop数量将减少。]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE下行吞吐量Troubleshooting]]></title>
    <url>%2F2018%2F04%2F03%2FLTE%E4%B8%8B%E8%A1%8C%E5%90%9E%E5%90%90%E9%87%8FTroubleshooting%2F</url>
    <content type="text"><![CDATA[原文链接：http://lteuniversity.com/get_trained/expert_opinion1/b/lauroortigoza/archive/2012/05/09/downlink-throughput-troubleshooting.aspx 在这篇博客中，我们将简要介绍下行吞吐量LTE网络与2×2 MIMO的一般故障排除指南。建议读者去寻找各自的OEM的文档，以解决每个低于探索领域的特定计数器。 一般故障排除策略进行说明，并覆盖的原因，坏的吞吐量见下图。 图1.低吞吐量导致的下行链路中的LTE网络。 第1步：确定低DL（下行链路）的吞吐量的小区a）第一件事就是找出那些低吞吐量的小区。此阈值由网络策略和做法定义（这也取决于你的设计参数）。报告应运行几天使得数据在统计学上是有效的。 第2步：确定下行链路干扰a）小区的下行链路干扰是那些CQI值比较低（一个例外是当大部分的流量是在小区边缘（小区位置不好））。分析由UE报告的CQI值。 发射分集 MIMO一层 MIMO两层 针对发射分集的典型值在7到8之间。 用于MIMO一层和两层典型值10到12之间。 b）若获得CQI报告之后发现低CQI值，下行干扰可能是低吞吐量的原因。 c）普通干扰的来源是，在700 MHz频段（LTE部署在美国）：互调干扰，小区干扰器和无线麦克风 步骤3：BLER值a）确定小区特定的BLER报告。BLER应小于10％或相等。如果该值较大，那么，这就是RF环境不好的指示。 B）不良BLER的典型原因是下行干扰，覆盖不好（在网络中孔等） 步骤4：MIMO参数a）确定你的网络的传输方式。有七种传输模式中所示的下表 b）调整由OEM建议的传输模式的SINR阈值。请求链路级仿真它们用于设置这些阈值，看看是否被计算在该值的条件适用于您的网络。否则，更新它们如果参数可设置并没有限制。 第5步：低需求a）使用由OEM提供的计算方法运行报告 每小区支持的RRC连接的最大数目（参数或功能） 每个小区活性的RRC连接最大数量 每个小区活跃RRC连接平均数 每个TTI每小区支持的的最大用户数（参数或功能） 在感兴趣的小区（多个）用户每个TTI调度的最大数量 每个TTI在感兴趣的小区（多个）的平均用户数量 b）若每个小区活性的无线资源控制连接最大数量是接近或等于RRC连接的支持的最大数量，则低吞吐量的原因是负载过大。 c）在每个TTI有大量的调度的用户并不一定意味着需求是导致低吞吐量。 第6步：调度类型a）找到OEM支持的调度类型 b）选择一个是更方便的您正在调查的小区的类型。调度的例子有：循环赛，比例公平，最大C / I，平等机会等OEM允许你切换调度网络中，但推荐一个特别。 c）错误的调度可能是坏的吞吐量的原因。 第7步：CQI报告参数a）检查您的网络是否使用周期性或非周期性CQI报告（或两者）。 b）核实CQI报告进行定期报告的频率以及每秒支持的用户的最大数量。 c）若与RRC活动连接的最大数目相比较，这个值过小，那么，增加的参数CQIConfigIndex与RIConfigIndex。 D）如果您的网络不使用非周期性CQI报告，然后启用它。 E）CQI慢频率报告可能会产生不好的信道估计，可能组织eNodeB的数据调度和给UE适量的调制和编码方案。 步骤7：其他a）运行的VSWR报告或要求您的OEM来运行它。 b）VSWR过高导致低吞吐量。 c）检查您的回程容量。很多时候，回程链路多种RAT中共享。请确保您的回程正确尺寸。 在这种方法的结束时，你将能够确定是否在你的小区低的原因是通过以下或者其组合，它们中的一个： BLER（坏的报道） 下行干扰（坏CQI） MIMO参数 调度算法 低需求 CQI报告频率 其他（VSWR，回程容量）]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE峰值数据率的计算方法]]></title>
    <url>%2F2018%2F04%2F03%2FLTE%E5%B3%B0%E5%80%BC%E6%95%B0%E6%8D%AE%E7%8E%87%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[原文链接：http://lteuniversity.com/get_trained/expert_opinion1/b/hongyanlei/archive/2010/02/18/how-to-calculate-peak-data-rate-in-lte.aspx 您可能会听到很多次了，LTE的峰值数据速率约为300Mbps的？如何计算出来的数字？背后什么是假设？让我们用一个简单的方法估计它。假设20 MHz信道带宽，正常的CP，4×4 MIMO。 首先，计算资源元素（RE）的数目与20MHz信道带宽的子帧：12个子载波×7个OFDMA符号×100个资源块×2个时隙=每子帧16800个RE。每个RE可携带调制符号。其次，假设64 QAM调制，并没有编码，一个调制符号将携带6位。总比特在子帧（1ms的）超过20MHz信道是16800调制符号×6比特/调制符号= 100800比特。所以数据速率为100800比特/ 1毫秒= 100.8 Mbps的。第三，具有4×4的MIMO，峰值数据速率上升至100.8 Mbps的×4 = 403 Mbps的。第四，估计约25％的开销，例如PDCCH，参考信号，同步信号，PBCH，和一些编码。我们得到403 Mbps的x 0.75 = 302 Mbps的。好吧，它是通过估算完成。有没有一种方法更准确地计算呢？如果这是你寻找什么，你需要检查3GPP规范36.213，表7.1.7.1-1和表7.1.7.2.1-1。表7.1.7.1-1显示MCS（调制和编码方案）指数和TBS（传输块大小）指数之间的映射。让我们挑选的最高MCS索引28（64 QAM用最少的编码），这是映射26. 表7.1.7.2.1-1 TBS指数表示传输块大小。这表明可以在一个子帧/ TTI（发送时间间隔）中发送的比特数。例如，具有100个RB和TBS 26指数，TBS是75376. 假定4×4的MIMO，峰值数据速率将是75376×4 = 301.5 Mbps的。 表7.1.7.1-1：调制和TBS索引表PDSCH（3GPP TX 36.213） 表7.1.7.2.1-1：传输块大小表（3GPP TS 36.213） [Q：想尝试一个小的锻炼？在这里，您是：什么是峰值数据速率，如果MCS 20时？假定信道带宽为10MHz和的2×2MIMO配置。] 我们还知道，有不同的设备能力，这在3GPP TS 36.306，表4.1-1和4.1-2表定义。例如，与cat2装置中，所支持的峰值数据速率是在DL大约50 Mbps的速度，UL约为25Mbps。所有的UE类应该支持所有的信道带宽（1.4 / 3/5/10/15/20 MHz）的所有双工模式（FDD / TDD / H-FDD）LTE中。cat1〜4的设备最多可支持在DL的2×2MIMO。只有cat5设备可以支持在UL DL和64QAM的4×4 MIMO。 现在，如果cat3装置用在与2×2的MIMO配置一个10MHz的信道，可以得到100 Mbps的在DL的峰值数据率是多少？让我们来计算。我们知道，在网络侧，峰值数据速率是300Mbps的用于与4×4的MIMO信道的20MHz，所以10MHz的2×2MIMO峰值数据速率是75 Mbps的。因此，如果cat3装置10 MHz与2×2的MIMO信道的，预期的峰值数据速率通过空中接口是：min （设备能力，网络能力）=min （cat3，10MHz的带的​​2×2MIMO）=（100， 75）= 75 Mbps的。 你声称你掌握了峰值数据速率计算之前，还有一件事，QoS 配置中还可以限制对用户期望的实际峰值数据速率的限制。 答：39.7 Mbps的。]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE Discontinuous Reception (DRX) in RRC_IDLE: Part 2]]></title>
    <url>%2F2018%2F04%2F03%2FLTE-Discontinuous-Reception-DRX-in-RRC-IDLE-Part-2%2F</url>
    <content type="text"><![CDATA[原文链接http://lteuniversity.com/get_trained/expert_opinion1/b/prakash/archive/2013/04/24/discontinuous-reception-drx-in-rrc-idle-part-2.aspx 在空闲模式下的UE监听PDCCH信道P-RNTI用于寻呼从基站接收寻呼消息。 UE需要只在某些特定的UE寻呼时机来监视PDCCH，即只在特定的无线电帧特定子帧。在其他时间，UE可以进入睡眠模式，以节省电池电量。该DRX参数和各DRX参数的意义，在这个博客的第一部分讨论。一个DRX参数“NB”是用于寻呼容量在小区中的决定因素。让我们来讨论不同的方案在这个博客考虑NB的不同的价值观和理解上的寻呼容量这个参数的影响。 方案1：NB = T / 2 观察： UE需要唤醒每32毫秒，并查找寻呼消息（共32个无线帧UE的DRX周期） 其中每2无线帧（NB = 16），可在UE的DRX周期的寻呼。即总共16个寻呼帧单元中配置的 按照寻呼帧的一个寻呼子帧（NS = 1），可用于寻呼 根据预定义的图案对于FDD，为Ns个= 1，i_s = 0，子帧9被用于寻呼在寻呼帧 总的跨哪些UE基于UE标识分布式16寻呼时机（NB = 16）每UE的DRX周期。 方案2：NB = 2T 观察： 每一个无线帧是寻呼帧 每PF（NS = 2）2子帧中的UE的DRX周期用于寻呼 根据预定义的图案对于FDD，为Ns个= 2和i_s = 0，子帧0和4被用于寻呼在寻呼帧和寻呼时机用于UE中的讨论，是子帧4 32寻呼帧和64寻呼场合（NB = 64）是内UE的DRX周期跨越哪些UE基于UE标识分布式可用。 方案3：NB = 4T 观察： 每一个无线帧是寻呼帧 每PF（NS = 4）的4个子帧中的UE的DRX周期用于寻呼 根据预定义的图案用于FDD为Ns个= 4，子帧0,4,5和9用于寻呼在用于UE中讨论的寻呼帧和寻呼时机是子帧5 32寻呼帧和128寻呼场合（NB = 128）是内UE的DRX周期可以跨哪些UE基于UE标识分布式]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
        <tag>DRX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE Discontinuous Reception (DRX) in RRC_IDLE: Part 1]]></title>
    <url>%2F2018%2F04%2F03%2FLTE-Discontinuous-Reception-DRX-in-RRC-IDLE-Part-1%2F</url>
    <content type="text"><![CDATA[原文链接：http://lteuniversity.com/get_trained/expert_opinion1/b/prakash/archive/2013/04/17/discontinuous-reception-drx-in-rrc-idle-part-1.aspx RRC空闲模式期间由UE执行的一个重要活动是监听寻呼消息。该UE应该监听寻呼消息了解来电，系统信息的变化，并ETWS（地震和海啸预警服务）通知ETWS的UE。在LTE中，UE需要连续监视PDCCH（每1ms）用于P-RNTI的收听寻呼消息和这将会导致UE电池功耗严重。相反，如果允许UE监视的P-RNTI的PDCCH中，仅在规定期间，比如说每60毫秒或100毫秒，这将减少UE的功率消耗。不连续地监视的PDCCH用于P-RNTI的过程期间RRC空闲状态被称为在RRC_IDLE非连续接收（DRX）收听寻呼消息。 什么是LTE终端的空闲模式？ UE与核心网络之间不存在的NAS信令连接 至少一个PDN连接中存在 UE被注册的MME＆EMM上下文存在于MME UE位置是已知的MME与跟踪区域的列表的精度 UE与eNB之间不存在RRC连接 该基站没有上下文信息 空闲模式的寻呼寻呼是处于RRC空闲模式或EMM注册状态用来发送寻呼消息到UE的一个过程。寻呼消息可以通过MME在核心网络或eNB触发。 不连续接收的寻呼UE的寻呼信息由在由PDCCH指示的资源块PDSCH上承载。在PDCCH上寻呼指示是单一固定指示器（FFFE）称为寻呼-RNTI（P-RNTI）。不同UE群组的监视其寻呼消息不同的子帧。 在空闲模式下的UE监听PDCCH信道P-RNTI用于从基站接收寻呼消息。 UE只在某些特定的UE寻呼时机来监视PDCCH，即只在特定的无线电帧特定子帧。在其他时间，UE可以去为睡眠模式，以节省电池电量。 让我们来讨论UE如何能够找出寻呼帧和寻呼时机的寻呼消息。 寻呼帧（PF）：一个寻呼帧（PF）是一个无线帧，其中UE正在寻找寻呼消息。一个寻呼帧可以含有一个或多个寻呼时机。 寻呼时机（PO）：这是在有可能的P-RNTI发送PDCCH上寻址用于UE的寻呼消息的子帧。对每个UE来说，在DRX周期中永远只有一个寻呼时机。 要找出PF（寻呼帧）和PO（寻呼场合），UE使用广播系统信息SIB2 DRX参数。 DRX参数的意义DRX周期：表示在寻呼周期的无线电帧的数目。这个参数的值越大，UE电池功耗越少。而DRX周期的值小，增加在UE电池功耗。 DRX周期可以是特定小区或UE特定的参数。当它被在eNB上配置并在系统信息中的SIB2作为默认寻呼周期广播到所有UE，这样的DRX周期是小区特异性的。 当DRX周期是UE特定的时，MME可以配置DRX周期，并在NAS信令中’UE特定的DRX周期“将其提供给UE和向eNB中的PAGING S1 AP消息为”寻呼DRX’（对于MME发起的寻呼消息）。UE和基站将使用默认和专用的DRX周期这两个中最小的一个。 128个无线帧的DRX周期，需要UE每隔1.28秒唤醒，并查找寻呼消息。 nB：在小区中特定的DRX周期用于指示寻呼时机的小区特定参数。 nB值的配置取决于小区中所需的寻呼容量。 nB的值配置为较大的，具有较大的寻呼容量。同样地，较小的寻呼容量时nB的值越小。 与此我们可以推断，一个最大1无线帧的可每UE以用于寻呼的DRX周期。此外，每无线电帧1的子帧的4个子帧的最小（NB≤1T）和最大（对于NB = 4T）可用于为UE寻呼消息。 寻呼帧号的计算eNB和UE计算由以下关系的寻呼帧号码： 该基站将寻呼接收UE_ID从MME S1AP消息“UE标识指数值”为MME发起的寻呼消息。 UE将找出UE_ID通过关系IMSI国防部1024（编号：TS 36.304 7.1） 该IMSI是作为类型整数（0..9）的数字序列。该IMSI应，在上述式中，被解释为一个十进制整数，其中该序列中给出的第一个数字代表的最高阶位。 例如：IMSI = 12（digit1 = 1，digit2 = 2）。在计算中，这应被解释为十进制整数“12”，而不是“1×16 + 2 = 18”。 寻呼时机的计算（在一个寻呼帧寻呼子帧号） 从基于Ns的值的预定义子帧模式（36.304第7.2节，下面所示为快速参考）中获得的寻呼场合为UE，i_s。例如，如果Ns个= 2和i_s = 1中，UE解释该子帧4和9被配置用于寻呼在小区和子帧9是用于它寻呼时机。 副车架模式（参考：TS 36.304 7.2节） FDD TDD（所有DL / UL模式） 《end》]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
        <tag>DRX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE-RACH过程]]></title>
    <url>%2F2018%2F04%2F03%2FLTE-RACH%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是设备故障的处理最棘手的部分？我的经验说：“如果做一些使用时中间的问题发生，就比较容易找到问题的根源并解决它（可能是我可能有过分简化的情况 - :)，但是如果有的话开始前发生了一件事，那将是一场噩梦。”例如，您设置的所有参数在网络仿真器要测试一个UE，然后打开了UE。在几秒之后，UE开始启动，然后再几秒之后，你看到一对的信号条在UE屏幕顶部的地方..然后在几秒钟内你看到’SOS’或’服务不可用“，而不是显示在屏幕和普通天线条网络运营商的名称。这就是我所说的“问题做一些中间”。在这种情况下，如果你收集客户端日志和设备日志，至少你可以很容易地针点出了问题发生的位置，并从那里开始的进一步细节。但如果你是在这种情况下怎么办？您将所有的参数在网络仿真器侧并打开UE .. UE启动开机..显示消息说“搜索网络…”，结果卡在那里..没有信号条吧..连“SOS”都没有..只是说“不服务”。我收集了UE侧记录和网络仿真器端日志，但没有信令消息。这是我们头痛的开始。 作为例子，1）当你在WCDMA UE打开，如果你没有看到’RRC Connection Request’？2）当你对GSM UE打开，若您没有看到 ‘Channel Request’？3）当你的LTE UE打开，如果你没有看到 ‘RACH Preamble’ ？ 首先你要做的是了解不仅在更高的信令层这一过程的每一个细节，也要涉及到关于这一步从高层到物理层一直下去的每一个细节。而你也必须使用适当的设备可以显示这些详细的过程。如果您有不提供日志记录的设备或提供日志，但只有高层信令日志，这将是很难解决。既然你有合适的工具，接下来的事情，你必须做好准备是要了解这些过程的详细知识。没有知识，即使有好的工具，这并不意味着任何东西给我。所以 ，我想在这里教我关于LTE信号的第一步，这是RACH过程。 （有人会说，即使在RACH之前，还有很多其他的步骤，如频率同步，时间同步，MIB / SIB解码..但它把这些放在一边，现在..因为它更像是基带处理）。 为什么RACH？ （RACH什么功能？） 当你第一次听到这个词RACH或RACH过程时，在你的心中第一个问题将是“为什么RACH？”，“什么是RACH过程，功能/目的是什么？”，“为什么我们需要这种复杂（看起来过分复杂的）？“。肯定的，这不是为了混淆你:)，RACH具有非常重要的功能，尤其在LTE中（在WCDMA中也一样）。 RACH的主要目的可以如下所述。1）实现高达UE与eNB之间链路同步2）为消息3获取资源（例如，RRC连接请求） 在大多数的通信（无论它是有线或无线的，特别是数字通信中），最重要的先决条件是建立接收机和发射机之间的定时同步。所以，无论你学习什么通信技术，你会看到一种是专门特定的通信同步机制。 在LTE（在WCDMA中也一样），在下行链路的同步（发送是基站，接收机是UE），这种同步是通过特别的同步​​信道（专用物理信号模式）来实现的。请参阅时间同步处理页面的详细信息。这个下行同步信号被广播给大家，它是以一定的时间间隔一直发送的。然而，在上行链路（发射机是UE，接收机是eNB），如果UE正在使用广播/始终发送同步机制，它是没有效率的（实际上浪费能源，造成了很多其他UE的干扰）。你可以很容易地理解这样的问题。在上行链路的情况下，这种同步过程应符合下列标准1）仅仅在立即需要的时候才应该发生同步过程2）同步应该只专用于特定UE 在这个页面中关于程序讨论的所有复杂的专门设计机制，都满足这些标准。 RACH过程的另一目的是为消息3获得资源（消息3）。 RRC连接请求是消息3的一个例子，根据不同的情况，有几种不同类型的消息3。你会找出这部分通过此网页阅读，这是不是很复杂，很好理解。 什么时候RACH发生？ 当你想到WCDMA中RRC连接发生时（或当PRACH发生时），这将很好帮助你理解。当你想到GSM中信道请求发生时，这将很好帮助你理解。 我的LTE RACH过程的印象是PRACH过程（WCDMA）和信道请求（GSM）的组合。它可能不是100％正确的比喻……但无论如何，我得到了这样的印象。在LTE中，RACH过程发生在下列情况下（3GPP规范中，36.300 10.1.5随机接入过程）1）RRC_IDLE首次访问2）RRC连接重建程序3）切换（基于竞争的还是非竞争为主）4）在RRC_CONNECTED状态DL数据到达，需要随机接入过程。例如，当UL同步状态为非同步5）在RRC_CONNECTED 状态UL数据到达，需要随机接入过程。例如，当UL同步状态为“非同步”或不存在可以使用SR的PUCCH资源。6）对于RRC_CONNECTED 状态下定位目的，需要随机接入过程; 例如。当UE定位需要定时超前TA 两种类型的RACH过程：基于竞争和非竞争的 当UE发送PRACH前导码，它发送特定的序列，这个序列被称为“签名”。在每个LTE小区，总共64个前导签名可用与UE随机选择这些签名中的其中一个。 UE选择“随机”这些签名中的其中一个？这是否意味着有一些可能性，即多个UE发送PRACH具有相同的签名？是。有这样的可能性。它意味着同样的PRACH前置码从多个UE同时到达NW..这种PRACH碰撞被称为“争用”。在RACH过程中，允许这种类型的“争用”被称为“基于竞争”的RACH过程。在这种基于竞争的RACH过程，网络会经历另外的过程，在稍后的步骤来解决这些争用和这个过程被称为“竞争解决”步骤。 但有一些情况下，这些种类的争用是不能接受的，由于某些原因（例如，时序限制），这些争用可被防止。通常在这种情况下，网络通知使用的每个确切时间和UE的前导签名。当然，在这种情况下，网络将分配这些前导签名，以便它不会发生碰撞。这种RACH过程被称为“无竞争”RACH程序。要启动的“无竞争”RACH过程中，UE应在连接模式的RACH过程，在切换之前。 典型的“基于竞争的”RACH程序如下：1）UE - &gt;NW ：RACH前导码（RA-RNTI，指示L2 / L3消息的大小）2）UE &lt; - NW ：随机接入响应（定时提前TA，T_C-RNTI，对L2 / L3消息的UL授权）3）UE - &gt;NW ：L2 / L3消息4）关于早竞争解决的消息 现在让我们假设一个竞争发生在步骤1）。例如，两个UE发送PRACH。在这种情况下，在步骤2）两个UE的将收到同一T_C-RNTI和资源分配。其结果是在步骤3），UE将通过相同的资源分配（具有相同的时间/频率位置）发送L2 / L3消息到NW。会发生什么，当两个UE的发射在完全相同的时间/频率位置完全相同的信息？一种可能性是，这两个信号充当彼此干扰和NW都不能解码码它们。在这种情况下，没有UE能获得从NW任何响应（HARQ ACK），并且它们都认为RACH过程失败，并返回到步骤1）。另一种可能性将是NW可以成功地从仅一个UE解码所述消息并且未能另外一个UE的解码。在这种情况下，NW成功的L2 / L3解码的UE将从网络得到HARQ ACK。此HARQ ACK过程步骤3）消息被称为“竞争解决”的过程。 典型的“无竞争”RACH程序如下：1）UE &lt; - NW：RACH前导码（PRACH）分配2）UE - &gt;NW：RACH前导码（RA-RNTI，指示L2 / L3消息的大小）3) UE &lt; - NW：随机接入响应（定时提前，C-RNTI，UL授权L2 / L3消息） 信息是如何编码成PRACH（RACH前导）？ 在LTE中，在PRACH前导码之后所有的信息（数据）都具有其自己的二进制结构，这意味着它们翻译成一定的数据结构。然而，在PRACH前导码中的信息是由纯粹的物理特性表示的。形成的信息中的PRACH物理性质如下。1）PRACH前导码传输时序（t_id）2）PRACH传输的频域位置（F​​_ID）3）PRACH信号的整个I / Q数据的序列（如下所示的一个示例） 从1）和2）中，RA-RNTI被描述下面的链接中。从3）中，可以得出前导码索引（RAPID）。在了解RA RNTI的推导时，你可能不会有太大的困难，但它不会是那么简单理解序列索引部分的推导。涉及到这个过程，大多数本页面有很多公式和复杂的表格，但我不认为我的工作做得很好以至于可以简单/清楚地描述这一部分。我将在未来添加其他短节，当我把一切都理清了。在此同时，请参阅Matlab的LTE工具箱：PRACH页面在你的大脑获得直观的形象，并了解在本页面PRACH前导信号生成部的部分。当然，你不会得到一切都一样。没有那么简单的工程:) 究竟在何时何一个UE的发射RACH？要回答这个问题，你需要参考3GPP规范TS36.211 - 表5.7.1-2。 它准确显示当UE应该根据一个所谓的“PRACH配置索引”参数来发送RACH。 例如，如果UE正在使用“PRACH配置索引0”时，它应该只在偶数SFN（系统帧号）发送所述RACH。这是足够好的答案吗？这是否意味着该UE可以以指定的SFN在任何时间发送RACH呢？这个问题回的答案在表中的“子帧号”列。它说：“1”为“PRACH配置索引0”。它意味着在UE仅被允许在每一个偶数SFN的子帧号1上发送的RACH。 检查你的表的理解，我会给你一个问题。使用哪个“PRACH配置索引”，网络能更容易的检测到来自UE的RACH？为什么？答案是14，因为UE可以在任何SFN和帧内的任何时隙发送RACH。 在一个大的图片上，你应该知道，如下图的所有维度。 （红色矩形是PRACH信号）。 该R_Slot由PRACH配置指标确定，R_length由Premable格式决定。当前导码格式0〜3时，F_offset由以下方程决定。 这个方程式中n_RA_PRBoffset是由PRACH-FreqOffset在SIB2规定。 （参考36.2115.7物理随机接入信道的细节）&lt; FDD &gt;&lt; TDD : Preamble format 0-3 &gt;&lt; TDD : Preamble format 4 &gt; 什么是前导码格式？ 如果你看到上面的表5.7.1-1展示，你看到标题为“序言格式”的列。什么是前导码格式？它被定义为下面的图。 你会看到，PRACH前导码的长度取决于前导码格式。例如，PRACH前导码格式0的长度为（3186+24567）的抽样。 （如你所知，一个抽样（TS）为1/30.72（=0.03255）us，它在36.2114帧结构定义为1 /（15000×2048）s（=0.03255us））。 你可能会问：“为什么我们需要这么多个前导码格式？”，特别是“为什么我们需要与不同时间长度的不同PRACH格式？”。其中一个主要的原因是，他们使用根据小区的半径不同使用不同的前导码格式，但是这是过于简单的回答。我想推荐一本名为“LTE：UMTS的从理论到实践”第19.4.2的PRACH结构。这是描述PRACH在最详细的级别我曾经阅读材料。 正如简短的结论为小区大小，我们可以如下重写表。 Note 1 : T_CP (in ms) = T_CP(in Ts) x 0.03255 x 1/1000,Note 2 : T_SEQ (in ms) = T_SEQ(in Ts) x 0.03255 x 1/1000,Note 3 : Guard Time (in ms) = Number of Subframe - Total LengthNote 4 : 小区半径大约是电磁波传输距离除以2。 如何网络知道什么时候UE将发送RACH？ 这很简单。网络知道当UE将发送所述RACH之前UE发送它，因为网络通知UE的当UE应该发送所述RACH。 （如果UE未能正确地解码有关的RACH的网络信息，网络将无法检测到它，即使UE发送RACH）。 以下部分将描述在RACH网络，情报。 其中RRC消息中包含RACH配置？ 正是在SIB2，你可以找到在3GPP36.331的细节。]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
        <tag>RACH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE基本过程]]></title>
    <url>%2F2018%2F04%2F03%2FLTE%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[我们中的大多数将被专门某个或某几个特定的​​区域/层的一名工程师。从技术上讲这是可以理解的，因为没有一个人可以掌握一切，但我强烈建议你尝试把整个过程的大图掌握。只要你有一些问题或东西给你的工作，尝试着问你自己“当前的问题是位于整个画面的哪部分？”。你不必去尝试死记硬背这些全过程，但如果你继续努力映射整个画面中的当前问题，这些全序列会自动在你的记忆弹出。我常常告诉我的孩子和我的晚辈“不要试图记住它，只需重复，直到你自动调用”（他们都看着我说 :“那有什么区别吗？”我只是微笑 - ： ）。 以下是我的版本的LTE全过程..但如果​​你试图去描述它，你将有一点点的不同版本..但我觉得总体逻辑是相似的。时不时地，只要回想一下这些序列，在你的心中，并问你自己“如何在细节上我可以解释有关的每个步骤？”。其实每个步骤可以在一本厚厚的书一章描述。 1）UE处于关闭状态2）UE开机3）&lt;频率搜索&gt;4）&lt;小区搜索&gt;：正常情况下，在这个过程中UE会发现多个小区5）&lt;小区选择&gt;6）MIB解码7）SIB 解码8）&lt;初始RACH过程&gt;9）&lt;注册/验证/连接&gt;10）&lt;默认EPS承载设置&gt;11）现在UE处于空闲模式12）&lt;（如果当前的电池变弱或UE移动到另一个小区注册）小区重选&gt;13）&lt;（当寻呼消息到来或用户拨打电话）RACH过程&gt;14）&lt;设置专用EPS承载&gt;15）接收数据16）发送数据17）（如果网络接收到UE功率太弱）网络发送TPC命令来增加UE Tx功率18）（如果网络接收到UE功率太强）网络发送TPC命令减少UE Tx功率19）&lt;（如果UE移动到另一小区区域）的网络和UE执行切换过程&gt;20）用户停止呼叫，UE进入空闲模式 基本信息UE能力：UE类别，频带带宽，同步信号序列，通用无线资源信息，MIMO参数，双工模式，前导序列生成算法 USIM：网络运营商的PLMN列表，签约信息 存储的信息：最近使用的频段，PLMN，跟踪区域代码，小区ID，S-TMSI，Inter-RAT频段 UE需求获取的信息：频率和时间同步信息，系统带宽，MIMO天线数量，标识（C-RNTI，物理小区ID，跟踪区域代码），网络（PLMN），信号系统和广播源，RACH_ROOT_SEQUENCE与PRACH配置。 1-LTE Basic Procedure：Initialization Sequence : From Power-On to PRACH 以下步骤列出从上电到初始PRACH的每个步骤。虽然它看起来很简单，但每一个步骤可能是UE内发生的最复杂的过程之一。更困难的是，都没有明确规定在3GPP规范了这些步骤，大部分均达到UE实现。此外，如果你的移动设备验证/验证工程师，你将有一个很大的困难，因为没有那么多详细的log，它是可将需要很长的时间和练习，直到你得到熟悉这些log。 1）UE处于关闭2）开机UE3）&lt;频率搜索&gt;4）时间和帧同步5）&lt;小区搜索&gt;：正常情况下，客户端会发现多细胞在这个过程中6）MIB解码7）SIB deconding8）&lt;小区选择&gt;：UE可以找到多个合适的细胞，但它尝试驻留到HPLM细胞具有最高优先级9）&lt;初始RACH过程&gt; 1-频率和带宽检测1）搜索中心频率注1：该算法将是最复杂的，是由每一个芯片制造商实现注2：根据UE的PHY协议栈实现中，UE可以测量RSSI并确定其是否进行到下一步骤或没有。 2）解码PSS（主同步信号） 3）解码SSS（辅同步信号）注1：UE结合PSS/SSS的结果，UE可以计算出小区ID。 （所以，如果你在UE log中看到小区ID并且它eNodeB的配置匹配，这意味着UE成功地检测到的PSS/SSS.4）结合步骤2)和3)的结果，UE可以检测小区特定参考信号 5）解码BCH占用在中心频率的72个子载波（6个RB）。 6） BCH（MIB）告诉系统的频率信息（例如，系统频率带宽） MasterInformationBlock ::= SEQUENCE {dl-Bandwidth ENUMERATED { n6, n15, n25, n50, n75, n100},phich-Config PHICH-Config,systemFrameNumber BIT STRING (SIZE (8)),spare BIT STRING (SIZE (10))} 2-时间同步过程1）UE解码主同步用三种不同主同步序列找出哪些序列被分配给该小区并获得主定时同步。2）用主同步序列解码辅同步码，并计算出被分配给该单元的序列。 此同步检测每5毫秒进行一次。 （你会明白，如果你看一下LTE下行链路帧结构的DL 帧结构部分，就可以解释了这个时间间隔） 正如我在上一节所提到的，三个不同的序列被用作主要同步信号和有各自的三个序列，小区标识组内的小区ID和这三个序列之间一对一映射。UE检测这个小区标识组后，就可以确定帧定时。从这个小区标识组中，UE也找出哪些伪随机序列被用于产生在小区的参考信号。 3）一旦这个定时同步得到确立，UE可以解码MIB并找出SFN号码，因为MIB携带SFN号码。 3-小区搜索4-小区选择5-初始RACH过程]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE帧结构-上行]]></title>
    <url>%2F2018%2F04%2F03%2FLTE%E5%B8%A7%E7%BB%93%E6%9E%84-%E4%B8%8A%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[上行时隙结构如下。当我第一次读LTE材料，几乎所有的书籍和文章中说“LTE采用SC（单载波）FDMA用于上行链路信号”，因为这个词“单载波”，并让我非常困惑，创造不出上行时隙结构的任何图像。即使是现在，我不认为我能解释清楚有关“SC FDMA”。你可能会问到FPGA或DSP工程师有关的SC FDMA机制的细节。 时隙结构但无论如何，让我感到高兴的是也是最重要的部分是，上行时隙是和下行时隙相同的。下面看一看整体上行时隙结构。 如在下行链路中，在上行链路上帧时间和时隙时间是和下行链路中相同的。在资源块结构上，上行链路和下行链路相同。如上所示，在一个时隙中有7个符号，这也是在上行链路和下行链路是相同的。 不同之处在于，你会发现，每个信道的位置不同。通常在下行链路的情况下，一个信道往往横亘整个带宽，但在上行链路时隙中的信道似乎更本地化。例如，PUCCH位于仅在频域的最低端和最高端，参考信号也局限在时域或时域和频域两者。 PUCCH RS承载参考信号用于解调PUCCH。这意味着，如果这一部分没有正确配置或eNodeB的未能检测出这一部分，eNodeB将不能解码PUCCH。 PUCCH这个信道可以携带大量的信息（UCI），但根据不同的配置中，它可以携带只有少数的以下信息。 收到的PDSCH数据的ACK / NACK CQI RI PMI 正如在时隙结构看到的，PUCCH位于上行链路频域的两个极端，以一个子帧两个时隙中交替使用的方式，也就是说，如果在PUCCH是在时隙0的频域的最低部分（第一时隙），它会被位于在时隙1频域的最高部分（第二时隙）。究竟有多少资源元素被分配给PUCCH是由网络确定，配置是由广播经SIB2到UE。 PUSCH RS承载参考信号用于解调的PUSCH。这意味着，如果这一部分没有正确配置或eNodeB的未能检测出这一部分，eNodeB的不能解码PUSCH。这总是位于上行时隙的中心。 PUSCH携带该UE试图发送的上行数据。而且还可以承载用于PDSCH的ACK / NACKUE。 SRS（探测参考信号）参见SRS的快速参考http://www.sharetechnote.com/html/Handbook_LTE_SRS.html 上行链路资源网格介绍详细信息，上行链路资源也具有一种网格格式，如下图所示。尝试熟悉在该图中参数名，因为这个参数将在本说明书的所有其它部分中使用。如果你不熟悉这些参数，当你阅读说明书的其他部分，你将无法想象的内容。 正如你看到的，最小的单位是”资源元素（RE）”，最小的资源分配单位是RB（资源块），横跨时域的7个RE和频域的12个RE。这意味着一个RB有84 RE（7×12）在里面。 实际通信中的信道下面的图表显示上行/下行数据传输的整体序列。你就可以将数据传输的序列图和在DL / UL帧结构的每个信道的特定位置相关联。 Gallery 《end》]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTE帧结构-下行]]></title>
    <url>%2F2018%2F04%2F03%2FLTE%E5%B8%A7%E7%BB%93%E6%9E%84-%E4%B8%8B%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[学习这个东西并获得实践理解的好的途径是从高层开始，一步一步的逐步深入。 Overview - FDD高层如下所示，36.211 FDD LTE。下面展示了时域一帧的结构。没有展现任何频域的结构。从这个高层描述图中你可以得到： 一帧的时长是10ms（一个无线帧，一个系统帧）。也就是意味着一秒有100个无线帧。 一帧中的采样个数是307200个。也就是意味着一秒有307200*100=30.72M个采样。 一帧包含10个子帧。 一个子帧包含两个时隙。也就是意味着一帧包含20个时隙。 一个时隙是时域中最小的结构吗？不是。如果你进一步放大这个帧结构，你得到下面的图。现在你可以看到一个时隙有7个符号组成。（一个符号是信号的某个时间跨度，在I/ Q星座图携带一个点）。而你看到一个符号内甚至更小的结构。在符号的开始，你看到一个非常小的“循环前缀”，剩余部分才是真正的符号数据。有两种不同类型的循环前缀。一种是正常的循环前缀，而另一个是“扩展循环前缀’，它比正常循环前缀较长。 （由于一个时隙的长度是固定的，不能改变，如果使用“扩展循环前缀’，即可以一时隙内容纳的符号数目减少。因此，如果我们使用”扩展循环前缀’，仅具有6个符号）。如果放大的子帧，以显示的确切时间和采样，它可以如下图说明。 有关上面显示的帧结构需要注意几点： 第一OFDM CP符号比其他OFDM符号的CP要长一点 在此图中所示的采样数是基于采样率是30.072 M个samples/s和2048 bins/ IFFT（N_ifft）的假设。因为实际情况下的采样率和N_ifft取决于系统带宽，则需要根据特定的BW缩放这个数字。 每个系统带宽下的典型N_ifft如下 system BW number of RBs N IFFT (bins/IFFT) 1.4 6 128 3.0 15 256 5.0 25 512 10.0 50 1024 15.0 75 2048 20.0 100 2048 下面显示了“LTE资源网格”的总体子帧结构（http://dhagle.in/LTE） 现在，让我们进一步放大帧结构，但这次扩大在频域，而不是在时域。你会得到下面的全部细节图。 作为从事LTE一个工程师，你的第一件事情是得非常熟悉上面这张图。 我们可以在二维上表示LTE信号，如上所示。水平轴是时域，而垂直轴是频域。垂直轴的最小单位是一个子载波和横轴的最小单位是符号。对于在时域和频域，这是这些单元的多层级组合，意思是多个较小的单位成为一个更大的单元。 让我们首先来看看在频域结构。LTE（任何OFDM / OFDMA）频带由多个小间隔的信道组成，我们称每个小信道为“子载波”。无论在LTE频带的系统带宽，所述两个信道的空间总是相同的。因此，如果LTE的系统带宽发生变化，信道（子载波）数目也发生变化，但信道之间的空间不会改变。 Q&gt;一个子载波和下一个子载波之间的空间？A&gt; 15kHz Q&gt;20MHz的LTE频段的信道（子载波）数量是？A&gt; 12x100=1200个子载波。 Q&gt;10MHz的LTE频段的信道（子载波）数量是？A&gt; 12x50=600个子载波。 Q&gt;5MHz的LTE频段的信道（子载波）数量是？A&gt; 12x25=300个子载波。 是不是感受到子载波和系统的带宽有关系？ 现在，让我们来看看横轴的基本单位是时域。时域的最小单位是一个符号，这相当于66.7us。无论带宽，符号长度不会改变。在时域中的最大的单位是一帧，长度10ms。每帧包括10个子帧，每个子帧长度1ms。每个子帧的由2个时隙，其中每一个时隙是0.5ms。每个时隙由7个符号，每一个67.7us。 Q&gt;一个时隙有多少符号？ A&gt; 7个符号。Q&gt;一个子帧有多少符号？ A&gt; 14个符号。Q&gt;一个帧有多少时隙？ A&gt; 20个时隙。 现在，让我们来看看由两个时域（横轴）和频域（纵轴）的单元。让我们把这种类型的单元叫二维单元。 最小二维单元是由在时域中的一个符号和一个子载波的频域资源元素。另一个二维单位是资源块（RB），其是由在时域中的一个时隙和12个子载波组成。资源块（RB）是LTE中的最重要的单位，常用于协议侧和RF测量侧。 Q&gt;一个资源块多少个符号？ A&gt; 7个符号。Q&gt;一个资源块多少个子载波？ A&gt; 12个子载波。Q&gt;一个资源块有多少个资源单元？ A&gt; 84个资源单元。 现在是时候我们所有涉及单位结合起来。下面的问题是读取任何LTE规范的很重要的。 Q&gt;20 MHz频段有多少资源块？ A&gt; 100个资源块。Q&gt;10 MHz频段有多少资源块？ A&gt; 50个资源块。Q&gt;5 MHz频段有多少资源块？ A&gt; 25个资源块。 我已经看到了这类型映射了这么多次，从这么多不同的来源，但我真正明白了地图的所有细节？还没有。这将需要几年的时间来了解这张图的每一个方面。 也许是我做的第一个步骤就是口头形式描述地图的每个部分。 Overview-TDD PBCH（物理广播信道） 它仅携带的MIB。 它是使用QPSK。 映射到6个资源块（72个子载波），在子帧0，围绕DC子载波。 映射到未被预留用于传输参考信号/PDCCH或PCHICH的资源元素 前L（1或2或3）个符号这是因为这个区域是二位图中最混乱的地区之一，多个信道分配在这里。第一个符号是PCFICH，但PCFICH仅仅占用第一符号上的资源块的一部分不是全部。 PHICH也是在这个区域承载。而不被PCFICH和PHICH占用的剩余空间分配给PDCCH。 PCFICH（物理控制格式指示信道） 它携带了用于控制信道（PDCCH和PHICH）的符号的数目。 映射到在每个下行链路子帧的第一OFDM符号，包含从PBCH上接收的PDCCH的OFDM符号的数目和PHICH的符号持续时间的信息，UE解码此信道找出多少OFDM符号分配给PDCCH 它是由这个子帧的第一OFDM码元的16个子载波来承载。 PCFICH的数据由4个REG承载，不管带宽多大，这四个的REG是均匀分布在整个频带上。 PCFICH的确切位置是由小区ID和带宽决定的。 有关详细信息，请参阅PCFICH页面。http://www.sharetechnote.com/html/Handbook_LTE_PCFICH.html PDCCH（物理下行链路控制信道） 映射到在每个下行链路子帧的前L个OFDM符号。 符号（L）的PDCCH的数目可以是1,2，或3。 由PCFICH指定PDCCH符号数 PDCCH携带DCI。DCI携带​​传输格式，资源分配，和与DL-SCH，UL-SCH和PCH相关的H-ARQ信息。 PDCCH也携带DCI 0，这是用于UL调度分配（例如，UL授权）。 支持多个PDCCH，UE监视一组控制信道。 调制方式为QPSK。 PDCCH就像是HSDPA的HS-SCCH，R99的PDCCH，HSUPA的E-AGCH / E-RGCH。 即使PDCCH有很多的功能，并非所有的功能都在在同一时间使用，PDCCH配置应灵活进行。 如果你有兴趣有关映射此通道的详细信息，参考36.211 6.8.1。以下是这个章节的初始描述。 物理下行链路控制信道携带调度分配和其他控制信息。物理控制信道是在一个或几个连续控制信道元素（CCE）的组合上传送的，其中一个控制信道元素对应于9个资源元素组。没有分配到PCFICH或PHICH资源元素组的数量是REG N。在系统中可用的CCE的编号为从0到N_CCE-1，其中N_CCE =floor（N_REG/9）。该PDCCH支持多种格式，如表6.8.1-1中列出。占用n个连续的CCE的PDCCH可以从一个CCE满足i mod N =0的开始，其中i是CCE号。 PHICH 携带H-ARQ反馈 在UE UL 传输数据后，它在等待PHICH中的ACK。 它像HSPA中的E-HICH 有时几个PHICH构成使用相同的资源元素的PHICH组。 PDSCH（物理下行链路共享信道） 携带用户特定的数据（DL有效载荷）。 携带随机接入响应消息。 它可以使用AMC以QPSK，16QAM和64QAM PRACH 它所携带的随机接入前导码 它在频域占用72个子载波的带宽。如果随机接入前导码成功被接收，随机接入消息上将会在UL-SCH上发送。 随机接入前导是由Zadoff-Chu序列生成的。 P-SS（主同步信号） 映射到72个活动的子载波（6资源块），在0时隙（子帧0）和10时隙（子帧5​​）的DC子载波的周围。 由62的Zadoff-chu序列值 用于下行链路帧同步 其中一个关键因素是用来确定物理小区ID 如果你是一个开发人员，负责LTE芯片组的初期工作，这将是你必须实现第一信号之一。但是，当你有以下的数据和信息，你能找出到底是哪频道映射的一部分，将进行该消息？这是理解LTE协议的最棘手的部分之一，它需要很长的时间进行研究。 （如果你是一个RF工程师，这未必是对你那么重要）。 S-SS（辅同步信号）SSS是用于无线电帧同步的特定的物理层信号。它的特点如下所示。 映射到72活动子载波（6资源块），在FDD中，分布在0时隙（子帧0）和10时隙（子帧5​​）的DC子载波的周围。 SSS的在子帧0的序列和子帧5是彼此不同 由62扰码序列（基于m序列） 在奇数索引的资源元素和偶数索引的资源元素的值由不同的公式产生 用于下行链路帧同步 其中一个关键因素是用于确定物理小区ID 但是，如果你是一个开发人员的LTE芯片组的初期工作，这也将是你必须实现第一信号之一。 RS（参考信号） - 小区特有大部分的信道（例如，DPSCH，DPCCH，PBCH等）是用于携带特有信息（比特序列）和有一些较高层的信道连接到它们，但参考信号是只存在于PHY层的特殊信号。这不是用于递送任何特定信息。此参考信号的目的是为下行链路功率提供的参考点。 当UE测量DL功率（即从eNodeB信号的功率），它衡量这一参考信号的功率，并把它作为下行小区功率。 这些参考信号是通过在每一个时隙的特定资源元素，这些资源元素的位置是根据专门由天线配置确定的。 在下面的附图中，红/蓝/绿/黄是携带参考信号的部分，被标记为灰色的资源元素是保留用于参考信号的，但对那个特定天线并不携带参考信号。 有两种不同类型的参考信号：小区固有参照信号和UE特定的参考信号 小区专用参考信号：该参考信号在每个子帧上传输，并涉及所有的工作带宽中。它是由天线端口0,1,2,3发送。 UE特定参考信号：该参考信号被仅分配给特定UE的资源块中传输，并正在通过天线端口5发送。 Q&gt;对于小区特定参考信号的资源元素是否固定？A&gt;不，位置根据物理小区ID，如下所述变化。 参考信号的时域索引（I）是固定的。 （I= [0,4]） 参考信号的频域索引k是根据物理小区ID的变化而变化的，根据36.2116.10.1.2中描述映射到资源元素。 主要原则是：k=6m +（v+v_shift）mod 6，其中v_shift=物理小区ID mod 6. 有关进一步详情，请参阅36.211 6.10.1.2 Q&gt;下行参考信号携带的是什么样的值？ A&gt;该值是通过在36.211 6.10.1.1所定义的序列生成算法产生的伪随机序列（注：上行链路参考信号 - DMRS - 是的Zadoff Chu序列）。该序列的一个决定值是物理小区ID，这意味着物理小区ID影响参考信号的值。 RS（参考信号） - MBSFN以下是根据36.211图6.10.2.2-1：MBSFN参考信号映射（扩展循环前缀，ΔF= 15 kHz） RS（参考信号） - UE特定以下基于36.211图6.10.3.2-1：UE专用的映射参考信号，天线端口5（正常循环前缀） RS（参考信号） - 定位以下是根据36.211图6.10.4.2-1：定位基准信号映射（正常循环前缀） RS（参考信号） - CSI以下是基于36.211图6.10.5.2-1：CSI参考信号（CSI配置0，正常循环前缀）的映射 全帧快照以下是示出了上述全信道的快照。当然，这不是给你的详细信息。这是给你的整体框架的整体画面。你能够识别上述各信道的位置？刚刚尝试它，这将是一个很好的做法。 在这个网格中的每个组件都有自己的作用，并以各种不同的上下文中使用。如果你有兴趣在如何这些渠道在实际通信过程中使用，请参考下面的快速参考页节。 通信中的物理信道下面的图表显示上行/下行数据传输的整体序列。你就可以将数据传输的序列图和在DL / UL帧结构的每个信道的特定位置相关联。 画廊我不会把太多的评论以下捕获。这些捕获是你的做法，以关联你在前面的章节中读取到现实生活中的信号模式是什么。]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2018%2F04%2F03%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[This is my first blog.]]></content>
  </entry>
  <entry>
    <title><![CDATA[26-LTE IP Address Allocation II - A Case for Two Cities]]></title>
    <url>%2F2016%2F04%2F03%2F26-LTE-IP-Address-Allocation-II-A-Case-for-Two-Cities%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=7257 I. Introduction在之前的文档我们已经覆盖了基本IP地址分配过程，解释了在用户同一个地点不同时间接入网络时LTE网络是怎么分配IP地址的。这个文档有一点不同，学习用户在不同物理位置上接入网络时的分配IP过程。和之前的文档意一样，要讨论两种分配方式：静态和动态的。另外我们要学习UE和PDN之间的连接PGW是怎么选择的，默认承载路径是怎么设置的。 对于动态分配方式，不管UE接入到哪个城市，LTE网络都分配一个动态的IP地址给UE，并且UE可以使用这个IP地址通过PGW连接到PDN。这个IP地址不管用户的接入位置和之前文档介绍的分配方式一样。但是对于静态分配方式，网络分配一个固定的IP地址，允许UE通过一个指定的PGW接入到PDN，不管UE接入到哪里。这个过程和之前文档根据用户的签约配置文件分配固定IP地址的方式一样。但是不同点在于默认承载路径要在城市内或者两个物理城市之间设置，现在有一个指定的PGW。 这个文档组织如下：第二章，讨论不同IP地址分配类型–静态和动态的以及他们的特点。第三章和第四章将提供动态和静态分配的详细过程。 II. Types of IP Address Allocation下面，我们将使用两个城市的模型来描述分配过程。在这个场景中，我们假设在每一个城市（city1和city2）都包含MME和SGW和PGW。每一个PGW有自己的IP地址池，只有city1有HSS。UE仅仅使用一个PDN服务（Internet）。当请求PDN连接时，UE请求dns服务器地址和PDN地址。详细的场景如下： 在city1，用户打开UE，接入LTE网络，使用PDN服务 在使用Internet服务后，用户关闭UE，并移动到city2 一旦到达city2，用户打开UE，接入LTE网络，使用PDN服务。 在city1或者city2初始附着时，UE向MME请求PDN连接。一旦请求，MME通过UE接入的PDN选择一个PGW，这个PGW决定IP地址。当默认承载建立之后PGW转发IP地址给UE，UE可以使用这个IP地址来使用PDN服务。 在这个两个城市的模型中，IP地址以两种类型分配–动态和静态。动态分配在第三章讨论，静态在第四章讨论。每一种方式的IP地址是谁选择和PGW选择的方式是不同的，如下表所示： III. Dynamic IP Address Allocation对于动态分配方式，IP地址不论用户什么时候执行初始附着到网络都是动态分配的。MME通过用户接入的PDN选择一个PGW，并要求建立一个EPS会话。PGW动态选择一个IP地址供UE使用来接入PDN。图1描述了在两个城市模型中动态IP地址分配的情况。 PGW中IP地址提供在PGW1和PGW2中，IP地址池包含待分配的IP地址，dns服务器地址已经由网络运营商提供了。IP地址获取和PDN连接用户打开UE，向当地的MME请求PDN连接。从hss下载的签约配置文件中，MME知道UE不是使用静态IP地址。所以MME选择一个本地的PGW（PGW1 PGW2），接着从这个PGW IP地址池中选择一个可用的IP地址分配给UE。当默认承载建立时，UE从本地PGW中获得dns服务器地址和UE IP地址，接着，通过本地PGW连接PDN使用Internet服务。 动态IP地址分配过程在city1或者city2动态IP地址分配的过程在之前的文档已经详细叙述过了。 IV. Static IP Address Allocation对于静态IP地址分配，i）UE使用的IP地址，ii）PGW的ID，这些都已经作为签约配置文件在PDN中提供了。不管用户在哪里接入LTE网络，MME选择指定的PGW，这个PGW分配存储存在用户签约配置文件中的静态IP地址。不管初始接入的位置，UE一直会分配相同的固定IP地址，并且在UE和指定PGW之间建立默认承载。图2描述了静态IP在两个城市模型中是怎么分配的。 hss中提供IP在hss中每一个用户提供签约配置文件。没有签约配置文件包含PDN类型，PDN地址和PGW ID。 PGW提供IP在PGW中，分配给UEdns服务器地址。 IP地址获取和PDN连接在开机后，UE1向本地MME请求PDN连接。MME从HSS中下载UE的签约配置文件，并确认UE有一个静态IP地址和指定的PGW。基于这些信息，MME开始创建EPS会话和建立EPS承载。这种方式，无关UE1是在哪里接入LTE网络，i)分配相同的静态IP地址，ii）建立连接指定PGW（PGW1）的默认承载路径，iii）UE1通过PGW1连接到PDN。这个默认承载路径是每一一个城市是这样的：city1： UE1- eNB-SGW1-PGW1city2：UE1-eNB-SGW2-PGW1 静态IP地址分配过程图3描述了在两个城市模型中静态IP地址分配的过程。 在city1 1）【UE1-&gt;MME1】请求PDN连接在city1，开机后，UE1通过发送PDN connectivity request消息(PDN Type=IPv4, PCO=DNS Server IPv4 Address Request) 来请求MME1建立PDN连接。这时，除了包含UE的IPv4地址还包含请求的dns服务器地址。 2）【MME1-&gt;HSS】请求LTE网络注册MME1通过发送update location request消息通知HSS，UE1已经在控制之下，并且在网络上注册UE1。 3）【MME1&lt;-HSS】转发签约配置文件HSS识别到UE1已经在MME上注册了，通过发送update location answer(IMSI, PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1))消息来转发UE1的签约配置文件。这个签约配置文件包含静态IP地址和PGW ID。 4）~5）【MME1-&gt;SGW1-&gt;PGW1】请求会话创建在从HSS接收到UE签约配置文件后，MME1知道UE1已经有一个静态IP地址了。MME1准备create session request消息(IMSI, PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1), PCO=DNS Server IPv4 Address Request)并发送给PGW1。这时，这个消息在PDN地址域包含从hss接收到的静态IP地址，在PCO域包含从UE接收到的PCO信息。 6）~7）【MME1&lt;-SGW1&lt;-PGW1】对创建会话请求的响应作为对4-5步请求的响应，PGW1发送create session response消息(IMSI, PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1), PCO={Primary DNS IP, Secondary DNS IP})给MME1。这个消息在PDN地址域包含静态IP地址，在PCO域包含dns服务器地址。 8）【UE1&lt;-MME1】请求默认承载上下文的激活MME1通过发送active default EPS bearer context request消息(PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1), PCO={Primary DNS IP, Secondary DNS IP})请求默认承载上下文的创建。这个ESM消息包含UE的静态IP地址和dns服务器地址，嵌入到attach accept消息中。 9）【UE1】获得静态IP地址来使用PDN服务UE1获得静态IP地址和dns服务器IP地址。UE和PGW之间(UE1 – eNB – S-GW1 – P-GW1)建立了默认承载。UE现在连接了PDN，可以通过静态IP地址使用Internet服务了。 在使用Internet服务之后，UE1关机，从LTE网络detach，一旦到达city2，UE1重选开机。 在city2 1）【UE1-&gt;MME1】请求PDN连接在city1，开机后，UE1通过发送PDN connectivity request消息(PDN Type=IPv4, PCO=DNS Server IPv4 Address Request) 来请求MME2建立PDN连接。这时，除了包含UE的IPv4地址还包含请求的dns服务器地址。 2）【MME2-&gt;HSS】请求LTE网络注册MME1通过发送update location request消息通知HSS，UE1已经在控制之下，并且在网络上注册UE1。 3）【MME2&lt;-HSS】转发签约配置文件HSS识别到UE1已经在MME2上注册了，删除在MME1中的UE上下文，通过发送update location answer(IMSI, PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1))消息来转发UE1的签约配置文件。这个签约配置文件包含静态IP地址和PGW ID。 4）~5）【MME2-&gt;SGW2-&gt;PGW1】请求会话创建在从HSS接收到UE签约配置文件后，MME2知道UE1已经有一个静态IP地址了。MME1准备create session request消息(IMSI, PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1), PCO=DNS Server IPv4 Address Request)并发送给PGW1。这时，这个消息在PDN地址域包含从hss接收到的静态IP地址，在PCO域包含从UE接收到的PCO信息。 6）~7）【MME2&lt;-SGW2&lt;-PGW1】对创建会话请求的响应作为对4-5步请求的响应，PGW1发送create session response消息(IMSI, PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1), PCO={Primary DNS IP, Secondary DNS IP})给MME2。这个消息在PDN地址域包含静态IP地址，在PCO域包含dns服务器地址。 8）【UE&lt;-MME】请求默认承载上下文的激活MME2通过发送active default EPS bearer context request消息(PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1), PCO={Primary DNS IP, Secondary DNS IP})请求默认承载上下文的创建。这个ESM消息包含UE的静态IP地址和dns服务器地址，嵌入到attach accept消息中。 9）【UE】获得静态IP地址来使用PDN服务UE1获得静态IP地址和dns服务器IP地址。UE和PGW之间(UE1 – eNB – S-GW2 – P-GW1)建立了默认承载。UE现在连接了PDN，可以通过静态IP地址使用Internet服务了。 V. Closing当UE试图初始附着到LTE网络，LTE网络根据用户签约的服务提供PDN连接，一旦连接上，网络保持这个连接直到用户从网络detach。这就意味着网络分配一个IP地址来使用。PDN连接是为每一个PDN提供的。所以IP地址也是为每一个PDN提供的。 我们目前已经学习到LTE网络在两个城市模型中是怎么分配IP地址的。 References[1] Netmanias Technical Document, “LTE IP Address Allocation Schemes I: Basic”, February 2015,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=7246[2] Netmanias Technical Document, “EMM Procedure 1. Initial Attach - Part 1. Cases of Initial Attach”,December 2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6098[3] 3GPP TS 23.401, “General Packet Radio Service (GPRS) enhancements for Evolved UniversalTerrestrial Radio Access Network (E-UTRAN) access”[4] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[25-IP Address Allocation I - Basic]]></title>
    <url>%2F2016%2F04%2F03%2F25-IP-Address-Allocation-I-Basic%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=7246 I. Introductionlte是全IP网络。这就意味着交付所有用户流量时都是以IP数据包的形式，提供给用户always on IP connectivity的服务。当UE加入LTE网络，会给UE分配一个PDN地址让UE连接这个PDN，并建立默认承载。默认承载保持连接知道UE从LTE网络中detach掉。默认承载对用户拥有的没有APN建立，为每一个APN分配独立的IP地址，一个IP地址可以为ipv4，ipv6，ipv4/ipv6三种类型。 这篇文件主要解释当用户初始接入网络时LTE网络怎么给用户分配IP地址的，并通过实例来解释。 在接下来的文档中我们将会涉及到两种类型的IP地址，这篇文档涉及到基本IP地址分配机制和过程，描述熊地址是怎样分配给用户的（用户处于一个位置，对网络执行多次初始attach）。接下来文档我们将学习不同类型的IP地址分配（用户在两个物理分割区域cityA和cityB执行初始附着）。这篇文档组织如下：第二章，不同类型的IP地址分配–动态的和静态的，并讨论他们的特点。第三章和第四章将详细讨论动态和静态IP地址的分配过程。 II. Types of IP Address Allocation当UE初始附着到LTE网络，UE请求PDN连接。PGW分配一个IP地址供UE连接PDN，并在U默认承载建立时连接UE和PDN，转发给UE。使用这个IP地址，UE可以获得PDN提供的服务。PGW分配IP地址有两种方式：动态的和静态的分配。对于动态分配，当UE每次接入网络时自动分配一个IP地址。对于静态分配，一旦用户签约后指定给UE一个固定的IP地址，并在每次UE接入网络时都分配这个指定的IP地址。图1比较两种方式的不同。 对于动态分配，网络PGW自动为UE选择IP地址。在PGW中网络运营商有一个IP地址池。的那个UE初始附着到LTE网络时，PGW动态为UE分配一个IP地址。所以每次UE初始附着到网络时分配的一个新的动态IP地址。但是，对于静态分配，一旦UE签约网络之后网络运营商就分配了一个固定的IP地址。运营商在hss中和其他签约信息一起为UE分配了静态的IP地址。接着当UE初始附着到LTE网络时，PGW从hss中获得这个静态IP地址并转发给UE。所以在每次UE初始附着网络时给UE分配的都是特定的IP地址。 当在初始附着请求PDN连接时，UE通过使用协议配置选项PCO可以请求和外部协议/应用相关的协议数据（eg请求dns服务器地址，P-CSCF地址）。这篇文档将详细解释dns服务器地址和IP地址的请求。 III. Dynamic IP Address Allocation对于动态IP地址分配，PGW为UE保留IP地址池，并在UE初始附着到LTE网络时为其分配一个IP地址。 PGW中提供IP地址在PGW中，分配了一个IP地址池，并且dns服务器IP地址已经分配了。 动态IP地址分配过程用户打开UE，试图初始附着到LTE网络上。 1）【UE-&gt;MME】请求PDN connectivityUE通过发送PDN connectivity request(PDN type=IPv4, PCO=DNS Server IPv4 Address Request)消息给MME请求PDN连接。这是，除了请求ipv4地址，也请求dns服务器地址。PDN connectivity request消息是一个ESM消息，但是这个消息是嵌入在attach request(IMSI，ESM Message Container)消息中传输的。 2）~3）【MME-&gt;SGW-&gt;PGW】请求会话创建MME基于从hss接收到的签约配置文件，发送create session request(IMSI, PDN Type=IPv4, PDN Address=0.0.0.0, PCO=DNS Server IPv4 Address Request) 消息给SGW请求EPS会话创建。因为是动态IP分配，这个签约配置文件中不包含IP地址信息，在create sessionrequest消息中PDN地址域是0.0.0.0，从UE接受到的PCO信息也包含在PCO域中。 4）【PGW】分配PDN地址和dns服务器地址PGW在检查PDN类型和PDN地址（0.0.0.0）之后发现需要分配ipv4地址。PGW从ipv4地址池中选择一个IP地址(e.g. UE IP=1.1.1.5)，并分配给UE。根据PCO域的请求，也分配相应的dns服务器IP地址。 5）~6）【MME&lt;-SGW&lt;-PGW】对请求会话创建的响应作为对2-3步请求的响应，PGW发送create session response消息给MME。这个消息包含PDN地址域的UE IP地址，PCO域的dns服务器IP地址。 7）【UE&lt;-MME】请求默认承载上下文的激活MME给UE发送activate default EPS bearer context request(PDN Type=IPv4, PDN Address=UE IP(1.1.1.5), PCO={Primary DNS IP, Secondary DNS IP})消息来请求对默认承载上下文的激活。这个ESM消息包含dns服务器IP地址和UE IP地址，嵌入到attach accept消息中传输。 8）【UE】获得动态IP地址使用PDN服务UE获得动态IP地址和dns服务器地址。UE和PGW之间建立默认承载。UE现在已经连接到PDN上，可以以动态IP地址来使用Internet服务。 IV. Static IP Address Allocation对于静态IP地址分配，当用户第一次签约网络时网络运营商为用户指定了一个UE IP地址，在hss中提供用户签约配置文件，并在用户每次初始附着到网络时分配一个存储在配置文件中的静态IP地址。详细的过程如图3所示。hss中提供IP在hss中，提供了每一个签约用户的签约配置文件。这个配置文件包括PDN类型，用于PDN连接的PDN地址。PGW中IP提供在PGW中，dns服务器IP地址已经设置了。 静态IP地址分配的过程用户打开UE，试图初始化附着到LTE网络。 1）【UE-&gt;MME】请求PDN连接UE通过发送PDN connectivity request消息(PDN type=IPv4, PCO=DNS Server IPv4 Address Request)消息给MME请求PDN连接。这时，除了IPv4地址，包括dns服务器地址也请求了。 2）【MME-&gt;HSS】为了注册请求LTE网络MME通过发送update location request消息通知HSS，UE已经在MME的控制之下，请求在网络上注册UE。 3）【MME&lt;-HSS】转发签约配置文件HSS识别到UE已经在MME上注册了，通过发送update location answer(IMSI, PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1))消息来转发UE的签约配置文件。这个签约配置文件包含静态IP地址。 4）~5）【MME-&gt;SGW-&gt;PGW】请求会话创建在从HSS接收到UE签约配置文件后，MME知道UE已经有一个额静态IP地址了。MME准备create session request消息(IMSI, PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1), PCO=DNS Server IPv4 Address Request)并发送给PGW。这时，这个消息在PDN地址域包含从hss接收到的静态IP地址，在PCO域包含从UE接收到的PCO信息。 6）~7）【MME&lt;-SGW&lt;-PGW】对创建会话请求的响应作为对4-5步请求的响应，PGW和SGW发送create session response消息(IMSI, PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1), PCO={Primary DNS IP, Secondary DNS IP})给MME。这个消息在PDN地址域包含静态IP地址，在PCO域包含dns服务器地址。 8）【UE&lt;-MME】请求默认承载上下文的激活MME通过发送active default EPS bearer context request消息(PDN Type=IPv4, PDN Address=Static UE IP(1.1.1.1), PCO={Primary DNS IP, Secondary DNS IP})请求默认承载上下文的创建。这个ESM消息包含UE的静态IP地址和dns服务器地址，嵌入到attach accept消息中。 9）【UE】获得静态IP地址来使用PDN服务UE获得静态IP地址和dns服务器IP地址。UE和PGW之间建立了默认承载。UE现在连接了PDN，可以通过静态IP地址使用Internet服务了。 V. Closing到目前为止，我们讨论了两种分配IP的方式：静态和动态。当用户试图初始附着到LTE网络时，LTE网络分配一个IP地址来连接到PDN上和默认承载。只要用户网络注册有效，PDN地址和默认承载一直保持有用，即使用户没有在使用服务。这种方式叫做always-on IP connectivity。这个文档解释了IP地址分配的机制和过程。下面一个文章我们将讨论在不同的位置UE连接PDN时的情况。 References[1] Netmanias Technical Document, “LTE IP Address Allocation Schemes II: A Case for Two Cities”,February 2014 (TBD)[2] Netmanias Technical Document, “EMM Procedure 1. Initial Attach - Part 1. Cases of Initial Attach”,December 2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6098[3] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23-LTE Charging I_Offline]]></title>
    <url>%2F2016%2F04%2F03%2F23-LTE-Charging-I-Offline%2F</url>
    <content type="text"><![CDATA[原文链接： http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=7179 I. Introduction之前的PCC文档，我们的焦点在讨论关于QoS规则的PCC策略。现在我们的焦点是付费策略，特别是离线付费策略。 在LTE网络中，服务是按照承载（eg，EPC）/子系统（eg.IMS）/服务级别（eg MMS）或者是在线和离线来付费的。对于在线付费，当用户请求网络资源，网络运行账户查询并决定是否授权用户用户使用请求的网络资源。这个情况，用户的网络资源利用被实时测量，所以说付费信息对提供的服务有实时的影响。这个方法应用在预付套餐上。（预付套餐是神马？？）另一方面，对于离线付费，用户为已经使用过的网络资源付费。也就是说，网络通过转发用户的CDR（付费数据记录）到账单系统来报告特定用户的资源使用情况。用户使用的信息定期的收集，或者在没有会话结束时收集。所以付费信息对提供的服务没有实时性影响。通常上，在线付费是使用在预付费套餐上，离线付费使用在后付费套餐上。例如，多数韩国的移动用户是后付费套餐使用者，他们都属于离线付费策略。这种类型套餐的使用者首选使用服务，然后他们的运营商每月再计算他们的使用情况付费。在全球范围内，预付费用户比后付费用户要多。预付费用户首先付费，然后保证他们的配额。一旦他们的配额超出，激活的会话就会终止。这篇文档主要讨论当在承载级别后付费用户使用Internet服务时运用离线付费策略的付费过程。这篇文档组织如下：第二章提供付费相关的接口和离线付费是怎么工作的，第三章解释离线付费的过程。第四章总结CDR参数，离线付费参数。 II. Overview of Offline Charging下面我们将定义LTE参考模型中付费相关的接口。图1描述了LTE付费架构和相关的接口。 策略和付费规则功能PCRF：当决定到用户SDF的PCC策略时，PCRF选择一个付费策略适用于SDF（service data flow），并通过Gx接口转发这个策略到PGW中的PCEF（policy and charging enforcement function）。 PGW：PGW对用户的SDF执行PCRF转发的付费策略。在离线付费，PGW根据付费策略生成CDR，并通过Gz接口转发至OFCS（offline charging system）。在在线付费，PGW首先请求和获得配额，然后通过Gy接口和OCS（online charging system）执行信用控制来测量和报告用户的使用情况。 OFCS离线付费系统：一旦接收到Gz接口上PGW的CDR，OFCS后处理他们并转发至账单系统billing system、 OCS在线付费系统：通过Gy接口和PGW执行信用控制来给用户分配配额（eg，这个会话持续多长时间，用户交付多少数据等等） 遮普文档只关于离线付费的，图1展示了PCRF PGW OFCS怎么工作的。在我们进一步详细讨论之前，我们先简要介绍一下离线付费系统是怎么工作的。 图2提供了离线付费工作的概况，特别的付费规则的交付和CDR的传输。 1）PCRF，一旦EPS会话建立，PCRF选择一个付费策略，并嵌入到PCC策略中转发给PCRF（PGW）。同事，付费策略的名字被定为PCC规则的名字。像付费方法（在线或者离线），排序组（服务是怎么付费，每分钟100元，100M 1000元等等）这些信息作为付费规则包含在PCC规则中。在图2中，Internet会话建立了，在上面应用了offline的付费方法和rgInternet排序方法的付费规则。 2）PGW从PCRF接收到付费规则，PGW知道使用的是离线付费。PGW决定应该测量或者产生什么样的付费信息，通过那个接口传输这些信息。接着PGW创建默认承载，在上面应用这些付费规则，并打开CDR，准备好生成付费信息。 3）现在IP数据包通过PGW传输。PGW开始通过Internet SDF开始测量网络使用量，生成付费信息。 4）一旦EPS会话终止，PGW把这些CDR记录信息转发给OFCS。在这个实例中，每一个排序组的使用量都报告了，CDR包含以下信息： 用户信息（eg用户ID，用户位置） 网络/承载信息（eg服务网络ID，APN，PGW，SGW地址，请求的QoS，授权的QoS） 网络资源使用量（eg传输的字节数） 使用量信息（eg总的获取时间，数据包传输时间） 服务信息（eg服务id，数据包过滤） III. Offline Charging Procedure图3是LTE网络中离线付费过程。这个文档只关注在付费处理过程。 1）【PCRF&lt;-SPR】获得用户配置在用户初始附着过程中，PCRF从SPR中请求和获得用户的签约配置文件为了决定PCC规则。 2）【PGW&lt;-PCRF】请求会话建立PCRF基于用户签约配置文件决定Internet会话的付费策略。PCRF通过CCA（credit control answer消息）转发PCC规则“Internet”给PGW。 3)【PGW】CDR创建PGW根据PCC规则创建默认承载，并且对这个承载执行付费策略。接着PGW通过创建CDR准备好生成付费信息。 4）【PGW】生成付费信息一旦用户开始使用Internet，PGW记录用户网络资源使用情况和详细使用信息，生成付费信息。 5）【PGW】CDR关闭PGW一旦在用户detach之后EPS会话结束后关闭CDR。 6）【PGW-&gt;OFCS】CDR传输PGW通过data record transfer request（CDR）消息通过GTP’协议把CDR传输给OFCS。报告的信息包括每一个排序组的使用信息，数据包交付时间，字节交付时间等等。 7）【PGW&lt;-OFCS】CDR接收确认OFCS通过发送data record transfer accept消息确认CDR的接收。 OFCS收集CDR，后处理他们，并且把他们转发给运营商计费系统。这个计费系统分析接收到的CDR来获得统计值决定要付费多少钱。接着使用这些结果向用户收费或者运营商之间账户。 IV. Parameters for Charging Data Record (CDR)图2和图3总结了CDR的主要参数。除了这些参数，CDR还有其他另外的付费参数。表1列出了在承载级别上使用的CDR参数。 V. Closing我们讨论了付费过程。下一个文档将讨论在线付费系统。 References[1] Netmanias Technical Document, “LTE Policy and Charging Control (PCC)”, August 2014,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6562[2] 3GPP TS 32.240, “Telecommunication management; Charging management; Charging architectureand principles”[3] Netmanias Technical Document, “LTE Network Architecture: Basic”, July 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5904[4] 3GPP TS 32.295, “Telecommunication management; Charging management; Charging Data Record(CDR) transfer”[5] Netmanias Technical Document, “EMM Procedure 1. Initial Attach - Part 2. Call Flow of Initial Attach”,January 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6102[6] 3GPP TS 32.298, “Telecommunication management; Charging management; Charging Data Record(CDR) parameter description”[7] Netmanias Technical Document, “LTE Charging: Online”, TBD[8] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[22-LTE Policy and Charging Control (PCC)]]></title>
    <url>%2F2016%2F04%2F03%2F22-LTE-Policy-and-Charging-Control-PCC%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6562 I. introduction为了使用LTE服务，用户必须购买一个LTE设备，和运营商签署一个账户，并选择服务类型和想要的计划。为了支持和管理这些选择的服务，运营商根据用户的签约信息来配置签约文件。当用户使用LTE服务时，对每一个和不同服务相关的APN建立EPS会话。这时，网络决定一个策略：当EPS会话建立或者修改是,网络资源时怎么分配的，这些服务时怎么付费的。接着，当会话保持激活状态时，应用这个策略到EPS会话。这个过程叫做策略和付费控制PCC，主要由策略付费控制功能PCRF和策略付费增强功能PCEF实现。 当建立或者修改EPS会话，基于运营商的策略PCRF决定每一个服务数据流SDF的PCC规则。 PCEF (P-GW)检测一个SDF，并适用一个PCC规则，这个规则对用户数据包上的一个特定的SDF是特定的。它可以绑定SDF QoS和承载QoS，适用承载QoS到EPS承载。也就说，EPS承载上下文是在EPS实体(UE, eNB, S-GW, P-GW, and MME)上设置和修改的。 EPS会话的建立，修改和结束的执行时和PCC过程一致的。EPS会话修改过程可能包含EPS承载的建立修改和结束。在这个过程中，UE和MME之间的EPS承载上下文是按照NAS层的EPS会话管理功能ESM来处理的。 这篇文档讨论PCC规则和过程，是按照如下组织的：第二章定义PCC规则并描述PCC规则对于不同的服务烈性在GX接口时怎么提供的。第三章讨论伴随ESM过程的EPS会话建立和修改需要的PCC规则。第四章介绍当使用策略控制时，IP数据包是怎么处理的。第五章总结EPS实体中策略控制相关的信息。 II.PCC rulesPCRF决定每一个SDF的PCC规则，并通过Gx接口把这些规则转发给PCEF（PGW）。PGW接着对每一个SDF执行这些PCC规则。在执行PCC规则后，当IP数据包到达，检测到每一个数据包属于的SDF，并根据他们的SDF对每一个数据包适用PCC规则。3GPP29.312按照如下定义PCC规则： 目的：PCC规则的目的是检测一个数据包属于哪个SDF，并识别出SDF作用的服务，为这个SDF提供合适的付费参数，并为这个SDF提供策略控制。 适用：适用于不同的SDF。PCEF (P-GW)通过使用数据包过滤器（SDF templates）来匹配对IP数据包进行分类，并对这些数据包应用上匹配的PCC规则。 类型：动态PCC规则，或者预定义的PCC规则。动态PCC规则是在EPS会话建立或者修改时，由PCRF动态地提供给PGW的。预定义的PCC规则是在PGW中预先配置的，可以由PCRF激活或者去激活。 elements：PCC规则包含策略规则名字，service ID，SDF templates，gate status，QoS参数，付费参数等等，并根据运营商的策略而变化。 下面，我们详细介绍不同类型的PCC规则是怎样通过Gx接口传送的，并且在PGW上执行的。2,1节描述预定义的PCC规则，2.2节描述动态PCC规则。 2.1 预定义PCC规则一些运营商适用限制不是他们服务的流量的比特率这样的策略，例如P2P。所以，我们使用P2P作为示例介绍下预定义PCC策略。图1描述了在PGW中预定义PCC策略是怎么配置的。 在这个图中，预定义规则“P2P”是在PGW中预配置和去激活的。因为这个规则是预定义的，一旦PCRF决定，就需要给PGW这个策略规则的名字 ie“P2P”，来代替发送这个规则的所有元素。一旦接收到P2P这个规则名字，PGW激活之前去激活的P2P规则，并执行。 2.2 动态PCC规则动态PCC规则是在当有时间时使用的。图2描述了动态PCC规则在用户使用Internet和语音服务是在PGW中怎么配置的。图中做如下假设： 运营商策略：互联网服务的接入性在一定程度上取决于网络资源。并且可以保证语音服务的数据速率。 APN：Internet和语音服务可以通过不同的APN接入。 PCC规则名字：Internet服务“Internet”，语音服务“voice-C”（SIP信令）/“voice-U”（voice packet） “Internet”规则适用于接入Internet的所有数据包。它支持不限制的MBR（UL/DL），允许Internet接入最大可能的比特率。这个规则适用于接入Internet的默认承载。APN-AMBR(uL/DL)是设置为非限制的，如果没有其他用户在服务数据可以以最大速率传输。但是服务的用户越多，支持的速率越慢。 “voice-C”规则适用于SIP信令数据包。它适用于接入IMS网络的默认承载，支持100Kbps的APN-AMBR(uL/DL)。 “voice-U”规则适用于多媒体数据包，是用户语音数据包，支持GBR。在激活的语音会话中，分配的网络资源确保数据包随时是按照UL/DL 88 Kbps的速率交付的。专用承载建立，也是允许数据包以UL/DL 88 Kbps的速率交付。 每次建立或者修改一个EPS会话，PCRF动态决定PCC规则，包含根据选择服务类型特定规则的规则名字和规则参数。接着PCRF把这些参数提供给PGW。接着PGW在把这些参数映射到承载QoS参数上之后对IP数据包执行这些策略。 一旦用户通过初始附着过程接入Internet和IMS网络，用户默认承载保持连接直到UE从LTE网络中去附着。所以基本上，“Internet”“voice-C”规则在PGW中保持激活。另外一旦检测到语音电话，就在IMS APN上建立专用承载，并在通话结束时终止承载。 3. PCC procedures我们再第二章讨论了PCC规则。在第三章，我们将通过EPS会话建立和修改过程在探索PCC规则。在LTE中，语音服务和Internet服务使用不同的PDN，所以他们有自己的默认承载。语音信令消息是使用SIP协议通过默认承载传输的，而媒体数据包（用户语音数据包）是使用RTP协议通过专用承载传输的。 Internet服务用户的初始附着和EPS会话建立过程已经在LTE初始附着的文档中讨论过了。我们深入讨论在EPS会话建立或者修改过程对用户接入IMS拨打语音通话时PCC是如何工作的。为了在LTE网络拨打语音通话，附着LTE和IMS注册时提前必须的。一旦语音服务的EPS会话通过LTE attach过程建立了，attach到IMS网络的默认承载也在LTE网络中创建了。在这个过程中，voice-C语音服务信令的PCC规则适用于这个承载。通过这个承载，交付SIP信令消息，用户和IMS网络之间的IMS鉴权注册接着执行。接着当有一个语音通话，IMS网络监测到它，并通过PCRF。PCRF决定PCC规则（“voice-U”）并转发至PGW。PGW为语音数据包传输创建专用承载，并且通过这个专用承载传输语音数据包。 3.1 语音会话建立：默认承载建立和IMS注册图3描述了通过IMS APN初始attach的用户时如何建立EPS会话的。我们假设EPS会话建立是由用户打开UE而发起的。随着使用EMM消息完成初始附着过程，EMM之前我们已经介绍了，现在我们简要过一下ESM过程。 1）【UE-&gt;MME】PDN connectivity request UE通过PDN connectivity request消息给MME请求接入IMS网络。在ESM消息中的PCO协议配置选项域用来要求代理呼叫会话控制功能P-CSCF地址。这个消息是包含在attach request消息中，发送给MME。 2）【MME-&gt;SGW-&gt;PGW】请求语音会话的创建 MME在位置更新时从hss接收到签约配置文件中获得APN和签约QoS配置。从APN，MME意识到APN要为语音服务创建默认承载，并为这个默认承载分配ID。这个签约配置文件获得QoS参数(QCI = 5, ARP = 6, APN-AMBR = 100 Kbps)，这些配置文件应用于默认承载。MME准备create session request消息，包含默认承载ID，APN，PCO和签约QoS配置文件，并把它转发给PGW。这时候，从UE接收到PCO域被透传给PGW。 3）【PGW】UE IP和P-CSCF地址分配 PGW为IMS APN分配UE IP，并选择P-CSCF的地址。 4）【PGW-&gt;PCRF】EPS会话建立的通知 PGW通过发送Credit-Control-Request (CCR)消息把用户签约QoS配置转发给PCRF，请求鉴权。 5）~6）【PCRF，SPR】用户配置获取 PCRF可以从SPR中获得用户签约配置文件，并使用配置文件来为语音服务决定PCC策略。 7）【PCRF】策略决定 基于签约配置文件，PCRF决定EPS会话的策略。这个实例中是SIP信令，选择“voice-C”作为PCC规则。“Voice-C” rule: QCI = 5, ARP = 6, APN-AMBR (UL/DL) = 100 Kbps, Charging Rule: Offline, SIP Packet Filter 8）【PGW&lt;-PCRF】PCC规则提供 PCRF转发PCC规则(“Voice-C”) 给PGW。 9）【PGW】策略实施 一旦接收到(“Voice-C”) PCC策略，PGW执行策略参数，并把SDF QoS参数映射到默认承载QoS参数上。 P-GW (SDF): QCI = 5, ARP = 6, MBR (UL/DL) = 100 Kbps/100 Kbps, SDF Template (UL/DL) = (UE IP, ,SIP, , UDP) /( , UE IP, SIP, , UDP) P-GW (Default Bearer): QCI = 5, ARP = 6, APN=AMBR (UL/DL) = 100 Kbps/100 Kbps, TFT (UL/DL) =(UE IP, , SIP, , UDP)/( , UE IP, SIP, , UDP) 10）【MME&lt;-SGW&lt;-PGW】对语音会话创建的响应 作为对step-2请求的响应，PGW发送Create Session Response消息给MME。这个消息包含提供的QoS配置文件和上行策略参数，都需要转发给UE。 11）【UE&lt;-MME】请求默认承载上下文激活 MME通过发送Activate Default EPS Bearer Context Request消息请求UE激活默认承载上下文。这个ESM消息包含APN，UE IP，P-CSCF地址，PGW提供的策略参数，是嵌入在attach accept消息中的。 12）【UE】策略执行：默认承载上下文激活 UE执行上行策略并激活默认承载上下文UE: QCI = 5, APN-AMBR (UL) = 100 Kbps, TFT (UL) = (UE IP, , SIP, , UDP) 13）【UE-&gt;MME】默认承载上下文激活的通知 UE通过发送Activate Default EPS Bearer Context Accept消息通知MME，用于传输SIP信令消息的默认承载上下文已经激活了。一旦SIP信令的默认承载建立完成，IMS鉴权和注册过程将紧接着执行。使用SIP协议的IMS过程在本文档的讨论范围之外，我们将会在volte文档中叙述。一旦IMS注册完成，UE准备发送/接收语音通话了。3.2 语音会话修改：专用承载建立一旦LTE附着和IMS注册完成，UE准备开始语音通话。但是，因为语音数据包需要实时传送，为SIP信令建立的默认承载提供的QoS不鞥呢满足语音数据包的QoS。所以，现在需要建立一个能盲足语音数据包QoS的新承载。对每一个语音通话，建立语音数据包的专用承载，通过语音会话修改过程。图4展示了专用承载是怎么建立的，一旦检测到语音通话根据新的PCC策略语音会话时如何修改的。在途中，当发起端UE请求语音通话，PCRF从SIP信令（session progress消息）知道请求的是语音通话。接着PCRF决定一个PCC策略“Voice-U” rule (QCI = 1, ARP = 7, GBR/MBR = 88 Kbps)，并把它转发给PGW，接着PGW创建GBR类型的专用承载。当发起端UE通过默认承载接收到对端UE的200 OK的SIP消息时，UE通过专用承载转发语音数据包。 1）【UE-&gt;P-CSCF】语音通话生成 发起端UE通过发送invite消息给IMS网络请求语音通话。详细的过程将会在IMS网络的文档中叙述。 2）【PCRF&lt;-P-CSCF】传送服务信息 一旦接收到这个SIP消息，IMS网络的P-CSCF就知道了请求的是语音电话。所以他发送一个AAR（AA-request）给PCRF，转发服务消息。这个AAR消息包含媒体信息，比如最大/最小带宽，IP数据流标识，codec等等。 3）【PCRF】策略决定 基于从P-CSCF接收到的服务信息，PCRF通过选择一个PCC规则和承载来决定EPS会话的策略。对于PCC规则，它选择voice-U规则来支持语音数据包。对于这个承载的QoS级别，选择QCI=1。由于语音数据包QoS不能被已经存在的默认承载的QoS支持，需要建立一个不同QoS等级的专用承载，接着修改EPS会话。“Voice-U” rule: QCI = 1, ARP = 7, GBR (UL/DL) = 88 Kbps/88 Kbps, MBR (UL/DL) = 88 Kbps/88 Kbps,Charging Rule: Offline, RTP Packet Filter 4）【PGW&lt;-PCRF】PCC规则提供 PCRF给PGW传输PCC规则(“Voice-U”) 5）【PGW】策略执行 一旦接收到这个PCC规则(“Voice-U”) ，PGW配置QoS和付费策略参数，并且把SDFQoS参数映射到专用承载QoS参数。 P-GW (SDF): QCI = 1, ARP = 7, GBR (UL/DL) = 88 Kbps/88 Kbps, MBR (UL/DL) = 88 Kbps/88 Kbps, SDF Template (UL/DL)=(UE IP, , RTP, , UDP) /(, UE IP, RTP, , UDP) P-GW (Dedicated Bearer): QCI = 1, ARP = 7, GBR (UL/DL) = 88 Kbps/88 Kbps, MBR (UL/DL) = 88Kbps/88 Kbps, TFT (UL/DL) = (UE IP, , RTP, , UDP)/(, UE IP, RTP, , UDP) 6）~7）【MME&lt;-SGW&lt;-PGW】专用承载创建请求 PGW给MME发送create bearer request消息来请求专用承载建立。这个消息 包含连接EPS承载标识LBI，专用承载ID，专用承载QoS和上行TFT信息。专用承载相关的信息包含LBI，是作为一个每一个专用承载所属的EPS会话的默认承载ID。从上图中，它是用语音会话的默认承载ID表示的。 8）【UE&lt;-MME】请求专用承载上下文的激活 MME通过发送activate dedicated EPS bearer context request消息来请求专用承载上下文的激活。在这个消息中包含PGW发送的策略参数。 9）【UE】策略执行：专用承载上下文的激活 UE执行上行策略，并激活专用承载上下文。UE: QCI = 1, GBR (UL) = 88 Kbps, MBR (UL) = 88K bps, TFT (UL) = (UE IP, , RTP, , UDP) 10）【UE-&gt;MME】通知专用承载上下文激活 UE通过发送activate dedicated EPS bearer Context accept消息通知MME，用于语音数据包的专用承载上下文已经激活了。 11）~12）【MME-&gt;SGW-&gt;PGW】专用承载创建的通知 MME给PGW通知专用承载已经创建了。 13）【PGW-&gt;PCRF】通知PCC策略已经适用 PGW给PCRF通知PCC规则已经执行了。IV. How Policy Control Affects the Way IP Packet Flows are Handled我们将学习了PCC策略是如何影响EPS会话中IP数据流的处理的。图5描述了EPS会话中UE产生的IP数据流。在图5a中，Internet流量通过为Internet服务创建的默认承载从Internet PDN传输。对于语音服务，SIP信令流通过为语音服务创建的默认承载在IMS PDN（PCSCF）传输。语音媒体流通过为语音服务创建的专用承载和呼叫对端之间传输。图6显示了应用于图5IP数据包流的策略控制。在途中，在图2中列出的策略参数在PGW中执行。PGW检测上下行的SDF，并对每一个SDF的每一个IP数据包执行策略控制。在EPS承载上，设置EPS承载QoS参数。 下行 IP数据包流到达PGW。根据PGW中设置的门状态，来自Internet和IMS网络的流量都是允许的。 SIP流量（APN=IMS）是i)由PGW的数据包过滤PF1作为SDF1检测的，ii）限制MBR（100Kbps）速率，iii）映射到默认承载，iv）限制APN-AMBR（100Kbps）。在eNB，流量时根据UE-AMBR的速率来调度的，并传送给UE。 语音流量（APN=IMS）是i）由PGW的数据包铝PF2作为SDF2来检测的，ii）保证GBR速率，iii）映射到专用承载，iv）再次保证GBR。在eNB，流量时以GBR调度的，并传送给UE。 Internet流量（APN=Internet）是i）由PGW的数据包过滤PF3作为SDF3来检测的，ii）不限制速率，iii）映射到默认承载，iv）保证APN-AMBR速率，不受限。在eNB，流量是以UE-AMBR来调度的，并传送给UE。 上行 IP数据包从应用层到达UE。上行IP数据包通过上行数据包过滤器(UL TFT; PF1, PF2, PF3)映射到相应的的承载，并对数据包适用每一个承载的QoS。接着转发给PGW，PGW适用数据包过滤器(SDF template; PF1, PF2, PF3)检测SDF，在应用SDF QoS之后转发到目的地。 SIP流量是i）在UE的PF1映射到连接IMS APN的默认承载，ii）限制MBR（100Kbps）速率，iii）发送给eNB。在PGW中，它是i）再次限制MBR（100Kbps）速率，ii）有PF1作为SDF1检测，iii）保证SDF MBR（100Kbps），iv）接着转发给IMS网络。 语音流量是i）在UE的PF1映射到连接IMS APN的专用承载，ii）以GBR发送给eNB，作为eNB调度。一旦到达PGW，它是i）有PF2作为SDF2检测，iii）保证SDF GBR（88Kbps）转发的。 Internet流量是i）在UE的PF3映射到连接Internet APN的默认承载上的，ii）保证APN-AMBR速率，不限制，iii）发送给eNB。一旦到达PGW，它是i）再次保证上行 APN-AMBR，ii）由PF3作为SDF3检测，iii）保证SDF MBR，不限制，iv）转发到Internet。 V. EPS entity information下面我们介绍在PCC规则在Internet和语音流量上执行之后每一个APN上EPS实体信息的变化情况。 5.1 Internet服务图7展示了对Internet服务流量执行PCC规则之后EPS实体中的信息。在初始接入Internet时，PCRF选择一个PCC规则“Internet”，并转发给PGW。接着PGW使用这个规则对Internet服务的EPS默认承载执行QoS参数。这个默认承载保持激活知道UEdetach。 5.2 语音服务图8展示了对语音服务榴莲根治性PCC规则之后保存在EPS实体中的信息。在实例中，一旦UE初始接入IMS网络，默认承载就建立了，就检测到了语音通话。在初始接入IMS网络时，PCRF选择一个PCC规则“voice-C”，PGW对SIP信令的EPS默认承载执行QoS参数。因为语音通话是在很短的时间内检测的，接着，PCRF选择voice-U规则，PGW对EPS专用承载执行QoS参数。 一旦语音通话结束，P-CSCF通知PCRF。接着PCRF发起EPS会话修改过程，把专用承载终止，删除UE/eNB/SGW/PGW中的专用承载上下文。但是，SIP信令的默认承载还是保持激活直到UE从LTE网络中detach。 VI. closing目前，我们已经学习了PCRF怎么决定PCC规则的以及当用户使用Internet和语音服务时PGW怎么执行规则的，并分析PCC规程。我们还学习了基于PCC规则PGW是怎么控制EPS承载的，并举例说明了策略控制是怎么影响IP数据包流的。这篇文档覆盖了PCC规则，集中在QoS策略。下一个文档我们将介绍付费，讨论付费信息和过程。 References[1] 3GPP TS 29.212, “Policy and Charging Control over Gx Reference Point”[2] Netmanias Technical Document, “LTE EMM Procedure 1. Initial Attach – Part 2. Call Flow of InitialAttach”, January 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6102[3] Netmanias Technical Document, “LTE QoS: SDF and EPS Bearer QoS”, September 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5908[4] Netmanias Technical Document, “Initial Attach procedure for VoLTE”, TBD[5] Netmanias Technical Document, “LTE Charging: Offline”, TBD[6] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[21-EMM Procedure - 10 & 11. Move to Another City and Attach]]></title>
    <url>%2F2016%2F04%2F03%2F21-EMM-Procedure-10-11-Move-to-Another-City-and-Attach%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6354 I. introduction随着UE的移动当服务小区的信号强度变弱时UE试图进行切换或者小区重选。如果在UE移动的周边没有邻区，信号强度将会逐步减弱直到UE最终从网络detach。接着一旦达到LTE覆盖区域，UE重选通过小区选择初始注册到网络。 这篇文档讨论当UE移动到一个LTE覆盖范围之外从网络detach，并移动到另外一个LTE网络重新attach到网络。 EMM case-10 move to another cityEMM case-11 initial attach in another city这两个EMM case，本文档假设移动运营商： 在不同城市服务 只有LTE-only网络，没有2/3G 每一个城市有MME SGW PGW HSS PCRF SPR仅仅安装在一个城市 所有的MME通过S10接口 图1显示了city1和city2，车里的用户从city1移动到city2.在EMM case10中，随着UE离开city1，UE从网络detach，移动出LTE覆盖范围。不论是connected 模式下使用服务还是在idle模式下驻留在服务小区，随着UE离开city1，UE被MME网络detach掉。 在EMM case11中，随着在city2 UE移动进入LTE覆盖范围，UE再次attach到网络。不像之前文档的情况，当UEattach 新的MME时，旧MME已经包含了UE上下文。UE初始附着到新MME上时就可以使用旧MME分配的UE ID。这样，UE就可以从detach 状态转换到connected状态。 这篇文档组织如下：第二章和第三章讨论EMM case10和11的过程。第四章将描述在这个过程前后EPS实体信息的变化。 II. EMM Case 10. Move to Another City2.1 在connected模式下移动在图2中，我们看到当在city1服务的UE是怎么移出LTE覆盖范围并从网络detach的。 1）【UE-&gt;eNB】测量报告随着UE离开city1，服务小区的信号强度变弱。随着A2事件的激活，UE给eNB发送measurement report消息通知服务小区的信号强度。 2）【eNB】没有邻区来切换enB没有找到供UE切换的邻区。 3）【eNB-&gt;MME】错误指示因为糟糕的通信质量，在无线接口上传送失败。eNB通过发送error indication(Cause=Failure in the Radio Interface)给MME通知这个失败。如果eNB发现和UE之间很难保持最低的质量，eNB将给MME发送UE context release request消息。 如果UE因为糟糕的通信质量丢失了RRC连接，UE试图RRC连接重建。如果这个质量的衰减是暂时的，为了正常的无线通信允许RRC进行重建。但是服务提供会中断。如果这个质量衰减是持续的，RRC连接重建将会持续失败，最终导致连接丢失。 假设i）当eNB和UE之间的RRC连接还持续有效，eNB给MME发送error indication。ii）因为UE当前服务小区位于城市边界，并且没有邻区切换，MME决定detach掉UE。所以由MME触发detach过程。 4）MME发起detachMME通过发送detach request消息执行detach过程。这里的过程和之前文档中介绍的MME发起显式detach过程是一样的。MME存储UE的GUTI和NAS安全上下文，结束EPS会话，释放S1信令，并转移到detach状态。UE存储自己的GUTI和NAS安全上下文，删除EPS会话承载上下文，并转移到detach状态。 2.2 在idle模式下移动idle模式下的UE会周期性的通过TAU报告自己的位置给网络。当UE有电话或者数据到来，MME不知道idle模式下的UE是否可达的。为了这个原因，idle状态下的UE即使处于TAI列表中的TA也需要周期性的报告自己的位置，这样网络可以知道UE是否可达的。MME有一个TAU定时器T3412, 手机可达定时器，和隐式detach定时器。TAU定时器的值是在UE初始附着到网络时通过attach accept消息转发给UE的，或者当UE做TAU request时通过TAU accept消息发给UE的。 TAU定时器默认是54分钟，如果MME设置这个值为0，UE就不激活TAU 定时器，并不执行周期性TAU。当UE从connected状态到idle状态转换时UE的TAU定时器激活。当这个定时器超时，UE转移到connected状态给MME发送TAU request消息通知UE是可达的，接着转移到idle状态，并重启TAU定时器。UE在从idle状态到connected状态转移时停止这个定时器，或者从网络detach时停止定时器。如果MME为了UE超时设置的TAU定时器，MME立刻接收到了TAU request消息，通过这个消息MME可以跟踪UE的位置。接着，MME分配新的TAI列表，并重启TAU定时器。也就是说网络会在每一个TAU定时器周期结束时检查UE是否可达，并设置paging proceed flag为1，标示UE是可达的。 如果UE有任何问题，比如UE在T3412定时器超时时在一个阴影区域并不可达，UE在T3412超时时发起TAU request，就导致不能给MME通知自己的位置。当TAU失败时UE需要重新尝试。所以，如果UE很快从阴影区域移出，接着重选尝试TAU请求成功了。但是如果UE一直待在阴影区域，TAU 请求过程一直失败。 网络使用手机可达定时器来检查UE是否可达。和T3412 TAU定时器相比，有稍微更大的值，默认是T3412+4分钟。当在ECM连接释放时这个定时器开始，当一个新的ECM连接建立时停止定时器。 当手机可达定时器超时，MME知道UE在已经移除LTE服务区域，但是不知道移除覆盖状态需要持续多长时间。所以为了不立即删除UE上下文，MME清除PPF flag并开启隐式detach定时器。当PPF flag清除时，UE是本地detach的。也就是说当隐式detach定时器运行时，网络仍旧保持UE上下文没有删除，但是MME不会寻呼UE。即使当SGW有到达UE的电话或者数据包，SGW给MME发送downlink data notification时，MME拒绝这个消息。 当UE发送NAS消息，建立ECM连接，隐式detach定时器停止。如果MME在隐式detach定时器超时不能定位UE，MME相信UE已经长期到了LTE覆盖范围外，并从网络把UEdetach掉。现在网络中的UE上下文删除。 图3描述了UE在city1服务小区上驻留，随着移出LTE覆盖从网络detach的过程。 1）【MME】TAU定时器T3412超时UE设定的TAU定时器超时，MME没有收到从UE的TAU request消息，并必须检查UE是否可达 2）【MME】手机可达定时器超时UE的手机可达定时器也超时了。MME相信UE是在覆盖区外的状态，并清除PPF flag并开启隐式detach定时器。分配给UE的EPS承载安全上下文资源保持有效，但是MME不会寻呼UE。 3）【MME】手机隐式detach定时器超时UE的隐式detach定时器超时。MME相信UE已经长期在覆盖范围之外，并决定从网络隐式detach掉UE。 4）【eNB，MME，SGW，PGW，PCRF】UE detachedMME发起隐式detach过程。这个过程和之前文档中的MME发起的隐式detach过程意义昂。分配给UE的而资源和上下文都被删除了。 III. EMM Case 11. Initial Attach in Another City这章描述UE移动到city2，进入LTE覆盖，并选择一个新的小区，执行初始attach，从detach状态转移到connected状态。我们假设UE已经通过MME发起的隐式detach过程从city1的网络中detach掉了，所以在UE和网络MME1中的old GUTI和NAS安全上下文都保持有效。 图4显示了在city2UE初始附着过程的初始附着的类型和功能模块。这个初始附着类型和attach case-5中的类型是一样的。也就是说UE成功从网络detach，UE和old MME中都保留有效的old GUTI和NAS安全上下文，接着UE使用这些参数向new MME做初始attach。UE使用old GUTI作为ID发送attach request消息。这个消息是使用NAS完整性秘钥完保的。这个new MME转发这个消息给old MME，因为old MME可以做完整性检查。 在这篇文档中，假设在old MME上完整性检查通过了。new MME在从old MME获得包括IMSI的上下文后，执行位置更新和EPS会话建立过程。如果在old MME上完整性保护失败，old MME将给new MME发送error消息，接着UE获得IMSI并执行用户鉴权，NAS安全建立，位置更新和EPS会话建立过程。 图5描述了UE在city2的new MME上执行初始附着的过程。 1）【UE，eNB】建立RRC连接一旦进入city2，UE检测到LTE信号，选择一个新的小区，并向eNB请求RRC连接。 2）【UE，new MME】使用old GUTI向new MME请求初始附着UE向MME2发送attach request消息 (Old GUTI, Last Visited TAI, KSIASME, NAS-MAC)，使用oldMME分配的old GUTI作为UE ID。这个罅隙是使用Knasint完整性保护的，通过在无线接口上的RRC connection setup complete消息发送，并在S1接口上的initial ＵＥmessage消息发送。 3）【new MME】标识old MMEMME2通过接收到的initial UE message消息检查UE的位置，并从old GUTI中知道它是由old MME1分配的。接着MME2检查在S10接口上和MME1使用old GUTI是否有效，并获得存储在MME1中的UE上下文。 4）~6）【old MME，new MME】从old MME中获得UE上下文4）new MME（MME2）把接收到的attach request消息和old GUTI包裹在identification request消息(Old GUTI, Complete {Attach Request} message from UE)中发送给old MME（MME1）。 5）当接收到new MME的这个消息，oldMME知道这个GUTI是自己分配的，接着通过保留的UE安全上下文对UE发送的attach消息执行完整性检查，完整性检查通过。 6）完整性保护成功后，old MME给new MME通过identification response消息(IMSI, UE-AMBR, UE Security Context (KASME, KSIASME, Unused AVs, NAS Keys, etc))发送无上下文。new MME获得UE上下文。 7）~10）【old MME，new MME，HSS】在new MME更新位置信息，并在old MME中删除7）MME2现在具有了有效的UE上下文，给HSS发送update location request消息(IMSI, MME ID=MME2)来在MME2上注册UE。通过这种方式，MME2给hss通知包含IMSI的UE已经注册上MME2了。hss更新UE新的位置。 8）hss给MME1发送 cancel location request（IMSI）消息来要求MME1删除UE上下文，MME应要求删除UE上下文。 9）MME1通过发送cancel location response（IMSI）消息给hss通知UE上下文已经删除了。 10)HSS通过发送update location answer(IMSI, APN, Subscribed Profile (QCI, ARP, APNAMBR (UL/DL), UE-AMBR (UL/DL))给MME2提供UE的签约配置信息，包括签约QoS信息。所以MME2可以建立EPS会话了。 11）【new MME】建立EPS会话MME2通过使用从MME1接收到的UE上下文和从hss获得签约配置文件建立EPS会话。这个过程和之前文档中叙述的EPS会话建立过程一样。 IV. EPS Entity Information在EMM case10移动到另外一个城市过程的前后EPS实体信息的变化如下所示： before 如果UE在connected状态，保持和初始附着过程后存储的信息一样。 如果UE在idle状态，保持和S1释放过程后存储的信息一样。 after UE从网络detach。EPS实体中存储的信息和detach过程后存储的信息一样。 在EMM case11在另外一个城市初始附着前后EPS实体信息的变化如下所示： before：UE从网络detach，和detach过程后存储的信息一样。 after：UEattach到网络，存储的信息和初始附着过程后的信息一样。 V. Closing这篇文档讨论了UE移出LTE覆盖范围之外，UE怎么和新的MME建立初始附着的。这个场景的目的是介绍使用old GUTI初始附着的过程。所以实际移动到另外一个城市的过程将根据不同运营商怎么配置网络和对网络节点的实现。韩国的LTE网络时全国的，所以LTE服务是任何地方可用的。所以LTE覆盖空洞可以在低无线质量的地方找到。实际中，LTE有邻区，LTE or 2/3G。实体网络中，UE执行切换到邻区或者小区重选而不是从网络detach。 References[1] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[2] Netmanias Technical Document, “LTE EMM Procedure 2. Detach”, January 2014,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6108[3] Netmanias Technical Document, “LTE EMM Procedure 1. Initial Attach – Part 2. Call Flow of InitialAttach”, January 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6102[4] 3GPP TS 36.413, “Evolved Universal Terrestrial Radio Access Network (E-UTRAN); S1 ApplicationProtocol (S1AP)”.[5] Netmanias Technical Document, “LTE EMM Procedure 5. Periodic TAU”, February 2014,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6193[6] Netmanias Technical Document, “LTE EMM Procedure 1. Initial Attach – Part 1. Cases of InitialAttach”, December 2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6098[7] Netmanias Technical Document, “LTE Identification II: NE and Location Identifiers”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5906[8] 3GPP TS 23.401, “General Packet Radio Service (GPRS) enhancements for Evolved UniversalTerrestrial Radio Access Network (E-UTRAN) access”.[9] Netmanias Technical Document, “LTE EMM Procedure 3. S1 Release”, January 2014,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6110[10] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20-EMM Procedure 8&9. Handover & Cell Reselection with TAU]]></title>
    <url>%2F2016%2F04%2F03%2F20-EMM-Procedure-8-9-Handover-Cell-Reselection-with-TAU%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6324 I. Introduction当UE接入网络时，MME通过TAI列表分配一组TA。UE在这些TA中移动不需要给网络报告自己的位置。网络不知道UE驻留在哪个小区，但是知道在哪个TA。所以如果idle状态的UE有电话或者数据包到达，网络在UE注册的这些TA中发起寻呼。分配给UE的TAI列表是UE已经注册的区域列表。当UE移动到不在TAI列表中的TA时，UE必须执行TAU过程来请求TA更新，网络就可以更新UE的TAI列表并分配更新过的列表。 这篇文档描述的是UE移动到没有注册过的TA时的过程（EMM case-8）。在这个case-8中，在连接模式(EMM-Registered, ECM-Connected, RRC-Connected)的UE移动到另外一个TA。在这个移动过程中，从source eNB到target eNB的切换过程如EMM case-6一样。不同的地方在于，UE接着需要在target eNB的新小区上执行TAU过程。在idle模式(EMM-Registered, ECM-Idle, RRC-Idle)状态下的UE移动到另外一个TA时，服务小区重选的过程和EMM case-7一样。不同的是，在小区重选后，必须在UE新驻留的小区上进行TAU过程。 这个文档组织如下：第二章解释EMM case-8过程，第三章描述EMM case-9过程，在第四章我们学习在这些过程前后EPS实体的信息有什么不同。 II. EMM case 8. handover with TAU图1展示了连接模式下的UE移动到没有注册过程的TA时执行的过程。当UE初始附着到网络，MME为UE选择TA1和TA2，并在attach accept消息中包含TAI列表={TAI1=1,TAI=2}。UE通过eNB2 cell5获得服务。现在移动到TA3 eNB5 cell13。这里我们假设eNB2和eNB5连接到同一个MME和SGW。 handover在上图中，随着UE移动到eNB5，handover事件触发。UE测量服务小区和邻区的信号强度，并把结果发送给eNB2，包含在measurement report消息中。首先source eNB选择切换的类型 X2 or S1.在X2切换中，是source eNB选择target eNB，而在S1切换中是MME选择target eNB。接着切换在eNB2和eNB5之间执行。 TAU1）【UE-&gt;MME】TAU request当切换到target eNB时，UE知道eNB5不属于MME分配的TAs，接着只要切换一完成，UE就发送TAU request消息(Update Type=TA Updating, GUTI, Last Visited TAI, KSI ASME, NAS-MAC)给MME，请求TA更新。这时，这个消息包含如下信息：TAU Request (Update Type=TA Updating, GUTI, Last Visited TAI, KSI ASME, NAS-MAC) Update Type: indicates the TAU type. Set as TA Updating unless UE is handed over to a registered TA GUTI: UE ID previously allocated by MME. Used by MME for UE identification. Last Visited TAI: TAI reported through TAU Request last time KSIASME: index for KASME, the NAS security base key NAS-MAC: message authentication code used in protecting the integrity of TAU Request with NAS integrity Key (KNASint). TAU消息通过UL information transfer消息从 UE发送到eNB，通过uplink NAS transfer消息(NAS-PDU (TAU Request), ECGI, TAI)从eNB发送到MME。uplink NAS transfer消息包含TAU请求消息和当前小区的ECGI和TAI发送给MME。因为UE和MME之间的NAS安全上下文已经建立起来了，TAU request消息是使用NAS完成性保护秘钥完保的。如果MME对接收到的TAUrequest消息完成性保护检查失败，MME执行用户鉴权和NAS安全建立过程。在这个文档中，我们仅仅讨论MME成功完成完整性检查。 2）【MME】TA 更新：分配新TA因为UE移动到没有注册过的TA上，MME选择一组TA分配给UE，并为UE配置一个新的TAI列表。这是，也要分配一个新的GUTI。 3）【UE&lt;-MME】TAU acceptMME发送新选择的TA包含在TAU accept消息中(GUTI, TAI List)。这个消息是加密和完成性保护的，通过downlink NAS transfer消息从MME到eNB传输，接着通过DL information transfer消息从eNB传输给UE。 4）【UE-&gt;MME】TAU complete如果分配了一个新的GUTI，UE给MME发送TAU complete消息来确认收到了新的GUTI。 一旦TAU过程完成，UE现在具有了一个新的TAI列表，并通过eNB5获得服务。 III. EMM case 9. cell reselection with TAU图2显示了idle模式下的UE移动到一个没有注册的TA时需要的小区重选过程。在图中，UE驻留在eNB2的cell5,移动到eNB5的cell13。 cell reselection1）~7）【UE】小区重选UE移动eNB5触发小区重选。UE测量邻区并排序，基于结果，选择满足消息重选准则的eNB5 cell13作为最合适的小区。这里的小区重选过程和之前文档介绍的一样。 TAU当选择了eNB5 cell13，UE知道这个小区不属于之前分配TA中。所以，UE一旦完成重选过程就执行TAU过程。TAU过程和之前的描述的EMM case-5一样。不同之处在于谁发起的TAU过程。对于周期性TAU过程，UE因为TAU定时器T3412的超时执行TAU给网络报告当前位置。然而，对于上面给到的TAU，则是因为UE移动到一个没有注册的TA时UE执行TAU。所以这是TAU request消息的TA更新类型是TA updating而不是periodic updating。TAU过程简要叙述如下： 8）【UE-&gt;MME】TAU requestUE通过发送TAU request消息(Update Type=TA Updating, GUTI, Last Visited TAI, KSIASME, NAS-MAC)给MME来请求TA更新。这个TAU request消息和第二章包含相同的信息。这个消息也是使用NAS完整性秘钥完保的。UE和eNB建立RRC连接，并发送这个消息，接着从idle 状态转到connected状态。 9）【MME】TA update：分配新的TA一旦通过uplink NAS transfer消息接收到TAU request消息，MME从uplink NAS transfer消息中的TAI标记处UE当前驻留的哪个TA，并在TAU request消息包含的last visited TAI知道上次报告的TA。因为UE当期驻留的TA不是之前MME分配的TA，MME允许新分配一个TA集合最适合UE当前位置和速度。对于快速移动的UE，分配大范围的TA来减少由TAU引起的信令负载。当时，这样，由寻呼引起的心灵负载就会增加。寻呼消息将需要更长时间。所以为了每一个UE分配不同TAI，在TAU信令和寻呼性能之间的权衡应该考虑。MME更新last visited TAI包含在和UE当前TAI的UE上下文中。 10）【MME，SGW，PGW，PCRF】EPS承载/会话修改一旦UE位置改变，MME通过发送modify bearer request消息通过SGW这个变化。是否需要MME给PCRF报告TA的变化，包含UE初始附着建立EPS会话时从PCRF接收到的change report action参数中。会话修改构成执行，报告给PCRF TA的改变。 11）【UE&lt;-MME】TAU acceptMME通过tau accept消息给UE发送新的TAI列表。这是，这个消息和第二章包含相同的信息。并且也是完整性保护和加密的。 12）~14）【UE，eNB，MME】转移到idle状态在TAU过程之后，MME释放S1连接，接着释放eNB5和MME之间的S1信令连接、eNB5释放和UE之间的RRc连接。现在UE和MME之间的ECM连接都移除了。并返回到idle摸下。 15）【UE】驻留在cell13一旦返回到idle状态，UE驻留在cell13，现在，在每一个DRx周期结尾处UE醒来测量cell13的信号。 IV. EPS实体信息handover with TAU过程前后存储在EPS实体中的信息和handover without TAU的一样。只有TAI的信息由于TA更新发生了变化。cell reselection with TAU过程前后存储在EPS实体中的信息和cell reselection without TAU一样。只有TAI的信息由于TA更新发生了变化。 V. closing我们到目前为止讨论了UE移动到一个在注册TA中的切换和小区重选过程。我们学习到通过切换或者小区重选过程，UE通过TAU过程获得了新的TAI列表。下面的文档将讨论UE移动到另外一个城市，包含从城市1detach，在城市2 attach。 References[1] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[2] Netmanias Technical Document, “LTE EMM Procedure 6. Handover without TAU – Part 1. Overview ofHandover”, March 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6224[3] Netmanias Technical Document, “LTE EMM Procedure 6. Handover without TAU – Part 2. X2Handover”, March 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6257[4] Netmanias Technical Document, LTE EMM Procedure 6. Handover without TAU – Part 3. S1Handover”, April 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6286[5] Netmanias Technical Document, “LTE EMM Procedure 7. Cell Reselection without TAU”, April 2014,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6322[6] Netmanias Technical Document, “LTE EMM Procedure 1. Initial Attach – Part 2. Call Flow of InitialAttach” , January 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6102[7] Netmanias Technical Document, “LTE EMM Procedure 5. Periodic TAU”, February 2014,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6193[8] Netmanias Technical Document, “LTE EMM Procedure 3. S1 Release”, January 2014,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6110[9] Netmanias Technical Document, “LTE EMM Procedure 10 &amp;11. Move to Another City and Attach”,May 2014, TBD[10] 3GPP TS 23.401, “General Packet Radio Service (GPRS) enhancements for Evolved UniversalTerrestrial Radio Access Network (E-UTRAN) access”[11] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19-EMM Procedure 7. Cell Reselection without TAU]]></title>
    <url>%2F2016%2F04%2F03%2F19-EMM-Procedure-7-Cell-Reselection-without-TAU%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6322 I. Introduction通过前面三篇文档，我们学习了EMM case-6 handover without TAU。这篇文档我们描述在idle模式下的UE是怎么重选小区的。切换控制的是连接态的UE的移动性，小区重选是控制idle状态下UE的移动性。在切换时，是网络决定要切换到哪个小区，在小区重选中，是UE决定驻留在哪个小区。 小区重选过程可能是图1中的两种类型之一。在图1中UE驻留在cell-5，属于MME分配的{TA1，TA2}这个TA列表里，并处于idle状态。 cell reselection without TAU（7）：UE移动到TA列表中的一个TA时，例如图1的TA2，执行小区重选但是不执行TAU。 cell reselection with TAU（9）：UE移动到不属于TA列表中的一个TA时，例如图1的TA3，在小区重选后，需要执行TAU。 UE可能重选到一个小区i）和当前驻留的服务小区使用相同的LTE频率，ii）和当前小区不使用相同的频率，iii）使用另外的RAI接入（inter-RAT）。在图1中小区重选的实例中，我们只讨论intra-frequency小区重选，即使用同单一LTE频率。这篇文档只描述case-7的情况。case-9的情况在下面的文档中叙述。在第二章，我们将描述小区重选过程需要的准备信息。第三章描述不带TA过程的小区重选的详细过程。 根据之前的LTE文档，当UE在attach完成后处于idle模式下（EMM-Registered, ECM-Idle, RRCIdle）: UE IP地址保持有效，在EPC中EPC承载保持有效。 EPC（MME）知道UE的存在，但是E-UTRAN不知道。 UE是在TA级别被MME知道的 当UE移动到不在TA列表的TA时执行TAU过程，并给MME通知自己的TA位置。 UE cannot send it generates？？？？？ 如果有发往UE的数据，MME在UE所在的整个TA区域内寻呼。 UE周期性的唤醒并检查是否有寻呼消息。 当驻留在一个小区上，UE在idle状态： 接收eNB广播的系统消息 接收寻呼信号，并对paging消息响应 周期性的测量服务小区的信号强度 当小区重选触发时测量邻区的信号强度并重选到一个小区 如果重选到一个不在TA列表中的TA时发起TAU过程。 II. Cell Reselection: Required System Information and Criteria在我们详细学习第三章的小区重选过程之前，我们先简要介绍一下小区重选。接着我们学习这个过程需要的系统信息和小区重选的准则。 2.1 小区重选过程概述UE控制小区重选过程。UE从eNB广播的系统消息中获得小区重选相关的信息（决定是否测量邻区信号强度的门限值，计算服务小区和邻区的排行的参数）。在intra-frequency小区重选中，需要的信息包含在SIB3和SIB4中。 小区重选触发服务小区测量：idle状态的UE在每一个DRX周期的结尾处醒来测量服务小区的信号（Qrxlevmeas）并计算服务小区的接收信号水平（Srxlev）来决定是否待在这个当前小区还是移动到另外的小区。这里，UE的发射和接收条件都反映在计算中，例如通过应用最小接收信号水平（Qrxlevmin）允许最大发射功率水平Pemax等等。小区重选触发：如果服务小区的接收信号水平（Srxlev）比指定的门限值（s-IntraSearch）搞，UE待在当前的服务小区。如果不是，UE触发小区切换过程。这个门限值通过SIB3传输作为触发判决条，在rel-8中定义为s-IntraSearch，在rel-9中定义为s-IntraSearchP和s-IntraSearchQ。 当UE处于相同的位置，在idle状态的UE在每一个DRX周期结尾醒来去测量服务小区的接收信号水平，我们假设UE驻留在相同的服务小区，因为这个小区的接收信号水平比设定的门限s-IntraSearch持续的低。如果UE离开这个服务小区，这个小区的接收信号水平就会很快的降低，最终，当接收信号水平低于门限s-IntraSearch时，触发小区重选过程。接着UE开始测量邻区的信号强度。 小区重选准则小区排序准则：UE基于服务小区(Qmeas,s)和邻区(Qmeas,n)测量信号强度来对每一个小区排序(Rs, Rn)。小区排序需要的参数从SIB3和SIB4接收。服务小区使用SIB3中的q-Hyst这个迟滞值来排序，而邻区使用SIB4中的q-OffsetCell这个偏移值进行排序。小区重选：一旦服务小区和邻区排序，UE检查小区重选准则是否满足(Rn &gt; Rs)。如果邻区满足这个准则，UE选择最好的满意小区，接着驻留在那里。小区重选仅仅在(t-ReselectionEUTRA)时间内持续满足才会执行。 移动运营商会阻止太频繁的小区重选，通过这个迟滞值和小区特定偏移值可以通知UE在服务小区的驻留时间，根据这个小区状态来执行重选。另外，他们也会控制 q-Hyst and t-ReselectionEUTRA通过根据UE的移动速度来使用合适的(q-hystSF, t-ReselectionEUTRA-SF)。 2.2 系统信息系统信息是由eNB广播的信息，包括MIB和SIB。MIB，SIB1和SIB2是必须的，其他的是可选的。所有的系统信息像MIB SIB1或系统信息都是通过RRC消息传送给UE的。一个系统信息包括一组SIB（SIB2-16），除了MIB和SIB1。 UE基于eNB广播的系统消息来执行小区重选的。MIB SIB1 SIB2是适用于所有的UE，不论是connected模式还是idle模式下。相反的，SIB3-8仅仅只用于idle模式下的小区重选。表1描述了不同的系统信息和他们的参数。 我们假设两个移动运营商A和B，他们的网络工作如下：A：全国的LTE-only网络 LTE 频率：在1.8GHz仅仅有10MHz的一个信道(lteFA1)B：有全国的3G和LTE网络 3G频率：2.1GHz上的5MHz的六个信道 LTE频率：1.8GHz上的10MHz的一个信道，850MHz上的10MHz的另一个信道(lteFA1, lteFA2) 对于运营商A，它的eNB需要小区重选的intra-frequency相关的信息（eNB广播SIB3，SIB4，但是不广播SIB5/6/7/8）另外，对于运营商B，它需要所有的三种类型的重选信息，intra-frequency，inter-frequency，inter-RAT相关的信息（eNB广播SIB3/4/5/6） 由eNB广播的系统是通常应用于所有的UE，但是每一个根据自己的能力（release9 UE还是release11UE）来接收不同类型的系统信息。 图1描述了UE驻留在eNB2下的cell-5和它的邻区，图2只显示了eNB。 在图1中的网络时LTE-only网络，使用但是home PLMN的单一频率(lteFA1)。这篇文档只关心intra-frequency的小区重选过程。和intra-frequency重选相关的系统信息是通过SIB3和SIB4广播的。表2描述了这两个SIB的参数，但是他们和其他频率，RAT，VPLMN无关。 2.3 小区重选准则尽管不在本篇文档范围内，下面我们将简要看下在UE开机后小区重选使用的准则。下面只适用一个准则。表3提供了这个准则中参数的详细描述。 在初始小区选择是，小区接收限号水平(Srxlev)必须比Qrxlevmin和PCompensation的和要大。Srxlev要比Qrxlevmin要大，因为为了使UE正确的接收服务小区的信息，测量的信号强度必须至少大于Qrxlevmin。UE的发射功率低于UE在小区中允许的最大值Pmax将导致P-Compensation变大，使得更难选择这个小区。当选择一个小区时，UE的发射和接收条件是在考虑范围的。 在release9的情况下，增加量Squal作为小区选择准则。Qrxlevmeas是小区参考信号接收功率RSRP，而Qqualmeas是小区的参数信号接收质量RSRQ。RSRP只是接收信号的强度，而RSRQ提供关于无线链路质量更准确的信息，因为它指示信号和干扰噪声比，SINR。 小区重选触发UE一旦驻留在服务小区将一直驻留在那儿，如果服务小区的接收水平满足2-1或者2-2，UE将不需要进行测量。 在上述的不等式中，SintraSearch, SintraSearchP and SintraSearchQ是通过SIB3给出的，如果服务小区不满足前面的准则，即是它满足3-1或者3-2准则，UE开始为了小区重选进行小区测量。小区重选准则小区排序准则如果服务小区的测量Srxlev满足3-1或者3-2，UE开始测量邻区的RSRP，基于测量的结果，UE会应用4-1或者4-2进行排序。 小区重选如果有多个小区满足下面的准则，UE会选择最好的小区，并驻留在上面。 像在之前4=1或者4-2看到的，Rs和Rn是使用不同的准则进行计算的。Qhyst and Qoffset这两个值越大，UE停留在服务小区的时间越长。 III. procedure for cell reselection without TAU图3描述了EMM case-7，在图1中，UE选择cell-5满足1-1或者1-2，在通过cell-5初始附着到网络后由MME分配了一个TA列表{TA1, TA2}。接着在cell-5被服务，转移到idle状态，并一直驻留在cell-5。图3描述了驻留在cell-5上的UE怎么执行intra-frequency小区重选转移到eNB4下的cell-10的。这里UE的移动性状态为normal，所以不考虑比例因子。需要测量邻区4/6/10/13，但是图3为了描述的方便仅仅显示了cell-10和cell-13。第三章我们将详细秒后苏intra-frequency小区重选过程。必须满足一下条件。 驻留在服务小区：UE驻留在cell-5 小区重选触发：因为UE移出服务小区，小区重选触发。1、服务小区测量：服务小区的测量决定是否测量邻区，2、邻区测量：为了小区重选要测量邻区。 小区重选准则：1，小区排序：小区基于服务小区和邻区的测量结果来进行排序，2，小区重选：识别出满足准则的小区，并选择最好的。 驻留在新的小区，UE驻留在cell-10. 1）【UE】UE驻留在服务小区UE驻留在哎服务小区并保持idle状态 2）【UE】从服务小区获得系统信息UE从服务小区获得关于小区重选的系统信息。如果每一个邻区和服务小区由不同的偏移值，服务小区通过SIB4提供给UE邻区列表。接着UE通过SIB3和SIB4获得下面的信息： 决定小区重选触发需要的参数：q-RxLevMin, p-Max, sIntraSearchP, s-IntraSearchQ, t-ReselectionEUTRA, q-QualMin (SIB 3) 服务小区排序需要的参数：q-Hyst (SIB 3) 邻区排序需要的参数：q-OffsetCell (SIB 4) 3）【UE】测量服务小区的信号强度在每一个DRX周期结尾处，UE醒来并测量服务小区的信号(RSRP and RSRQ)获得Qrxlevmeas and Qqualmeas。接着，基于他们，计算出小区重选接收水平Srxlev和小区重选质量水平Squal。UE通过应用3-1或者3-2，检查UE应该重选到那个小区或者继续驻留在当前小区。例如，如果Srxlev和Squal不满足准则，UE继续驻留在当前小区，否则，执行下一步。 4）【UE】测量邻区UE测量具有和当前服务小区相同频率的邻区的RSRP。 5）【UE】小区排序准则一旦测量完RSRP，UE对服务小区和邻区进行排序，服务小区的排序R5，邻区的排序R4/6/10/12分别基于4-1和4-2。 6）【UE】小区排序比较现在UE比较R5和Rn，检测准则5是否满足。如果每一个小区满足5，UE继续驻留在cell5，在途中，cell10和cell13满足准则。 7）【UE】选择一个新小区UE比较两个满足准则的小区，R10和R13，并选择最好的一个R10作为新的服务小区。 8）【UE】驻留在新的小区上UE驻留在cell10上，在接收cell10广播的SIB1后，UE知道cell10所在的TA在TAI列表中。因为这个新的服务小区主语UE注册过的TA列表，不需要执行TAU过程。接着，UE在每一个DRX周期结尾处醒来监控cell10的系统信息和寻呼信息，并测量cell10的信号。 IV. EPS Entity Information: Before/After Cell Reselection without TAU这章描述在小区重选过程前后EPS实体信息的变化情况。在重选过程前后UE在idle状态下，MME也保持在idle状态下。UE从cell5移动到cell10，没有执行TAU过程。在小区重选后，EPS实体中的信息保持不变，和在S1释放后保持的信息相同。如图4所示。 V. Closing我们学习了UE在idle状态下移动到UE注册过的TA中，并在不执行TAU的情况下进行小区重选过程。这个文旦仅仅描述了intra-frequency过程。多数的移动运营商有多个LTE频点。他们也可以和2/3G进行互操作，所以不仅仅有intra-frequency小区重选，而且还有inter-frenqucy和inter-RAT小区重选。在接下来的文档中，我们将讨论执行TAU的小区重选过程。 References[1] Netmanias Technical Document, “LTE EMM Procedure 6. Handover without TAU – Part 1. Overview of Handover”, March 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6224[2] Netmanias Technical Document, “LTE EMM Procedure 6. Handover without TAU – Part 2. X2 Handover”, March 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6257[3] Netmanias Technical Document, “LTE EMM Procedure 6. Handover without TAU – Part 3. S1 Handover”, March 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6286[4] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[5] 3GPP TS 36.304, “Evolved Universal Terrestrial Radio Access (E-UTRA); User Equipment (UE) Procedures in Idle Mode”[6] Netmanias Technical Document, “LTE EMM Procedure 8 &amp; 9. Handover and Cell Reselection with TAU”, 2014, TBD[7] Netmanias Technical Document, “LTE EMM and ECM States”, September 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5909[8] 3GPP TS 36.331, “Evolved Universal Terrestrial Radio Access (E-UTRA); Radio Resource Control (RRC); Protocol Specification”[9] 3GPP TS 36.101, “Evolved Universal Terrestrial Radio Access (E-UTRA); User Equipment (UE) Radio Transmission and Reception”[10] Netmanias Technical Document, “LTE EMM Procedure 3. S1 Release”, January 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6110[11] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18-EMM Procedure 6. Handover without TAU - Part 3. S1 Handover]]></title>
    <url>%2F2016%2F04%2F03%2F18-EMM-Procedure-6-Handover-without-TAU-Part-3-S1-Handover%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6286 I. Introduction之前的文档，我们讨论了X2切换，这篇文档我们关注在EPC干预下的S1切换。这里，我们假设source和target eNB连接在同一个MME/SGW，并且位于UE的TAI列表中的同一个TA下。第二章我们描述S1切换的概念，第三章我们详细描述S1切换，最后第四章我们总结在S1切换前后EPS实体信息的变化。 II. Concept of S1 Handover2.1 S1协议栈S1切换是通过S1接口source和target eNB之间执行的。在控制面eNB和MME通过S1AP信令通信，在用户面eNB和SGW通过GTP隧道通信。图1显示控制面和用户的S1接口上的协议栈。 当安装一个新eNB时，就需要在eNB和MME之间执行S1 setup过程。eNB通过发送S1 setup request(eNB ID, eNB Name,TAC)给MME通知eNB配置信息。在MME中也会使用相应的 MME容量参数 用于MME间的负载均衡。这个值被标记为权值，表示每一个MME处理UE连接的相对容量。eNB连接不止一个MME，当选择一个MME建立新的UE连接时使用这个值。eNB和EPC之间的UE连接如下：在控制面，eNB和MME之间每一个用户的信令都是通过S1AP信令连接提供的，并使用{eNB UES1AP ID, MME UE S1AP ID}标识，在用户面，eNB和SGW之间的每一个用户的S1承载都是通过GTP隧道来提供，并使用{DL S1 TEID (S1 eNB TEID), UL S1 TEID (S1 SGW TEID)}标识。 2.2 和切换相关的S1AP过程和消息表1和2是在GPP TS 36.413中S1AP的基本过程，包含non-UE和UE相关的过程。这个文档是和切换相关的，所以这里只讨论UE相关的过程。表1列出了S1切换相关的S1AP过程和他们相关的S1AP消息。 列在上表中的这些S1AP消息在下面详细介绍： Handover Required message : 这个消息用于切换准备阶段，由eNB发送给MME，包含target eNB的信息和source cell的无线资源。 Handover Request message : 这个消息在切换准备阶段使用，由MME发送到target eNB，包含UE上下文信息。 Handover Request Acknowledge message : 这个消息是在切换准备阶段使用的，它是当在target eNB中成功为UE分配资源时由target eNB发送给MME。target eNB分配DL S1 TEID供S1承载在切换后使用，并分配DL S1 TEID供S1承载(indirect tunnel)用于在切换时下行数据包的传送，包含在这个消息中转发他们。 handover command message ：这个消息用于切换准备阶段，是由MME发送给source eNB。它包含了UE接入target eNB需要的信息（e.g. Target C-RNTI, Target eNB AS Security algorithm, DRB ID, etc.），并包含UL S1 TEID供SGW在切换时用于下行数据包传送。 eNB status transfer message ：这个消息是在切换执行阶段使用，由source eNB发送给MME。指示target eNB应该从哪个数据包开始接收或者发送。 MME Status Transfer message : 这个消息是在切换执行阶段使用，是由MME发送给target eNB。指示target eNB应该从哪个数据包开始接收或者发送。 Handover Notify message : 这个消息在切换完成阶段使用，是由target eNB发送给MME，指示UE已经完成到target eNB的切换。 UE Context Release Command message : 这个消息用在切换完成阶段，是由MME发送给source eNB请求UE上下文的释放。 UE Context Release Complete message : 这个消息是在切换完成阶段使用，是由source eNB发送给MME指示UE上下文已经释放了。 2.3 S1 Handover Procedure at a Glance像之前文档看到的，S1切换过程包括准备，执行，完成阶段。在我们详细介绍之前，我们简要预览一下S1切换过程。 图2描述了在切换前/中/后需要的过程。方便起见，SGW和PGW被标记为SAE-GW，source和target eNB被标记为SeNB和TeNB。 before S1 handover在上图中，UE是通过eNB A获得服务的。当UE检测到测量事件时，UE发送measurement report 给eNB A。 S1 handover preparationsource eNB基于自己保留的邻区列表信息和在measurement report 消息中包含的邻区信号强度信息选择target eNB作为切换目的地。接着，source eNB意识到通过X2连接切换到target eNB是不可能的，所以决定执行S1切换，并通过MME执行。所有的eNB都是通过S1AP信令和MME通信。这时，target eNB提前分配资源来确保source eNB提供的服务在target eNB同样可用。MME提供给source eNB所有的UE接入target cell需要的所有信息。 期间，target eNB和SGW分配创建indirect tunnel需要的资源，通过这个indirect tunnel，到达source eNB的下行数据转发给SGW，最终发送给target eNB。如下所示： source eNB发送target eNB所需要的信息给MME， 包含在handover required消息中。（1） MME发送handover request消息给target eNB，包含target eNB需要的AS安全信息来创建AS安全基础秘钥和UE上下文。 target eNB（2） 使用从MME获得的S1 S-GW TEID建立上行S1承载，通过这个承载在切换后可以转发上行数据包。并为下行S1承载分配S1 target eNB TEID。（3） 为连接SGW和target eNB的indirect tunnel分配S1 target eNB TEID。 配置handover command消息，包含UE接入target cell所需要的所有的信息。 把这些信息包含在handover request ack发送给MME。（4） MME一旦接收到这个消息，在create indirect data forwarding tunnel request消息中包含target eNB为indirect tunnel分配的S1 target eNB TEID，并把这个消息发送给SGW。（5） SGW 创建indirect tunnel连接target eNB（6） 分配S1 S-GW TEID用于source eNB和SGW之间的indirect tunnel的创建，并通过Create Indirect Data Forwarding Tunnel Response消息发送给MME。 MME包含i）SGW为indirect tunnel分配的S1 S-GW TEID，ii）包含UE接入target cell所需的信息，包含在handover command消息发送给source eNB。 接着，source eNB创建连接SGW的indirect tunnel。 通过第8和第6步，连接source eNB，SGW，target eNB三个实体的indirect tunnel创建成功了。 S1 handover execution现在两个eNB准备好切换了，是时候命令UE执行了。 source eNB 通过发送handover command消息包含UE接入target cell需要的信息命令UE执行切换到target cell（1） 发送eNB status transfer消息通知MME，eNB应该从哪个上行/下行数据包开始接收/发送。（2） 通过indirect tunnel发送从SGW接收到的下行数据包给target eNB。（4） MME通过发送MME status transfer消息通知target eNB，它应该从哪个UL/DL数据包开始发送/接收。（3） UE从source eNB断开，接入到target eNB。（5） 一旦UE成功接入target eNB，UE就立即有能力发送或接收数据包了。（6） S1 handover completion因为MME已经知道UE执行切换，不像X2切换，target eNB不需要MME进行路径修改。一旦UE连接到target eNB，target eNB给MME发送handover notify消息指示UE已经完成切换。 一旦UE连接，target eNB给MME发送handover notify通知切换完成（1） 接着MME请求SGW做S1承载修改。SGW修改下行S1承载路径连接target eNB。（2）（3） SGW改变承载路径：如下 SGW通过连接source eNB的下行S1承载发送end marker（EM）停止下行数据包传输。 接着SGW创建连接target eNB的下行S1承载，并恢复下行数据包传输给target eNB。 target eNB给UE发送下行数据包如下： target eNB在EM标记数据包到达之前通过indirect tunnel发送下行数据包 一旦EM标记数据包到达，target eNB通过新路径给UE发送数据包。 MME： MME通过发送UE context release command消息请求source eNB释放S1承载资源和UE上下文。（4） MME通过发送delete indirect data forwarding tunnel request消息通过SGW释放和indirect tunnel相关的资源。（5） after S1 handoverUE现在可以通过eNB B提供服务。 2.4 在S1切换前后UE状态和连接信息图3描述了在S1切换前后控制面用户面的连接建立情况，和UE/MME的状态。 before S1 handoverUE在EMM-REgistered和ECM/RRC-connected状态，并保持着E-UTRAN和EPC分配的所有资源。 during S1 handover即使在切换阶段，NAS层的UE状态一直保持不变。source eNB和target eNB都通过S1信令连接到MME上。他们也通过indirect tunnel连接到SGW上。在图3中，step-2展示了在切换执行阶段切换中断时的连接和状态。在这个阶段，没有激活的无线连接，但是UE仍保持连接状态。 after S1 handoverUE保持在EMM-REgistered和ECM/RRC-connected状态。在用户面，E_RAB（DRB+S1承载）转到连接新eNB的路径上，在控制面建立了新的RRC连接。 III. Procedure of S1 Handover现在我们详细介绍S1切换过程。图4描述了在S1切换之前的EPS承载和信令连接，并包括S1切换准备阶段详细过程。 before handover 1）【UE-&gt;eNB】measurement report一旦测量事件触发，UE测量邻区的信号强度，并给服务小区发送measurement report 消息。 handover preparation 2）【source eNB】handover decisionsource eNB根据measurement report消息包含的信息和source eNB自己保留的邻区列表信息中选择target eNB。并且发现在两个eNB之间没有有效X2连接可用，source eNB决定执行S1切换。 3）【source eNB-&gt;MME】 requesting handoversource eNB发送handover required消息给MME，请求切换到target eNB。这个消息包含如下：Handover Required (Handover Type, Target eNB ID, Source to Target Transparent Container) Handover Required (Handover Type, Target eNB ID, Source to Target Transparent Container) Target eNB ID: 包含Target Global eNB ID and Selected TAI information Source to Target Transparent Container: is used when forwarding the radio-related information of the source cell to the target cell transparently through EPC (MME) 4) [MME] 产生安全上下文转发给target eNBMME生成安全上下文{NCC,NH}, target eNB可用产生AS安全基础秘钥。NCC从初始NCC值开始加1，NH是从初始NH值和Kasme值产生的。 5）【target eNB &lt;-MME】请求target eNB切换MME给target eNB发送handover request消息，代表 source eNB请求切换。这个消息如下：Handover Request (UE-AMBR, E-RAB to be setup (E-RAB ID, QCI, ARP, S1 S-GW TEID), Source to Target Transparent Container, UE Security Capability, Security Context) Handover Request (UE-AMBR, E-RAB to be setup (E-RAB ID, QCI, ARP, S1 S-GW TEID), Source to TargetTransparent Container, UE Security Capability, Security Context) E-RAB to be setup: UE’s E-RAB information stored at Source eNB. Includes E-RAB ID, QoS parameters, UL S1 bearer information Source to Target Transparent Container: is used when forwarding the radio-related information of the source cell (e.g. UE radio access capability, RRC configuration Info, etc.) to the target cell transparently through EPC (MME). UE Security Capability: security algorithms supported by UE (encryption and integrity algorithm) Security Context: includes {NCC, NH} to be used when Target eNB derives the AS Security base key, KeNB* 6) [Target eNB] 准备S1 handover一旦接收到handover request消息，target eNB开始准备切换为UE提供无缝服务 i)新的S1承载资源分配 ：target eNB基于要建立的E-RAB信息，检查source eNB提供的QoS是否在target eNB中可用。如果可用，target eNB使用存储在source eNB中的上行S1承载信息（S1 SGW TEID）建立上行S1承载连接SGW。接着分配S1 target eNB TEID准备下行S1承载。 ii）indirect tunnel资源分配 ：在UE执行S1切换时，应该有一个从source eNB到target eNB的indirect tunnel。所以，target eNB分配S1 target eNB TEID，SGW可以建立indirect tunnel连接target eNB。 iii）为UE在无线链路上分配资源 ：基于E-RAB的QoS信息，target eNB为UE在无线链路上保留RRC资源，并分配C-RNTI。 iv）Kenb*产生 ：使用从MME中接收到的安全上下文信息（NCC1，NH1）来产生Kenb，接着获得AS安全秘钥(KRRCint, KRRCenc, KUpenc)。接着，当UE连接到target eNB是，UE和target eNB可以使用这些秘钥来安全的通信。图5显示了Kenb 是怎么产生的。我们可以看到Kenb *从NH1，PCI，频点生成。 7）【target eNB-&gt;MME】通知MME准备完毕target eNB给MME发送handover request ack消息，消息中包含了step-6中的所有资源。这些消息如下所示：Handover Request Ack (E-RAB Admitted(E-RAB ID, S1 Target eNB TEID, DL S1 Target eNB TEID), Handover Command (Target C-RNTI, Target DRB ID, AS Security Algorithm of Target eNB)) E-RAB Admitted E-RAB ID : E-RAB ID allocated by the target eNB S1 Target eNB TEID : DL S1 TEID that the target eNB allocated to S-GW for establishment of S1 bearer connecting to itself. DL S1 Target eNB TEID : DL S1 TEID that the target eNB allocated for establishment of an indirect tunnel for handover through which to deliver DL packets. Handover Command: Transparent Container, delivered by the target eNB to the source eNB, that contains the radio information of the target cell that UE needs to access the target eNB. Target C-RNTI: C-RNTI allocated by the target cell to identify UE. Target DRB ID: ID of DRB that the target eNB set to deliver user packets over the radio link. Target DRB ID: ID of DRB that the target eNB set to deliver user packets over the radio link. 8）【MME-&gt;SGW】请求S1承载创建用于下行数据包传输MME给SGW发送Create Indirect Data Forwarding Tunnel Request消息，请求创建indirect tunnel用于交付下行数据包。这个消息包括GTP TEID（S1 Target eNB TEID，target eNB分配的） 9）【MME&lt;-SGW】通知MME S1承载创建完成SGW一旦接收到Create Indirect Data Forwarding Tunnel Request消息，创建一个连接target eNB的indirect tunnel。接着分配S1 SGW TEID，通过Create Indirect Data Forwarding Tunnel Response消息转发给MME，source eNB可以使用这个TEID穿件indirect tunnel连接SGW。 10）【source eNB&lt;-MME】通知完成切换MME发送给source eNB handover command消息包含i)S1 SGW TEID（在step-9从SGW接收到）ii）包含包含handover command消息（在step-7从target eNB接收到的）source eNB从handover command消息中知道target eNB和EPC已经准备UE切换了。 handover execution图6描述了S1切换的执行阶段。 11）【UE&lt;-source eNB】命令UE执行切换一旦source eNB准备好切换，source eNB发送handover command消息命令UE执行切换。这个消息是包含在RRC connection reconfiguration消息中的。 12）【UE】执行切换一旦UE从handover command消息中获得C-RNTI和DRB ID，并从source eNB detach。现在UE和source eNB之间的所有的数据包交换都停止了，切换中断时间开始了。 13）【UE】AS安全建立UE产生AS安全秘钥用于target eNB的无线链路。首先产生Kenb*，接着使用target eNB选择的AS安全算法产生AS安全秘钥 (KRRCint, KRRCenc, KUPenc)。 14）~15）【source eNB-&gt;MME.MME-&gt;target eNB】通知从哪个数据包开始发送/接收source eNB发送eNB status transfer 消息，包含DL count和UL count给MME。接着MME通过MME status transfer消息包含相同的信息给target eNB。这是为了让target eNB知道从哪个数据包开始发送/接收数据包。这里这个count值是PDCP PDU计数，每一个count是32bit值，包含HFN超帧号和PDCP序列号SN。这个消息如下：eNB Status Transfer (DL Count, UL Count) DL Count: Count of the first packet to send to the UE UL Count: Count of the first packet to receive from the UE在发送eNB status transfer消息之后，source eNB开始通过indirect tunnel转发从SGW到达的下行数据包给target eNB。target eNB缓存这些数据包，知道UE成功接入到target eNB。 16）-18）【UE，target eNB】UE接入到target eNB16）UE检测到target eNB的同步信号并执行同步到target eNB。一旦同步完成，UE发起非竞争的随即接入。17）target eNB给UE发送时间偏移信息和上行授权。18）UE给target eNB发送handover confirm消息包含在RRC connection reconfiguration complete消息中。现在UE可以从target eNb接收或发送数据包了。切换中断时间结束。 19）【UE~target eNB】无线链路上的安全通信UE和target eNB之间的所有的RRC信令消息和用户数据包都是使用AS安全秘钥安全传输的。rrc信令消息是完整性保护和加密的，用户数据是加密的。 20）【target eNB】恢复下行数据包交付给UE随着UE成功连接到target eNB，target eNB通过下面的路径恢复发送缓冲的下行数据包给UE。S5承载( PGW到SGW)—-S1承载（SGW到source eNB）—–S1承载（source eNB到SGW）—-S1承载（SGW到target eNB）—DRB（target eNB到UE）对于UE发送的数据包，target eNB检查是否以正确的顺序接收到上行数据包，接着通过下面的路径转发给SGW。DRB（UE到target eNB）—S1承载（target eNB到SGW）—S5承载（SGW到PGW） handover completion图7描述了S1切换结束阶段的过程。 21）【target eNB-&gt;MME】请求EPS承载路径转换一旦UE成功接入，target eNB通过发送handover notify消息给MME通知UE已经成功完成了S1切换，这个消息中包含ECGI和TAI。 22）~27）修改EPS承载MME转发由target eNB分配的S1 target eNB TEID给SGW（通过发送modify bearer request消息）。通过这种方式请求SGW修改承载路径。接着SGW建立下行S1承载连接target eNB。一些SGW，根据UE初始附着时的选项设置，需要报告UE的服务小区是否发生变化。就需要SGW发送modify bearer request消息给PGW（PGW报告给PCRF），根据EPS会话修改过程，表示UE服务小区发生变化了。 28）~29）【SGW】修改S1承载路径SGW转换下行数据包转发路径为连接target eNB的下行S1承载。首先SGW发送end marker（EM）来指示发送给source eNB的最后一个数据包。接着它通过连接target eNB的S1承载来发送下行数据包。 30）【target eNB】数据包重新排序现在，target eNB接收到从source eNB转发过来的下行数据包，和通过新修改的路径的下行数据包。所以应该以正确的顺序交付给UE。首先target eNB转发从indirect tunnel接收到的数据包，接着当EM到达时，就是知道从indirect tunnel的最后一个数据包，接着发送从新修改的路径上接收到的下行数据包给UE。 31）~32）【source eNBMME】释放存储在source eNB中的UE上下文和S1资源MME通知source eNB，source eNB可以释放indirect tunnel和S1资源，以及UE上下文了（通过发送UE context release command消息）。 33）~34）【MMESGW】MME给SGW发送delete indirect data forwarding tunnelrequest消息请求释放indirect tunnel。一旦接收到这个请求，SGW释放indirect tunnel，并发送delete indirect data forwarding tunnel response消息通知MME释放完成。 IV. EPS entity information：before/after S1 handover在intra-LTE环境中，在S1切换前后存储在EPS实体中的信息和X2相同、 切换相关的As安全上下文会根据切换的类型不同俄日变化（S1 or X2）。切换安全在本篇文档范围之外。 在切换过程中，EPS实体中存储的信息十分相同，但是也会根据切换类型而不同。 V. closing目前为止，我们讨论了在SGW和MME都不发生变化时的S1切换过程。不想X2切换，在S1切换中，EPS知道UE的切换。EPC从切换准备阶段参与到切换过程。它和source eNB，target eNb协作共同完成切换。在EMM case-6我们讨论了LTE 切换。接下来对我们将讨论小区重选。 References[1] Netmanias Technical Document, “LTE EMM Procedure 6 – Part 2. X2 Handover”, March 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6257[2] 3GPP TS 36.413, “Evolved Universal Terrestrial Radio Access Network (E-UTRAN); S1 Application Protocol (S1AP)”[3] Netmanias Technical Document, “LTE EMM Procedure 6 – Part 1. Overview of LTE Handover”, March 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6224[4] 3GPP TS 36.331, “Evolved Universal Terrestrial Radio Access (E-UTRA); Radio Resource Control (RRC); Protocol specification”[5] Netmanias Technical Document, “LTE Security II: NAS and AS Security”, August 2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5903[6] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[7] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[17-EMM Procedure 6. Handover without TAU - Part 2. X2 Handover]]></title>
    <url>%2F2016%2F04%2F03%2F17-EMM-Procedure-6-Handover-without-TAU-Part-2-X2-Handover%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6257 I. Introduction在前一篇文档中我们讨论了LTE切换相关的过程，并学习了LTE切换是一个 UEassisted / network - controlled 的过程，即UE报告，eNB决定。这篇文档将讨论X2切换。所以我们假设源和目的eNB都连接到同一个MME/SGW，并且位于同一个TA，也就是在UE的TAI列表中。第二章将讨论X2切换的概念，第三章详细介绍X2切换的过程，最后第四章将总结在X2切换前后EPS实体的信息是怎么变化的。 II. Concept of X2 Handover2.1 X2 Protocol StacksX2切换是通过X2接口在源eNB和目的eNB之间执行的。在一个LTE网络中，两个eNB可以通过X2接口直接通信，这不同于在2/3G网络的情况。在2/3G网络中，eNB获得邻eNB状态的唯一的方法就是通过数据核心节点的控制。但是在LTE网络，允许eNB直接通过X2接口来交换状态信息，并在没有EPC节点的介入下来独立的执行切换。图1展示了控制面和用户面X2接口上的协议栈。 在控制面，两个eNB通过SCTP数据流控制传输协议提供给多个用户X2AP X2应用层协议信令。在X2AP层，使用eNB UE X2AP ID (Old eNB UE X2AP ID, New eNB UE X2AP ID)来标识用户。在数据面，两个eNB通过GPRS隧道协议GTP协议连接。为每一个用户产生一个独一无二的GTP隧道，并且每一个隧道被分配的TEID标识。 2.2 X2AP功能表1列出了通过X2AP信令执行的功能，并且和每一个功能相关的基本过程。如下所示，X2AP信令信息可以粗略地分为两种，一种是和负载/接口相关（例如，负载管理），另一种是和切换相关（例如，移动性管理，移动参数管理，移动鲁棒性优化）。 对比2/3G网络，像LTE宽带网络具有少的小区覆盖，但是有很多基站来覆盖。所以，像2/3G那样传统的配置和管理网络方式将不再有效。为了处理这个问题，在LTE网络中，定义了X2AP协议来提供自组网SON功能。这就允许eNB可以连接到邻eNB，获取他们的状态信息，并使用获取的信息自动的配置和优化参数。在表1列出的X2AP功能，这些和SON相关的如下： Load Management: 通过在两个eNB之间交换负载和接口信息来增强性能干涉。eNB Configuration Update: 执行自动eNB配置Mobility Parameters Management: 在eNB之间协商切换触发设置信息，并使用这些信息来切换优化Mobility Robustness Optimization: 对切换失败事件提供信息Energy Saving: 通过交换交换小区的激活或者去激活来帮助eNB减少能量消耗 2.3 和移动向管理相关的X2消息表2显示了用于移动性管理功能的消息，和切换相关的将会在第三章讨论。我可以看出在切换准备阶段需要来自目标eNB的响应消息。 Handover Request message: 这个小区在切换准备阶段使用。它由源eNB发送给目的eNB，包含用户的UE上下文。Handover Request Acknowledge message: 这个消息在切换准备阶段使用，在目的eNB成功完成资源分配之后由目的eNB发送给源eNB。Handover Preparation Failure message: 这个消息在切换准备阶段使用，在目的eNB分配资源失败时由目的eNB发送给源eNB。SN Status Transfer message: 这个消息在切换执行阶段使用，它由源eNB发送给目的eNB来指示从哪一个数据包开始应该接收或者发送。UE Context Release message: 这个消息在切换完成阶段使用，由目的eNB发送给源eNB，来请求UE上下文的释放。Handover Cancel message: 这个消息在切换准备阶段使用，当需要删除一个正在准备的切换时由源eNB发送给目的eNB。 2.4 简要X2切换过程如前一个文档所述，X2切换过程包括准备，执行，完成阶段。在我们深入讨论之前，我们将简要预览一下X2切花过程。如2描述了在X2切换前，中，后需要的过程。为了方面SGW和PGW被标记为SAE-GW，源和目的eNB被标记为SeNB和TeNB。 Before X2 Handover在上图中，UE是由eNB A服务，当UE检测到一个测量事件，UE给eNB A发送测量报告消息。 X2 Handover Preparation源eNB基于自己保存的邻区列表信息和包含在测量报告消息中的邻区信号强度信息来选择目的eNB切换。接着，通过X2信令和目的eNB准备X2切换。这时，目的eNB提前分配资源，使得在源eNB用户可用的服务现在在目的eNB也可用了。为了切换更快的切换，目的eNB发送给源eNB 目的eNB需要的所有UE信息，同样也把这些信息发送给UE，来发起切换执行阶段。目的eNB分配的资源如下： 当源eNB给目的eNB发送handover request消息包含用户UE上下文（1）。 目的eNB： 获取S1承载信息(S1 S-GW TEID)来建立上行S1承载传输上行数据包（2）. 为X2传输协议（GTP-U）分配TEID，用于在UE试图接入目的eNB时接收下行数据。 分配DRB资源和C-RNTI供UE在目的小区中使用。 发送handover request ack消息给源eNB（3）。 一旦接受到这个消息，源eNB建立X2传输承载用于发送下行数据包（4）。 X2 Handover Execution一旦在两个eNB之间切换准备完成，可以开始执行切换了。 源eNB 通过发送handover command消息（包含接入目的小区需要的所有信息）指示UE来执行切换到目的小区。（1） 通过发送给目的eNB一个SN status transfer消息通知目的eNB当和UE通信时哪一个UL/DL数据包需要接收或者发送（2） 通过X2传输承载转发从SGW接收到的下行数据包给目的eNB（3） UE从源eNB去附着，并接入到目的eNB（4）. 一旦UE成功接入，目的eNB有能力发送和接收数据包了（5）。 X2 Handover Completion到目前为止，从源eNB决定执行切换开始，在切换执行阶段到UE最终连接到目的eNB，之间执行的所有过程都没有切换相关的信息报告给EPC（MME）。现在切换完成了，目的eNB通知EPC： 一旦UE接入完成，目的eNB通知EPC，并发送path switch request消息给MME，通知EPC承载路径可以修改了。（1） 当接收到这个消息，MME觉察到UE新的服务小区，接着需求请求SGW修改S1承载（2）。 一旦请求，SGW建立下行S1承载(S1 Target eNB TEID)连接到目的eNB。接着SGW停止发送下行数据包到源eNB，并通过新建立的下行承载开始向目的eNB发送下行数据包。（3） MME通知目的eNB，下行S1承载路径已经修改完成（4）。 目的eNB发送给源eNB一个UE Context Release消息，允许源eNB释放UE上下文。（5） After X2 HandoverUE开始通过eNB B获得服务。 2.5 X2切换前后UE状态和连接信息图3描述了在用户面控制面建立的连接，和UE、MME状态Before X2 HandoverUE处于EMM-Registered and ECM/RRC-Connected状态并保持E-UTRAN和EPC分配的资源。During X2 Handover即使在切换状态，NAS层UE状态保持不变，X2承载和X2信令连接通过X2接口建立。在图3中，第2步展示了在切换执行阶段当切换中断时的连接和状态。这时候，没有无线连接处于激活状态，但是UE一直保持connected。After X2 HandoverUE保持在EMM-Registered and ECM/RRC-Connected状态。用户面的E-RAB(DRB+S1承载)路径转移到新的eNB上，控制面的新RRc连接和S1信令连接(eNB(B) S1AP UE ID)也建立起来了。 III. Procedure of X2 Handover现在我们来详细讨论X2切换过程。图4描述了在X2切换之前的EPS承载和信令连接，和详细的X2切换准备过程。 Before Handover1) [UE -&gt; eNB] Measurement Report随着测量事件触发，UE测量邻区的信号强度，并发送measurement report消息给响应的eNB。 Handover Preparation2) [Source eNB] Handover Decision源eNB基于measurement report消息包含的信息和自己保存的邻区列表信息选择目标eNB。在实际切换中，有不止一个目标eNB选择或者不是UE报告的邻区被选择为目标小区。但是，我假设只有一个eNB包含在measurement report消息里面，这个eNB被选择为目标eNB。 3) [Source eNB] Deriving the AS Security Base Key (KeNB) to be Used by the Target eNB当切换发生时，UE的服务eNB发生转换。在转换期间，RRC信令消息和用户数据包不得不无缝的和安全的传送。在无线连接上，是AS安全秘钥确保这些数据的安全传输。AS安全秘钥是从KeNB（AS安全基础秘钥）衍生的。KeNB是在用户鉴权后从KASME派生的，由MME发送给eNB。但是，因为X2切换是在没有EPC干预下在两个eNB之间执行的，目的eNB不能从MME中获得KeNB（KeNB被目的eNB使用）。所以，源eNB生成这个秘钥然后发送给目的eNB。这样，一旦源eNB决定执行切换，它会首先产生KeNB ，如图5所示。KeNB 从KeNB/目标小区PCI和频率（EARFCN-DL）中派生。4) [Source eNB -&gt; Target eNB] 请求X2切换源eNB给目的eNB发送handover request消息请求切换。通过这个消息，传输存储的UE上下文信息和UE历史信息（UE连接目的小区优先于最后切换到的目标小区）。这个信息包括如下：Handover Request (Target Cell ID, UE Context Info(UE-AMBR, UE Security Capability, KeNB*, E-RAB to be setup (E-RAB ID, QCI, ARP, S1 S-GW TEID), RRC Context), UE History Info) Target Cell ID: the target cell’s ECGI UE Context Info: UE context stored at the source eNB UE-AMBR: provided by HSS, but can be modified by MME. This value can be set for eNB, and used to control the aggregated MBR value of non-GBR bearers. UE Security Capability: security algorithms supported by UE (encryption and integrity algorithm) KeNB*: AS security base key generated by the source eNB for the target eNB’s use, i.e. KeNB to be used by the target eNB E-RAB to be setup: UE’s E-RAB information stored at the source eNB UE History Info: information about the cells that UE has accessed while staying Active, including each cell’s ECGI, type and the duration of UE’s stay in the cell. 5) [Target eNB] 准备X2切换一旦接收到handover request消息，target eNB开始切换准备为UE提供无缝的服务。(i) 首先，target eNB从source eNB接收的KeNB*生成AS安全秘钥(KRRCint, KRRCenc, KUPenc)。使用这些秘钥，target eNB可以和UE安全的通信。(ii) 接着，target eNB基于要建立的E-RAB信息检查source eNB提供的相同的QoS是否在target eNB中可用。如果可用，target eNB通过存储在source eNB的上行S1承载信息(S1 S-GW TEID)建立上行S1承载连接SGW。(iii) 接着，基于E-RAB QoS信息，target eNB在无线链路上为UE保留RRc资源，并分配C-RNTI。(iv) 当UE执行切换时，到达source eNB的下行数据包需要转发给target eNB。为了实现这个，target eNB分配X2 Target eNB TEID (DL TEID of X2 GTP tunnel) ，source eNB可以建立X2传输承载（GTP隧道）。6) [Source eNB &lt;- Target eNB] 给source eNB通知切换准备完成target eNB发送handover request ack消息包含在step-5准备的所有资源。这些信息如下：Handover Request Ack (E-RAB Admitted (E-RAB ID, Target eNB TEID), Handover Command (Target CRNTI, Target DRB ID, AS Security Algorithm of Target eNB)) E-RAB Admitted 12: includes i) E-RAB ID allocated by the target eNB, and ii) TEID information of X2 transport bearer through which E-RAB packets are to be forwarded to the target eNB. Handover Command: Transparent Container, delivered by the target eNB to the source eNB, that contains information that UE needs to access the target eNB Target C-RNTI: C-RNTI allocated by the target cell to identify UE Target DRB ID: ID of DRB that the target eNB set to deliver user packets over the radio link AS Security Algorithm of Target eNB: AS Security algorithm supported by the target eNB 7) [Source eNB] 为下行数据包交付建立X2传输承载一旦接收到handover request ack消息，source eNB知道target eNB可以服务UE了。接着使用X2 target eNB TEID，source eNB开始建立X2传输承载，在切换执行阶段可以使用这个承载把下行数据包转发给target eNB。 Handover Execution图6显示了X2执行阶段的详细过程。 8) [UE &lt;- Source eNB] 命令切换一旦source eNB和target eNB完成切换准备，source eNB发送handover command消息命令UE执行切换。 9) [UE] 执行切换UE从handover command消息中获得C-RNTI和DRB ID用于target cell，并从source eNB上detach。现在UE和source eNB之间的所有数据包都中断了，切换中断时间周期开始。 10) [UE] AS安全建立UE产生AS安全秘钥用于target eNB的无线链路。首先从source eNB的KeNB/target cell的PCI和频点信息中生成KeNB*，接着通过target eNB选择的AS安全算法来生成target eNB的AS安全秘钥(KRRCint, KRRCenc, KUPenc) 。11) [Source eNB -&gt; Target eNB] 通知发送或者接收的数据包序号source eNB给target eNB发送SN Status Transfer 消息通知从哪个数据包开始发送或者接收，在这个消息中包含下行计数和上行计数，这个计数值是PDCP PDU的计数，每一个计数32bit，是由Hyper Frame Number (HFN) and PDCP Sequence Number (SN)组成。这个信息如下所示：SN Status Transfer (DL Count, UL Count) DL Count: Count of the first packet to send to the UE UL Count: Count of the first packet to receive from the UE 在发送给target eNB SN status transfer消息后，source eNB开始转发从SGW的下行数据包到target eNB。target eNB缓存这些数据包等待UE接入完成。 12) ~ 14) [UE, Target eNB] UE接入到target eNB 12) UE检测到target eNB的同步信号并执行同步到target eNB。一旦同步完成，UE发起非竞争的随机接入。 13) target eNB给UE发送定时偏移信息（时间提前量）和UL grant。 14) UE给target eNB发送handover confirm消息包含在RRC connection reconfiguration complete 消息。现在，UE可以发送或接收来自target eNB的数据包，切换中断时间周期结束。 15) [UE - Target eNB] 在无线链路上安全通信UE和target eNB之间无线链路上的所有rrc信令消息和用户数据包都使用AS安全秘钥安全的传输。RRC信令消息是完整性保护和加密的，用户数据包是加密的。 16) [Target eNB] 恢复发送至UE的下行数据包一旦UE成功连接到target eNB，target eNB开始通过图6的路径发送缓存的下行数据包给UE。至于UE发送的数据包，target eNB检查上行数据包是否以正确的顺序接收，并通过图6的路径转发给SGW。 Handover Completion图7描述了X2切换完成阶段的详细过程。 17) [Target eNB -&gt; MME] 请求EPS承载（S1承载）路径转换target eNB通过发送path switch request消息通知EPC（MME）UE的服务消息转换了，并请求转换EPS承载路径。 18) ~ 23) 修改EPS承载MME转发target eNB分配的S1 Target eNB TEID给SGW。通知SGW下行S1承载已经改变了，并要求改变这个承载路径。SGW建立下行S1承载连接到target eNB。一些SGW根据UE初始attach的设置的选项在EPS会话创建时需要报告UE的服务小区是否改变。在此场景下，S-GW向P-GW发一个modify bearer request消息，让P-GW向PCRF发送报告，根据EPS session modification procedure，指示说UE的服务小区已经发生了改变。 24) [S-GW] 修改EPS承载路径并发送EM数据包现在下行S1承载已经修改，SGW转换下行数据包交付路径到连接target eNB的下行S1承载。首先SGW发送结束标记EM来标识到达source eNB的下行S1承载的最后一个数据包。接着SGW通过修改过的下行S1承载发送下行数据包。 25) [Target eNB] 数据包重新排序现在target eNB从source eNB和从修改过的下行S1承载接收下行数据包。所以，应该以一定的顺序交付给UE这些数据包。首先，target eNB交付给UE source eNB转发的下行数据包，当收到EM，target eNB知道这是从X2承载的最后一个数据包，接着target eNB发送从S1承载接收到的数据包给UE。 26) [Target eNB &lt;- MME] 通告修改过的承载路径MME通过发送path switch request ack消息通知给target eNB，SGW已经完成了EPS承载路径的转换。接着，MME转发用于切换的安全上下文{NH Chaining Count (NCC), Next Hop (NH)}，target eNB可以在UE下次切换到另外一个小区时使用。 27) [Source eNB &lt;- Target eNB] 通知释放UE上下文target eNB保留{NCC, NH}并给source eNB发送UE context release消息，通知UE上下文可以释放，UE承载路径转换完成。 IV. EPS Entity Information: Before/After X2 Handover这章描述在X2切换前后EPS实体信息的变化。所有的信息被分类为UE ID，UE Location，安全，EPS会话/承载信息。 4.1 Before X2 Handover在X2切换前，UE处于EMM-Registered and ECM/RRC-Connected状态。直到执行X2切换构成，所有的信息和初始附着/service request之后的信息相同。也就是，E-UTRAN和EPC分配的资源和存储在EPS实体中的UE上下文信息。图8列出来这些信息。 4.2 After X2 Handover在X2切换后，UE处于EMM-Registered and ECM/RRC-Connected状态。存储在每一个EPS实体中的信息没有改变，但是UE的Location信息发生变化。在source eNB中所有的E-UTRAN资源和UE上下文都释放了，但是在target eNB中设置了。图9列出来这些信息。在图中，改变的信息被标记为蓝色。 V. Closing到目前为止我们讨论了MME和SGW都不发生改变的X2切换过程。X2切换是在没有EPC参与下由source 和target eNB来执行的。我们学习了下行数据包通过X2传输承载转发来避免数据包丢失。在第三篇文档，我们将讨论S1切换，以及S1切换和X2切换的不同之处。 References[1] Netmanias Technical Document, “LTE EMM Procedure 6. Handover without TAU – Part 1. Overview of Handover”, March 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6224[2] 3GPP TS 36.423, “Evolved Universal Terrestrial Radio Access Network (E-UTRAN); X2 application protocol (X2AP)”.[3] 3GPP TS 36.331, “Evolved Universal Terrestrial Radio Access (E-UTRA); Radio Resource Control (RRC); Protocol specification”[4] Netmanias Technical Document, “LTE Security II: NAS and AS Security”, August 2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5903[5] Netmanias Technical Document, “LTE Security I: LTE Security Concept and LTE Authentication”, July 2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5902[6] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16-EMM Procedure 6. Handover without TAU - Part 1. Overview of LTE Handover]]></title>
    <url>%2F2016%2F04%2F03%2F16-EMM-Procedure-6-Handover-without-TAU-Part-1-Overview-of-LTE-Handover%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6224 I. Introduction这篇文档描述EMM case-6。这个过程是当UE移动到在TAI列表中的TA的一个小区时执行的。在handover过程中，并不发起TAU过程。我们定义这种过称为“Handover without TAU”。这个过程通过接下来的三篇文档讲述。第一个文档描述LTE handover，提供基本的信息。第二篇文档描述X2 handover，第三篇文档描述intra-LTE环境下的S1 handover。 II. Overview of LTE Handover无线设备比有线的一个最大的好处就是它可以移动中使用服务。这种移动性可以使用户在任何位置使用该服务，不论是家里还是在路上，任何想要的时间都可以。正因为这种便利，无线用户大大超过有线用户。签约服务的用户可以在路上使用服务就是因为移动网络支持handover切换。UE可以从一个基站在不丢失数据的情况下切换到另外一个基站。这确保用户可以被无缝地服务到，不论连接到那个小区。这个文档描述UE和LTE实体需要采取什么行动来支持切换，并且简要的讲述这些行为的不同。和切换的过程如表1所示。 UE有一个天线可以在多个band上搜索多个频率信道。所以在检查完多个邻区之后，UE通常接入有最强信号强度的那个小区（除非因为接入限制或者拥塞控制而不允许接入）。接着随着UE的移动和遮蔽，UE当前服务小区的接收信号强度变弱了，而邻区的信号变强，发起handover。允许UE接入邻区并建立新的RRC连接。 为了达到这种目的，当UE和eNB建立RRC连接时，eNB通过一个配置消息（RRC Connection Reconfiguration）给UE指示哪些事件的接收信号强度需要报告。UE监视服务小区和邻区的接收信号强度。当其中一个事件发生，UE通过Measurement Report消息把接收信号强度报告给eNB。eNB一旦接收到这个消息，通过查看报告强度信息和邻区的负载状态决定是否发起handover。一旦决定，将执行handover到选择的目的小区。 2.1 Measurement图1描述了当UE测量和报告信号轻度的测量配置和测量报告过程。 (1) Measurement Configuration测量配置是由eNB提供给UE的，eNB指示什么类型的测量信息需要报告。eNB通过RRC connection reconfiguration消息提供给UE这些测量配置。这些信息包含如下： 测量对象：提供UE需要测量的E-UTRAN小区，包括，频道号，物理小区ID-PCI，小区ID的黑名单，每一个小区的偏移值等等。 报告配置：指示需要UE发送测量报告信息的触发事件 测量ID：描述测量对象的ID Quantity配置：指示UE测量的值 测量间隔：指示UE测量邻区的间隔 在同频邻区测量情况下，UE可以不使用测量间隔(gap)来测量邻区。但是在异频邻区测量时，UE应该首先同步到邻区的频点，然后在上下行idle周期内使用测量间隔gap来测量信号强度。 (2) Measurement Report TriggeringUE测量服务小区和邻区的信号强度。接着UE把测量结果报告给eNB（周期性的，或者在满足测量配置中设定的报告门限时触发测量事件）。E-UTRAN的报告门限包括事件A1, A2, A3, A4 and A5，在inter-RAT测量报告中包括事件 B1 and B2。Event A3通常用来触发切换。图2显示了由事件A3触发切换的实例。表2提供了事件A3使用的符号。 Event A3当邻区的信号强度（信号强度和偏移，MNbr = Mn + Ofn + Ocn）比UE服务小区的信号强度（信号强度和偏移，MSer = Ms + Ofs + Ocs）高时，并且这个差额比A3偏移 (Off)还要大时，事件A3触发，UE给eNB报告测量结果。迟滞(Hys)是服务小区和目标小区越区切换界限的值。在A3触发的时候并且A3触发判决持续指定的TTT周期，eNB决定触发切换。 Table 2. Definition of the Symbols Represented in E-UTRA Measurement Symbol Definition Mn Measurement result of the neighbor cell Ms Measurement result of the serving cell Hys Hysteresis parameter for Event A3 Off Offset parameter of Event A3 Ofn Frequency specific offset of the frequency of the neighbor cell Ocn Cell specific offset of the neighbor cell Ofs Frequency specific offset of the serving frequency Ocs Cell specific offset of the serving cell 2.2 Handover Decision当事件A3报告时，eNB决定执行什么类型的切换到哪一个目标小区，接着发起切换过程。切换可以分类为不同的类型，但是他们的分类遵循以下的目的： (1) Handover分类1: EPC实体是否发生变化切换可以分类为不同的类型–同频LTE，异频LTE，inter-RAT切换，这些根据UE连接的EPC实体在切换前后是否发生变化。 同频LTE切换▪ Intra-MME/S-GW Handover: 在切换前后UE服务的MME和SGW是否发生变化 异频LTE切换: 在切换前后UE服务的MME和/或SGW发生了变化▪ Inter-MME Handover: 在切换后，UE服务MME发生变化，而服务的SGW保持不变▪ Inter-S-GW Handover: 在切换后，UE服务SGW发生变化，而服务的MME保持不变▪ Inter-MME/S-GW Handover: 在切换后，UE服务MME和SGW都发生了变化 Inter-RAT Handover: 在不同无线接入技术之间的切换▪ UTRAN to E-UTRAN▪ E-UTRAN to UTRAN, etc. (2) Handover 分类2: 是否有EPC实体涉及到根据是否有EPC实体涉及到在源eNB和目标eNB之间准备和执行切换，LTE切换可以分为使用X2接口的X2切换和使用S1接口的S1切换。图3描绘了随着UE的移动而触发的两种不同类型的切换。图4显示了源eNB是如何决定是哪种类型的切换，X2或者S1。 X2 HandoverX2接口连接两个eNB。如果在两个服务小区的eNB和目标小区的eNB之间存在X2连接，并且X2连接可用于切换，则发起X2切换。一旦切换完成，两个eNB相互通信来控制切换，并没有MME的介入。 S1 HandoverS1接口连接eNB和EPC。如果i）在源eNB和目标eNB之间没有X2连接，ii）有X2连接，但是这个连接不允许用于切换，iii）在源小区和目标小区之间切换准备失败，则发起S1切换。一旦切换完成，源eNB通过MME和目标eNB通信控制切换。 2.3 Handover Procedure根据接收到的测量配置，UE把测量结果报告给eNB。一旦eNB决定，切换则发起。切换过程包含三个阶段–准备，执行，完成阶段。 (1) Handover Preparation Phase在这个阶段，源eNB和目标eNB准备切换。对X2切换，通过X2信令两个eNB直接进行通信，并且不需要MME介入情况下执行。对S1切换，通过S1信令，需要MME介入。源eNB发送用户UE上下文给目标eNB来检查目标eNB是否有能力提供满意的服务质量。如果可以，目标eNB建立传输承载（下行数据包转发承载）用于数据转发。接着分配C-RNTI（用于UE接入这个eNB），并把这个值转发给源eNB。这就完成了准备阶段。这时候对X2切换，下行数据包转发承载是一个连接两个eNB的直传隧道，对S1切换，则是连接三个实体的非直传隧道。图5标书了这个阶段的数据包转发路径，UL/DL承载数据交付路径，控制信息交付路径，和下行数据包转发路径。 (2) Handover Execution Phase在这个阶段，执行切换。UE从源eNB上释放无线连接，并连接到目标eNB，接入到新小区。一旦用于两个eNB之间数据包转发的资源(i.e. a DL packet forwarding bearer)分配完成，并且在准备阶段目标eNB为UE分配了新资源(i.e. a DRB, DL S1 bearer, C-RNTI, etc.)，则这两个eNB准备好切换了。接着源eNB通过发送handover command消息命令UE执行切换。在切换执行阶段，UE使用在切换准备阶段目标eNB分配的C-RNTI。这样可以使UE更快的接入目标eNB。一旦到达目标eNB，下行数据包通过转发承载转发给目标eNB，并缓存直到UE完成到目标eNB的接入。这确保了没有数据包丢失。从UE的上行数据包不转发直到UE成功的接入目标eNB。一旦UE完成对目标eNB的无线接入，上行数据立即通过目标eNB转发至SGW。图6描述了在切换执行阶段下行数据交付路径，和通过目标eNB上行数据交付路径。 (3) Handover Completion Phase一旦UE完成对目标eNB的无线接入，UE承载路径 (DL S1 bearer)连接到目标eNB上而不是源eNB上。一旦这个路径转换完成，在切换执行阶段使用的转发承载被释放。在图7中，一旦完成切换完成阶段，上下行数据都使用新承载来交付的。 2.4 切换中断时间在切换准备阶段，网络实体在执行切换时提前分配资源来确保没有下行数据包丢失。但是实际切换中，切换中断时间是不可避免的。在这个时间内（UE从源eNB释放无线资源到重新连接上新小区），数据包时不能在UE和小区之间交付的。图8显示了X2切换时切换中断时间的实例。如果中断时间持续过长，无缝服务将不支持，用户要承受差的服务质量。切换中断时间包括：❶ 下行同步到目标eNB的时间❷ RACH等待时间❸ 发送专用RACH preamble请求上行资源的时间❹ 目标eNB检测到preamble 并处理的时间❺ 准备RACH Response 的时间❻ 解码RACH Response 的时间❼ 通知UE已经完成到目标eNB切换的时间❽ 在完成切换阶段获得目标eNB确认的时间 2.5 Mobility Robustness Optimization移动性鲁棒优化有时候，在切换执行阶段在UE完成接入到目标小区之前UE从服务小区或者目标小区接收到的信号不足够强将会导致无线链路失败RLF。RLF引起的因素有很多，可能和切换有关，也可能没关。如果是由切换执行时间相关的原因，切换发起的太早或者太晚都会引起RLF。如果在执行切换时RLF发生，UE可能会执行RRC重建过程，并连接到服务小区/目标小区或者另外一个小区（错误的小区）。RLF也和小区覆盖有关。所以，3GPP标准定义了移动鲁棒性优化（Mobility Robustness Optimization (MRO)）来帮助检测哪种类型的接入失败，并增强切换的鲁棒性。MRO超出本片文档的范围，将可能在LTE SON自组网文档中介绍。在下一个文档，我们将讨论没有RLF的成功切换。 III. Closing这篇文档，讨论了LTE切换的概述，讨论了小区测量，不同类型的切换和切换阶段。接下来的两篇文档将继续深入讨论X2和S1切换。 References[1] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[2] 3GPP TS 36.300, “Evolved Universal Terrestrial Radio Access (E-UTRA) and Evolved Universal Terrestrial Radio Access Network (E-UTRAN); Overall description”[3] 3GPP TS 36.331, “Evolved Universal Terrestrial Radio Access (E-UTRA); Radio Resource Control (RRC); Protocol specification”[4] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15-EMM Procedure 5. Periodic TAU]]></title>
    <url>%2F2016%2F04%2F03%2F15-EMM-Procedure-5-Periodic-TAU%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6193 I. Introduction这篇文档描述EMM case-5 周期性TAU过程。这个过程是在ecm-idle rrc-idle状态下的UE因为没有数据传输而需要周期性的更新MME的位置信息。当UE进入一个不在TAI列表中的TA时发起TAU，或者当TAU定时器超时。这篇文档介绍的是周期性TAU。当TAU定时器超时时，idle状态的UE发送TAU request消息报告自己的位置信息。在转移到ecm-connected rrc-connected状态后，执行周期性TAU过程，然后UE返回到idle状态。这篇文档介绍idle状态的UE执行周期性TAU过程，第二章介绍周期性TAU的概念，第三章描述具体的过程，最后第四章总结在这个过程前后EPS实体信息的变化。 II. Concept of Periodic TAU在connected状态的UE已经建立UE到PGW的端到端的EPS承载。MME保持UE位置的跟踪。所以如果有到达UE的数据，网络可以立即传送。但是如果UE在idle状态，UE和MME之间的信令连接和承载已经被释放，MME丢失了UE位置的跟踪。网络应该时刻知道UE的位置信息，无论是idle还是active，这是为了能够传送给UE数据。所以在idle状态的UE即使没有数据传输时，应该给MME周期性的报告自己的位置信息（比如UE所在的TA）。TA是一些小区的组合，由MME管理。idle状态的UE位置信息的识别是在TA级别。当UE初始附着网络时，MME会在attach accept消息中包含TAI列表和TAU定时器（T3412）给UE。使用这些信息，UE可以在TAU定时器超时时执行TAU过程。当MME接收到UE的位置信息，MME会更新UE的最新位置信息。如果UE在idle状态下有数据到达UE，MME可以通过发送给这个TA下的所有小区寻呼信息来通知UE有数据到达，这个TA是idle状态的UE报告给MME的TA。图1描述了TAU执行的实例。UE1在初始附着时attach上了eNB1的cell2，并且通过attach accept由MME分配了TAI列表(e.g. TAI={TAI1, TAI2})和TAU timer (e.g.T3412=60 mins)，接着在转移到idle状态，❶ -&gt; ❷ -&gt; ❸ -&gt; ❹。我们假设i)UE只在TAI列表中的TAs中移动，ii）UE报告TA信息的MME是存储着UE的上下文信息，iii）MME和UE都包含有效的NAS安全上下文。 在cell2 attach和转移到idle状态后，在t1时刻当TAU超时时UE1醒来并建立ECM信令连接。接着UE1发送给MME TAUrequest消息 (TAI=TAI1, Last Visited TAI=TAI1) 包含当前小区的TAI和上次访问的TAI(❶)。接着UE1接收到TAU accept消息后返回到idle状态。在接收到TAU request消息后，MME检查UE的上次TAI是否改变，如果变化了更新最新的TAI信息。如果有到达UE1的数据，SGW通知MME有下行数据，MME根据上次TAU报告的最新的TAI查找UE在哪个TA，并在这个TA下的所有小区发送寻呼消息。接下来，如果UE1移动到cell4，并且TAU定时器超时，UE给MME发送TAU request消息(TAI=TAI1, Last Visited TAI=TAI1)，因为UE一直在TA1中。如果UE1移动到cell11中，并且定时器超时，UE给MME发送TAU Request 消息(TAI=TAI2, Last Visited TAI=TAI1)，用TAI2代替TAI1，因为这个小区属于TAI2。接着MME更新UE1的上次TAI为TAI2。图2描述了连接建立，TAU前后用户面和控制面UE、MME的状态。 UE状态如下：（i）在TAU之前，UE在EMM-Registered, ECM-Idle and RRC-Idle状态，E-UTRAN分配的资源，ECM信令连接都释放了。 （ii）在TAU过程中，UE处于EMM-Registered, ECM-Connected and RRC-Connected状态。周期性TAU过程不同于初始附着和service request过程，周期性TAU过程没有e-rab建立，只有ecm信令连接用于传输周期性TAU相关的NAS消息。 （iii）在TAU过程之后，ECM连接释放，释放E-UTRAN资源。接着UE返回到EMM-Registered, ECM-Idle and RRC-Idle状态。 图3描述了在TAU前后状态转换的过程。一旦T3412超时，idle状态的UE给MME发送TAU request报告当前TA和上次TA。MME在更新完最新UE位置信息后发送TAU accept消息。最后释放信令连接返回到idle状态。 III. Procedure of Periodic TAU图4和图5描述了周期性TAU的详细过程。图4中，UE的NAS通过发送TAU request消息给MME报告新的TA，更新类型标记为“Periodic Updating”。“Periodic Updating”类型的TAU不需要承载的建立，只需要建立ECM信令连接后就可以发送TAU request消息。当UE接收到TAU accept消息，释放ECM信令连接。TAU request消息是完整性保护。所以MME通过对这个消息完整性检查来决定是否执行鉴权过程。 ❶ Periodic TAU Triggering 1) [UE] TAU Timer Expiryidle状态UE在T3412TAU定时器超时后出发TAU过程给MME报告自己的位置信息。 ❷ ECM Connection Establishment and TA Report UE的NAS层 i）配置TAU消息，ii）发送RRC参数给RRC层。 2), 3) [UE – eNB] RRC Connection Establishment一旦接收到TAU request消息，UE的RRC层给eNB发送RRC connection request消息，请求专用信令资源。eNB通过分配SRB信道和给UE发送RRC connection setup消息来建立RRC连接。 4), 5), 6) [UE -&gt; MME] ECM Connection Establishment Request and TA ReportTAU request消息在UE到eNB之间包含在RRC Connection Setup Complete消息中，在eNB和MME之间包含在Initial UE Message消息中，TAU request消息是完整性保护和加密的。 The TAU Request消息如下信息:TAU Request (Update Type=Periodic Updating, Active Flag=0, GUTI, Last Visited TAI, KSI ASME, NASMAC) Update Type: 标识TAU类型，当TAU定时器超时设置为Periodic Updating Active Flag: 标识是否有上行用户数据或者信令要传送，如果有这个参数设置为1，会在TAU之后建立承载和维持ECM连接。 GUTI: UE ID, 之前由MME分配，用来标识UE的。 Last Visited TAI: UE上次注册的TAI KSIASME: index for KASME, the NAS security base key NAS-MAC: TAU request的消息完整性保护时使用MAC 为了从NAS层接收TAU request消息，UE的RRC层在RRC Connection Setup Complete消息中包裹这个消息发送给eNB。这时，RRC Connection Setup Complete消息包含GUMMEI。这个ID是从NAS层接收的，标识UE注册在哪一个MME上。通常eNB可以连接不止一个运营商网络和MME，所以一旦接收到RRC Connection Setup Complete消息，eNB检查自己是否连接着这个标记的MME。接着，eNB把TAU request消息包裹在Initial UE Message消息中发送给MME。这时，eNB分配给initial UE message消息一个eNB S1AP UE ID标识。MME一旦接收到Initial UE Message消息，分配MME S1AP UE ID，并建立S1信令承载。这时候就完成了UE和MME之间的ECM信令连接，允许UE转移到connected状态。 ❸ UE Authentication and NAS Security Setup (Optional) 7) [UE – MME – HSS] UE AuthenticationMME一旦接收到TAU request消息，对这个消息进行完整性保护检查，如果检查通过，MME跳过UE鉴权过程，并继续使用自己保存的NAS安全上下文来传递NAS消息。如果检查失败了，需要执行UE鉴权。 8) [UE – MME] NAS Security Setup一旦UE鉴权完成，NAS安全秘钥用于NAS消息传输。 ❹ TA Update 9) [MME -&gt; S-GW] TA Update当MME接收到了TAU request消息后，重置TAU定时器，并给SGW发送Modify Bearer Request消息，转发UE的位置信息(ECGI, TAI)。 10) EPS Session Modification (Optional)SGW接收到UE位置信息后，检查UE的小区是否发生变化。如果变化，SGW发送Modify Bearer Request消息给PGW通知这个变化。接着PGW通过EPS session modification过程发送同样的信息给PCRF。 11) [MME &lt;- S-GW] Responding to TA Update RequestSGW给MME发送Modify Bearer Response消息作为对Modify Bearer Request 消息的响应。 12) [MME] Preparing TAU Accept MessageMME配置新的TAI列表来反映UE当前位置，或者分配一个新的GUTI（根据实现来决定）。 13) [UE &lt;- MME] Sending TAU Accept MessageMME给UE发送TAU Accept 消息，完整性保护而且加密的。这个消息使用Downlink NAS Transport消息（从MME到eNB）和DL Information Transfer message消息（从eNB到UE）发送给UE。 14) [UE] Updating TIN and TAI List当UE从MME接收到TAU Accept消息，检查GUTI和TAI列表值。如果这些值发生变化，UE会用新值来更新TIN (Temporary Identifier used in Next update)和TAI列表。这里的TIN是在下次UE发送TAU request消息时使用的用户ID，并且更新包含在TAU accept消息中的GUTI。 15) [UE] Acknowledging New GUTI如果MME分配了一个新的GUTI，UE发送TAU complete消息给MME作为对新GUTI的响应。 ❺ ECM Connection Release 16) [eNB &lt;- MME] Requiring E-UTRAN to Release UE Context在更新UE的位置信息后，MME给eNB发送UE Context Release Command消息来释放用于周期TAU的ECM连接，并释放存储在E-UTRAN中的UE上下文。 17) [UE &lt;- eNB] Releasing RRC Connection一旦接收到UE Context Release Command 消息，eNB释放UE上下文，并释放分配给UE的E-UTRAN资源。接着给UE发送RRC Connection Release消息来释放RRC连接，然后释放分配给UE的SRB。 18) [eNB -&gt; MME] Announcing Release of UE Context from E-UTRANeNB给MME发送UE Context Release Complete消息指示S1信令连接已经释放了。现在，为TAU request建立的ECM连接释放了，UE重新回到idle状态。(ECM/RRC-Idle) IV. EPS Entity Information: Before/After Periodic TAU这章描述周期性TAU过程前后EPS实体的信息。所有的信息被分类为UE ID，UE Location，安全，EPS会话/承载信息。 4.1 Before Periodic TAU在TAU过程触发之前，UE在EMM-Registered, ECM-Idle and RRC-Idle状态，和service request发起之前存储的信息相同。即，E-utran分配的无线资源和相关的EPS承载和信令都被释放了。在图6中描述了在周期性TAU之前EPS实体中存储的信息。 4.2 After Periodic TAU在周期性TAU止呕，ECM连接释放，UE重新返回到idle状态。存储的EPS实体中的信息和TAU request之前的信息相同，如图6所示。 V. Closing我们学习了周期性TAU过程。不像service request过程，这个过程不建立e-rab承载，但是需要建立ECM连接。在TAU完成后，ECM连接释放，UE重新返回到idle状态。如果有上行数据要发送，首先建立e-rab承载，然后在TAU之后发送数据，像service request过程一样。接下来将介绍connected UE移动到另外的TA引起handover，但是没有TAU的情况。 References[1] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[2] Netmanias Technical Document, “LTE EMM Procedure 4. Service Request”, February 2014,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6134[3] Netmanias Technical Document, “LTE Identification II: NE and Location Identifiers”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5906[4] Netmanias Technical Document, “LTE EMM Procedure 1. Initial Attach – Part 2. Call Flow of InitialAttach”, January 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6102[5] Netmanias Technical Document, “LTE Security I: LTE Security Concept and LTE Authentication”, July2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5902[6] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14-EMM Procedure 4. Service Request]]></title>
    <url>%2F2016%2F04%2F03%2F14-EMM-Procedure-4-Service-Request%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6134 I. Introduction这篇文档描述EMM case-4：service request过程。这个过程是当有新流量时，在idle状态不活动的UE想激活来处理流量时执行的。新用户流量可以是从UE开始的上行流量，也可以是从网络到UE的下行流量。UE的E-UTRAN资源已经被释放了，UE处于ecm-idle rrc-idle状态。所以UE为了能够接受或者发送数据，UE需要通过service request过程来转换到ecm-connected rrc-connected状态，E-UTRAN资源被重新分配。这个文档解释了LTE网络下的service request过程。第二章根据新流量产生在哪，对service request分为不同的类型。第三章和第四章描述了每一种service request详细过程的不同。最后第五章总结在service request前后EPS实体中信息的变化。 II. Cases of Service Request当UE仍注册在网络，但是由于用户不活动删除了S1连接，UE没有可用的无线资源。这时候UE处于emm-registered和ecm-idle状态。如果这时候有新数据从UE产生或者从网络到UE，UE请求网络服务，转换到ecm-connected状态。ECM连接(RRC + S1 signaling connections)和e-RAB连接(DRB + S1 bearer)在控制面和用户面建立，允许UE接收或发送数据。如果网络发送数据给UE，网络会通知给UE自己的意图，让用户可以请求服务。当UE有数据发送，或者从网络的意图中知道网络要发送数据，UE发送给MME service request消息，并转移到ecm-connected、rrc-connected状态。接着UE通过使用分配的无线和网络资源，可以接受和发送数据。service request可以由UE或者网络来触发，根据不同的触发情况，可以分类为以下几种： service request case-1：UE触发的新数据。当UE有新上行数据要发送给网络。 service request case-2：网络触发的新数据。当网络有下行数据要放给UE。 图1展示了在service request执行前后用户面和控制面连接建立、UE和MME状态。在service request之前，用户时emm-registered ecm-idle rrc-idle状态。只有EPS分配的资源保持连接没有释放，而由E-UTRAN分配的所有资源都被释放了。在控制面S5 GTP-C and S11 GTP-C保持在连接状态。 在service request之前，用户处于EMM-Registered and ECM/RRC-Idle状态。只有EPC分配的资源没有被释放，e-utran分配的资源都释放了。在ECM连接丢失的情况下，在控制面S5 GTP-C和S11 GTP-C隧道仍然保持激活。在用户面，在下行S1承载和DRB被释放的情况下，S5承载和上行S1承载保持激活。 在service request之后，UE被e-utran分配了资源，处于emm-registered和ecm-connected rrc-connected状态。我们可以看到EPS承载的所有承载和连接以及信令连接都被建立起来用于传输数据。 III. UE-triggered Service Request图2和3描述了由UE触发的service request过程。UE的NAS通过service request消息给MME指示说UE有数据要发送。接着网络为数据传输分配资源。因为UE注册在网络，所以UE的NAS安全上下文在UE和MME中保持有效。所以UE可以发送加密和完整性保护的service request消息。当MME接收到这个消息，MME决定是否执行对用户的鉴权，尽管这个消息是加密和完整性保护的，接着eNB建立e-rab。 ❶ ECM连接建立 当有数据要发送，UE给MME发送service request消息建立ECM连接。service request消息通过无线链路上建立的RRC连接和S1信令连接传送给MME。这篇文档假设在UE和MME中有有效的GUTI和NAS安全上下文。 1), 2) [UE – eNB] RRC Connection SetupUE的NAS层提供给RRC层S-TMSI。RRC层使用S-TMSI作为UEID发送RRC connection request消息到eNB来建立RRC连接。eNB返回给UE RRC connection setup消息。 3), 4), 5) [UE -&gt; MME] ECM Connection Setup RequestUE的NAS层发送service request消息给MME来建立ECM连接。NAS安全上下文已经存储在UE和MME中。这个消息中包含KSI-ASME，并且是加密和完整性保护的。service request消息包含在RRC connection setup complete 消息中传送给eNB的。这个消息是包含在S1AP消息（initial UE消息）中从eNB传送到MME的。这是，eNB分配eNB UE S1AP ID，并包含在initial UE消息消息中发送给MME。一旦接收到initial UE消息，MME分配MME S1AP UE ID，并和eNB之间建立S1信令连接。 ❷ UE鉴权和NAS安全建立(可选) 6) [UE – MME – HSS] UE Authentication在接收到service request消息后，MME执行完整性检查，如果通过，MME使用当前的NAS安全上下文传输NAS消息，并不对UE再执行鉴权流程。如果失败，MME会对UE执行鉴权流程。 7) [UE – MME] NAS Security Setup当鉴权过程完毕后，UE和MME都生成了用于传输NAS消息的NAS安全秘钥。 ❸ E-RAB 建立 在收到service request消息之后，MME通过e-rab建立过程建立DRB和下行承载。 8) [eNB &lt;- MME] 请求E-RAB建立一旦接收到UE发送的service request消息，MME意识到要建立e-rab。接着MME给eNB发送Initial Context Setup Request 消息，让eNB可以建立和SGW建立S1承载，和UE建立DRB。这个消息包含以下信息： Initial Context Setup Request (E-RAB ID, KeNB, S1 S-GW TEID, MME UE S1AP ID) E-RAB ID KeNB: AS安全基础秘钥，用来eNB和UE建立AS安全 S1 S-GW TEID: 标识连接到SGW的上行S1承载 MME UE S1AP ID: 标识连接到MME的S1信令承载 9) [UE &lt;– eNB] AS Security Setup在接收到initial context setup消息后，eNB意识到要建立DRB和S1承载用于用户数据传输。在建立DRB之前，eNB执行AS安全建立过程。UE和eNB通过AS安全建立过程生成KRRCint/KRRCenc用于加密和完整性保护，生成KUPenc 用于用户数据加密。在成功完成AS安全建立，RRC消息在无线链路上是加密和完整性保护传输的，用户数据也是加密传输的。接着eNB开始DRB建立。 10) [UE &lt;- eNB] DRB EstablishmenteNB分配一个DRB ID来创建DRB，并根据从MME接收到的e-rab QoS配置DRB QoS参数后，发送RRC connection reconfigutaion消息给UE。UE一旦接收到RRC Connection Reconfiguration消息，生成DRB和SRB2。 11) 上行传输通道可用一旦完成步骤10生成DRB之后，就建立从UE到PGW的上行EPS承载，允许UE传输上行数据。 12) 13) &amp; 16) [eNB -&gt; S-GW] 建立下行S1承载在步骤12，eNB为S1承载分配下行S1 TEID (S1 eNB TEID)，并把这个ID包含在initial context setup response消息中发送给MME，作为对Initial Context Setup Request消息的响应。MME把S1 eNB TEID包含在Modify Bearer Request消息中发送给SGW，SGW使用这个信息建立下行S1承载。接着，在步骤16，SGW通过Modify Bearer Response 消息通知MME下行S1承载建立完成。 14) 下行传输通道可用一旦完成步骤13，从SGW到eNB的下行S1 GTP-U隧道就建立了，完成了从PGW到UE的下行EPS承载。用来传输下行数据给UE。 15) Modifying EPS Session (UE Location Registration)在service request时如果UE的当前小区或者TA发送变化，SGW通知PGW这个变化。接着PGW通过EPS session medication过程报告给PCRF。 IV. Network-triggered Service Request图4和 5描述了网络触发的service request过程。这种类型的service request是当网络有下行数据要发送给UE时触发。MME不知道idle状态的UE处于什么位置，所以MME不得不通过寻呼过程来通知UE它有数据要发送，接着已经释放的承载资源可以重新建立。 ❶ Service Request触发如果SGW从PGW通过S5承载收到下行数据包，但是不能通过下行S1承载发送给eNB，因为下行S1承载已经释放了。首先SGW缓存这些数据包，并找到UE注册在哪一个MME。接着SGW给MME发送Downlink Data Notification消息通知需要为UE建立信令连接和承载。 ❷ PagingMME知道UE驻留在哪一个TA，但是不知道UE驻留的小区。所以MME给这个TA下的所有eNB发送寻呼消息。eNB广播接收到的寻呼消息（通过PCH信道），UE在常规监控PCH时可以接收到这个消息。 ❸ ECM连接建立意识到有数据要到来，UE发送service request消息来建立ECM连接。ECM建立从UE通过无线接入信道接入小区开始，接着发送RRC Connection Request消息建立RRC消息。执行过程如图2所示。 ❹ UE鉴权和NAS安全（可选）MME一旦接收到UE发送的service request消息，如果NAS-MAC完整性检查失败，将实行UE鉴权和生成NAS安全秘钥。 ❺ E-RAB 建立在从UE接收到service request消息后，MME通过e-rab建立过程建立DRB和下行S1承载。接着准备接收从SGW的数据包。详细过程如图3所示。 V. EPS Entity Information: Before/After Service Request这章将描述在service request前后EPS实体中信息的变化。所有的这些信息将分类为UE ID，UE Location，安全和EPS会话/承载信息。 5.1 Before Service Request在service request触发之前，UE以为S1承载的释放而转移到emm-registered和ecm-idle rrc-idle状态。在S1承载释放后，所有EPS实体中的信息都保持相同直到service request过程执行。也就是说，E-UTRAN分配的无线资源和相关的EPS承载信令都从EPS实体中删除了。在图6中，在service request之前EPS实体中信息被标记为黑色。 5.2 After Service Request一旦完成service request过程，UE转移到ECM/RRC-Connected状态，RRC连接、S1信令和e-rab承载都建立起来了。用于UE和PGW之间传输的所有需要的信息都存储在EPS实体中。图7描述了在service request之后，EPS实体中存储的信息。 VI. Closing这篇文档，学习了service request过程。总结了存储在EPS实体中的信息。接下来的文档将讨论TAU过程。 References[1] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[2] Netmanias Technical Document, “LTE EMM Procedure 1. Initial Attach – Part 2. Call Flow of InitialAttach”, January 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6102[3] Netmanias Technical Document, “LTE Security II: NAS and AS Security”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5903[4] Netmanias Technical Document, “LTE EMM Procedure 3. S1 Release”, January 2014,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6110[5] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13-EMM Procedure 3. S1 Release]]></title>
    <url>%2F2016%2F04%2F03%2F13-EMM-Procedure-3-S1-Release%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6110 I. Introduction这个文档 描述了EMM case-3，当UE不活动状态时释放S1连接。当注册到网络的UE处于不活动状态，没有使用任何服务（并不意味着不适用eNB分配的无线资源）。所以网络需要释放这些相关的无线接入相关的资源，并删除相关的信息（ID，QoS参数等等）。从网络的角度看，S1释放意味着和UE有关的控制面S1信令和RRC连接，以及用户面下行S1承载和DRB。但是，从UE的角度来看，它意味着在控制面和用户面丢失RRC连接和DRB。一旦S1连接释放，MME和UE之间的ECM连接也丢失了，在eNB中和UE相关的所有上下文都被删除了。接着用户从ecm-connected状态转移到ecm-idle状态，但是一直保持emm-registered状态。这个文档解释了LTE网络中因为用户的不活动引起的S1释放。第二章描述了S1释放是怎么执行的，第三章描述了在S1释放过程之后信息单元是怎么变化的。 II. S1 Release due to User InactivityS1释放可以被eNB或者MME触发。eNB触发的释放原因有： 用户不活动 RRC信令完整性校验失败（再三） 因为UE产生信令连接释放而释放 未知错误 O&amp;M干预 MME触发的释放原因有： 鉴权失败 detach 不允许CSG小区 另外，S1释放可以被其他另外两个因素，例如处理超负荷，没有足够可用的用户面处理资源等等。图1展示了在S1释放前后，控制面和用户面UE和MME的状态。在释放前，EPS承载和信令连接建立来支持用户网络之间的流量传输。EPS承载包括DRB，S1承载，S5承载。信令连接包含ECM（RRC+S1信令连接），S11和S5连接。UE和MME都在emm-registered状态和ecm-connected状态，UE和eNB在rrc-connected状态。在S1释放后，用户面的DRB和下行S1承载被释放，在控制面ECM（RRC+S1信令连接）连接丢失，释放E-UTRAN资源。应该注意的是，这时候只有下行S1承载释放了，上行的S1承载还在保持着。S1释放不同于在detach过程中释放一样。在detach过程中，所有分配给UE的资源都被释放，UE转移到emm-deregistered状态。而在S1释放过程中，只有由无线接入网络分配的这些资源释放，而被EPC分配的资源则没有释放。所以UE保持在emm-registered状态，转移到ecm-idle状态。在接下来，当有上下行用户流量时，ECM连接和DRB/S1承载（下行）建立起来，UE状态转到ecm-connected并传输用户流量。 图2描述了由eNB触发的一旦用户不活动时S1释放过程。在由MME触发的S1释放情景中步骤1和2保留。 1）【eNB-&gt;MME】请求UE上下文释放一旦检测到用户不活动，eNB发送给MME UE Context Release Request消息，伴随着释放的原因，来释放UE上下文。 2）【MME-&gt;SGW】请求S1承载释放MME通过发送给SGW Release Access Bearers Request消息来请求SGW释放和eNB关联的资源，S1的下行端口。通过这个消息，通知SGW没有下行流量传输给UE了。 3）【SGW】下行S1承载释放SGW释放和UE关联的所有下行S1承载（eNB相关的资源，包含eNB分配的下行S1 TEID等等）但是保留着上行S1承载资源（SGW相关的资源，包括上行S1 TEID和自己分配的上行S1 TEID等等）。所以当上行数据包到达时，eNB可以保持上行S1 TEID，通过S1承载无延迟的传输这些数据包。 4）【MME&lt;-SGW】响应S1 Bearer Release RequestSGW通过发送Release Access Bearers Response消息来确认下行S1承载资源已经被释放了。之后，如果有到达UE的下行数据包到达，SGW缓存他们，然后在下行S1承载重建之后再传输。详细的步骤将在下面文档中解释EMM case-4、 5）【eNB&lt;-MME】UE Context Release CommandMME给eNB发送UE Context Release Command消息来释放存储在eNB中的UE上下文。 6) [UE &lt;- eNB] RRC Connection ReleaseeNB一旦从MME接收到命令，将删除eNB具有所有UE上下文。如果RRC连接还没有释放，eNB发送给UE RRC Connection Release消息来释放。通过这个消息，eNB释放和UE相关的所有无线资源和承载，并伤处UE上下文。 7) [eNB -&gt; MME] UE Context Release CompleteeNB给MME发送UE Context Release Complete message作为步骤5的响应。MME确认UE所有的上下文已经删除了。 8) 【MME】 S1 ReleaseMME释放在UE上下文中所有eNB相关的信息，除了上行S1承载信息。但是保留和eNB不关联的信息。 III. EPS Entity Information: Before/After S1 Release这章将学习在S1释放前后EPS实体中信息的变化。所有的信息分类为UE ID，UE Location，安全和EPS会话/承载信息。 3.1 Before S1 Release在S1释放之前，UE连接到网络，在EMM-Registered, ECMConnected and RRC-Connected 状态下使用服务。所有的EPS实体保持着和初始附着后相同的信息。图3列出来在S1释放之前所有EPS实体的信息。 3.2 After S1 Release在S1释放之后，UE仍然注册在网络上，但是是在EMM-Registered, ECM-Idle and RRC-Idle状态，不使用任何服务。因为UE和任何eNB没有连接，所有UE请求连接eNB和传输数据需要的信息被释放。在控制面，ECM连接（RRC和S1信令连接）被释放，在用户面DRB和下行S1承载被释放。图4列出了在S1释放之后每一个实体中的信息。在S1释放的信息被标记为灰色。 在UE中删除的信息： C-RNTI：在UE要连接小区中标识UE的ID。 ECGI：在UE要连接的小区上的信息 DRB ID：在无线链路上的EPS承载的ID。由eNB分配给UE。 AS Security Info: 在UE和eNB之间的AS安全上下文。 在eNB中删除的信息： 所有的信息 在MME删除的信息： S1AP UE ID：用在S1信令连接的UE ID信息(eNB S1AP UE ID and MME S1AP UE ID) ECGI: 在UE要连接的小区上的信息 S1 TEID (DL): 在下行S1承载上使用的TEID信息 在SGW删除的信息 S1 TEID (DL): 在下行S1承载上使用的TEID信息 ECGI: 在UE要连接的小区上的信息 IV. Closing我们已经讨论完了当用户不活动时S1释放过程。接下来我们学习service request过程。 References[1] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[2] Netmanias Technical Document, “LTE EMM Procedure 1. Initial Attach – Part 2. Call Flow of InitialAttach”, January 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6102[3] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12-EMM Procedure 2. Detach]]></title>
    <url>%2F2016%2F04%2F03%2F12-EMM-Procedure-2-Detach%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6108 I. Introduction这篇文档讨论EMM case-2。在这个过程中，用户从附着的网络上去附着。用户在EMM case-1通过初始附着附着到网络上在emm-registered状态使用LTE服务，在使用服务后，当在ECM/RRC-connected状态或者ECM/RRC-idle状态下用户可能被网络或者UE去附着。无论任何一种情况，一旦去附着过程完毕，用户的EPS承载释放并且状态信息清除。 这篇文档介绍LTE网络的detach过程，组织如下：第二章根据detach是谁发起的来定义不同的类型，第三章描述每一个detach类型的具体过程，第四章深入了解在detach后每一个EPS实体的信息有如何变化。 II. Cases of Detach通过初始附着生成EPS会话和默认EPS承载之后用户可以使用LTE服务。在一些情况下，用户一旦使用完了服务可以may从网络detach。在另外一些情况下，用户一直在使用网络服务时被网络detach，然后不能和网络保持连接了。 一旦用户从网络detach，所有分配给这个用户的EPS会话和承载都将被释放。释放过程将删除用户的MM上下文和给EPS实体设置的EPS承载。这时，EMM状态从registered转到de-registered。如果用户正确的detach了，GUTI，NAS层的用户ID和安全上下文，用户接入网络所需要的这些信息都将在UE和MME中保持有效，所以用户可以在下一次接入网络时使用这些信息。 detach可以由UE和网络来触发。网络触发的detach是由MME或者HSS引起的。detach根据在哪里触发可以分为以下几类：1) Detach Case 1: UE发起的DetachUE可以发起detach: 如果UE关机 USIM从UE中移除 UE试图使用non-EPS服务（比如，CSFB，SMS等等） 2) Detach Case 2: MME发起的DetachMME发起detach可以更信息分为显式detach和隐式detach。对于显式detach，MME通过发送detach request消息提前通知UE它要detach，并通知UE在detach之后是否要重新attach。对于隐式detach，MME不通知UE就发起detach过程，因为UE没有能力和MME通信。MME可以发起 i)显式detach 运营商O&amp;M（操作或者维护）的目的 重新鉴权失败 如果MME不能为用户提供分配资源 ii）隐式detach 由于无线链路质量比较差导致不能和用户通信（比如RLF） 3) Detach Case 3: HSS发起的DetachHSS可以发起detach: 如果HSS提供的用户配置文件发生变化，保存在MME中的配置文件也不得不改变时 如果运营商试图限制一个非法的UE接入网络 在下面几章中，我们将描述下面三种类型的详细过程。在这个三个类型中，假设用户在detach之前处于emm-registered ecm-connected rrc-connected状态，并且仅仅通过默认EPS承载提供服务。图1描述了建立了哪些连接，在detach前后用户和控制面的UE和MME都处于什么状态。在detach之前，已经建立默认EPS承载和相关的控制连接，用户处于emm-registered ecm-connected rrc-connected状态。在detach之后，默认EPS承载和所有的信令连接都被释放，用户进入EMM-Deregistered, ECM-Idle and RRC-Idle状态。 III. UE-initiated Detach图2展示了用户发起的detach是怎么执行的。用户发起的detach是由UE触发的，由UE发送detach request消息。当UE接收到MME的detach accept消息（除非用户关机情况下）这个过程结束。 ❶ UE触发detach当检测到UE触发detach，UE和MME都能感知到，这两个实体开始以下的过程：1）【UE-&gt;MME】detach requestUE通过发送detach request消息给MME，请求MME detach。detach request消息参数根据这个消息传送的方向有不同的解释。如果是从UE到MME，这个消息参数如下所示：Detach Request (GUTI, KSIASME, Detach Type(Switch Off)) GUTI：MME在网络attach时分配的用户ID KSI-ASME：UE使用的KSI值 detach type：只是detach的类型 switch off：只是detach是normal detach（0）还是switch off（1） type of detach：EPS detach 2）【UE】处理安全和承载上下文在发送完detach request消息后，UE存储它当前NAS安全上下文，GUTI和TA信息，并删除EPS承载上下文。 3）【MME】通知detach意图和处理安全上下文在接收到detach request消息后，MME可以知道UE detach的意图。并存储用户当前NAS安全上下文，检查detach的类型，例如，是否是normal detach或者关机。通过上述步骤，MME可以知道是否需要发送detach accept消息。 ❷ EPS会话终止一旦MME感知到UE发起的detach并存储用户当前NAS安全上下文，请求对已经激活EPS会话的终止。这个请求触发PCEF（PGW）发起EPS终止，释放所有分配给用户的网络/无线资源。 1）EPS承载释放和PCC策略移除4）【MME-&gt;SGW】请求EPS会话释放MME和SGW在S11接口上通过GTP-C协议通信。MME通过发送给SGW一个delete session request消息来请求删除用户的会话和默认EPS承载。这时，在消息中传递 默认EPS承载ID和UE位置信息 (ECGI, TAI)。 5）【MME】删除EPS承载上下文MME在发送delete session request消息后删除用户EPS承载上下文。 6）【SGW-&gt;PGW】请求EPS会话释放SGW和PGW在S5接口上通过GTP协议相互通信。SGW转发从MME接收到的delete session request消息给PGW。 7）【SGW】删除EPS承载上下文SGW在发送delete session request消息后删除用户EPS承载上下文。 8）【PGW-&gt;PCRF】通知EPS会话终止PGW和PCRF在Gx接口上通过Diameter协议通信。PGW发送给PCRF一个CCR（CC-request）消息来通知PCRF用户已经结束了使用服务。这样，它就可以发起EPS会话终止过程。 9）【PCRF】删除PCC策略一旦PCRF从PGW收到CCR消息，PCRF删除用户的PCC策略。 10）【PGW&lt;-PCEF】确认EPS会话终止PCRF通过发送给PGW CCA（CC-answer）消息来确认用户的PCC策略已经删除了。 11）【SGW&lt;-PGW】响应EPS delete session request当PGW从PCRF接收到CCA消息，PGW发送给SGW一个Delete Session Response消息作为对delete session request消息的响应。 12）【PGW】删除EPS承载上下文在发送delete session response消息后，PGW删除用户的EPS承载上下文。 13）【MME&lt;-SGW】响应EPS Session Release Request当SGW从PGW接收到delete session response消息后，SGW发送给MME delete session response消息作为对delete session request消息的响应。 14）【MME&lt;-UE】确认detach一旦接受到delete session response消息，MME确认用户资源释放已经由PCRF同意了。接着MME发送给UE detach accept接收到作为detach request消息的响应。detach accept消息仅仅当UE的detach请求原因除关机之外的情况下才发送。如果detach 请求原因是因为设备关机，么么不会发送detach accept消息。 (2) S1信令连接释放一旦发送完detach accept 消息给UE之后，么么和eNB释放分配给用户的所有资源（S1信令连接，RRC连接和eNB中的UE上下文），以为UE不要他们的服务了。 15）【eNB&lt;-MME】确认S1信令连接释放MME发送UE Context Release Command给eNB来释放S1信令连接。 16）【UE&lt;-】RRC连接释放eNB发送RRC Connection Release消息给UE来释放任何没有释放的RRC连接。 17）【eNB】删除UE上下文eNB删除所有和UE相关的信息。 18）【eNB-&gt;MME】RRC Connection Release Complete最后eNB发送给MME UE Context Release Complete消息作为对15）请求消息的响应。 IV. MME-initiated Detach图3显示了MME发起的detach是怎么执行的。MME发起的detach是由MME触发，接着MME发送detach request消息给UE，当分配UE的EPS会话资源都被释放后这个过程结束。 ❶ MME触发的detach下面描述了MME检测到detach触发之后，在EPS会话终止过程执行之前的步骤。如果用户这时处于idle状态，MME执行寻呼来建立S1信令连接。1）【UE-&gt;MME】detach request因为这是一个显式detach，MME发送detach request消息来请求UE detach。消息参数包含如下：Detach Request (Detach Type(Re-attach required or not), Cause) detach type：指示UE在detach之后是否需要重新attach（001-需要重新attach，010-不需要重新attach） cause：指示detach的原因 对于隐式detach，MME不发送detach request消息给UE。 2）【MME】处理安全上下文在发送detach request消息给UE之后，MME在删除EPS会话之前存储当前NAS安全上下文。下次重新attach时，MME可以使用这些存储的上下文，并跳过鉴权和ＮＡＳ安全建立过程。 3）【UE】通知detach意图和处理安全承载上下文在接收到MME发送的detach request后，UE获知MME detach的意图。UE检查detach的类型是否需要在detach之后重新attach。然后存储当前NAS安全上下文，并删除EPS承载上下文。 ❷ EPS会话终止一旦MME存储NAS安全上下文，MME请求PGW终止用户的EPS会话。这个请求触发PCEF（PGW）发起EPS终止过程，释放分配给用户的所有网络无线资源。（1）EPS承载释放和PCC规则移除通过4）~13），MME请求终止用户EPS会话，PCEF一旦接收到请求删除PCC规则，删除S5承载资源。在MME发起的detach中需要重新attach时，MME可以保存当前的UE-AMBR，在下次重新attach时UE可以更快的建立EPS承载。 14）【UE-&gt;MME】确认detach一旦接收到detach request消息，在存储NAS安全上下文和删除EPS承载上下文之后，UE发送detach accept消息作为detach request像爱惜的响应。对于隐式detach的情况，1）14）16）步骤是跳过的。 （2）S1信令连接释放在这节中，MME在接收到UE发送的detach accept消息和从SGW发送的delete session response消息后，释放所有未释放的资源。这节的过程和第三章的15-18步相同，除了detach 类型是允许重新attach，UE是在RRC连接释放完成后重新attach到网络的。 V. HSS-initiated Detach图4描述了HSS发起detach的过程 ❶ HSS触发的detach当因为签约信息退回由HSS触发detach，HSS试图立即删除用户的MM上下文和EPS承载。1) 【MME&lt;-HSS】 Detach RequestHSS和MME在S6a接口上通过Diameter协议相互通信。HSS通过发送请求给MME Cancel Location Request (CLR)消息来detach用户。使用以下参数：Cancel Location Request (IMSI, Cancellation Type) IMSI：要detach的用户ID cancellation type = Subscription Withdrawn：指示detach的原因 ❷ EPS会话终止一旦从HSS接收到Cancel Location Request (CLR) 消息，MME释放之前分配给UE的所有资源。这个步骤和MME发起detach的过程是一样的，除了在2）中描述的额外的步骤。MME需要发送给HSS Cancel Location Answer消息作为Cancel Location Request消息的响应。 2) [MME -&gt; HSS] 响应Detach Request一旦从UE接收到detach accept消息，和从SGW接收到delete session response消息，MME会发送给HSS Cancel Location Answer消息作为Cancel Location Request消息的响应。 VI. EPS Entity Information: Before/After Detach这章描述了在执行“EMM Case 2: Detach”步骤之后EPS实体中的信息是如何变化的。每一个实体中的所有信息被分类为UE ID，UE Location，安全和EPS会话/承载信息。 6.1 Before Detach在detach之前用户处于ECM/RRC-Connected状态。所以在detach之前，所有的EPS实体都有和初始附着完成后他们具有的信息相同。图5列出了在detach之前每一个实体中所有的信息。 6.2 After Detach在detach之后，用于用户下次更快和安全attach的信息存储在UE和MME中。所有和用户相关的其他上下文信息，例如NAS安全上下文，GUTI，MME分配的TAI信息都将会释放。图6列出了在detach之后每一个EPS实体中的信息。在detach之后需要删除的信息标示为灰色，不要保留的信息标示为黑色，在下次attach时需要使用的信息被表示为蓝色。 VII. Closing我们已经学习了连接到LTE网络的用户从网络detach的过程。我们根据触发的位置分类detach类型，并对每一种类型进行详细的讲解。我们对比了detach前后每一个实体存储信息的变化。接下来的文档将讨论在用户不活动时删除S1资源的情况。 References[1] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[2] Netmanias Technical Document, “LTE EMM Procedure 1. Initial Attach – Part 2. Call Flow of InitialAttach” , January 2014, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6102[3] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11-EMM Procedure 1. Initial Attach Part2]]></title>
    <url>%2F2016%2F04%2F03%2F11-EMM-Procedure-1-Initial-Attach-Part2%2F</url>
    <content type="text"><![CDATA[EMM Procedure 1. Initial AttachPart 2. Call Flow of Initial Attach 原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6102 I. Introduction我们首先详细探讨EMM case-1：unknown UE的初始附着。这是当用户在签约LTE网络之后，首次打开UE并尝试附着到网络上。之前被分类为attach case-1。 这个文档组织如下：第二章讨论EMM case-1的详细过程，关注在在这个case中的功能需求。第三章描述在初始附着之后每一个实体中哪些信息发生了变化。 II. Initial Attach Procedure图1描述了EMM case1的初始附着过程，还有在每一个流程中的功能模块需求。 2.1 IMSI获取图2展示了这个流程中的第一步。在这一步结束后，MME从UE获得IMSI。UE用attach request包含IMSI试图初始附着到网络上，MME从这个消息中获得IMSI。这一步可以细分为两小步：1）UE在无线连接同步之后待在初始状态2）UE建立ECM连接来传送attach request消息给MME。ECM建立连接过程又可以分为两个子过程，1）RRC连接建立过程2）S1信令连接建立过程。 1）在无线连接同步之后初始状态 为了UE请求附着到网络上，和eNB通信是必须的。所以UE通过PLMN选择和小区搜索过程选择一个eNB，并无线连接同步。接着用户可以和eNB通信了。在这个时候，UE是EMM-deregistered ECM-idle/rrc-idle状态。 2）ECM连接建立 在NAS层上，UE发送attach request消息（包含IMSI和UE网络能力信息）给MME的NAS层来请求初始附着。为了能使attach request消息传输，在UE和MME之间的ECM连接时需要的。对于ECM连接，包含UE和eNB之间的RRC连接，eNB和MME之间的S1信令连接。NAS消息发送首先作为RRC消息通过RRC连接传输，然后通过S1信令连接作为S1AP消息传送（initial UE message初始UE消息）。 （1）RRC连接建立RRC连接时建立在UE和eNB的RRC层之间的。一旦建立完成，在控制面传输消息到RRC层或者上层（NAS层）时使用RRC连接。建立RRC连接的过程如下所示： 1) [UE -&gt; eNB] RRC Connection RequestUE通过发送RRC connection request消息给eNB来请求RRC连接。当UE请求attach，detach，TAU时都是用“Mobile Originating Signaling”，它是一个值，包含在Establishment Cause域。这个消息通过SRB0，CCCH，逻辑信道由UE发送给eNB。SRB0可以被这个小区的所有UE使用。 2) [UE &lt;- eNB] RRC Connection SetupeNB通过发送给UE RRC connection setup消息来为UE分配专有SRB1，这个消息是通过SRB0 CCCH传输的。UE的上行和下行无线资源是由eNB控制的。所以当完成这一步之后，UE通过使用RRC connection setup消息分配的SRB配置信息来使用无线资源。然后UE转到到EMM-deregistered ECM-idle RRC-connected状态。 3) [UE -&gt; eNB] RRC Connection Setup CompleteUE通过使用SRB1 DCCH发送RRC connection setup complete消息通知eNB RRC连接建立完成了。为了有效的传输，当RRC Connection Setup Complete消息传输时，传输到NAS层的attach request消息也被发送到eNB（嵌入到RRC Connection Setup Complete消息的专用NAS信息域DedicatedInfoNAS）。 （2）S1信令连接建立 在eNB和MME之间的控制信息时通过S1-MME接口嵌入到S1AP消息中发送的。S1AP消息是通过为他们专有建立的S1信令连接来传送的。S1信令连接使用eNB和MME分配的ID对（eNB UE S1AP ID, MME UE S1AP ID）来定义标示UE。 在图2中，第一个NAS消息attach request消息在S1信令连接建立之前到达eNB。 eNB接着分配eNB UE S1AP ID用于S1信令连接的建立，并发送给MME attach request消息，嵌入到initial UE message中。attach request消息嵌入到initial UE message消息的NAS-PDU域。这个initial UE message消息包含以下信息字段： Initial UE Message (eNB UE S1AP ID, NAS-PDU, TAI, ECGI, RRC Establishment Cause) eNB UE S1AP ID: 在S1-MME接口上(Uplink)在eNB中标识UE NAS-PDU: a NAS message (Attach Request) TAI: 标识UE待在的TA ECGI: 标识UE待在的小区 RRC Establishment Cause = mo-Signaling: 标识这个信令是UE产生的 当MME在S1-MME接口从eNB接收到这个initial UE message消息，MME为UE分配一个 MME S1AP UE ID。现在有了新分配的这个ID和之前分配的eNB UE S1AP ID，在这两个实体间的S1信令连接建立起来了。接下来MME S1AP UE ID会用于在S1-MME接口（下行）上MME标识UE。 （3）ECM S1连接建立 通过步骤（1）（2），在UE和MME的NAS层之前的ECM连接建立起来了。接着UE转移到EMM-registered ECM-connected RRC-connected状态。 （4）IMSI获取 MME的NAS层从UE的NAS发送的attach request消息中获取的UE的IMSI，通过UE的网络能力信息可以知道UE使用的安全算法和安全能力。 在从attach request消息中获取UE的IMSI和安全能力信息之后，MME执行鉴权和NAS安全建立过程用于NAS消息的安全传输（根据EPS AKA过程使用收集到的信息）。这两个过程–鉴权和NAS安全建立–是在2.2和2.3节描述。我们已经在LTE安全文档中详细介绍了，在这里我们将简单介绍一下。 2.2 鉴权图3描述了UE和MME之间的鉴权过程。这个过程包含两部分，1）鉴权向量获取，MME从HSS获取鉴权向量，2）相互鉴权。在第一步中是在MME和HSS之间S6a接口使用Diameter协议来执行。第二步在UE和MME之间使用NAS协议执行。 （1）鉴权向量的获取1）【MME-&gt;HSS】authentication information RequestMME向HSS发送authentication information Request消息，请求鉴权向量AV。这时候，在这个消息中包含UE的SN ID（服务网络ID）和IMSI，确保HSS返回的是UE当前服务网络信息。authentication information Request消息的主要参数包括： Authentication Information Request (IMSI, SN ID) IMSI: Subscriber identifier (a fixed value provisioned at HSS for a UE) SN ID: indicates the serving network of a subscriber, and consists of an PLMN ID (MCC+MNC) 2）【HSS】产生鉴权向量HSS使用在IMSI中的LTE K和SN ID来生成鉴权向量。鉴权向量生成包含下面两步：第一，HSS生成SQN和RAND，接着在加密函数中输入{LTE K,SQN, RAND} 生成了{XRES, AUTN, CK, IK}. 接着在秘钥生成函数中输入 {SQN, SN ID, CK, IK} 生成KASME。 鉴权向量的最终格式是{RAND, AUTN, XRES, KASME}, 每一个鉴权向量单元的角色如下： Authentication Vectors (RAND, AUTN, XRES, KASME) RAND: HSS生成的随机数，并发送至UE。UE使用它来生成自己的鉴权向量 AUTN: HSS生成的鉴权令牌，并发送至UE，UE在生成自己的鉴权向量之后，和自己对比的鉴权令牌来鉴权网络 XRES: HSS生成的值。MME保留这个值而不发送给UE，接着MME和UE发过来的RES对比来鉴权用户。 KASME: 接入网络的顶层秘钥，由UE和HSS生成，并由HSS发送至MME。它作为MME和UE的基本秘钥用来生成NAS安全秘钥。 3）【MME&lt;-HSS】传输鉴权向量HSS在authentication information Response消息中包含鉴权向量发送给MME。MME接着使用这些信息和UE相互鉴权。 （2）相互鉴权LTE需要相互鉴权。用户必须鉴权网络，网络必须鉴权用户。一旦MME从HSS接收到鉴权向量{RAND, AUTN, XRES, KASME}，它把RAND和AUTN发送给UE，UE使用它们来生成鉴权向量，并鉴权网络。MME保留着XRES, KASME用来用户鉴权和NAS安全秘钥生成。KASME是不会传输UE的。但是KASME的索引KSI-ASME是传输给UE的。相互鉴权过程如下： 4）【UE&lt;-MME】MME请求用户鉴权MME传输authentication Request消息（RAND, AUTN, KSIASME）给UE。 5）【UE】用户鉴权网络：生成鉴权向量并鉴权网络一旦接收到authentication Request消息（RAND, AUTN, KSI-ASME），UE首先从AUTN中生成SQN，接着像图4HSS那样生成鉴权向量。接着UE对比自己生成的AUTN-UE和接收到的AUTN来鉴权网络。并存储 KSI-ASME作为K-ASME的索引。 6）【UE-&gt;MME】用户的RES传输给MME通过对比AUTN，用户完成网络鉴权之后，UE发送自己生成的RES到MME，包含在authentication Response消息中。这样MME就可以鉴权用户了。 7）【MME】网络鉴权UE一旦接收到authentication Response消息，MME对比UE发过来的RES和从HSS接收到的XRES来鉴权用户。 一旦上述步骤完成后，UE和网络就完成了相互鉴权。现在将开始建立NAS安全。 2.3 NAS安全建立一旦用户鉴权完成，MME发起NAS安全建立过程为了NAS消息可以安全的传输。图5展示NAS安全建立过程的流程。 1）【MME】生成NAS安全秘钥MME从attach Request消息中选择应用于NAS消息的加密和完整性算法。接着，从K-ASME中生成NAS完整性秘钥和NAS加密秘钥K-NASint/K-NASenc，应用于NAS消息。 2）【UE&lt;-MME】帮助UE生成NAS安全秘钥MME通过Security mode command消息(KSIASME, Security Algorithm, NAS-MAC)通知给UE选择的加密算法，帮助UE生成NAS安全秘钥。这个消息时包含NAS-MAC完整性保护的。 3）【UE】产生NAS安全秘钥 当UE收到Security mode command消息，UE通过使用MME选择的NAS安全算法来生成NAS安全秘钥(KNASint and KNASenc)。并通过NAS完整性秘钥(KNASint)来对Security mode command消息进行完整性检查。如果完整性检查通过，表示NAS安全秘钥成功设置并工作正常。 4）【UE-&gt;MME】NAS安全秘钥生成完毕UE通过发送Security mode complete消息通知给MME NAS安全秘钥成功生成，接着可以使用生成的秘钥来加密和完整性保护。 在完整上述步骤之后，NAS安全建立过程结束。接着来UE和MME之间的消息都是安全传输的（使用加密和完整性保护）。 2.4 位置更新一旦完成鉴权和NAS安全建立过程，MME需要注册签约用户，并找出来签约用户使用的服务。MME通知HSS签约用户已经注册了并驻留在它的TA，接着从HSS下载签约用户信息。所有这些过程都是通过MME和HSS之间S6a接口的Diameter协议来执行位置更新过程来完成的。具体过程如图6所示。 1）【MME-&gt;HSS】通告UE位置MME向HSS发送update location Request（IMSI，MME ID）消息为了通告UE的注册和获取UE的签约信息。 2）【HSS】UE位置更新HSS注册MME ID来指示UE驻留的哪个MME。 3）【MME&lt;-HSS】用户签约信息的传输HSS把用户的签约信息包含在update location answer消息中发送给MME，MME创建这个签约用户的EPS会话和默认EPS承载。包含在update location answer消息中的签约信息如下： Update Location Answer (IMSI, Subscribed APN, Subscribed P-GW ID, Subscribed QoS Profile) Subscribed APN: 用户签约的APN (e.g. Internet service) Subscribed P-GW ID: 用户接入签约APN通过的那个PGW的ID Subscribed QoS Profile(UE-AMBR(UL/DL), QCI, ARP, APN-AMBR(UL/DL)) UE-AMBR (UL/DL): MME决定和eNB控制的UE具有所有的nonGBR承载的聚合带宽 QCI, ARP, APN-AMBR (UL/DL): 应用于签约APN的QoS 4）【MME】存储签约信息MME从HSS接收到update location answer消息后，存储这个消息中的签约信息。 从下载的签约信息，MME可以检查用户签约的服务，使用什么QoS级别的资源来连接到哪个APN。 2.5 EPS会话建立MME基于签约信息建立EPS会话和默认EPS承载。MME为每一个用户提供满足用户签约QoS的网络/无线资源。图7/8描述了EPS会话和默认EPS承载建立过程。 1）【MME】分配EPS承载IDMME从5-15选择一个值，分配作为EPS承载ID（EBI）来为新附着的用户连接默认EPS承载。 2）【MME】选择PGWMME检查从HSS接收到的APN，并决定使用哪个PGW来接入这个APN。这个决定是基于从HSS接收到的签约信息（PGW ID）。或者如果没有这些信息，MME请求DNS服务器获得APN FQDN(e.g. internet.apn.epc.mnc05.mcc450.3gppnetwork.org), 并从按照PGW选择策略返回的PGW IP地址列表中选择一个。这时候，也需要选择一个SGW来到达PGW。 3）~4）请求EPS会话创建MME通过给PGW发送create session Request消息来请求EPS会话和默认EPS承载的创建。在这个消息中，MME包含从HSS接收到的用户签约信息，当请求PCRF创建EPS会话时，PGW可以使用这些信息。这时候，UE-AMBR还没有包含，因为它是由MME决定的。 3）【MME-&gt;SGW】请求EPS会话创建MME和SGW在控制面使用GTP协议在S11接口上通信。MME发送给第二步选择的SGW create session Request消息，包含以下参数： Create Session Request (IMSI, EPS Bearer ID, P-GW IP, APN, Subscribed Profile (QCI, ARP, APNAMBR (UL/DL)), ECGI, TAI) IMSI: 固定的用户ID EPS Bearer ID: 由MME分配的默认EPS承载ID P-GW IP: MME选择用于EPS会话/承载创建的PGW IP地址 APN: 用户签约的APN Subscribed Profile (QCI, ARP, APN-AMBR (UL/DL)): 建立默认EPS承载时使用的QoS信息 ECGI: 用户驻留的小区 TAI: 用户驻留的TA 4）【SGW-&gt;PGW】请求EPS会话的创建SGW和PGW在S5接口上用户面和控制面使用GTP（UP：GTP-U，CP：GTP-C）协议通信。SGW在create session Request消息中分配S5 TEID来建立到PGW的S5 GTP。接着在create session request消息中发送这个ID和其他参数给PGW。 Create Session Request (IMSI, EPS Bearer ID, S5 S-GW TEID, APN, Subscribed Profile (QCI, ARP, APN- AMBR (UL/DL)), ECGI, TAI) 5）【S5 承载：下行】一旦4）完成之后，下行S5 GTP-U隧道就建立起来了，允许PGW发送下行流量给SGW。在图7和8中，分配和发送GTP隧道TEID的实体被标记为实点，接收的一个被标记为虚点。 6）【PGW】分配用户IP地址PGW一旦接收到create session request消息，意识到用户试图通过IMSI接入网络。所以PGW给UE分配IP地址，让UE可以使用IP。 7）【PGW-&gt;PCRF】通知EPS会话建立PGW和PCRF通过Gx接口使用Diameter协议通信。当创建了用户的EPS会话，用户的资源配置和QoS控制都必须基于用户订阅的服务来决定。PCRF负责所有接入网络UE的接入策略。所以，PGW提供给PCRF用户的签约信息，并获取资源分配和网络运营商策略的PCRF授权。从UE的签约信息（从MME接收到的），PGW获取用于PCRF运营商策略决策制定的信息，并通过CCR消息（CC-request）发送这些信息给PCRF。这个消息实例如下：CCR (IMSI, UE IP, PDN ID (APN), Subscribed QoS Profile (QCI, ARP, APN-AMBR (UL/DL)), ECGI,TAI)： IMSI: 固定的用户ID UE IP: 正在服务中的用户使用的IP地址 PDN ID: 用户使用的APN Subscribed Profile (QCI, ARP, APN-AMBR (UL/DL)): 建立默认EPS承载时应用的QoS信息 ECGI: UE驻留的小区 TAI: UE驻留的TA 8）【PCRF-&gt;SPR】请求接入配置PCRF向SPR请求用户接入配置文件来决定用户的PCC策略 9）【PCRF&lt;-SPR】返回接入配置SPR返回用户的接入配置文件。这个配置文件包含的信息例如，SDF Filter, QCI, ARP, APN-AMBR (UL/DL), Charging Method (e.g. Offline), Changing Reporting Action (e.g. Start Reporting ECGI, TAI),等等 10）【PCRF】决定策略PCRF决定EPS会话建立（基于用户接入配置文件）的PCC策略。 11）【PGW&lt;-PCRF】确认EPS会话建立PCRF传输决定好的PCC策略给PGW，包含在CCA（CC-answer）消息中。这个消息的实例如下：CCA (IMSI, PCC Rule (SDF Filter, QCI, ARP, APN-AMBR (UL/DL), Charging=Offline, Change Reporting Action (Start Reporting ECGI, TAI)) 12）策略实施PGW应用从PCRF接收到的PCC策略。PCC策略应用到每一个SDF上，所以PGW需要建立SDF和EPS承载之间的映射，并准备应用QoS配置文件到默认EPS承载上。 13）~15）EPS session create responsePGW通过发送create session response消息通知MME，应用于建立EPS会话和默认EPS承载的QoS信息。PCRF可能会保存这个从HSS接收到的值或者选择一个新的值。 13）【SGW&lt;-PGW】EPS session responsePGW为建立到SGW的S5 GTP分配S5 TEID。接着在create session response消息中包含S5 PGW TEID和QoS配置文件应用于默认EPS承载，并发送给SGW作为对create session request消息的响应。Create Session Response (UE IP, EPS Bearer ID, S5 P-GW TEID, Authorized QoS Profile (QCI, ARP,APN-AMBR (UL/DL)), TFT (UL), Change Reporting Action (Start Reporting ECGI, TAI)) 14）【S5承载：上行】S5承载建立在完成13）之后建立了上行S5 GTP-U隧道，允许SGW和PGW剑豪上下行流量。 15）【MME&lt;-SGW】EPS session create response当从PGW接收到create session response消息后，SGW保留上行S5 TEID用于上行流量，并允许S1GTP 隧道的S1 TEID用于S1承载。在处理完这个消息后，SGW在处理完的消息上加入新分配的S1 SGW TEID，然后发送到MME，作为对3）的create session request的响应。 16）【MME】为什么MME保留S5 PGW TEID一旦附着到网络，如果UE执行TAU或者切换，SGW可能发生改变。所以MME通知UE新SGW的上行S5 TEID，这样新SGW可以传输上行流量给PGW。 17）【S1承载：上行】完成15）之后建立了上行S1 GTP隧道。但是因为eNB还没有S1 SGW TEID，所以这是还不能给SGW传输上行流量。 18）【MME】计算ue-ambr这时候，MME返回给attach accept消息给UE作为对attach request消息的响应，并通过控制eNB来转呗e-rab建立（eg，为无线链路和S1承载分配资源）。MME计算ue-ambr值发送给eNB。MME已经接收到ue-ambr值，包含在签约信息中。但是MME可以调整这个值，使之不超过每一个APN的全部apn-ambr，并分配它。 19）决定E-rab和NAS信令需要的信息在从PGW接收到create session response消息之后，MME知道已经指定和分配给用户的资源。接着，MME负责E-RAB的建立，并控制eNB和SGW。最后，MME决定E-RAB建立所需要的资源和NAS信令需要的信息： 分配给UE GUTI代替IMSI 决定和控制TAU相关的参数（TAI列表分配，tau定时器值） 决定eNB使用的ue-ambr值 分配e-rab ID 20）【UE&lt;-MME】attach acceptMME在attach accept消息中包含下面信息：PGW分配的UE IP地址，GUTI，TAI list，EPS bearer ID，MME自己分配的UE-AMBR，从SGW接收到的QoS参数，并发送给UE作为对attach request的响应。这个消息是包含在initial context setup request消息中通过S1信令连接传送的，接着通过RRC连接包含在RRC connection reconfiguration消息中。 21）【MME】生成K-eNBMME从K-asme中生成K-enb，（AS安全基础秘钥）。这是为了确保eNB可以生成AS安全秘钥用于eNB和UE之间无线链路的安全传输。 22）【eNB&lt;-MME】请求e-rab建立MME发送initial context setup request消息，接着eNB和SGW建立起S1承载，和UE建立起DRB承载。这个消息包含以下信息：Initial Context Setup Request (UE-AMBR (UL/DL), E-RAB ID, E-RAB QoS (QCI, ARP), S1 S-GW TEID,KeNB, , UE Security Algorithm, NAS-PDU)： UE-AMBR(UL/DL):只能被eNB控制的QoS参数 E-RAB ID: 由MME分配，并由eNB作为EPS bearer ID使用 E-RAB QoS: 由MME以及与从PGW接收到的EPS bearer QoS来决定 S1 S-GW TEID: 从SGW接收到的上行S1 TEID KeNB: 由MME从Kasme生成的，用于eNB中AS安全秘钥的生成 UE Security Algorithm: 包含在Attach Request消息中，和KeNB一起用来eNB建立AS安全 NAS-PDU: NAS消息 (Attach Accept) 23) [S1 承载: 上行]一旦22）完成，获得了S1 SGW TEID，eNB可以传输上行流量到SGW。当eNB接收到MME的Initial Context Setup Request消息来请求E-RAB建立，eNB通过发送attach accept消息给UE来建立DRB。接着eNB在Initial Context Setup Response消息中包含下行S1 TEID来建立S1承载，并发送Initial Context Setup Response消息到MME来作为Initial Context Setup request消息的响应，所以MME可以转发这个消息给SGW。 24) ~ 27) AS安全建立一旦接收到MME的initial context setup request消息，eNB试图和UE通信建立DRB。为了在无线链路上安全的通信，eNB在发送信息给UE之间需要执行AS安全建立过程。 24) [eNB] 产生AS安全秘钥eNB从KeNB中生成AS安全秘钥用于RRC消息和用户流量的安全传输。eNB从MME传输过来的安全算法中为RRC消息选择加密和完整性算法，并未用户流量选择加密算法。接着，从K-eNB中生成KRRCint/KRRCenc（RRC完整性和加密秘钥）和KUPenc（用于用户数据的加密）。 25) [UE &lt;- eNB] 帮助UE生成AS安全秘钥eNB通过通知给UE选择的AS安全算法来帮助UE生成AS安全秘钥 (KRRCint, KRRCenc and KUPenc)，（使用Security Mode Command(AS Security Algorithm, MAC-I)消息来传输）。eNB发送完整性保护的RRC消息，（包含mac-I）. 26) [UE] 生成AS加密秘钥一旦接受到Security Mode Command 消息，UE通过使用eNB选择的AS安全算法来生成AS安全秘钥，并执行Security Mode Command 消息的完整性检查。 27) [UE -&gt; eNB] AS秘钥生成完成一旦完成对Security Mode Command 消息的完整性检查，AS安全秘钥被成功的建立起来，并准备在UE和eNB之间使用。UE通过使用Security Mode complete (MAC-I) 消息指示eNB AS安全秘钥已经产生。UE使用RRC完整性秘钥来对发送的消息进行完整性保护。随着在无线链路接上AS安全建立过程结束，在随后的无线连接上的RRC消息交换都是加密和完整性保护的，并用户消息是加密传送的。现在eNB开始建立DRB 28) ~ 29) DRB建立28) [UE &lt;- eNB] 重配RRC连接eNB分配上下行 DRB ID，并从E-RAB QoS中配置DRB QoS参数来建立无线连接的DRB。接着通过安全的RRC连接发送RRC connection reconfiguration消息给UE。RRC连接上在UE发送attach request消息时建立。现在RRC连接必须重配，因为UE被允许接入网络后需要根据网络分配的资源来配置参数。UE的RRC层根据RRC connection reconfiguration消息中的配置参数来分配无线资源。接着从RRC connection reconfiguration中提取attach accept消息，并发送到NAS层。当UE的NAS层接收到这个消息，从这个消息中蝴蝶UE IP地址和GUTI，用于接下来的通信需要。 29) [DRB 建立: 上行和下行] DRB建立完成一旦28）完成后，UE可以和eNB之间传输上下行数据。 30) [eNB -&gt; S-GW] E-RAB Setup ResponseeNB为S1承载分配下行S1 TEID (S1 eNB TEID) 。接着在 Initial Context Setup Response消息中包含分配的ID发送给MME，作为 Initial Context Setup request消息的响应，接着MME把这个消息转发给SGW。 31) [eNB] 为S1承载分配下行TEID一旦29）完成后，eNB为S1承载分配了下行TEID，建立下行S1 GTP-U隧道。因为SGW并不知道是否建立，现在它还不能传输下行数据到eNB。 32) [UE -&gt; MME] 发送Attach Complete 消息UE发送Attach Complete消息给MME作为20）的消息的响应。Attach Complete消息是在RRC连接上通过UL Information Transfer消息，在S1信令连接上通过Uplink NAS Transport 消息传输的。 33) [UE][MME] EMM State现在UE和MME处于EMM-Registered状态。如果在20）从MME接收到的是Attach Reject消息，UE必须释放ECM/RRC连接，并且转移到EMM-deregistered状态。 34) [MME -&gt; S-GW] 请求S1承载修改MME通过Modify Bearer Request消息转发从eNB接收到的下行S1 TEID(S1 eNB TEID)给SGW。 35) [MME &lt;- S-GW] 响应S1 Bearer Modification RequestSGW发送给MME Modify Bearer Response消息作为对Modify Bearer Request消息的响应。现在SGW准备传输下行S1数据。 36) [S1 Bearer: Downlink] S1 Bearer Setup Complete在35）完成S1承载建立过程。随着S1承载建立的完成，eNB和SGW可以相互交换数据了。现在从UE一直到PGW的默认承载终于建立起来了，允许在UE和PGW之间传输上下行EPS承载通信。 III. EPS Entity Information: Before/After Initial Attach在这一章，我们将讨论在“EMM Case 1: Initial Attach by Unknown UE”过程前后EPS实体的EMM状态的变化。存储在EPS实体中的信息将会被分组给UE ID信息，UE 位置信息，安全上下文信息，安全上下文信息，EPS会话/承载信息，如图9所示。 3.1 Initial Attach之前图10描述了在“EMM Case 1: Initial Attach by Unknown UE”过程之前每一个实体中的信息。因为EMM case-1是未知用户的初始附着，所以仅包含网络提供的信息。 UE ID information: 在UE, HSS and SPR.中提供的用户的IMSI。 UE Location information: 在UE和网络都没有任何关于UE位置的信息。 Security Context information: 在UE and HSS提供了用于用户鉴权的LTE 主秘钥 EPS Session/Bearer information: 用户签约信息 (Default APN, Subscribed QCI, ARP,UE-AMBR, APN-AMBR, etc.) 和用户接入配置 (Subscribed QCI, ARP, APN-AMBR, etc.)在HSS and SPR中提供。 3.2 Initial Attach之后图11描述了在“EMM Case 1: Initial Attach by Unknown UE”过程之后EPS实体中存储的信息。因为用户已经注册到网络上，所有必要的信息都分配了，信息（用于UE安全接收用户数据和用于在任何设定的位置以想要的服务质量使用服务的信息）都分配了。我们将学习在initial attach之后什么信息发生了变化。 UE ID Information的变化 IMSI: 在EPS承载/会话建立之后，由UE通过attach request消息传输的IMSI被加入到MME, SGW, P-GW and PCRF。 GUTI: 在NAS消息中使用由MME分配的用来代替IMSI的GUTI加入到MME和UE. UE IP address: PGW分配的UE IP地址被加入到P-GW, PCRF, MME and UE. C-RNTI: eNB分配的C-RNTI 用来空中接口物理层识别UE被加入到到eNB和UE. UE S1AP ID: eNB UE S1AP ID和MME UE S1AP ID接入到eNB和MME用来S1-MME接口S1AP消息中标识用户。 UE Location Information的变化 ECGI: 用户驻留小区信息加入到UE, eNB, MME, S-GW, P-GW and PCRF. 每次用户移动到一个新小区，MME通知PGW，接着通知PCRF，用PCRF设定的Change Reporting Action策略通知小区。 TAI: 用户驻留的TA加入到UE, eNB, MME, S-GW, P-GW and PCRF. 每次用户移动到一个新的TA，MME通知PGW，接着通知PCRF，用PCRF设定的Change Reporting Action策略通知TA。 TAI list: UE不需要tau就可以进入的TA列表加入到MME和UE MME ID: 用户附着打MME信息加入到HSS中 Security Context Information的改变 NAS Security Info: NAS安全上下文信息加入到UE和MME中 AS Security Info: AS安全上下文加入到UE和eNB中 EPS Session/Bearer Information的改变 APN in Use: 在EPS会话创建时加入到MME, S-GW, P-GW, PCRF and UE EPS Bearer ID: 加入到MME和默认承载创建的实体，像UE, eNB, S-GW and P-GW. DRB ID: 加入到UE 和eNB使之能在无线连接上通信 E-RAB ID: 在E-RAB创建时加入到eNB和MME中 S1 TEID (UL/DL): 在S1承载建立时加入到eNB, S-GW and MME S5 TEID (UL/DL): 在S5承载建立时加入到S-GW, P-GW and MME QCI: 分配用于所有类型的SDF和EPS承载，加入到UE, eNB, MME, S-GW, P-GW and PCRF. 这个值是由PCRF提供的。 ARP: 分配用于所有类型的SDF和EPS承载，加入到eNB, MME, S-GW, P-GW and PCRF,但是不分配给UE(unlike QCI). 这个值是由PCRF提供的。 UE-AMBR (UL/DL): 在EPS会话和承载创建时加入到MME和eNB中。是由MME计算得到的。 APN-AMBR (UL/DL): 在EPS会话和承载创建时加入到MME和eNB中。这个值是由PCRF提供的。UE只有APN-AMBR（UL）。 TFT (UL/DL): 在EPS承载创建时加入到PGW和UE中。PGW上下行都有这个值，但是UE只有上行有。 SDF Filter: 在EPS会话创建时加入到PCRF。 Subscribed Profile: 在用户位置更新过程时在从HSS中下载签约信息时加入到MME中。 IV. Closing我们讨论了在签约服务之后第一次附着网络initial attach过程。另外，在上面的文档讨论了四种case。在接下来我们将讨论detach过程。 References[1] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[2] Netmanias Technical Document, “EMM Procedure 1. Initial Attach – Part 1. Cases of Initial Attach”,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6098[3] Netmanias Technical Document, “LTE Security II: NAS and AS Security”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5903[4] Netmanias Technical Document, “LTE Security I: LTE Security Concept and LTE Authentication”, Julyhttp://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5902[5] Netmanias Technical Document, “LTE QoS: SDF and EPS Bearer QoS”, September 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5908[6] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10-EMM Procedure 1. Initial Attach Part-1]]></title>
    <url>%2F2016%2F04%2F03%2F10-EMM-Procedure-1-Initial-Attach-Part-1%2F</url>
    <content type="text"><![CDATA[EMM Procedure 1. Initial AttachPart 1. Cases of Initial Attach 原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6098 I. Introduction这个文档讨论初始附着，也就是第九篇文档所讨论的case1。在这个阶段，用户在签约到一个LTE网络服务之后，用户开机，试图附着到网络上，发送IMSI给网络。初始附着过程随着环境发生变化。可以是下面将要讨论的case1也可以是EMM case11（在另外一个城市初始附着，将在后面的文档中讨论）。或者可以使其他类型，取决于用户是否保存着上次附着到网络时使用的信息，（这里是指最后附着信息，或者MME是否有用户的信息，包括UE ID，接下来都是指最后一次UE上下文）。所以这个文档描述了不同初始附着类型，发现他们的特征和不同。接下来的文档part2将描述EMM case1，详细介绍相关的过程。 这个文档组织如下：第二章描述不同的初始附着类型，第三章通过列出MME执行的功能来简要讨论每一种情况的不同初始附着过程。 II. Cases of Initial Attach当UE初始附着到网络，MME根据附着的类型来发起不同的过程。这个过程以attach request消息开始，以attach accept消息结束。当UE发送给MME attach request消息，在这个消息包含UE ID（IMSI or old GUTI）来识别UE。当MME发送attach accept（GUTI和TAI列表）消息，在消息中包含用来代替IMSI的ID –GUTI，和包含TAI列表（在这个区域，UE不需要TAU过程可以进入的区域）。 在接收到attach request消息之后，发送attach accept消息之前，MME可能执行以下过程的全部或部分： UE ID 获取 鉴权 NAS安全建立 位置更新 EPS会话建立 基于UE发起的初始附着的类型，决定要执行哪些过程。但是，UE ID过去和EPS会话建立过程是所有初始附着过程都必须的。其他过程，像鉴权，NAS安全建立和位置更新更具初始附着的类型选择的执行。这些过程的选择受到下面因素的影响：i)UE有的UE ID是什么（IMSI or old GUTI），ii）上次附着信息是否依旧保存在MME中有效等等。在这个文档中，我们将使用下面的判决来分辨初始附着的不同类型，如图1所示。 UE使用什么UE ID累发起初始附着请求（IMSI or old GUTI）？ UE尝试附着的MME是哪个（是上次附着的那个，还是从来没有附着过的一个新的）？ 在网络中是否有有效的UE上下文存在？ 在这个文档中，如果上次UE上下文（包含UE ID）在网络中不存在，UE被定义为未知UE，其他的称为已知UE。2.1节描述未知UE的初始附着，2.2节描述已知UE的初始附着。下面，如果UE有上次附着信息，我们假设attach request消息已经完整性保护的。 2.1 未知UE图2描述了当UE给网络发送了attach request消息初始附着的实例，MME没有关于用户的有效的UE上下文。我们将分辨初始附着的类型，并解释每一种类型的特征比较。现在UE想附着的MME称为新MME，上次UE已经附着过的MME称为旧MME。 attach case-1：当UE使用IMSI来附着 这个是在UE和MME中都没有上次UE上下文，这种情况下需要的场景如下： 1）UE使用IMSI作为UE ID发送给MME attach request消息。MME从这个消息中获得IMSI。2）假设MME不知道UE（以为发送的而是IMSI），MME发起鉴权和NAS安全建立过程。3）MME向HSS发送位置更新消息通知HSS UE已经注册上了，并从HSS中下载这个用户的签约信息。 attach case-2：当UE附着的MME是上次已经附着的MME（new MME=old MME），但是MME没有包含有效的上次UE上下文 这个是当UE在上次附着后仍保留着上次附着信息（old GUTI和NAS安全上下文）时UE尝试附着到相同的MME上，但是MME没有任何UE的上下文。基本的过程如下：1）UE使用old GUTI给新的MME发送attach request消息。这时候，这个attach request消息是使用NAS安全秘钥（K-NASinc）完整性保护的。2）因为GUTI包含GUMMEI，新的MME就可以从old GUTI中知道这个旧的GUTI是从哪里分配的。新的MME查找上次UE上下文，但是没有找到任何信息（例如，完整性验证失败或者没有old GUTI）。3）MME给UE发送identity request消息来请求IMSI。4）UE给MME发送identity response消息提供请求的IMSI。5）现在，MME通过使用获取的IMSI按照attach case-1的流程执行鉴权和NAS安全建立过程，接着发送UE位置更新消息给HSS。 attach case-3：当UE附着到一个之前从来没有附着过的MME上（new MME ！= old MME），且MME没有有效的上次UE上下文信息 这是当UE在上次去附着之后仍然还保留着上次附着信息，附着到一个新的MME，不是旧的MME，但是就的MME没有和UE关联的有效的UE上下文信息。基本过程如下所示：1）UE使用old GUTI作为UE ID给新的MME发送attach request消息，这时候这个消息是完整性保护的2）当新的MME接收到这个消息，他从这个old GUTI知道来自哪里。3）接着，新的MME向旧的MME发送identification request（old GUTI，完整的attach request消息）把旧的GUTI和attach request消息转发给旧的MME。通过这个消息，新的MME请求和旧的GUTI相关的上次UE上下文。4）一旦接收到这个消息，旧MME查找UE上下文，但是没有找到任何信息。5）旧MME给新MME发送identification response消息，通知没有找到UE上下文。 从这儿开始开始和attach case-2相同，执行attach case-2的3/4/5。新MME发送给UE identify request消息来请求IMSI。接着UE携带自己的IMSI使用identify response消息发送给MME。MME接收到IMSI后，MME开始执行鉴权和NAS安全建立和UE位置更新。 2.2 已知UE图3展示了UE发送attach request初始附着到网络，并且MME有用户有效的UE上下文信息的情况。在初始附着时，不像未知UE，所有的已知UE都是使用GUTI，不是IMSI。在图3中，UE和MME中都包含和用户相关的UE上下文信息，并且UE发送的attach request消息是完整性保护的。 attach case-4：当UE附着到上次附着过的MME上，并且这个MME中包含用户有效的上次UE上下文 这是当UE仍旧有上次附着信息（old GUTI，NAS安全上下文），附着到它上次附着的MME，MME具有这个UE的有效UE上下文。具体的场景如下：1）UE使用old GUTI作为自己的UE ID给new MME发送attach request消息。这个attach request消息是使用NAS完整性秘钥K-NASint完整性保护的。2）这个new MME从old GUTI中知道谁分配的这个ID。然后它查找old GUTI，找到有效的UE上下文（IMSI，MM上下文（NAS安全上下文，UE-AMBR））。3）MME对attach request消息执行完整性检查 i)如果完整性检查失败，MME必须使用IMSI来鉴权用户，并执行用户的NAS安全建立过程。 ii）如果完整性检查通过，MME会略过鉴权和NAS安全建立过程。 attach case-5：当UE附着到之前没有附着过的MME上（new MME！=old MME），并且old MME具有有效的上次UE上下文 这是当仍包含上次附着信息，附着到一个新的MME，在旧的MME上具有有效的UE上下文。一个简单过程如下：1）UE使用old GUTI作为自己的UE ID给new MME发送attach request消息。这个attach request消息是完整性保护的。2）new MME从接收到的old GUTI上知道是谁分配的（old MME）。3）new MME向old MME发送identification request（old GUTI，完整的attach request消息），转发old GUTI和attach request消息。通过这样，new MME请求和old GUTI相关联的上次UE上下文信息。4）一旦接收到这个消息，old MME查找UE上下文，找到和这个UE相关联的IMSI和MM上下文（NAS安全上下文，UE-AMBR）。5）old MME对attach request消息执行完整性检查6）old MME把完整性检查的结果通过identification response消息发给new MME i)如果完整性检查失败，old MME在这个消息转发错误原因消息。 ii）如果完整性检查通过，则转发UE上下文（IMSI，old GUTI，MM上下文）。 如果完整性检查失败，情况和attach case-3相同，因此需要执行和attach case-3上相同的IMSI获取，鉴权和NAS安全建立过程。如果检查通过，new MME从old MME接收到IMSI和MM上下文，并略去鉴权和NAS安全建立的过程（类似case-4）。和case-4不同的一点就是因为UE是附着到一个new MME，这个new MME需要和HSS通信更新UE的位置信息。 III. Simplified Call Flow in Each Case第二章介绍了不同类型的初始附着。第三章将描述在每种类型的流程，主要关注在功能模块上。图4描述了基于使用不同的UE ID，每一个初始附着过程具有不同的流程。对于known UE的初始附着情况，我们讨论NAS-MAC完整性检查在什么地方完整。在初始附着过程中执行的功能模块包括： 1）UE ID获取MME获取去UE ID用于用户身份认证和鉴权。UE ID可以是IMSI和old GUTI。IMSI可以通过attach request或者iDentify response消息从UE中获取，而old GUTI可以通过attach request消息从UE中获取。 2）鉴权如果MME通过attach request消息获取IMSI或者old GUTI作为UE ID，但是这个消息的完整性检查失败了，网络检查是否需要通过执行EPS AKA过程来允许UE附着。通过产生鉴权向量并发送到MME，HSS产生K-ASME（MME基本秘钥），接着和UE之间执行相互鉴权。 3） NAS安全建立一旦用户鉴权完成，产生了在UE和MME之间用于NAS消息安全传输的NAS安全秘钥。 4）位置更新MME从HSS下载用户信息，并且HSS更新UE当前位置的信息。MME只有当i)UE使用IMSI作为UE ID时ii）MME没有有效的上次UE上下文信息iii）MME没有关于用户的任何签约信息iv）UE上次从其他MME上去附着，这些情况下MME才会执行位置更新。 5）EPS会话建立EPS会话和默认承载建立。 3.1 使用IMSI初始附着attach case-1：unknown UE UE使用IMSI请求初始附着，MME从attach request消息中获取用户的IMSI。 【UE-&gt;MME】attach request（IMSI） 在初始附着时UE如果使用IMSI，MME会执行鉴权，NAS安全建立和位置更新，建立EPS会话/默认EPS承载。 3.2 使用GUTI初始附着attach case-2：unknown UE，MME unchanged UE使用old GUTI请求初始附着，但是MME中没有old GUTI。所以MME向UE请求UE ID，并获取IMSI。 【UE-&gt;MME】 attach request（old GUTI）【MME】 no IMSI【UE&lt;-MME】 identity request（UE ID=IMSI）【UE-&gt;MME】identity response（IMSI） 剩下来的过程和case-1相同。也就是，MME执行鉴权，NAS安全建立，位置更新和建立EPS会话/默认EPS承载。 attach case-3：unknown UE，MME changed UE使用old GUTI请求初始附着。所以，new MME向old MME请求上次UE上下文，但是没有接收到任何有效的。所以MME向UE请求UE ID，获取IMSI。 【UE-&gt;new MME】 attach request（old GUTI）【new MME-&gt;old MME】identification request(old GUTI)【old MME】no IMSI【new MME&lt;-old MME】identification response（error cause）【UEnew MME】identify response（IMSI） 剩下的过程和case-1相同。也就是，MME执行鉴权，NAS安全建立，位置更新和建立EPS会话/默认EPS承载。 attach case-4： known UE， MME unchanged UE使用old GUTI请求初始附着，MME有和old GUTI相关的上次UE上下文。所以不需要获取IMSI的步骤。 【UE-&gt;MME】 attach request（old GUTI）【MME】 IMSI，old GUTI，MM上下文 如果在NAS-MAC完整性检查通过，MME可能不执行鉴权，NAS安全建立和位置更新立即建立EPS会话/默认EPS承载。 attach case-5：known UE，MME changed UE使用old GUTI来请求初始附着。所以new MME向old MME请求上次UE上下文信息，并获取UE的IMSI和MM上下文。 【UE-&gt;new MME】 attach request（old GUTI）【new MME-&gt;old MME】identification request(old GUTI)【old MME】IMSI，old GUTI，MM上下文【new MME&lt;-old MME】identification response（IMSI，old GUTI，MM上下文） 如果old MME的NAS-MAC完整性检查通过，new MME介绍接收到IMSI和MM上下文，就不执行鉴权和NAS安全建立。但是因为MME发生了改变，new MME需要和HSS通信来更新UE位置信息，并建立EPS会话/默认EPS承载。HSS从old MME到new MME更新UE的位置信息，并发送cancel Location消息给old MME来通知UE的MM上下文信息可以从old MME中删除了。 IV. Closing到目前为止，我们讨论了初始附着的不同类型，并且不同类型所需要的步骤。在接下来的文档中，我们将关注详细的初始附着过程，并探讨在这些附着过程中在EPS实体中有哪些信息需要设置。 References[1] Netmanias Technical Document, “Eleven EMM Cases in an EMM Scenario”, October 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002[2] Netmanias Technical Document, “LTE Security II: NAS and AS Security”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5903[3] Netmanias Technical Document, “LTE Security I: LTE Security Concept and LTE Authentication”, July2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5902[4] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9-EMM Scenario and Eleven EMM Cases]]></title>
    <url>%2F2016%2F04%2F03%2F9-EMM-Scenario-and-Eleven-EMM-Cases%2F</url>
    <content type="text"><![CDATA[原文地址：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=6002 NOTE：初始状态，UE A是关机的，并且在网络中没有UE A的UE上下文存在。 EMM case 1，Initial Attach（初始附着）UE状态：“EMM-Deregistered，ECM/RRC-Idle”–&gt;“EMM-Registered，ECM/RRC-Connected” UE A开机，UE A进入“EMM-Deregistered，ECM/RRC-Idle”并试图接入网络。 在UE A和MME中没有UE A的UE上下文 在同步到一个小区之后，UE A用IMSI作为UE ID发送Attach Request给MMT来发起initial attach过程 在成功完成initial attach之后，UE A进入“EMM-Registered，ECM/RRC-Connected”状态并使用注册的服务。 EMM case 2，Detach（去附着）UE状态：“EMM-Registered，ECM/RRC-Connected”–&gt;“EMM-Deregistered，ECM/RRC-Idle” UE A在“EMM-Registered，ECM/RRC-Connected”状态下从网络去附着。 根据detach触发的原因，有三种类型的detach过程（UE发起的，MME发起的和HSS发起的）。 一旦成功完成了Detach过程之后，UE A进入”EMM-Deregistered，ECM/RRC-Idle”状态 EMM case 3，由于用户不活动释放S1UE状态：“EMM-Registered，ECM/RRC-Connected”–&gt;“EMM-Registered，ECM/RRC-Idle” 在“EMM-Registered，ECM/RRC-Connected”状态下在一段时间内UE A没有使用服务。 eNB检测到用户的不活动，释放S1承载和S1信令连接。 在成功完成S1释放过程后，UE A进入“EMM-Registered，ECM/RRC-Idle”状态。 EMM case 4，由于新的业务发起服务请求UE状态：“EMM-Registered，ECM/RRC-Idle”—&gt;“EMM-Registered，ECM/RRC-Connected” UE A在“EMM-Registered，ECM/RRC-Idle”状态下产生了新的业务。 新的业务可以由UE A产生也可以由网络产生，并发起服务请求过程。 在成功完成服务请求过程之后，UE A进入“EMM-Registered，ECM/RRC-Connected”状态。 EMM case 5，TAUUE状态：“EMM-Registered，ECM/RRC-Idle”—&gt;“EMM-Registered，ECM/RRC-Connected”—&gt;“EMM-Registered，ECM/RRC-Idle” UE A在“EMM-Registered，ECM/RRC-Idle”状态，且周期性TAU定时器（T3412）超时。 UE A执行周期性TAU过程，UE A建立到MME的ECM连接，发送TAU Request消息并转移到“EMM-Registered，ECM/RRC-Connected”状态。 在成功完成周期性TAU过程之后，释放ECM连接并且UE A进入“EMM-Registered，ECM/RRC-Idle”状态。 EMM case 6，没有TAU的切换UE状态：“EMM-Registered，ECM/RRC-Connected”–&gt;“EMM-Registered，ECM/RRC-Connected” UE A在“EMM-Registered，ECM/RRC-Connected”状态，移动到一个新的小区，并且检测到这个新进入的TA包含在TAI列表中。 执行切换到新的小区，但是不需要执行TAU过程。 在成功完成切换之后，UE A保持在“EMM-Registered，ECM/RRC-Connected”状态。 EMM case 7，没有TAU的小区重选UE状态：“EMM-Registered，ECM/RRC-Idle”–&gt;“EMM-Registered，ECM/RRC-Idle” UE A在“EMM-Registered，ECM/RRC-Idle”状态，移动到一个新的小区，并且检测到这个新进入的TA包含在TAI列表中。 执行重选到新的小区，但是不需要执行TAU过程。 在成功完成重选过程之后，UE A保持在“EMM-Registered，ECM/RRC-Idle”状态。 EMM case 8，包含TAU的切换UE状态：“EMM-Registered，ECM/RRC-Connected”–&gt;“EMM-Registered，ECM/RRC-Connected” UE A在“EMM-Registered，ECM/RRC-Connected”状态，移动到一个新的小区，并且检测到这个新进入的TA不包含在TAI列表中。 执行切换到新的小区，并且需要执行TAU过程。 在成功完成切换之后，UE A保持在“EMM-Registered，ECM/RRC-Connected”状态。 EMM case 9，包含TAU的小区重选UE状态：“EMM-Registered，ECM/RRC-Idle”–&gt;“EMM-Registered，ECM/RRC-Connected”–&gt;“EMM-Registered，ECM/RRC-Idle” UE A在“EMM-Registered，ECM/RRC-Idle”状态，移动到一个新的小区，并且检测到这个新进入的TA不包含在TAI列表中。 执行重选到新的小区，并且需要执行TAU过程。UE A建立到MME的ECM连接并发送TAU Request消息，转移到“EMM-Registered，ECM/RRC-Connected”状态。 在成功完成TAU更新过程之后，UE A进入“EMM-Registered，ECM/RRC-Idle”状态。 EMM case 10，移动到另一个城市UE状态：“EMM-Registered，ECM/RRC-Connected”–&gt;“EMM-Registered，ECM/RRC-Idle”–&gt;“EMM-Deregistered，ECM/RRC-Idle” UE A从城市1（正在服务或者在idle状态）移动到城市2。UE A移出了LTE的覆盖区外，并且从网络detach。 在detach过程之后，UE A进入“EMM-Deregistered，ECM/RRC-Idle”状态。 EMM case 11，在另一个城市初始附着UE状态：“EMM-Deregistered，ECM/RRC-Idle”–&gt;“EMM-Registered，ECM/RRC-Connected” UE A在“EMM-Deregistered，ECM/RRC-Idle”状态，进入到城市2，并且检测到一个新的LTE小区。 UE A用GUTI作为UE ID发送Attach Request小区给新的MME发起初始附着过程。 在成功完成初始附着过程之后，UE A进入“EMM-Registered，ECM/RRC-Connected”状态。 References[1] Netmanias Technical Document, “LTE EMM and ECM State”, February 2013,http://www.netmanias.com/bbs/zboard.php?id=1x_TechdocsForum_4G[2] 3GPP TS 24.301, “Non-Access-Stratum (NAS) Protocol for Evolved Packet System (EPS); Stage 3”.[3] 3GPP TS 23.401, “General Packet Radio Service (GPRS) Enhancements for Evolved Universal Terrestrial Radio Access Network(E-UTRAN) Access“.[4] NMC Consulting Group Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8-LTE EMM and ECM States]]></title>
    <url>%2F2016%2F04%2F03%2F8-LTE-EMM-and-ECM-States%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5909 I. Introduction通过之前的技术文档，我们已经学习了LTE网络架构和LTE identification和LTE安全操作（当用户附着到LTE网络时需要的，并保证通信的安全）。现在我们开始更深入学习LTE的详细过程。 一旦用户附着到LTE网络，i）在网络端鉴权用户和注册用户，ii）EPS会话和承载建立用于提供服务，iii）触发支持用户移动的移动性管理的功能。在这个时候，MME通过和用户建立信令连接并交换控制信息来负责这三个任务。在用户和网络之间的移动性和会话管理是由UE和MME的控制面的NAS层的NAS协议来控制的。这两个实体使用NAS消息相互通信。NAS协议定义在3GPP 24.301中。NAS可以大致分为EPS移动性管理EMM和EPS会话管理ESM。通过一系列的技术文档，我们描述EMM和ESM这两个过程。当前这个文档是这个系列文档的第一个，将描述i）EMM状态，ii）一旦EMM过程发起，在EPS实体中会保存什么用户信息。 本篇文档组织如下：第二章介绍EMM过程的类型和EMM相关的状态。第三章描述这些状态之间的转换。第四章总结在EPS实体中EMM的特征。第五章讨论在EMM/ECM/RRC状态的不同组合下EPS实体中保存着什么样的用户信息。 II. EMM, ECM and RRC States2.1 EMM过程的类型表1列出了NAS协议支持的EMM过程的类型和属于这些类型的特定的EMM过程。详细的EMM过程将通过这个文档在下面解释。我先简要看看每一个EMM类型都包含哪些特定的过程。 有三张类型的EMM过程：i）EMM 一般过程：是指在UE和MME之间NAS信令连接存在时总是可以发起的过程。这类过程分为五种过程：GUTI allocation（GUTI分配）Authentication（鉴权）identification（身份认证）Security mode control（安全模式控制SMC）EMM information（EMM消息）ii）EMM特殊过程：是指和用户移动性相关的过程（注册，位置更新）。可以分为三种过程，attach（附着）detach（去附着）TAU（TA更新）。在和3gpp网络共存的LTE网络中，额外的过程也包含在这类中（比如，combined attach联合附着，combined detach联合去附着，combined TAU联合TA更新）。但是因为这个文档仅仅讨论LTE网络，所以这几种没有列出在表1中。iii）EMM连接管理过程：是指和NAS信令连接建立有关的过程。可以分为三种过程，service Request（服务请求）paging（寻呼）NAS消息的传输。 2.2 EMM/ECM/RRC状态EMM是NAS层的一个子层。随着EMM过程的进行，UE处于七种EMM状态之一，MME处于四种EMM状态之一。在这些状态中，一些状态例如“EMM-registered”和“EMM-Dergistered”是这两个实体都具有的共同状态，在下文中，EMM状态就是指这两种状态。 为了UE和MME之间相互交换NAS消息，在他们之间必须建立信令连接。这个连接叫EPS连接管理（ECM）连接。它包含UE与eNB之间的RRC连接和eNB与MME之间的S1信令连接的逻辑连接，如图1所示。也就是意味着，当ECM建立和终止时，RRC和S1信令连接全部建立和终止。对于UE，一个建立的ECM连接意味着与eNB之间具有RRC连接，对MME，意味着与eNB之间具有S1信令连接。 图1描述了和UE与MME有关的EMM，ECM，RRC状态。EMM可以是“EMM-Registered” or “EMM-Deregistered”状态取决于附着到网络还是去附着到网络。ECM是可以是“ECM-Connected” or “ECM-Idle”取决于NAS信令连接是否建立。同样的，RRC可以是“RRCConnected” or “RRC-Idle”状态取决于是否有RRC连接建立。表2显示了什么条件下UE待在什么状态。 III. EMM State TransitionEMM，ECM和RRC状态随着EMM过程的处理发生改变。因为RRC连接是ECM连接的一部分，所以在UE的角度看ECM和RRC总是保持相同的状态。在图2中描述了状态转换的过程以及触发状态转换的事件。在图2中用户EMM，ECM/RRC连接的组合用A B C D表示。用户的过程将会是这样组合之一，见表3。 3.1 EMM-Deregistered状态在A和B中，状态都是EMM-Deregistered，ECM-idle，RRC-idle，UE从网络去附着了。但是，在这两种情况下在网络端存储的手机信息是不一样的。在A情况中，在网络端处理提供的信息，没有包含任何UE信息。而在B情况下，网络保存着UE上次附着时网络获得的GUTI和NAS安全上下文。根据在状态A和B中，UE是否附着到网络，初始附着过程可能会有变化。 在状态B，在UE再次附着到网络时，网络保持着鉴权和安全建立所需求的信息，过了一段时间之后，网络会删除这些信息，并转换到状态A。 在EMM-Deregistered状态（A或者B），当选择PLMN和小区的时候，UE能分辨出来UE能通信的哪个网络和哪个小区。当UE请求接入网络获取服务的允许时，开始初始附着过程，然后UE状态转换到C（EMM-registered，ECM-connected，RRC-connected）。 3.2 EMM-Registered状态在C和D状态，状态是EMM-registered，UE接入或注册到网络。但是ECM和RRC的状态是ECM-connected/RRC-connected或者是ECM-idle/RRC-idle状态取决于UE的激活特性。一旦UE成功地附着到网络，状态从EMM-Deregistered（A or B）转换到状态C，UE在使用服务的时候将会一直呆在状态C，当不用服务时转换到状态D。 在状态C，在控制面无线和网路资源分配给信令连接，在用户面分配给EPS承载。当有一个比当前正在通信服务的小区更好无线信号质量的小区时UE可能执行切换到邻小区。但是，当在状态D，UE是去激活的，ECM/RRC连接被释放了。资源在控制面没有分配给ECM连接，也没有分配给EPS承载（DRB和S1承载），除了S5承载一直存在。在这个状态，没有发送到UE或者网络的上下行流量。为了在状态D能传输用户流量，就需要建立ECM连接，转换到状态C，需要建立新的DRB和S1承载来激活EPS承载。在状态D，UE通过测量服务小区和邻小区的无线信号强度根据小区重选准则来选择一个小区驻留（见文档LTE EMM Procedure: 7. Cell Reselection without TAU）。 当i）上下行有新流量，ii）UE在idle状态由于TA改变或者TAU定时器超时，需要进行TAU请求时UE从状态D转换到状态C。另一方面，当i）UE去激活（也就说在一段时间内没有上下行UE流量）ii）UE在状态D完成TAU之后释放资源时UE状态从C转换到D。 当在EMM-Registered（C或D），如果UE从网络去附着，如果UE是关机或者无线链路失败RLF（如果在无线链路上数据包错误率超过门限值），这种情况下，UE转换到B转台（EMM-deregistered）。另外，当UE在状态C执行切换到非LTE网络，或者UE请求附着到网络被拒绝，或者TAU更新请求被拒绝，这时候，UE状态从EMM-registered转换到EMM-deregistered。 IV. EMM Features在这章，我们将讨论在图2的各个状态由EPS实体支持的EMM过程相关的特性。下面，我们将讨论以下议题：i）在每一个状态，被EPS实体知道的UE位置信息的粒度，ii）在什么状态EPS承载和NAS信令连接建立，iii）在每一个状态和UE移动性相关的特性，iv）在每一个状态在EPS实体中都设置了什么类型的ID。 4.1 UE位置信息在表4中展示了被每一个EPS实体识别的UE位置信息的粒度。EMM-registered状态标示UE是附着到网络且网络知道UE的当前位置。在状态C，网络在小区的粒度上知道UE的位置，在状态D，网络在TA粒度上知道UE的位置。对于HSS，不像其他EPS实体，除了UE在状态A，是在MME粒度上知道UE的位置信息。 4.2 EPS承载和NAS信令连接表5展示了在什么状态传输用户流量的EPS承载和传输NAS信令消息的NAS信令连接建立的。一旦UE成功附着到网络，变成EMM-registered状态，UE将通过EPS承载使用服务。一个EPS承载包含三个承载：DRB承载，S1承载和S5承载。如图3所示，当传输用户流量在ECM-connected/RRC-connected状态下，所有的这三种承载是建立和保持激活的，另一方面，当用户没有数据流量在ECM-idle/RRC-idle状态时，只有S5承载是建立，其他两种承载是去激活的。 NAS信令连接包含RRC连接和S1信令连接，是在当传输用户流量时建立的。当用户从网络去附着，或者附着在网络上但是在idle状态下，这时候ECM连接时释放的。 4.3 移动性表6列出了在每一个状态UE移动性相关的特性。移动性：在EMM-deregistered开机的UE通过选择PLMN和小区来知道需要驻留在哪个小区和哪个网络。当有一个无线信号质量比当前小区好的小区时，在EMM-registered状态使用服务的UE从当前小区切换到另外邻区。对一个当前不使用服务的UE，当有一个无线信号质量比当前小区好的小区时，在EMM-registered状态的UE从当前小区重选到另外邻区。 TAU：在EMM-registered状态下的UE，不论是否使用服务，当TA改变时就需要更新TA。但是当在ECM-idle/RRC-idle状态下，即使TA没有改变，当TAU定时器超时时也会更新TA。TA更新时由UE发送TAU request消息来发起的。当UE在ECM-idle/RRC-idle状态，ECM/RRC应该首先建立，然后UE需要转移到ECM-connected/RRC-connected状态来更新TA。一旦UE在状态C发送TAU request消息并从MME接收到TAU accept消息，TAU过程就结束了。这时候，释放ECM/RRC连接，然后UE返回到ECM-idle/rrc-idle状态。 寻呼：当UE附着到网络，但是在idle状态，如果有用户流量传输，网络需要发起寻呼来唤醒UE，接下来UE状态转换到C。寻呼是根据在最后一次TA更新中由UE提供的TAI信息来进行的。 4.4 UE ID表7列出了每一个实体在四种状态中所具有的UE ID。UE IP地址当UE初始附着到网络由PGW分配的，会建立默认承载，并且当默认承载去激活时释放。GUTI是当UE初始成功附着到网络由MME分配的，用来代替IMSI来使用。如果UE从网络成功的去附着，UE和MME会波爱吃UE最后一次的GUTI，并且在下次UE附着到网络时使用它，即使在附着之后。C-RNTI是由eNB分配，用来在一个小区中RRC-connected状态下区别UE的，只有当和小区中已经分配的C-RNTI关联才是有效的。eNB UE S1AP ID and MME UE S1AP ID是由eNB和MME来使用分辨在S1-MME接口上的UE的。Old eNB UE X2AP ID and New eNB UE X2AP ID是服务eNB和目标eNB用来在X2接口上分辨UE的（当UE在服务eNB和目标eNB之间执行切换时）。 V. EMM User Information这一章将描述在图2状态下EPS实体和用户关联的数据。 5.1 EMM-deregistered+ECM-idle/rrc-idle表8描述了在状态A下EPS实体包含的用户信息。在状态A，除了运营商提供的信息外，网络没有用户信息。也就是说，在状态A，在UE和NE中所有的信息都是运营商提供的。IMSI，LTE K，主秘钥在用户鉴权是需要，默认APN，EPS QoS签约信息和接入配置在建立EPS会话和默认EPS承载时都需要。在EPSQoS签约配置文件和接入配置包含如下信息： EPS QoS签约配置文件（在HSS中）：QCI，APR，APN-AMBR和UE-AMBR 接入配置文件（在SPR中）：SDF过滤器，QCI，APR，APN-AMBR、UE-AMBR和计费方法。 5.2 EMM-deregistered+ECM-idle/rrc-idle表9描述了在状态B下EPS实体包含的用户信息。在状态B，最后一次UE附着网络使用的信息在UE和MME中保持有效，所以，在下次附着时UE可以使用相同的信息。这些信息包括由MME最后一次分配的GUTI，在UE最后一次更新TA时的TA信息，在UE和MME之间最后一次使用的NAS安全上下文，由MME分配给UE的UE-AMBR等等。在状态A中UE和NE中没有的用户信息，在状态B中包含的被标记为绿色，已经在状态A分配的是黑色的。如表9所示。 5.3 EMM-registered+ECM-connected+RRC-connected表10列出了在状态C下EPS实体所拥有的用户信息。在状态C，建立了EPS承载和NAS信令连接，执行切换和TA更新。所以，在这个状态设置了这些过程需要的所有用户信息。为了容易和状态B进行区分，在状态C中新加入的标记被蓝色，B状态的标记为绿色。 5.4 EMM-registered+ECM-idle/rrc-idle表11列出了在状态D中EPS实体拥有的用户信息。这个状态首先可以从A/B转移到C。在状态D，在状态C分配给EPS承载和NAS信令连接的所有资源，除了S5承载，都被释放了。这些释放的信息被标记成灰色。在S1承载上，下行资源被释放，但由PGW分配的上行资源被保持。所以，在下次转换到状态C时，在建立S1承载时，相同的上行承载将会使用。我们可以看到一旦UE从状态C变成idle状态，在UE和eNB之间的所有的资源都被释放。 VI. Closing我们学习了EMM，ECM，RRC状态。在ESM过程中讨论EPS会话和承载建立相关的更有意义。作为EMM过程的一部分，UE初始附着流程包含默认EPS承载的建立，ESM相关的相关的EMM过程也包含在这个文档中。基于我们对EMM，ECM，RRC状态的讨论，我们为更深入的学习EMM过程。 References[1] 3GPP TS 24.301, “Non-Access-Stratum (NAS) protocol for Evolved Packet System (EPS); Stage 3”.[2] Netmanias Technical Document, “LTE Network Architecture: Basic”, July 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5904[3] Netmanias Technical Document, “LTE Security II: NAS and AS Security”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5903[4] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-LTE QoS: SDF and EPS Bearer QoS]]></title>
    <url>%2F2016%2F04%2F03%2F7-LTE-QoS-SDF-and-EPS-Bearer-QoS%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5908 I. IntroductionSDF：Service Data Flow LTE服务提供商应该能够根据用户的不同订阅等级来定制不同的QoS的服务需求。所以，为了能够根据不同用户流量分配无线和网络资源，并为了合适的管理这些资源，服务提供商需要能感知每一个用户的订阅级别和能感知请求的服务类型。 为了这种原因，LTE网络首先根据通过SDF提供服务的类型来把用户数据流分为不同的SDFs（具有不同QoS），然后对每一个SDF应用不同的QoS规则。因为SDF在LTE网络中是通过EPS承载来传送的，所以EPS承载QoS以保持SDF QoS的方式来控制。 在这个文档中，适用于SDF的QoS机制和EPS承载将解释为LTE中的QoS机制，并且举例说明他们是怎么工作的。这个文档组织如下：第二章定义SDF和EPS承载。第三章描述适用于SDF和EPS承载的QoS参数。第四章介绍QoS提供和QoS实施，通过实体的QoS参数是怎么提供和在哪里实施的。在第五章，将举例说明LTE QoS是怎么工作的。 II. SDF and EPS Bearer图1描述了SDF和EPS承载，和他们之间的关系。在LTE网络中，用户数据（IP数据包）被分为SDF数据流和EPS承载数据流。一个SDF是和用户正在使用的服务相关联的一组IP数据流，而EPS承载是具有相同QoS级别的聚合的SDFs数据流。 SDF和EPS承载是通过使用不同的数据包过滤器匹配IP数据流来检测的（SDF template用于SDF，traffic flow template TFT用于EPS承载）。数据包过滤器是由网络运营商根据他们的策略预先配置的。他们每一个都有由五元组组成（源IP地址，目的IP地址，源端口，目的端口，协议ID）。 换种说话，在ＬＴＥ网络中，具有相同服务特征（匹配SDF template数据包过滤器）的IP数据流被指定为一个SDF。匹配TFT数据包过滤器的SDFs被映射为EPS承载，最后交付给UE。具有相同QoS级别的SDFs被聚合在一起通过一个EPS承载传送，不同的QoS级别的SDF通过不同的EPS承载传送。 SDF 使用不同服务或应用的用户数据流具有不同的QoS。一个SDF是一个IP数据流或者是根据服务类型分类的用户IP数据流的聚合。不同的SDF由不同的QoS级别，因此一个SDF作为一个单元服务的，这个单元的QoS规则是按照LTE中PCC过程得到的。在图1中，到UE的IP数据流使用SDF template按照他们的服务类型被分类成不同的SDF。接着相应的QoS规则（例如，优先级，带宽控制等）在数据传输到ＵＥ之前应用到SDF上。QoS是当SDF在ＬＴＥ网络传输的时候由EPS承载提供的，每一个SDF被PGW映射到一个EPS承载来满足它的QoS需求，并交付给ＵＥ． EPS承载 有两种类型的EPS承载：默认和专用的。当UE附着到LTE网络时，分配一个IP地址用于连接PDN，同时建立一个默认EPS承载。当用户通过默认承载试图接入需要高QoS（当前的默认承载满足不了这个QoS）时，就按需建立一个专用承载。专用承载建立的QoS是不同于当前已经存在的承载上的QoS。UE可以连接不止一个PDN，包含一个必须的默认EPS承载和零到多个可选的专用EPS承载。UE拥有的EPS承载的数目不超过11个。 一旦在UE初始附着到网络时建立默认承载，这个承载会一直持续，即使没有服务在使用，直到UE从网络去附着。每一个PDN上都有一个默认承载。当UE初始附着到网络，网络MME需要关于怎样建立默认承载的信息，比如使用哪个QoS，需要连接哪个PDN。这些信息已经作为签约信息提供了HSS。所以，MME只需要下载这些签约信息即可（默认APN，EPS签约QoS信息等等），并基于这个APN选择一个PGW连接到PDN，并且基于签约QoS配置信息激活和这个PDN相关的默认承载。 在图1中的SDF和EPS承载图1展示了当通过EPS下行IP数据流交付给UE时的SDF和EPS承载。通过PDN IP数据流到达PGW并使用SDF templates过滤成不同的SDF。在这个图中，IP数据流1/2/3被过滤成SDF1/2/3，相应的IP数据流4/5倍过滤成SDF4。对每一个SDF适用不同的QoS策略，接着映射到通过使用TFT分类的EPS承载上。SDF1/2映射到默认承载，而SDF3/4映射到专用承载，接着都传输都ＵＥ。一旦到达UE，IP数据被发送到相应的目的应用。 在图1中显示的EPS承载和SDF列出来表1中。在IP连接接入网（IP Connectivity Access NetworksI P-CAN）范围外的在3gpp标准中。这个文档只讨论EPS。所以这里讨论的所有的IP_CAN都是指EPS承载。 III. QoS Parameters of SDF and EPS Bearer在第二章学习了使用数据包过滤器把用户承载分为SDF或EPS承载。SDF QoS和EPS承载QoS对应的应用于SDF和EPS承载。在第三章我们学习SDF和EPS承载的QoS，以及他们之间的关系。 在LTE网络中，QoS在服务层面和承载层面上定义。SDF QoS参数一个服务层面的QoS参数，而EPS承载QoS参数是承载层面的QoS参数。服务层面和承载层面也被称为SDF层面和SDF聚合层面。一个SDF聚合就是一组具有相同QCI（QoS级别标识QoS Class Identifier）和ARP（分配和保留优先级Allocation and Retention Priority）的SDF，这些SDF属于同一个EPS承载。QCI和ARP都是基本的QoS参数，适用于所有的SDF和EPS承载。QCI特别重要，因为它作为一个参考标识SDF和EPS承载的性能特征。除了这两个基本的参数，还有其他的QoS参数，例如GBR、MBR、AMBR，这些参数指定SDF和EPS承载的 带宽/比特速率特征。SDF和EPS承载的参数如下所示： SDF QoS参数：QCI、ARP、GBR、MBR EPS承载QoS参数：QCI、ARP、GBR、MBR、APN-AMBR、UE-AMBR SDF QoS参数 QCI和ARP使用于所有的SDF。QCI是1-9的整数，标识IP数据包9种不同的QoS性能特征，例如资源类型（GBR或NON-GBR）优先级（1-9）数据包延迟预算（50-300ms）数据包错误速率（10-2 ~ 10-6）。MBR和GBR（最大比特速率和保证比特速率Maximum Bit Rate 和Guaranteed Bit Rate ）都是SDFQoS参数，他们用来标识SDF带宽/比特速率。MBR指定SDF的最大比特速率。如果网络流量不拥挤，则以SDF传输的用户流量可以以最大MBR传输。而，GBR是SDF保证的比特速率。这意味着无论什么情况，SDF能保证一个特定的GBR。所以即使网络流量是拥挤的，通过SDF传输的用户流量也至少能按照保证的GBR传输。 有两种类型的SDF，GBR SDF和non-GBR SDF。对于GBR SDF，根据QCI指定的资源类型分配专用的网络资源。但是，对于non-GBR SDF，不分配专用的网络资源。GBR SDF分配一个GBR和MBR，而non-GBR SDF只分配一个MBR。这两种SDF的QoS参数如下所示： GBR SDF QoS参数：QCI、ARP、GBR（UL/DL）、MBR（UL/DL） non-GBR SDF QoS参数：QCI、ARP、MBR（UL/DL） 匹配TFT过滤器的SDF在PGW中映射为一个EPS承载，并通过这个映射的EPS承载交付给ＵＥ．具有相同QCI和ARP的SDF聚合被映射到一个EPS承载上。 EPS承载QoS参数 QCI和ARP使用所有的EPS承载。EPS承载根据不同QCI的资源类型被分为GBR承载和non-GBR承载。默认承载必须是non-GBR，而专用承载可以是GBR，也可以是non-GBR。除了QCI和ARP，EPS承载还有其他的QoS参数，MBR和GBR用来指示EPS承载的带宽/比特速率，AMBR（聚合最大比特速率Aggregated Maximum Bit Rate）指示多个EPS承载的总共带宽。MBR和GBR是EPS承载的最大和保证带宽，AMBR是多个EPS承载的最大总共带宽。 GBR EPS承载分配GBR和MBR，意味着为这个承载分配专用的网络资源。而，non-GBR EPS承载分配一个AMBR，意味着对这个承载没有分配专用的网络资源，但是分配了一个和其他non-GBR承载共享的最大带宽。由两种类型的AMBR，APN-AMBR（是在PDN中由所有的non-GBR承载共享的最大带宽）和UE-AMBR（在ＵＥ中共同分享的最大带宽）。一个UE可以连接到不止一个PDN，也就是说，所有PDN的总APN-AMBR不能超过UE-AMBR。这两种类型的QoS参数如下： GBR承载QoS参数：QCI、ARP、GBR（UL/DL）、MBR（UL/DL） non-GBR承载QoS参数：QCI、ARP、APN-AMBR（UL/DL）、UE-AMBR（UL/DL） SDF和EPS承载QoS参数图2显示了应用于SDF和EPS承载的QoS参数。 在图2中，UE连接两个PDN。UE有两个IP地址：IP地址1由PGW1分配用于PDN1，IP地址2由PGW2分配用于PDN2。每一个PDN有一个默认承载和两个专用承载。在PGW使用SDF templates把用户IP数据流分成了不同的SDF。从PDN1和PDN2由两组SDF（1-5）。对于这些SDF，根据在PGW设置的QoS规则来分配网络资源和数据包转发策略。并基于他们特定的QCI和ARP映射到EPS承载上。图中，对于PDN1，SDF1/2映射到默认承载，SDF3/4映射到non-GBR专用承载，SDF5映射到GBR专用承载，所有的都传送到UE。这样的从SDF到EPS承载的映射是由TFT决定的。所有用户流量在通过EPS承载传输时都准守EPS承载QoS。 所有和PDN关联的non-GBR承载都是由他们共享的最大APN-AMBR控制，而和UE关联的non-GBR承载都是由他们共享的最大UE-AMBR控制。 表2 SDF和EPS承载的QoS参数 项 描述 QCI 指示不同的QoS性能特征；标准QoS特征值用QCI=1-9定义；QCI代表了QoS的下列特征：资源类型（GBR or non-GBR），优先级（1-9），数据包延迟预算（50-300ms），数据包错误丢失率（10-2~10-6）；在网络节点（eNB，SGW，PGW）上控制数据包转发（调度权重，准入阈值，队列管理阈值，链路层协议配置等等）；在运营商网络节点（例如eNB）预先配置。 ARP ARP参数：优先等级，抢占能力，被抢占能力；优先级（1-15）：定义资源请求的相对重要性，1是最高。抢占能力（yes or no）：定义SDF是否占用已经分配给一个优先级较低的SDF/承载的资源。被抢占能力（yes or no）：定义SDF是否能失去已经分配给它了，但是为了建立更高优先级的SDF/承载的资源。用于控制呼叫准入：指示一个优先级值用于决定在网络资源有限的条件下一个新的SDF/EPS承载需要激活或者修改的情况下是否拒绝激活一个新的SDF/EPS承载或移除存在的SDF/EPS承载。仅当在决定是否激活一个新SDF/EPS承载时需要考虑。一旦成功的建立，ARP对数据包转发处理没有影响。 GBR (UL/DL) 应用于GBR SDF/承载。指示对GBR SDF/承载能保证的最小的带宽 MBR（UL/DL） 应用于GBR/non-GBR SDF和承载。指示对SDF/承载允许的最大带宽；任何超过指定MBR的数据流量都通过数据策略丢弃。 APN-AMBR(UL/DL) 每一个PDN定义一个。指示对所有和PDN相关的non-GBR承载所允许的最大带宽；只适用于non-GBR聚合带宽 UE-AMBR(UL/DL) 每一个UE定义一个。指示对所有和UE相关的non-GBR承载允许的最大带宽；只适用于non-GBR承载的聚合带宽；这个是由HSS提供的签约信息（UE-AMBR-HSS）。但是仍然可以由MME修改，只要不超过所有APN的APN-AMBR的许可范围即可（在UE-AMBR-HSS范围之内）。 GBR SDF/承载 给这种类型的SDF/承载分配专用的网络资源来达到保证的GBR。当没有流量的时候，网络总是为GBR SDF/承载保持GBR指定的带宽。 non-GBR SDF/承载 给这种类型的SDF/承载不分配专用的网络资源。依据网络的拥挤程度以最大能力来传输流量。 IV. QoS Provisioning and Enforcement4.1节将讨论QoS分配：QoS参数是在哪个实体中设置的。4.2节讨论QoS实施：决定哪个实体设置和应用哪个用户流量参数。 4.1 QoS分配图3展示了QoS参数是在哪个实体中设置的； SDF QoS分配SDF所有的QoS参数是由PCRF提供的（Policy and Charging Rules Function）。 EPS承载QoS分配应用于默认承载的QoS参数是由网络运营商作为签约信息提供给HSS的。当默认承载激活的时候，MME从HSS中下载关于这个承载的QoS配置信息，并发送给相应的EPS实体。一旦EPS回话建立，QoS规则经过PDRF授权时，由HSS提供给默认承载的QoS参数可以修改。由HSS提供的UE-AMBR由eNB控制，但可以由MME修改。在修改的情况下，MME可以使用所有正在激活的PDN的聚合APN-AMBR取代UE-AMBR，只要这个值没有超过由HSS提供的UE-AMBR-HSS值即可。 应用于专用承载的QoS参数是由PCRF提供的。当承载激活时，PCRF基于从SPR接收到的签约信息来决定承载的QoS参数。 4.2 QoS实施在QoS实施过程中，执行用户流量的检测，然后对每一个检测到的SDF和EPS承载执行相应的QoS规则。图4显示了SDF和EPS承载是在哪个实体中设置和实施的。EPS承载QoS参数实施于SGW和实施于PGW是一样的，除了APN-AMBR之外。但是为了绘图方便，在这个图中只显示了QCI。 SDF QoS实施SDF QoS参数是存在于PGW中。表4显示了SDF QoS在哪个实体中实施。到达PGW的IP数据流使用SDF templates过滤为不同的SDF，接着这些SDF由SDF QoS参数控制安装在PGW中。 EPS承载QoS实施EPS承载的QoS参数实施在UE和PGW之间传输用户流量的EPS实体上。表5描述了每一个QoS参数在哪个EPS实体中实施。APN-AMBR被承载的两个端点（UE和PGW）应用在PDN上激活的所有non-GBR EPS承载。APN-AMBR在UE中仅仅用于上行流量，但是在PGW中应用于上行和下行流量。而UE-AMBR由所有PDN发端的eNB来应用在UE上激活的所有non-GBR EPS承载。也就是说APN-AMBR只应用于和它关联的APN所表示的PDN，而UE-AMBR应用于UE，所有和UE关联的PDN。MBR只用于GBR承载，在UE和eNB中是用于上行流量，而在SGW和PGW中只应用于下行流量。GBR只适用于GBR EPS承载，对上行和下行除了UE之外的所有实体都适用。 V. An Example for SDF and EPS Bearer QoS在第五章，举例说明LTE QoS是如何基于SDF和EPS承载QoS提供的。通过这个实例，可以学习SDF和EPS承载QoS怎么工作和他们是在哪个实体中提供的。使用的场景如下： UE连接到一个PDN（因特网） UE通过三个承载和因特网通信（一个默认承载，一个GBR承载和一个non-GBR承载） 他们承载的ID（EPS承载ID EBI）是5,8,10. 5.1 下行的QoS操作图5显示了下行QoS操作的实例。在每一个实体的操作详细在下面描述。这里，可适用的流量控制包括流量监管和流量成型。图5和图6是应用流量监管的实例。 ❶ [P-GW] 下行IP数据流到达IP数据流到达PGW，数据流1-5分别是语音数据（RTP），视频数据流，语音信令（SIP），双向的游戏，尽力而为的因特网流量。 ❷ [P-GW] IP数据包过滤 (SDF Templates)一旦PGW接收到数据包，IP数据通过IP数据包过滤器 (SDF templates)被过滤成不同的SDF。在这里，五元组（源IP地址，目的IP地址，源端口，目的端口，协议ID）用来充当过滤规则。IP数据流1被分类为GBR SDF1，数据流2被分类为GBR SDF2，IP数据流3/4被分类为non-GBR SDF3，IP数据流5被分类为non-GBR SDF4. ❸ [P-GW] SDF QoS实施: MBR速率策略MBR速率策略对每一个SDF执行，任何超过指定下行MBR的流量都将被丢弃。 ❹ [P-GW] SDF – EPS 承载映射: IP 数据包过滤 (Traffic Flow Templates; TFT)SDF使用IP数据包过滤TFT被过滤成不同的EPS承载。SDF1和SDF2映射到GBR专用承载EBI=10。SDF3被映射被non-GBR专用承载EBI=8，SDF4被映射为non-GBR默认承载EBI=5。 ❺ [P-GW] EPS 承载QoS 实施: MBR/APN-AMBR 速率策略EPS承载QoS适用于每一个承载。对于GBR承载，MBR速率策略是使用下行MBR来执行，任何IP数据包超过指定下行MBR的都被丢弃。对于non-MBR承载，APN-AMBR速率策略被执行。也就是说，对于所有发往EBI=5/8的IP数据流都是适用速率策略，任何IP数据包超过指定的下行APN-AMBR的都被丢弃。 ❻ [eNB] EPS 承载QoS 实施: UE-AMBR 调度eNB对non-AMBR执行UE-AMBR速率策略，并且在无线链路上调度。也就是说对于所有发往EBI=5/8的IP数据流都执行下行UE-AMBR。在图5中，因为只有一个PDN，下行UE-AMBR和下行APN-AMBR是相等的。 5.2 上行QoS操作图6显示了上行LTE QoS的操作。不像下行，MBR和APN-AMBR的控制在上行方向在ＵＥ和PGW中都执行。 ❶ [UE] 上行IP 数据流到达从用户应用层的IP数据流到达ＵＥ，在这里，应用层和下行的是一样的。 ❷ [UE] IP数据包过滤 (TFT)上行IP数据流被IP数据包过滤TFT过滤为EPS承载。在这里，IP和TCP/UDP协议头中的五元组用于过滤规则。IP数据流1/2映射到GBR专用承载EBI=10，IP数据流3/4被映射到non-GBR专用承载EBI=8，IP数据流5被映射为默认承载EBI=5. ❸ [UE] EPS 承载QoS 实施: MBR/APN-AMBR速率策略EPS承载QoS应用于每一个EPS承载。对于映射到GBR专用承载EBI=10的IP数据流，使用上行的MBR来执行速率策略，对于non-GBR专用承载EBI=5/8的所有IP数据流使用上行APN-AMBR来执行速率策略。 ❹ [eNB] EPS 承载QoS 实施: MBR/UE-AMBR速率策略eNB对GBR承载EBI=10使用上行MBR执行速率策略和调度，对于non-GBR承载EBI=5/8使用上行UE-AMBR来执行速率策略和调度。认为只有一个PDN，上行UE-AMBR和上行APN-AMBR是相等的。 ❺ [P-GW] 承载流量到达承载数据流通过SGW到达PGW ❻ [P-GW] EPS 承载QoS 实施: APN-AMBR 速率策略对所有的从non-GBR承载接收到的IP数据流执行APN-AMBR。任何超过上行APN-AMBR的数据包都被丢弃。 ❼ [P-GW] IP数据包过滤 (SDF Templates)EPS bearers are filtered through IP packet filters (SDF templates) into different SDFs. IP flows 1 and 2 fromthe GBR dedicated bearer (EBI=10) are mapped to SDFs 1 and 2, IP flows 3 and 4 from non-GBR dedicatedbearer (EBI=8) are mapped to SDFs 3 and 4, and finally IP flows 5 from the default bearer (EBI=5) ismapped to SDF 5.EPS承载被IP数据包过滤SDF templates过滤成不同的SDF。GBR专用承载EBI=10的IP数据流1/2被映射为SDF1/2。non-GBR专用承载EBI=8的IP数据流3/4被映射为SDF3/4。默认承载的IP数据流5被映射为SDF5. ❽ [P-GW] SDF QoS 实施: MBR 速率策略对每一个SDF执行MBR速率策略，任何超过指定上行MBR的IP数据包都会被丢弃。 VI. Closing我们已经学习了在服务层次和承载层次上的LTE QoS机制。我们也学习了用户IP数据流在服务层次上被分为不同的SDF，接着用户数据流在承载层次上被分类为不同的EPS承载。我们也讨论了SDF和EPS的他们互相映射的关系。在eNB的MAC层给ＵＥ分配无线资源并基于EPS承载QoS参数来执行数据包调度。eNB数据包调度不在本文档的范围内。决定和鉴权QoS参数的具体过程将会在接下来的文档中描述。 References[1] Netmanias Technical Document, “LTE Identification III: EPS Session/Bearer Identifiers”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5907[2] 3GPP TS23.203, “Policy and charging control architecture”.[3] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6-LTE Security II: NAS and AS Security]]></title>
    <url>%2F2016%2F04%2F03%2F6-LTE-Security-II-NAS-and-AS-Security%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5903 I. Introduction在LTE安全的第一个文档，我们介绍了基于EPS AKA过程的LTE鉴权，并在鉴权结束后，UE和MME之间共享了相同的K-ASME。在这个文档中，我们将基于K-ASME来介绍NAS和AS安全，学习在安全建立过程后用户和控制面的数据是怎样传输的。 第二章将介绍NAS安全建立过程，和在这个过程后NAS消息时怎么发送和接收的。第三章介绍AS安全建立过程，并介绍RRC和IP数据包时怎么传输的。第四章在EPS实体上使用的EPS安全上下文和安全数据。最后第五章总结在两篇LTE安全文档中的所有安全秘钥。 在我们开始介绍安全建立过程之前，我们先看下NAS和AS所有应用的协议栈。图1表示NAS和AS安全建立相关的协议栈。 NAS安全：NAS安全的目的是为了确保UE和MME之间控制面NAS消息是使用NAS安全秘钥安全传送的。NAS安全秘钥是从K-ASME中计算出来，并且每次执行EPS AKA都会有一个新的秘钥。在NAS安全建立完成之后，UE和MME之间在传输之前共享了相同的NAS安全秘钥（K-NASenc）和NAS完整性秘钥（K-NASinc）分别用于加密和完整性保护。 AS安全：AS安全的目的是为了确保UE和eNB之间控制面RRC消息和用户面IP数据包是使用AS安全秘钥安全传送的。AS安全秘钥是从K-eNB中计算出来的，并且每次一个新的无线链路建立后都会产生一个新的秘钥。在AS安全建立完成后，UE和eNB之间共享了RRC完整性秘钥（K-RRCinc）、RRC加密秘钥（K-RRCenc）和用户加密秘钥（K-UPenc）。使用这些秘钥的加密和完整性包保护都是在PDCP层执行的。RRC完整性秘钥（K-RRCinc）、RRC加密秘钥（K-RRCenc）都用来确保在无线链路控制面上通过SRB传输的RRC消息的传输安全。RRC消息在发送之前在PDCP层使用K-RRCinc完整性保护和使用K-RRCenc加密。K-UPenc用于在无线链路上用户面通过DRB传输的IP数据包的安全传输。IP数据包在传输之前在PDCP层使用K-UPenc来加密。 II. NAS Security下面将对NAS安全展开详细描述。NAS安全建立过程包含在UE和MME之间的Security Mode Command消息（MME发送到UE的）和Security Mode complete消息（UE发送给MME的）。这个NAS安全过程和NAS消息怎么传输在2.1和2.2节分别阐述。 2.1 NAS安全建立（1）、Security Mode Command消息的传输图2展示了在NAS安全建立过程中Security Mode Command消息时怎么传送的。MME通过发送Security Mode Command消息给UE来通知UE，MME是被网络鉴权的，并且表示用于消息安全传输的NAS安全建立过程已经发起。Security Mode Command消息时完整性保护的，接着发送给ＵＥ，然后ＵE计算出NAS安全秘钥（加密秘钥和完整性秘钥）并使用完整性秘钥来验证这个消息的完整性。 NAS安全建立过程之前的LTE鉴权过程在图2中 显示。LTE鉴权的结果是在UE和MME之间共享了K-ASME。我们开始介绍NAS安全建立过程，假定MME分配KSI-ASME=1来标识K-ASME。 1、[MME]选择安全算法MME在从UE接收到的Attach Request消息中基于网络能力信息选择加密和完整性算法用于NAs消息。图2展示了选择EEA1作为加密算法，EIA1作为完整性算法。 2、[MME]计算出NAS安全秘钥MME使用算法ID（Alg-ID）和选择安全算法的算法分辨器来从K-ASME中计算出K-NASinc和K-NASenc。表1列出了算法ID和算法分辨器。 3、[MME]为完整性保护产生NAS-MACMME生成Security Mode Command消息发送给ＵＥ，并使用ＥＩＡ算法和输入参数计算出NAS-MAC。图3是展示了NAS-MAC是怎么生成的。参数说明： Count：32bit下行NAS计数 Message：NAS消息，在这里是Security Mode Command Direction：1bit表示传输的方向，0是上行，1是下行 Bearer：5bit的承载ID，固定值，设置为0 K-NASinc：128bit的NAS完整性秘钥 4、[UE&lt;-MME]发送Security mode command消息MME把计算出来的NAs-MAC包裹在Security mode command消息中发送给ＵＥ。这个消息时完整性保护而没有加密的。消息参数有以下几个： KSI-ASME：3bit和K-ASME关联的值，用来表示K-ASME 重返UE安全能力：UE安全能力包裹在UE发送的attach Request消息中的UE网络能力，指示UE可以支持的安全算法。 NAS加密算法：由MME选择的NAS加密算法，这里为EEA1 NAS完整性算法：由MME选择的NAS完整性算法，这里为EIA1 5、[UE]设置K-ASME表示（KSI-ASME）当UE从MME接收到Security mode command消息，UE设置在消息中的KSI-ASME，并使用它来表示当前的K-ASME。 6、[UE]产生NAS安全秘钥UE识别出MME选择的NAS安全算法，并使用算法ID和算法分辨器从K-ASME中计算出K-NASinc和K-NASenc。 7、[UE]检查Security mode command消息的完整性UE通过使用包裹在消息中的NAS-MAC来检查Security mode command消息的完整性。UE识别出由MME选择的NAS完整性算法是EIA1，并使用Security mode command消息中选择的EIA1算法计算出XNAS-MAC消息鉴权码和K-NASinc。图4是介绍XNAS-MAC是怎么通过相同的EIA计算出来的。UE通过比较由自己计算出来的XNAS-MAC和由MME计算出来NAS-MAC是否匹配来验证这个消息的完整性。如果匹配，它表示Security mode command消息是没有在途中被篡改的。 （2）、Security mode complete消息的传输图5展示了Security mode complete消息在NAS安全建立过程中是怎么传输的。UE通过发送Security mode complete消息给MME来通知MME在UE中生成了和MME中相同的NAS安全秘钥，并且Security mode command消息完整性验证通过。Security mode complete消息传输是加密和完整性保护的。 8、[UE]使用选择的加密算法EEA1加密消息UE生成和加密Security mode complete消息发送给MME。Security mode complete消息的加密数据流（Cipher Text Block加密数据块）是通过Security mode complete消息（Plane Text Block面数据块）和由EEA1、K-NASenc生成的加密秘钥流（Key Stream Block秘钥流块）经过bit位执行XOR异或操作来生成的。图6展示了NA消息时怎么加密的。用来产生秘钥流块的EEA算法的输入数据包括以下： Count：32bit上行NAS计数 Bearer：5bit的承载ID，固定值，设置为0 Direction：1bit表示传输的方向，0是上行，1是下行 Length：通过加密算法陈胜的秘钥流的长度 K-NASenc：128bit的NAS加密秘钥 9、[UE]产生NAS-MAC用于完整性保护UE使用EIA算法计算出NAS-MAC和K-NASint。图3a是NAS-MAC是怎么使用下面的EIA参数生成的。 Count：32bit上行NAS计数 Message：NAS消息，在这里是Security Mode complete Direction：1bit表示传输的方向，0是上行，1是下行 Bearer：5bit的承载ID，固定值，设置为0 K-NASinc：128bit的NAS完整性秘钥 10、[UE-&gt;MME]发送Security Mode complete消息UE把计算得到的NAS-MAC包裹在Security Mode complete消息中，并发送给MME。在这里这个消息是加密和完整性保护的，在这个之后，所有的UE发送给MME的NAS消息都是安全传输的。 11、[MME]验证Security Mode complete消息的完整性MME通过验证包含在消息中的NAS-MAC来检查Security Mode complete的完整性。MME使用在Security Mode complete消息中选择的EIA1算法和K-NASint来计算出XNAS-MAC。图4a展示了XNAS-MAC是怎么使用相同的EIA参数来计算出来的。MME通过检查自己计算出来的XNAS-MAC和从UE计算出来的NAS-MAC是否匹配来验证这个消息的完整性。如果匹配，它表示Security Mode complete消息在传输过程中没有被篡改。 12、[MME]解密Security Mode complete消息在成功验证Security Mode complete消息之后，MME开始使用EEA算法解密这个消息。Security Mode complete消息（UE产生的原来消息）是通过加密的Security Mode complete消息和秘钥流块XOR异或产生的。图7表示这个消息怎么使用EEA算法被解密的。 2.2 NAS安全建立后一旦NAS安全建立完成，在随后所有的UE和MME之间传输的NAS消息都是在发送之前加密和完整性保护的。图8显示了在NAS安全建立之后，ＵＥ和MME之间的NAS消息时怎么传送的。 当NAS消息发送之前，首先加密然后完整性保护。原NAS消息首先使用K-NASenc加密然后包含K-NASint计算出来的NAS-MAC做完整性保护，所有这些消息都是加密和完整性保护传送的。 当接收到NAS消息，首先做完整性验证，然后解密，和发送时相反的过程。首先对比使用K-NASint计算出来的XNAS-MAC和接收到的NAS-MAC对比来检查NAS消息的完整性，接着解密得到原始的NAS消息。 III. AS Security下面详细介绍AS安全。AS安全建立过程包含在UE和MME之间的Security Mode Command消息（MME发送到UE的）和Security Mode complete消息（UE发送给MME的）。通过RRC信令来AS安全建立过程的描述和RRC消息在控制面、IP数据包在用户面怎么传输在3.1和3.2节分别阐述。 3.1 AS安全建立（1）、Security mode command消息的传送图9和图10描述了在AS建立过程中Security mode command消息是怎样传输的。首先，在图9中显示eNB怎样生成AS安全秘钥，并传输Security mode command消息给UE。K-eNB（AS安全基本秘钥）是从K-ASME计算出的，然后eNB从K-eNB中计算出AS安全秘钥。因为K-ASME不会传送到eNB，所以MME从K-ASME计算出K-eNB，然后传输给eNB，接着从传递的K-eNB中计算出AS安全秘钥。1和2展示了LTE鉴权过程。 1、【MME】计算出K-eNBMME使用秘钥生成函数KDF用K-ASME和UL NAS Count计算出K-eNB。 2、【eNB&lt;-MME】发送K-eNBMME作为对attach Request的响应发送attach accept消息给UE。这个NAS消息时通过initial context setup Request消息（这是一个eNB和MME之间的S1信令消息）传输的。消息的参数如下： UE安全能力：MME从UE发送的attach Request中的UE网络能力中选择的安全算法。 Security key：256bit K-eNB 3、【eNB】选择安全算法eNB根据从MME接收到的initial context setup Request消息中包含的UE安全能力选择加密和完整性保护算法应用于RRc消息和IP数据包。图9展示了选择EEA1作为加密算法，选择EIA1作为完整性保护算法。 4、【eNB】产生AS安全秘钥eNB使用算法ID和选择的安全算法的算法分辨器从K-eNB中衍生出K-RRCint、K-RRCenc、K-UPenc。 5、【eNB】为完整性保护产生MAC-IeNB生成Security Mode Command消息发送给ＵＥ，并使用ＥＩＡ算法和K-RRCint计算出MAC-I。图3是展示了MAC-I是怎么生成的。参数说明： Count：32bit下行PDCP计数 Message：RRC消息，在这里是Security Mode Command Direction：1bit表示传输的方向，0是上行，1是下行 Bearer：5bit的承载ID K-RRCinc：128bit的NAS完整性秘钥（此处原文有误） 6、[UE&lt;-eNB]发送Security mode command消息eNB把计算出来的MAC-I包裹在Security mode command消息中发送给ＵＥ。这个消息时完整性保护而没有加密的。消息参数有以下几个： AS加密算法：由eNB选择的AS加密算法，这里为EEA1 AS完整性算法：由eNB选择的AS完整性算法，这里为EIA1 图10展示了UE怎么从Security mode command消息中获得AS秘钥并用于消息的完整性检查。 7、[UE]识别安全算法：EEA1、EIA1UE从接收到的Security mode command消息中识别出eNB选择的AS安全算法和完整性保护算法，图10是选择EEA1和EIA1的实例。 8、[UE]产生AS安全秘钥UE并使用算法ID和算法分辨器从K-eNB中计算出K-RRCinc和K-RRCenc和K-UPenc。 9、[UE]检查Security mode command消息的完整性UE通过使用K-RRCint来验证包裹在消息中的MAC-I来检查Security mode command消息的完整性。UE通过比较由自己计算出来的XMAC-I和由eNB计算出来MAC-I是否匹配来验证这个消息的完整性。如果匹配，它表示Security mode command消息是没有在途中被篡改的。图4是XMAC-I计算的过程。 （2）、Security mode complete消息的传输图11展示了Security mode complete消息在AS安全建立过程中是怎么传输的。UE通过发送Security mode complete消息给MME来通知MME在UE中生成了和MME中相同的AS安全秘钥，并且Security mode command消息完整性验证通过。Security mode complete消息传输是加密和完整性保护的。 10、[UE]产生NAS-MAC用于完整性保护UE使用EIA算法计算出MAC-I和K-RRCint。图3是MAC-I是怎么使用下面的EIA参数生成的 11、[UE-&gt;MME]发送Security Mode complete消息UE把计算得到的MAC-I包裹在Security Mode complete消息中，并发送给eNB。在这里这个消息是加密和完整性保护的。 12、[MME]验证Security Mode complete消息的完整性MME通过验证包含在消息中的MAC-I来检查Security Mode complete的完整性。eNB使用在Security Mode complete消息中选择的EIA1算法和K-RRCint来计算出XMAC-I。eNB通过检查自己计算出来的XMAC-I和从UE计算出来的MAC-I是否匹配来验证这个消息的完整性。如果匹配，它表示Security Mode complete消息在传输过程中没有被篡改。 3.2 AS安全建立后一旦AS安全建立完成，在随后所有的UE和eNB之间传输的RRC消息都是在发送之前加密和完整性保护的，所有的IP数据包也是加密的。图12显示了在AS安全建立之后，ＵＥ和eNB之间的RRC消息和IP数据包是怎么传送的。 当RRC消息发送之前，不像NAS消息，它会首先完整性保护然后加密发送。原NAS消息首先包含K-RRCint计算出来的MAC-I做完整性保护接着使用K-RRCenc加密，所有这些消息都是加密和完整性保护传送的。 当接收到RRC消息，首先做解密，然后完整性验证，和发送时相反的过程。首先使用K-RRCenc解密获得完整性保护的RRC消息，然后对比使用K-NASint计算出来的XNAS-MAC和接收到的NAS-MAC对比来检查NAS消息的完整性，确认得到原始的NAS消息。 用户面数据是加密的但是不进行完整性保护。用户数据包在发送端使用K-UPenc进行加密，在接收端使用K-UPenc进行解密获得原始的用户数据包。 IV. Security Context到目前为止，我们已经讨论完了LTE鉴权过程，NAS安全和AS安全过程。在这些过程中和安全相关的数据会在EPS实体中设置，这些数据叫EPS安全上下文，可以使NAS安全上文也可以是AS安全上下文。NAS安全上下文可以有两种类型：”full native” or “partial native”。在EPS AKA执行之后，第一个SMC进行之前的NAS安全上下文叫”partial native”。一个”partial native”的EPS NAS安全上下文在SMC过程完成之后转变为”full native” 。表2列出了这些EPS安全上下文。 图13显示了在EPS AKA和NAS/AS安全建立之后存储在EPS实体中的LTE安全数据。它显示了这些每一个安全数据是如何生成的，并且数据传输流指示从哪个数据开始安全数据开始传输。 V. ClosingLTE安全文档已经覆盖包括基于EPS AKA的LTE鉴权，和NAS、AS安全建立过程、在EPS实体中安全数据等的LTE安全技术。我们还学会了LTE安全秘钥的层次结构，他们是分离的，用于不同的目的。顶级的秘钥是K（LTE秘钥），它是一个固定的值存储在USIM和HSS/AuC中。从K，衍生出了CK、IK，然后从CK、IK衍生出K-ASME。NAS秘钥和K-eNB从K-ASME中衍生。从K-eNB又衍生出了AS安全秘钥。我们还发现从UE、eNB、MME衍生的秘钥取决于他们是用于NAS层还是AS，是用于控制面还是用户面，是用于加密还是完整性保护，或者是使用哪一个种算法。表3列出了所有的LTE安全秘钥。 References[1] Netmanias Technical Document, “LTE Security I: LTE Security Concept and LTE Authentication”, July2013, http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5902[2] 3GPP TS 33.401, “3GPP System Architecture Evolution (SAE); Security architecture”.[3] 3GPP TS 24.301, “Non-Access-Stratum (NAS) protocol for Evolved Packet System (EPS); Stage 3”.[4] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5-LTE Security I: LTE Security Concept and LTE Authentication]]></title>
    <url>%2F2016%2F04%2F03%2F5-LTE-Security-I-LTE-Security-Concept-and-LTE-Authentication%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5902 I. Introduction实际中的无线通信，因为数据是原始的发送和接收的，这些数据可能被接收，并被意想不到的用户非法使用，存在窃听和篡改的风险。用户的位置和移动轨迹也是可以通过追踪用户连接的小区很容易的跟踪。这将会引起隐私侵权。移动通信提供安全特性来保证在空中接口传输的数据避免被篡改，且阻止意想不到的用户非授权的接入来接收数据，并保护用户的隐私。 LTE安全文档描述LTE网络提供的基本安全特征，包括LTE鉴权，NAS安全，AS安全。LTE鉴权是判定试图接入网络的用户是否是合法的签约用户。NAS安全和AS安全是在NAS和AS级别上在LTE空中接口上传输的数据确保能安全地传送。 LTE安全文档包含两个部分，part I II。第一个部分主要介绍LTE安全的概念和LTE鉴权的详细过程，第二部分主要介绍NAS和AS安全建立过程。 第一部分组成如下：在第二章，将介绍这两个文档的范围和概述，第三张介绍LTE鉴权过程，第四章总结LTE鉴权和LTE鉴权相关的秘钥。 II. LTE Security Concept2.1 LTE安全的范围和概念图1展示了LTE安全文档的范围和概念。这些文档的将包含以下三个区域。1、LTE鉴权：在UE和网络之间执行相互的鉴权。2、NAS安全：在UE和MME之间执行完整性保护验证和NAS信令的加密（加密和解密）3、AS安全，在UE和eNB之间执行完整性保护验证和RRC信令消息的加密，执行用户数据的加密。 LTE鉴权在移动网络中，鉴权是判定试图接入网络的用户是否是合法的签约用户。在多种多样的可用的鉴权过程中，在LTE网络中，在用户和网络之间使用EPS AKA（Authentication and Key Agreement鉴权和秘钥协商）过程来相互鉴权。 EPS AKA过程是由两步组成，第一步，HSS生成EPS鉴权向量（RAND, AUTN, XRES, K-ASME），并把他们发送给MME。第二步，MME选择EPS鉴权向量中的一个，并使用它来双向鉴权，并相互共享这同一个鉴权秘钥-KASME。相互鉴权是网络和UE相关鉴权的过程。在LTE网络，因为当生成鉴权向量时用户服务网络的ID是需要的，所以网络的鉴权是由用户来执行，用户的鉴权是由网络来执行。 ASME（Access Security Management Entity 接入安全管理实体）是一个从HSS接收顶层秘钥的实体，用在接入网络中。在EPS中，MME充当ASME的功能，K-ASME作为一个顶层秘钥在接入网络中使用。MME代表HSS使用K-ASME和UE实施相互鉴权。一旦相互鉴权，UE和MME共享K-ASME作为鉴权秘钥。 为了避免在无线链路上数据的窃听和篡改，K-ASME不是通过E-UTRAN传输给UE。而是，MME传输鉴权向量的部分内容给UE，使用这些内容来鉴权网络，并像HSS那样生成K-ASME。 NAS安全NAS安全，是设计用来在无线链路UE和MME之间安全地传输信令信息的，用来执行NAS信令消息的完整性检查和加密。不懂得秘钥用于完整性检查和加密。完整性检查是必须的，而加密是可选的功能。NAS安全秘钥，例如，完整性秘钥（K-NASint）和加密秘钥（K-NASenc）。 AS安全AS安全是用来确保在无线链路上UE和eNB之间数据传输的安全。在控制面对RRC信令消息实施完整性检查和加密，在用户面对IP数据包仅执行加密。不同的秘钥用于RRC信令消息的完整性检查/加密和IP数据包的加密。完整性保护是必须的，而加密是可选的功能。AS安全秘钥，例如，K-RRCint，K-RRCenc和K-UPenc，是由UE和eNB从K-eNB中衍生的，K-RRCint和K-RRCenc是用于控制面数据的完整性检查和加密，K-UPenc用于用户面数据的加密。完整性检查和加密是在PDCP层执行的。 UE可以从K-ASME中衍生出K-eNB，因为K-ASME是不传输到eNB的，而是由MME从K-ASME中衍生出K-eNB，然后传递给eNB。 2.2 LTE安全过程的概述图2展示了LTE安全过程的概述。1显示了LTE鉴权过程， 2和3展示了相应的NAS和AS安全建立过程。下面对每一个过程的简要描述。然后在第三章和第二篇文档中详细介绍每一个过程。 1、LTE鉴权当用户请求接入LTE网络时，在用户和网络之间使用EPS KAK过程来进行相互鉴权。MME一旦接收到了这样的请求，使用用户的IMSI来标识用户，并向HSS请求鉴权向量（AV）。HSS使用EPS AKA算法生成AV，AV={RAND, XRES, AUTN-HSS, K-ASME}，并转发给MME。 在MME存储AV之后，MME从中选择一个，使用这个AV来和UE执行相互鉴权。MME会转发RAND和AUTH-HSS给UE，然后UE使用EPS AKA算法计算出RES，AUTN-UE和K-ASME。UE比较自己的AUTN-UE和从MME接收到的AUTH-HSS来执行网络鉴权。一旦鉴权完成，发送RES给MME，MME比较从HSS接收到的XRES和从UE接收到的RES来执行用户鉴权。如果ＵＥ和网络都鉴权了，则他们就共享了相同的Ｋ－ＡＳＭＥ（尽管Ｋ－ＡＳＭＥ不在UE和MME之间传送）。 2、NAS安全一旦UE和MME相互鉴权完毕并具有相同的秘钥K-ASME，NAS安全过程开始。在这个过程中，当传送NAS信令消息时，NAS安全秘钥从K-ASME中衍生，用于这些NAS消息的安全传送。这个过程包含NAS消息的一个来回（Security Mode Command 和 Security Mode Complete消息），并在MME传送Security Mode Command 消息给UE是开始。 第一，MME选择一个NAS安全算法（Alg-ID：算法ID），并使用它们来从K-ASME来产生K-NASinc和K-NASenc。接着MME把K-NASinc算法用于Security Mode Command消息产生一个NAS消息鉴权码（NAS-MAC：Message Authentication Code for NAS for Integrity)。MME接着传输包含选择的NAS安全算法和NAS-MAC的Security Mode Command消息给UE。因为UE并不知道选择的加密算法，所以这个消息是完整性保护的，但是没有加密。 一旦接收到了Security Mode Command消息，UE使用MME选择的NAS完整性算法来验证完整性，并使用NAS完整性/加密算法从K-ASME中产生NAS安全秘钥（K-NASinc，K-NASenc）。接着使用K-NASenc加密Security Command Complete消息，并使用K-NASinc生成消息鉴权码NAS-MAC用于加密的消息。现在UE可以传输包含NAS-MAC的加密和完整性保护的消息到MME了。 一旦NAS安全建立起来，在UE和MME之间的NAS信令都是通过NAS安全秘钥加密和完整性保护的，在无线链路上安全的传输。 3、AS 安全在NAS安全建立完成之后，在UE和eNB之间AS安全建立过程开始。在这个过程中，当传输RRC信令消息和IP数据包时，使用从K-eNB产生的AS安全秘钥用于这些数据的安全传输。这个过程包括RRC信令消息的一个来回（Security Mode Command 和 Security Mode Complete 消息），并且这个过程在eNB传输Security Mode Command消息给UE时开始。 第一，MME从K-ASME中计算出K-eNB并传输给eNB，eNB使用K-eNB来执行AS安全过程。eNB选择AS安全算法（Alg-ID：算法ID）并使用这个算法ID从K-eNB中计算出完整性秘钥（K-RRCinc）和加密秘钥（K-RRCenc）用于RRC信令消息，计算出加密秘钥（K-UPenc）用于用户面。接着，应用K-RRCint到Security Mode Command消息产生一个消息鉴权码（MAC-I，Message Authentication Code for Integrity）。现在eNB开始传输包含选择的AS安全算法和MAC-I的Security Mode Command消息到UE。 一旦从eNB接收到Security Mode Command消息，UE使用eNB选择的AS完整性算法验证完整性，并使用AS完整性/加密算法来计算出AS加密秘钥 (K-RRCint, K-RRCenc and K-UPenc)。接着UE使用RRC完整性秘钥产生一个消息鉴权码MAC-I给Security Mode Complete 消息，接着转发包含MAC-I的这条消息给eNB。 当eNB使用AS安全秘钥成功的验证了接收到的Security Mode Complete 消息的完整性，AS安全建立过程完成的。 在AS安全建立之后，UE和eNB之间的RRC信令消息都是使用AS安全秘钥加密的和完整性保护的，在空中链路上传输的用户IP数据包是加密的。 III. LTE Authentication Procedure在第二章简要介绍了LTE鉴权过程，接下来将详细介绍。图3是当UE附着到LTE网络时执行基于EPS AKA的LTE鉴权过程。在USIM和HSS/AuC上存储着固定的秘钥（LTE 秘钥K，IMSI）。当UE被生产的时候，在USIM卡上就存储了LTE K和IMSI，并且当用户开始签约LTE网络时在HSS/AuC中提供。 3.1 由UE请求的鉴权1、[UE -&gt; MME] UE请求对网络的鉴权 当UE在初始附着时试图接入网络，UE传送Attach Request消息给MME，这个消息触发了EPS AKA过程。在Attach Request消息中包含(IMSI, UE网络能力, KSIA-SME=7)参数。其中 IMSI：（ International Mobile Subscriber Identity），是和用户关联的唯一的ID。 UE网络能力：UE可用的安全算法。 KSIA-SME=7：指示UE没有安全秘钥。 UE网络能力通知MME 连接到EPS的UE具有什么样的能力，并指示UE支持的NAS和AS算法，比如EEA和EIA（EPS Encryption Algorithms 和 EPS Integrity Algorithms）。他们是用1bit的值来标识是否存在，（比如EEA0=0，EEA1=1……EIA1=1，EIA2=1….），表1列出了UE网络能力信息。 KSI-ASME标识UE和MME中的K-ASME，由3bit组成，从000到111（0-7），7是标识在UE中没有可用的K-ASME。 3.2 在MME和HSS之间鉴权数据的交换2、[MME -&gt; HSS]MME向HSS请求鉴权数据 MME识别到UE没有可用的K-ASME，通过向HSS发送Authentication Information Request消息来发起LTE鉴权过程获取新的鉴权数据。Authentication Information Request消息包含(IMSI, SN ID, n, Network Type)参数。其中 IMSI：和用户关联的唯一的ID。 SN ID（Serving Network ID服务网络ID）：是指用户接入的网络，由PLMN ID组成。 n（鉴权向量的个数）：MME请求鉴权向量的个数 Network Type：UE接入网络的类型（在此是E-UTRAN）。 一旦从MME接收到Authentication Information Request消息，HSS生成RAND和SQN，并使用EPS AKA算法用LTE K，SQN，RAND计算出XRES，AUTN，CK，IK。然后使用KDF（Key Derivation Function秘钥派生函数）用CK，IK，SQN和SN ID（PLMN）计算出接入网络的顶级秘钥（K-ASME），然后传输给MME。KDF是一个单向函数。因为在生成K-ASME时需要SN ID，所以当服务网络发生变化时K-ASME需要重新生成。在K-ASME生成后，HSS形成鉴权向量组AV-i=（RAND-i，AUTN-i，XRES-i，K-ASME-i），i=0….n-1. 3、[MME &lt;- HSS]HSS响应鉴权数据的请求 HSS应MME请求生成需要AV，然后发送Authentication Information Answer (AVs)消息给MME。 3.3 UE和MME之间的相互鉴权MME存储从HSS接收到的AV，然后在UE的LTE鉴权中选择其中一个使用。在图3中，MME选择第i个AV。K-ASME是MME基本的秘钥，在接入网络中作为一个顶级的秘钥起作用。它只存在于EPC中，不会通过E-UTRAN传送给UE，因为那样传输是不安全的。MME分配KSI-ASME（K-ASME的索引）代替K-ASME传送给ＵＥ，因此UE和MME都能使用KSI-ASME来代替K-ASME（在图3中，KSI-ASME=1）。 4、[UE&lt;-MME]MME请求对用户鉴权MME保留在AV中的K-ASME-i和XRES-i，把KSI-ASME-i代替K-ASME-i，RAND-i，AUTN-i包含在Authentication Request消息中传递给ＵＥ。XRES-i会在待会鉴权用户的时候用到。 UE一旦从MME接收到Authentication Request消息，传递RAND-i和AUTN-i给USIM，USIM使用和HSS相同的EPS AKA算法用存储的LTE K和接收到的RAND-i和HSS生成的SQN（SQN隐藏在AUTN中）计算出RES，AUTN-UE，CK，IK。UE比较通过EPS AKA算法产生AUTN-UE和从MME接收到的AUTN来鉴权LTE网络。 5、[UE-&gt;MME]UE响应对用户的鉴权一旦UE完成网络鉴权，UE发送包含由EPS AKA算法生成RES的Authentication Response消息给MME。如果使用AUTN网络鉴权失败，UE包含失败原因的Authentication Failure消息给MME。 当MME接收到从UE的Authentication Response消息，将对比由UE生成的RES和从HSS接收到的AV中的XRES-i来鉴权用户。 在完成网络鉴权之后，USIM卡传输CK，IK给UE。UE使用KDF函数用CK，IK，SQN，SN ID生成K-ASME，并使用从MME接收到的KSI-ASME作为它的索引存储。然后，在UE和MME之间NAS安全监理时用KSI-ASME代替K-ASME。 IV. Closing上面，我们已经讨论了LTE鉴权过程。LTE鉴权是基于EPS AKA过程的用户和网络之间的相互鉴权。在服务网络中的MME和UE代替HSS来执行相互鉴权，鉴权的结果是在UE和MME之间具有相同的K-ASME。在表2中总结了LTE鉴权相关的秘钥。在第二个文档将基于K-ASME来介绍NAS和AS安全。 References[1] Netmanias Technical Document, “LTE Security II: NAS and AS Security”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5903.[2] 3GPP TS 24.301, “Non-Access-Stratum (NAS) protocol for Evolved Packet System (EPS); Stage 3”.[3] 3GPP TS 33.401, “3GPP System Architecture Evolution (SAE); Security architecture”.[4] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4-LTE Identification III: EPS Session/Bearer Identifiers]]></title>
    <url>%2F2016%2F04%2F03%2F4-LTE-Identification-III-EPS-Session-Bearer-Identifiers%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5907 I. Introduction在LTE Identification I II中我们学习了UE ID，ME ID，NE ID和Location ID。这篇文档将学习和用户数据传输有关的EPS会话/承载ID。端到端的会话包含应用层实体不在本篇文档讨论范围，仅仅包含提供用户用于PDN连接的EPS会话。在表1表示这篇文档讨论的ID。我们在LTE identification I II中学习了不同的UE，ME，NE，有多个EPS会话ID和承载ID在一个UE中使用。这意味着，在一个UE中可以同时建立不止一个EPS会话和承载，所以需要ID来标识他们。 II. EPS Session and EPS Bearer: Overview在我们讨论和EPS会话和承载相关的ID之前，我们需要了解一下EPS会话和承载是什么，并且描述一下这些ID之间的关系。图1显示了一个用户的EPS会话和承载，并在下面标识了ID。 2.1 EPS会话UE和PDN之间的IP连接叫PDN连接或EPS会话。每一个PDN连接是由UE的IP地址和PDN ID（也叫APN）描述的。它有不止一个EPS承载来传输用户数据（IP数据包），并应用从PCRF到EPS承载获得的服务质量（QoS）策略。最小最基本的承载是EPS会话的一个默认EPS承载。 一旦EPS会话建立意味着1）已经选择一个用户使用服务的PDN（通过用户的输入或者基于HSS提供的签约信息），2）已经为用户分配了用于PDN内的IP地址，3）已经选择了用于用户IP数据包的策略规则（QoS和计费策略），4）在LTE网络上传送IP数据包的默认EPS承载已经建立了。通过已经建立的这个EPS承载，IP数据报可以通过运营商提供的策略在用户和PDN之间相关交换。会话的管理和操作，包括PCRF会在其他文档讨论，PDN ID（APN）将会作为和EPS会话相关的一个ID在本文档中讨论。 2.2 EPS承载EPS承载负责传送和处理标记了UE IP地址的IP数据流，并在UE和PDN之间传输（UE – P-GW – PDN）。另一个方面，一个EPS承载就是LTE网络上传输IP数据包的管道，例如，在UE和PGW之间(UE – eNB – SGW - P-GW)。一个UE可以同时又多个EPS承载。不同EPS承载使用MME分配的EPS bearer ID来标识。如图1所示，一个EPS承载是由以下三个承载串接起来的（DRB，S1承载和S5承载）: [UE] - [eNB]: 无线数据承载 (DRB)，EPS承载在LTE-Uu接口上建立。用户数据（IP数据包）通过DRB来传输。不同的DRB使用eNB分配的不同的DRB ID来标识。 [eNB] - [S-GW]: S1承载，EPS承载在S1-U接口上建立。用户数据通过GTP隧道传输。不同的S1承载使用由GTP隧道端点（(eNB and S-GW)）分配的TEID来标识。 [S-GW] - [P-GW]: S5承载，EPS承载在S5接口上建立。用户数据通过GTP隧道传输。不同的S5承载使用由GTP隧道端点（(S-GW and P-GW) ）分配的TEID来标识。 E-RAB是有UE和SGW两个端点的承载，包含DRB和S1承载。E-RAB是由DRB和S1承载串接，并在从UE到SGW连接(UE –eNB – S-GW)。不同的E-RAB使用由MME分配的E-RAB ID来标识。DRB ID和E-RAB ID是和EPS承载ID一对一映射的。 2.3 EPS承载的类型之前我们描述了EPS相关的承载ID，现在我们看看EPS承载的不同类型和他们是怎么工作的。图2描述了EPS承载的不同类型：默认承载和专用承载。每一个PDN必须有一个默认的EPS承载，但可以没有或者有多个专用ESP承载。 LTE网络是全IP网络，提供给用户永久在线的IP连接。这就意味着，一旦UE使用初始附着到网络分配的IP地址连接到PDN，在LTE网络上在默认EPS承载建立之后，IP连接将一直保持连接，直到UE从LTE网络去附着（比如，PDN连接终止了）。即使用户没有数据要发送，这个默认的EPS承载也是一直保持激活，并准备着可能到达的用户数据。 如果默认的EPS承载不能足够满足QoS，则需要建立额外的EPS承载。建立的额外EPS承载叫做专用EPS承载，并且根据用户或者网络的需要可以建立多个专用承载。当没有用户数据，这些专用EPS承载可以被移除，但默认的EPS承载不会被移除，一直保持用户和网络之间的连接，直到用户从网络去附着。专用EPS承载是和默认EPS承载联接在一起的。这个联接的承载是用LBI（Linked EPS Bearer Identity）标识，指示他们都联接到同一个默认EPS承载。 UE发送或者UE接收的IP数据都是在LTE网络上根据QoS等级通过适当的EPS承载来传输。上行IP数据从UE一直映射到EPS承载，而下行IP数据是从PGW一直映射到EPS承载。 根据2.2和2.3节讨论的，和EPS承载相关的ID有EPS Bearer ID，E-RAB ID，DRB，TEID，LBI。第三章将详细介绍这些EPS会话和承载ID。 III. Identifiers for EPS Session/Bearer (Session/Bearer IDs)3.1 识别PDN的ID：PDN ID(APN)PDN使用PDN ID（APN）来标识。一个APN关联一个用户想连接PDN的接入点。在图3是APN和格式。APN是由网络ID和运营商ID组成。网络ID用来识别PDN，像因特网、企业VPN，或者用来识别PDN提供的服务，像IMS。 APN是在用户签约时由HSS作为签约信息提供的。一旦UE初始附着，一个默认的APN从HSS下载到MME。MME首先基于APN选择一个PDN连接UE，接着通过UE连接到的PDN选择PGW。在图3中，MME基于APN1选择PDN1，然后选择PGW 1建立PDN1连接。 3.2 在EPS网络标识用户数据传输的ID：EPS承载IDEPS承载是UE和PGW之间虚拟连接集合，用来LTE网络上传输用户数据。EPS承载中不同的承载是用4bit的EPS承载ID标识的。表2是EPS承载ID值。一个UE可以最多11个EPS承载，他们的ID值从5-15。 图4是EPS承载相关的ID和他们是谁分配的。EPS承载ID，不论默认的还是专用的，都是由MME分配的。当UE初始附着到LTE网络，MME从HSS中获得建立默认EPS承载需要的QoS配置文件，并基于接收到的QoS建立起承载。当MME分配EPS承载ID时，发起默认EPS承载建立的过程。EPS承载的两个端点是UE和PGW。他们都执行数据流过滤（UE过滤上行用户数据流，PGW过滤下行数据流）来通过数据流要发送的哪一个承载来决定。图2是包含五个IP数据流（1-5）的下行用户传输。当IP数据流从PDN到达PGW时，PGW实行数据流过滤来决定IP数据流传输使用哪一个承载，并使用相应的承载来传输。下行EPS承载数据是通过S5承载，S1承载和DRB最终到达UE，并把数据流以IP流的方式传输到上层。为了让这个过程进行，每一个实体都必须对每一个承载映射承载ID，如表3。图5是映射的过程。 3.3 在UE和EPC之间来识别EPS的ID：E-RAB ID如图1/4/5所示，E-RAB是UE和SGW之间的一个EPS承载集合，用4bit的E-RAB ID来标识。E-RAB ID是由MME分配，通常和EPS承载ID有相同的值（根据EPS承载的建立），并和EPS承载ID一对一的对应。在EPS承载建立过程中，当MME请求eNB建立E-RAB时，eNB和UE创建DRB，和SGW创建S1承载。 默认EPS承载使UE一直和网络保持连接。当没有用户数据，UE保持在空闲状态，E-RAB是去激活的，只有S5承载保持存在。但是，只要用户数据到达，E-RAB重建，然后允许传送数据流从UE到PGW。 3.4 在无线链路上标识EPS承载的ID：DRB ID如图1/4/5所示，DRB是在UE和eNB之间在无线链路上的一个集合，用4bit的DRB ID来标识。一旦建立EPS承载，DRB ID由eNB分配，并且和EPS承载ID一对一对应。在EPS承载建立过程中，当MME请求eNB建立E-RAB时，eNB分配DRB ID创建DRB来和UE通信，并基于需求的QoS选择合适的逻辑信道配置参数。 3.5 识别GTP隧道端点的ID：TEIDS1承载和S5承载，都是EPS承载的一个部分，分别在eNB和SGW之间，在SGW和PGW之间以GTP隧道的方式建立。GTP隧道是以上行和下行两个端点的TEID标识的，TEID是32bit。图4显示S1和S5 GTP隧道上TEID的分配。当EPS承载建立时，对于S5承载，SGW分配DL S5 TEID，PGW分配UL S5 TEID。对于S1承载，SGW分配UL S1 TEID，eNB分配DL S1 TEID。 3.6 连接默认EPS承载和专用EPS承载的ID：LBI如图2所示，一个EPS会话有不止一个EPS承载。默认EPS承载在当EPS会建立时建立，在EPS会话结束时结束。另一方面，专用EPS承载可以在EPS会话建立后随时创建和删除。因为默认承载和专用承载都属于同一个用户的同一个PDN，所以需要一个ID来标识用于同一个PDN的两个不同的承载。这个引入的ID是LBI，默认EPS承载ID用作LBI。 当默认EPS承载创建时，MME分配一个承载ID，这个ID也作为一个LBI指定。接着，当专用EPS承载创建时，MME分配LBI（和承载ID一起）来标识默认承载。 IV. Summary我们已经表1中分类了EPS会话和承载相关的ID。表4分类和列出他们使用的范围等。表5总结所有的LTE ID。 V. Closing通过LTE identification文档，我们全部介绍了表1中的LTE ID，并且简要的介绍了他们的功能和目的。基于我们经学到的LTE网络架构和LTE identification，我们可以继续讨论高主要的议题。 References[1] Netmanias Technical Document, “LTE Identification I: UE and ME Identifiers”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5905[2] Netmanias Technical Document, “LTE Identification II: NE and Location Identifiers”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5906[3] Netmanias Technology Document, “LTE Network Architecture: Basic”, July 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5904[4] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3-LTE Identification II: NE and Location Identifiers]]></title>
    <url>%2F2016%2F04%2F03%2F3-LTE-Identification-II-NE-and-Location-Identifiers%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5906 I. Introduction在之前的文档，LTE identification I介绍了UE和ME的标识。这篇文档，将介绍网络设备（Network Equipment）和Location ID。在这篇文章中被标识的网络设备包括eNB，MME，PGW，都是EPS实体。另外小区（eNB下由一个天线覆盖的区域）和这些网络设备一起讨论。Location ID包括所有标识UE位置的ID。UE在网络中是以TA级别注册的。所以，在这篇文档中TA相关的ID和Location ID一起讨论。 在第二章和第三章，NE ID和Location ID基于分类分别讨论。在第四章，总结这些ID的共同特征。 这篇文档设计的ID的范围和类型在图1和表1中展示。如果运营商的策略需要eNB报告UE（属于这个eNB）的位置，在方框中的ID（ECGI，TAI）会从eNB到PCRF传输。 II. Identifiers for Network Equipment (NE IDs)这章描述LTE 网络设备相关的ID。属于NE ID组的ID有MME的GUMMEI和MMEI，eNB的全球eNB ID和eNB ID，小区的ECGI和ECI，PGW的PGW ID。LTE NE ID被分为两类，一类是有PLMN ID，一类是没有PLMN ID，取决于他们是在PLMN内或者是全球的唯一标识。 2.1 标识MME的ID： GUMMEI, MMEI, MMEGI and MMECMME处于E-UTRAN和EPC之间。它是关键性的控制设备，它通过和HSS交换控制信号允许UE附着到LTE网络上，在HSS中包含UE的用户签约信息。它在核心网侧通过和SGW（或PGW）交换控制信号支持承载的管理，在E-UTRAN侧通过和eNB交换控制信号支持UE的移动性。通常，LTE运营商把多个MME分为一组，把他们作为MME组来操作。MME ID用来标识MME，是当MME安装时由运营商分配的。 MMEI用来标识在运营商的网络中的MME（比如，A LTE运营商的网络管理人员需要标识在A LTE网络中的MME）。GUMMEI包含PLMN ID和MMEI，是在运营商外部用来识别MME的（比如，当C操作A和B LTE运营商的网络时，C需要标识在A LTE网络中的MME）。MME组是由运营商构建的，MMEI包含MMEGI和MMEC，MMEGI代表MME组，MMEC代表一个组内的特定的MME。图2是MME相关的ID和他们的格式。 2.2 标识eNB的ID：eNB ID和Global eNB IDeNB ID是用来标识运营商网络内的一个eNB，而Global eNB ID是由PLMN ID和eNB ID组成，是用来在网络外面标识一个eNB。图3是eNB和小区相关的ID和他们格式。为了标识属于一个eNB的小区，通过在eNB ID和Global eNB ID上加上一个小区ID。 eNB ID和小区ID是在eNB安装时由网络运营商分配的。一旦安装，eNB开始和MME之间建立S1连接的过程。当eNB请求MME 建立S1连接时，eNB报告Global eNB ID/所支持的TA/所支持的CSG（Closed Subscriber Group）。CSG是一种只对一部分签约用户开放的小区，它是由单一或者一些小区组成。MME发送服务的GUMMEI给eNB作为对S1连接建立请求的响应，并提供MME池的信息。 2.3 识别PGW的ID：PGW ID当一个UE尝试附着在LTE 网络上，LTE网络提供给UE PDN连接。为了在UE和PDN之间建立PDN连接，MME需要知道UE连接的PDN和UE附着的PGW。默认的PDN作为签约用户的配置文件在HSS中已经提供了。所有，MME只需要从HSS中下载这些信息就可以了。对于PGW，有两种方式分配固定分配（由网络运营商提供，在HSS中作为签约用户的配置文件）和动态分配（根据运营商提供的PGW选择策略，MME选择一个PGW）。对于固定分配，HSS把PGW ID通知给MME，所以MME可以请求PGW建立PDN连接。 PGW ID用来标识PGW，可以是IP地址或者FQDN（Fully Qualified Domain name全称域名）格式。图4是依据固定分配策略分配的PGW ID和格式。举例，UE的默认PDN中一个PDN1用于因特网服务，一个PDN2用于语音服务。当UE发起接入到LTE网络，MME向HSS请求UE的签约信息，HSS通知MME 1）UE的默认PDN是PDN1（因特网）和PDN2（IMS），2）PGW连接PDN1的是PGW 1，连接PDN2的是PGW 3。MME接着通过PGW 1在UE和因特网之间建立PDN连接，通过PGW 3在UE和IMS之间建立PDN连接。对于根据动态分配策略的PGW ID分配，MME从DNS中获取PGW IP地址列表，从列表中选择一个，然后请求PGW建立PDN连接。如果PGW列表是由DNS提供，MME按照PGW选择策略从列表中选择一个。 III. Identifiers for UE Location (Location IDs)MME负责管理UE的移动性，所以必须根据UE的位置来更新信息。如果UE在激活状态并且使用服务，UE的位置在LTE网络中是小区级别已知的。如果UE是在空闲状态并没有使用服务时，UE的位置则是TA级别已知的。因为在第二章已经介绍了小区ID，所以这一章只介绍TA ID。 3.1 识别UE位置的ID：TAC和TAIUE在TA级别注册到网络。MME在TA级别定位空闲状态的UE。标识TA的ID是TAC(Tracking Area Code)和TAI (Tracking Area Identifier)。TAC用来在一个运营商网络中标识一个TA。TAI是包括PLMN ID和TAC，用来唯一的标识一个TA。图5是TA ID不同类型和格式。当UE初始附着到一个LTE网络上，UE通过MME注册到网络上。在初始附着时，MME为UE分配一个TAI列表，并保持对UE位置的更新。UE把自己的新位置通知给MME，并当离开注册的TA时请求TA更新。用这种方法，MME就知道UE当前所待在的TA，并保存UE更新过的TAI列表。如果UE移动到包含在TAI列表中的TA区域，UE不会请求TA更新。但是，如果当前TA的更新周期超时，UE需要把自己当前的TA通知给MME，即使UE待在的TA包含在TAI列表中，让MME知道UE可以接收数据。 当在LTE网络有到达UE的数据，MME需要知道UE的位置来发送数据。如果UE是在激活状态，MME知道UE待在哪一个小区，因此可以容易地转发数据。但是如果UE在空闲状态，MME不知道UE待在哪一个具体的小区。所以，MME搜索UE最后一次报告的TA。空闲状态下的UE会在特定的周期醒来检查是否有寻呼消息。如果发现被寻呼了（通过检查在寻呼消息中的S-TMSI），它会相应寻呼消息来接收数据。TA区域越大意味着能容易地找到UE的概率越大。但是，在同一时间，TA区域越大意味着需要寻呼更多的eNB，因此需要更多的信令消耗。怎么分配TAI列表是一个优化的问题。 eNB通过安装时服务开通消息知道它属于哪个MME和TA。eNB中的每一个小区在系统消息中广播自己的小区ID（ECI，ECGI）和TA信息（TAC，TAI）。尝试接入新小区的UE通过监听广播系统消息判断新的小区是否和当前的小区有不同的TA，它的TA需要改变，或者新小区在UE的当前TA。图5展示了分配TA列表的UE的行为。在图中，eNB1是在TA1，eNB在TA2，eNB3和eNB4是在TA3（一个TA可以包括几个小区和eNB）。UE1注册到MME1，被分配了{TAI1, TAI2}的TAI列表。UE2注册到MME2，被分配了{TAI2, TAI3}的TAI列表。在UE1接入到eNB1后变为空闲状态，因为它沿着点线移动（eNB1 -&gt;eNB2-&gt;eNB3）,UE1的行为描述如下（TA在小区级别检测，但，当在同一个eNB下不同小区之间转移不在这里讨论）： 在eNB1：UE当前的TA是TA1 当从eNB1移动到eNB2：UE1当尝试接入新小区时，从新小区广播的系统信息知道新小区是TA2。UE检查TAI列表，发现TA2包含在TAI列表，所以，不需要请求TA更新。 当从eNB2移动到eNB3：UE1当尝试接入新小区时，从新小区广播的系统信息知道新小区是TA3。UE检查TAI列表，发现TA3不包含在TAI列表，所以，需要发送TAU请求消息到MME来更新自己的位置。 IV. Closing我们在之前的文档知道了LTE ID中的UE ID和ME ID，在当前文档学习了NE ID和Location ID。表2总结了这篇文档涉及的ID，其他的ID将会在第三篇文档中介绍。 References[1] Netmanias Technical Document, “LTE Identification I: UE and ME Identifiers”, August 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5905[2] Netmanias Technology Document, “LTE Network Architecture: Basic”, July 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5904[3] 3GPP TS 23.003, “Numbering, addressing and identification”.[4] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-LTE Identification I: UE and ME Identifiers]]></title>
    <url>%2F2016%2F04%2F03%2F2-LTE-Identification-I-UE-and-ME-Identifiers%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5905 I. Introduction在LTE网络中，根据和其他ID的关系使用不同的ID来标识每一个实体。就像在人际网络中使用不同的名字和头衔来标识一个人。理解这些ID和EPS实体是对理解LTE技术很必要。 我们之前讨论了第一个问题–LTE网络架构。现在我们讨论LTE标识，这是我们的第二个问题，将会有三个相关的文档来讨论。这个文档是第一个，聚焦在用户设备（UE） ID。第二个和第三个文档将f分别涉及到网络设备（NE）ID和EPS会话/承载标识。 这个文档组织如下。第二章，对LTE ID分为几个组。第三章和第四章，将分别描述UE ID和ME ID。第五章，总结UE和ME ID的总体特征。 II. Classification of LTE Identification图1表示，在LTE网络参考模型一些实体和接口使用和定义的ID。这些LTE ID将按照他们的生成时间/属性类型（固定的或暂时的）/其唯一标识的范围。 创建时间：LTE ID的创建时间有以下几种 一旦设备安装上就委任的 在服务操作之前或者进行中由运营商提供的 根据需求，当用户接入网络或者使用服务才创建 LTE ID的分配或者提供是在图1中在相应的实体上用蓝色方块表示。 类型：LTE ID有一个属性类型，固定的（一旦创建就保持固定），临时的（当激活时发生变化）。被委任的或者分配都有固定的值，但根据需求，当用户接入网络或者使用服务时分配的是临时的值。 范围（其ID被唯一标识的内部）：每一个LTE ID在全世界/运营商网络/实体还是信道上是唯一标识的。图1中，不同的ID根据LTE标识实际执行的地方来使用，例如，在哪个层，在哪个接口，或者在哪个物理区域。为了描述的方便，图1中的ID被分类展示在表1中。首先，EPS实体的ID被分组为UE ID，ME ID，NE ID。这些EPS实体被分类为UE和NE。ME是UE的一部分，被从UE中分离，被分为一个独立的组。NE是由LTE运营商操作的网络实体，比如，MME，eNB，PGW。像IMSI/GUTI/S-TMSI/IP地址/C-RNTI/UE S1AP ID/UE X2AP ID这样子的ID标识一个用户的，属于UE ID组。像IMEI/IMEISV这样的ID标识一个设备的，属于ME ID组。像MME的GUMMEI和MMEI，eNB的全球eNB ID和eNB ID，小区的ECGI和ECI，PGW的PGW ID，这些都属于NE ID组。像TAI和TAC这样的Location ID来标识用户附着的区域。最后，像PDN ID（or APN），EPS承载ID，E-RAB ID，DRB ID，TEID，LBI这样的会话/承载ID是和用户数据传送有关，用来识别EPS会话和EPS承载。 这个文档，描述了在表1中灰色的UE和ME的LTE ID。第二个文档将涉及LTE NE ID和Location ID用来标识UE的位置区域。第三个文档将讨论EPS会话和承载ID。 表1，LTE ID的分类 ID group LTE ID 相关的文档 UE ID IMSI, GUTI, S-TMSI, IP address (PDN address), C-RNTI, eNB UE S1AP ID,MME UE S1AP ID, Old UE X2AP ID, UE X2AP ID LTE Identification I ME ID IMEI LTE Identification I NE ID GUMMEI, MMEI, Global eNB ID, eNB ID, ECGI, ECI, P-GW ID LTE Identification II Location ID TAI TAC LTE Identification II 会话/承载ID PDN ID(APN), EPS Bearer ID, E-RAB ID, DRB ID, TEID, LBI LTE Identification III III. Identifiers for User Equipment (UE IDs)LTE网络是全IP网络。因为这个特性，在LTE网络中的UEs共享无线和网络资源。LTE网络的EPS实体给每一个UE分配UE ID来识别不同的UE。因为UEs在不同层和接口共享资源，所以需要多种多样的UE ID。在移动通信网络中最必要的ID是PLMN ID，用来识别特定网络的运营商。我们首先开始包含PLMN ID的UE ID的描述。 3.1 PLMN ID指示用户需要签约的网络PLMN是运营商分配和操作的，用来为公众提供移动通信服务。PLMN ID通常用来识别用户需要签约的移动通信网络。它包含MCC和MNC，如图2所示。MCC的三个数字表示用户所在的移动网络所属的国家。每一个国家有一个或多个PLMN ID。MCC的分配需要ITU-T的授权，定义在ITU-T E.212 [3]。例如韩国的MCC是450.一个MNC标识移动通信网络的运营商，是由每一个国家分配的。例如，在韩国有三个移动运营商，SK电信，KT和LG U+，他们的MNC如图2所示。 3.2 IMSI:分配给签约用户的固定IDIMSI（International Mobile Subscriber Identity）是全球为一个号码来标识一个签约用户。图3表示了IMSI的分配过程和IMSI的格式。一个IMSI是由指示签约用户网络的PLMN和由运营商分配的MSIN（Mobile Subscriber Identification Number）。IMSI长度最大15个数字。MSIN识别一个PLMN中的签约用户。当用户购买一个USIM卡并签约一个移动网络，就有了一个内建的唯一的IMSI开始启用并和用户关联。IMSI是存储在手机的USIM卡中，IMSI和用户签约信息是由运营商提供给HSS和SPR。在提供之后，当UE attach LTE网络的时候，UE发送IMSI给移动网络。在接收到UE的IMSI之后，MME开始LTE网络的默认EPS承载和基本传输路径的建立（通过1）基于从UE接收到的IMSI，识别出签约用户的本地网络，2）选择持有用户签约信息的HSS，3）从HSS中下载信息）。 存放在USIM/HSS/SPR中的IMSI是不可移除的固定值。另一方面，存储在MME/SGW/PGW/PCRF中的IMSI，在UE初始附着过程建立默认EPS承载时是一个临时值，当默认承载终止时被移除。 3.3 IDs Used at MME: GUTI, S-TMSI and M-TMSIIMSI是一个固定唯一的ID来标识签约用户。如果它经常暴露在无线链路上将会不安全。为了增强安全性，当UE附着在网络时MME给UE分配一个GUTI（Globally Unique Temporary Identifier）用来代替IMSI来标识UE。图4是GUTI的分配过程和格式。GUTI分配：当UE第一次附着到LTE网络时，它使用IMSI请求接入网络并从网络获得GUTI。当UE再次附着网络时，UE使用GUTI代替IMSI。当再次附着到网络时，UE使用IMSI或者GUTI作为ID取决于下次更新时临时标识（TIN）设置的是什么。 一旦UE的初始附着过程和TAU过程是成功执行，MME分配和发送GUTI给UE，接着设置GUTI作为它的TIN。其后，当UE附着网络或者请求TAU更新时都使用GUTI代替IMSI。 GUTI格式：LTE运营商有一个或者多个MME组包含多个MME。因此MMEI（MME Identifier）是由代表MME组的MMEGI（MME Group Identifier）和代表组内一个MME的MMEC（ MME Code）组成。GUMMEI（Globally Unique MME Identifier）是在MMEI基础上加上PLMN。每一个MME每一个注册的用户分配M-TMSI，这是在MME中唯一的值，来保护签约用户的机密性。 GUTI是由GUMMEI和M-TMSI组成，是全球唯一的值，用来代替IMSI标识UE。不像IMSI有一个固定的值，GUTI是临时的值，当UE注册到LTE网络时由MME分配的。所以，当GUTI经常暴露在无线链路上也是保持安全的。S-TMSI由MMEC和M-TMSI组成，用来唯一标识MME组中的UE。如果运营商没有多个MME组时，可以使用比较短的S-TMSI来提高在无线链路上传输的有效性。 3.4 IP地址：连接PDN必须的IDIP地址，也称为PDN地址，是当UE初始附着在LTE网络时LTE网络分配给UE的用来连接PDN。因为UE可以根据不同的服务通过LTE网络连接到多个PDN，所以LTE网络针对每一个UE连接到的PDN为UE分配不同的IP地址（例如两个IP地址用于两个连接的PDN，三个IP地址用于三个连接的PDN等等）。当IP数据包从LTE网络到PDN转发，或者从PDN接收数据包时，这些IP地址用来标示IP数据包发送或接收的UE。 IP地址固定或者动态地分配用于UE连接PDN。这两种分配方式称为静态IP分配和动态IP地址分配。对于静态IP地址分配，运营商在签约的时候分配给UE一个固定的IP地址，并把这个UE的IP地址提供给HSS。不管UE附着的时间和地点，每次UE发起附着到PDN时，UE都被分配相同的IP地址。对于动态的IP地址分配，PGW有一个IP地址池，每次UE执行初始附着到LTE网络时，UE被动态地从IP地址池中分配一个可用的IP地址。因此，每次UE初始附着LTE网络时，分配给UE的IP地址都不一样。 图5是动态IP地址分配的实例。它简单介绍了在初始附着过程，默认承载建立时，PGW动态分配临时IP地址的过程和在初始附着过程分配动态IP地址后，UE使用因特网服务的过程。 3.5 C-RNTI：在一个小区内分辨UE需要的IDC-RNTI（Cell Radio Network Temporary Identifier）是在随机接入过程中由eNB分配的，并仅仅在当前的服务小区有效。在小区中的UE是使用C-RNTI来唯一标识的。当UE离开当前小区，通过随机接入过程移动到一个新的小区时，分配一个新的C-RNTI。图6是C-RNTI是怎么样分配的，和C-RNTI应用于哪一层。 在上行和下行链路，eNB负责无线资源的分配。它通过在PDCCH（Physical Downlink Control Channel）上广播C-RNTI通知在下一个TTI（Transmission Time Interval）哪一个UE可以使用无线资源。如果UE在它所接入小区的PDCCH信道上发现自己的C-RNTI，则UE就获知在在下一个上行或下行TTI上可以使用无线资源。 3.6 在S1-MME接口上需要成对的UE S1AP ID来分辨UES1AP层成功优酷S1-MME接口上eNB和MME之间的控制信息。在同一时间有多个UE和eNB保持连接。eNB和UE对应的MME交换所有的S1AP控制信息时使用相同的S1链路。所以，为了识别那个S1AP消息对应于哪一个UE，当eNB发送UE的第一个S1AP消息给MME时，eNB为每一个UE分配了一个ID（eNB UE S1AP ID）。同样的，MME通过多个S1链路和多个eNB交换S1AP信息。为了识别哪一个S1AP消息对应于哪一个eNB的哪一个UE，当MME发送第一个UE消息给eNB时分配一个ID（MME UE S1AP ID）。 在S1AP消息的第一个来回后，在S1-MME接口上交换的所有用户控制消息（S1AP）是使用一对UE S1AP ID来传输的（eNB UE S1AP ID, MME UE S1AP ID），目的是为了eNB和MME都能分辨出来哪一个S1AP消息对应于哪一个UE。然后，根据这对ID，MME可以找到接收到的S1AP消息是来自哪一个eNB的哪一个UE，并且eNB可能知道接收到S1AP消息来自哪一个UE。图7是UE S1AP ID的分配过程和UE S1AP ID应用在S1AP层。 3.7 在X2接口上需要成对的UE X2AP ID来区别UEX2AP层处理在X2接口上两个相邻的eNB之间的控制信息。在两个相邻的eNB之间UE的切换时，X2AP消息使用相同的X2链路从UE发送到对端的eNB。第一次eNB（源eNB或者目的eNB）发送X2AP给对端eNB时，eNB为每一个UE分配ID，并使用这个ID发送消息来标识是哪一个UE的X2AP消息。源eNB在第一个到目的额NB的消息（切换请求消息）中分配一个Old eNB UE X2AP ID，目的eNB在第一个到源eNB的响应消息（切换请求确认消息）中分配一个New eNB UE X2AP ID。 在第一次来回信息交换后，所有的在X2接口上和切换相关的X2AP消息都使用成对的ID(Old eNB UE X2AP ID, New eNB UE X2AP ID)来交换，目的是为了源eNB和目的eNB都能识别出来哪一个X2AP消息对应于哪一个UE。图8是UE X2AP ID的分配过程和UE X2AP ID应用在X2AP层。 IV. Identifiers for Mobile Equipment (ME IDs)第四章将描述ME ID。在讨论ME ID之前先认识下UE和ME的关系。一个UE由ME和USIM（UMTS Subscriber identity Module）卡组成。ME可以分为TE（Terminal Equipment）和MT（Mobile Terminal）。MT是负责无线接入协议工作，而TE是负责MT控制功能工作。图9是这些功能组的组成。MT和TE是集成在手机里，但是在note PC上是分开的。 4.1 IMEI和IMEISV：ME拥有的固定IDIMEI（International Mobile Equipment Identity）是为每一个ME分配的唯一值。IMEI是在ME出厂的时候被给出的，包含了和生产厂商的信息，型号，和ME的序列号。图10是IMEI的格式和IMEI使用的举例。IMEI是由TAC（Type Allocation Code）和SNR（Serial Number）和CD（Check Digit）组成。一个IMEI/SV是由TAC（Type Allocation Code）和SNR（Serial Number）和SVN（Software Version Number）组成。TAC是由RBID和ME type ID组成，其中RBID是指示认证机构的RBID（Reporting Body Identifier），ME type ID代表生产厂商的名字和型号ID。序列号是由生产厂商所分配的。在图10的例子中，RBID=35标示ME是由BABT（British Approvals Board for Telecommunications英国电信认证委员会）批准的，ME ID=643205表示ME是由三星生产的智能手机。 运营商有数据库存储IMEI信息，使用这个数据库可以拒绝任何被报告被盗和丢失ME的接入尝试。 V. Closing在我们认识LTE技术之前，我们已经讨论了LTE标识。在这个文档，我们首先解释了UE和ME ID，接下来我们根据他们的范围/分配/属性分类和总结了这些ID，见表2。其他的ID将会在LTE identification II III中讨论。 References[1] Netmanias Technology Document, “LTE Network Architecture: Basic”, July 2013,http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5904[2] 3GPP TS 23.003, “Numbering, addressing and identification”.[3] ITU-T E.212, “The international identification plan for public networks and subscriptions”.[4] GSMA TS.06, “IMEI Allocation and Approval Guidelines”.[5] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1-LTE Network Architecture: Basic]]></title>
    <url>%2F2016%2F04%2F03%2F1-LTE-Network-Architecture-Basic%2F</url>
    <content type="text"><![CDATA[原文地址：http://www.netmanias.com/en/?m=view&amp;id=techdocs&amp;no=5904 I. Introduction这篇文章主要介绍LTE网络结构，是LTE的第一篇技术文章。LTE网络也叫EPS，是一个端到端的全IP网络；EPS分为两个部分，LTE部分负责处理和接入网络E-UTRAN相关的技术，EPC部分负责处理和核心网相关的技术。一个端到端的全IP网络一位置所有的数据流，从UE到连接服务实体的PDN之间的所有通路，在EPS内部，所有的传输都是基于IP协议的。 为了通过LTE网络提供给用户LTE服务，引入了一个端到端LTE网络的参考模型（NRM），这个模型除了基本的EPS域之外，还包含三个额外的域（用户的BSS/OSS域，提供服务的应用域，发送IP包的IP传输网络域）。这篇文章的范围集中在基本的EPS域。其他的EPS域特性，例如，LTE和其他3gpp/3gpp2的互操作性和漫游，这些特性是在本文档范围之外，后续会在其他文档中涉及。 这个文档剩余部分的组织如下，在第二章，定义LTE网络参考模型，解释EPS实体和接口。第三章描述协议栈架构。第四章描述整个LTE网络的数据流。 II. LTE Network Reference Model图1是LT网络的参考模型，包含LTE实体（UE和eNB）和EPC实体（SGW/PGW/MME/HSS/PCRF/SPR/PCSOFCS）。PDN是和UE进行通信的运营商内部或者外面IP域，它提供给UE服务，比如，因特网，IMS。表1和表2是LTE和EPC实体的功能。表3列出了LTE网络参考模型的参考点，并对EPS实体之间的接口进行了描述。 表格1：LTE实体 实体 描述 UE UE通过LTE-Uu接口连接eNB eNB eNB提供用户无线接口，并负责无线资源管理功能，例如，动态资源分配（调度器），eNB测量配置和规定，无线准入控制，连接移动性控制，无线承载控制，小区间干扰协调。 表格2：EPC实体 实体 描述 MME MME是E-UTRAN的主控制实体。它和HSS通信来用户鉴权和用户配置文件下载，并使用NAS信令提供给UE EPS移动性管理（EMM）和EPS会话管理（ESM）功能。MME支持的主要功能包括：NAS信令（EMM/ESM/NAS安全）；通过S6a接口和HSS通信负责用户鉴权和漫游；移动性管理（寻呼/TAI管理/切换管理）；EPS承载管理。 SGW SGW终止E-UTRAN方向的接口。它为eNB间和3gpp间切换的数据传输提供了本地移动锚点。 PGW PGW通过从PDN的地址空间分配IP地址提供给UE接入PDN的能力。PGW作为在3gpp和non-3gpp之间切换的移动锚点。PGW也执行策略实施，数据包过滤和由PCRF提供的基于PCC规则的计费。PGW主要的功能包括：IP路由和转发，数据包过滤，UE IP地址分配，在3gpp和non-3gpp之间切换的移动锚点，PCEF功能，计费。 HSS HSS是存储用户配置的中心数据库。它提供给MME用户鉴权信息和用户配置文件。 PCRF PCRF是策略和计费控制实体。它为服务数据流（SDF）提供策略决策，并且提供给PCEF（PCEF在PGW内）策略和计费控制（PCC）规则（包括QoS和计费规则） SPR SPR提供给PCRF用户信息（每个用户的接入配置文件）。PCRF接收到这个信息后，将执行基于用户的策略并创建策略和计费控制（PCC）规则。 OCS OCS提供实时的信用控制和基于体积/时间/事件的计费功能。 OFCS OFCS提供基于计费数据记录（CDR）的计费信息。 CDR：charging data recordOCS：online charging systemOFCS：offline charging systemOSS：operations support systemPCC：policy and charging controlPCEF：policy and charging enforcement functionPCRF：policy and charging rules functionSDF：service data flowSPR：subscriber profile repository 表3：LTE接口 参考点 协议 描述 LTE-Uu E-UTRA（控制面和用户面） UE和E-UTRAN（eNB）之间控制和用户面的接口。在LTE-Uu接口上，信令连接是用SRB表示的RRC连接，用户面连接是用DRB表示的逻辑信道。 X2 X2-AP（控制面）GTP-U（用户面） 两个eNB之间的控制和用户面的接口。它用于在X2切换或自组网（SON）相关的功能。控制面是使用的X2-AP协议，用户面为数据转发的每一个承载提供GTP-U隧道。 S1-U GTP-U 在eNB和SGW之间用户面的接口。它为每一个承载提供GTP隧道。 S1-MME S1-AP eNB和MME之间控制面的接口。 S11 GTP-C MME和SGW之间控制面的接口。它为每一个承载提供GTP隧道。 S5 GTP-C（控制面）GTP-U（用户面） SGW和PGW之间的控制和用户面接口。S5接口为用户面每一个承载提供GTP隧道，为控制面的每一个用户提供GTP隧道管理（创建/修改/删除）。对PLMN间，使用S8接口替代。S8接口在本文档范围之外，将在其他文档中描述。 S6a Diameter HSS和MME之间控制面的接口。它用于交换用户订阅和鉴权信息 Sp Diameter SPR和PCRF之间控制面的接口。 Gx Diameter PCRF和PGW之间控制面的接口。它从PCRF到PGW传输策略控制和计费规则来支持QoS策略和计费控制。 Gy Diameter OCS和PGW之间控制面的接口。 Gz GTP’ OFCS和PGW之间控制面的接口。 SGi IP PGW和PDN之间控制和用户面的接口。在用户面使用基于IETF的IP数据包转发协议，在控制面使用DHCP和RADIUS/Diameter协议。 III. LTE Protocol Stacks这一章主要介绍LTE用户面和控制面的协议栈。 3.1 用户面协议栈图2是LTE网络参考模型的用户面协议栈。接着介绍协议栈主要层的功能描述。 1）LTE-Uu接口 PDCP：PDCP支持在无线链路上IP数据包的有效性传输。它可以执行协议头压缩，接入层安全（加密和完整性保护），数据包重排序和重传。 RLC：在发送端，RLC构建RLC PDU，并提供给MAC层。RLC协议负责PDCP PDU的分片和串接。在接收端，RLC协议通过对RLC PDU的重组来重新构建PDCP PDU。RLC协议有三种操作模式（透明模式，确认模式，非确认模式），每一种模式提供不同的可靠性级别。RLC也数据包（RLC PDU）的重排序和重传。 MAC：MAC层在RLC和PHY层之间。它通过逻辑信道和RLC层连接，通过传输信道和PHY层连接。因此，MAC层协议在逻辑信道和传输信道之间支持复用和解复用。高层使用不同的逻辑信道来满足不同的QoS要求。MAC层通过对逻辑信道数据的调度和优先级来支持不同的QoS。eNB调度器可以使无线资源动态分配给UE，并通过执行QoS控制来确保每一个承载都分配了协商的QoS。 2) S1-U/S5/X2 接口 GTP-U：GTP-U协议通过在S1-U/S5/X2接口上来转发IP数据包。当在LTE切换过程中已经建立了用于数据转发的GTP隧道，则结束标记数据包应该在GTP隧道上作为最后一个数据包传输。 3.2 控制面协议栈图3是LTE网络参考模型的控制面协议栈。接着介绍协议栈主要层的功能描述。 1) LTE-Uu接口 NAS：NAS协议负责移动性管理和承载管理功能。 RRC：RRC协议对NAS信令的传输提供支持。它也负责无线资源的有效性管理功能。主要的功能包括：系统消息的广播，RRC连接的建立/重配/重建/释放，无线承载的建立/修改/释放。 2) X2接口 X2AP：X2AP协议支持在E-UTRAN内UE的移动性和自组网功能。为了支持UE移动性，X2AP协议提供了例如用户数据转发，序列号状态的传输，UE上下文的释放的功能。对自组网功能，eNB之间交换资源状态信息，负载信息，eNB配置更新信息，使用X2AP协议来相互协调来满足移动性参数。 3) S1-MME接口 S1AP：S1AP协议支持例如S1接口管理，E-RAB管理，NAS信令传输和UE上下文管理。它传输初始UE上下文给eNB来建立E-RAB，并且管理后续UE上下文的修改和释放。 4) S11/S5/S10接口 GTP-C：GTP-C协议支持GTP隧道的建立/修改/终止控制信息的交换。它在LTE切换时创建数据转发的隧道。 5) S6a接口 Diameter：Diameter协议支持在HSS和MME之间用户订阅和鉴权信息的交换。 6) Gx接口 Diameter：Diameter协议支持把PCC规则从PCRF发送到PCEF（PGW）。 7) Gy接口 Diameter：Diameter协议支持在PGW和OCS之间实时信用控制信息的交换。 8) Gz接口 GTP’：GTP’协议支持CDR从PGW发送到OFCS。 IV. Traffic Flow on the LTE Network图4是在LTE网络参考架构中，用户面数据流接入因特网的过程。图4a是数据流从UE到因特网，图4b是数据流从因特网到UE。IP数据包是在S1-U和S5接口上通过GTP隧道来转发的。这些隧道是在用户附着在LTE网络时对每一个EPS承载建立的。 在S1-U和S5的每一个接口上有多个EPS承载建立。因此，为了识别这些承载，每一个GTP隧道的端点都分配了一个TEID（隧道端点标识），（通常识别一个GTP隧道，采用TEID，IP地址，UDP端口号。但是，在这里，为了描述的方便，仅仅使用了TEID）。GTP隧道的接收端本地分配的TEID，发送端必须使用。TEID的交换是在隧道端点使用控制面协议交换的。 当在S1-U接口上建立了GTP隧道时，SGW分配一个TEID用于上行传输，eNB分配一个TEID用于下行传输。S1 GTP隧道TEID是在eNB和SGW之间使用S1AP和GTP-C消息来交换的。同样的，当在S5接口上建立了GTP隧道时，PGW分配一个TEID用于上行传输，SGW分配一个TEID用于下行传输。S5 GTP隧道TEID是在SGW和PGW之间使用GTP-C消息来交换的。 当用户的数据包在S1-U和S5接口上通过GTP隧道传输时，eNB/SGW/PGW通过封装接收对端GTP实体分配的TEID来转发用户IP数据包。在上行方向，SGW在S1 GTP（UL S1-TEID）隧道和S5 GTP（UL S5-TEID）隧道间建立一对一的映射，来终止S1 GTP隧道，并转发用户数据包到S5 GTP隧道。同样的，在下行方向，SGW在S5 GTP（DL S5-TEID）隧道和S1 GTP（DL S1-TEID）隧道间建立一对一的映射，来终止S5 GTP隧道，并转发用户数据包到S1 GTP隧道。在图4中，通过哪一个EPS实体转发因特网数据流的过程如下所示： a）上行方向数据流，从UE到因特网 UE通过LTE-Uu接口传输用户IP数据包到eNB。 eNB使用S1 GTP隧道协议头封装用户IP数据包，并转发封装好的IP数据包给SGW。在这里，eNB使用TEID/目的IP地址/源IP地址作为S1 GTP隧道协议头。 在接收到封装好的IP数据包后，SGW剥离掉S1 GTP隧道协议头，并且使用S5 GTP隧道协议头封装用户IP数据包，并转发封装后的IP数据包。在这里，SGW使用TEID/目的IP地址/源IP地址作为S5 GTP隧道协议头。 在接收到封装好的IP数据包之后，PGW剥离掉S5 GTP隧道协议头得到用户IP数据包，并通过IP路由转发到因特网。 b）下行方向数据流，从因特网到UE PGW从因特网接收到一个目的为UE的IP数据包。 PGW使用S5 GTP隧道协议头封装用户IP数据包，并转发封装好的IP数据包给SGW。在这里，PGW使用TEID/目的IP地址/源IP地址作为S5 GTP隧道协议头。 在接收到封装好的IP数据包后，SGW剥离掉S5 GTP隧道协议头，并且使用S1 GTP隧道协议头封装用户IP数据包，并转发封装后的IP数据包。在这里，SGW使用TEID/目的IP地址/源IP地址作为S1 GTP隧道协议头。 在接收到封装好的IP数据包之后，eNB剥离掉S1 GTP隧道协议头得到用户IP数据包，并在无线链路上通过DRB传输给UE。 V. ClosingLTE网络架构作为第一个LTE系列技术文档。这个文档描述的LTE网路架构只适用于单一运营商的LTE only网络，并描述EPS系统最基本的部分。为了更理解以后的LTE文档，对实体/接口的基本理解是必须的。下一个文档，是另一个基本的文档，讨论应用于LTE网络参考模型的LTE标识。这些基本文档对很好的理解后续的文档有很大帮助，会接着讨论LTE网络更高级的功能，包括LTE互操作和漫游。 References[1] 3GPP TS 36.300, “Evolved Universal Terrestrial Radio Access (E-UTRA) and Evolved UniversalTerrestrial Radio Access Network (E-UTRAN); Overall description; Stage 2”.[2] 3GPP TS 23.401, “General Packet Radio Service (GPRS) enhancements for Evolved UniversalTerrestrial Radio Access Network (E-UTRAN) access”.[3] Magnus Olsson, et. al., SAE and the Evolved Packet Core – Driving the Mobile Broadband Revolution,AP, 2009.[4] NMC Consulting Group Confidential Internal Report, “E2E LTE Network Design”, August 2010.]]></content>
      <categories>
        <category>通信</category>
        <category>LTE</category>
      </categories>
      <tags>
        <tag>LTE</tag>
        <tag>通信</tag>
      </tags>
  </entry>
</search>
